<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>辣椒炒莲藕</title>
      <link href="/essay/fi4c0o/"/>
      <url>/essay/fi4c0o/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uff4b105c" class="ne-p" style="text-align: center"><span class="ne-text">辣椒炒莲藕</span></p><p id="u4b0dd2cb" class="ne-p" style="text-align: center"><span class="ne-text"></span></p><p id="ubd73c524" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1656819779743-aa355d3d-1fc6-454d-bebc-9f0178742cc7.jpeg" width="2736" id="ued5f21b8" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>辣椒炒平菇</title>
      <link href="/essay/cgp1qa/"/>
      <url>/essay/cgp1qa/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue9535782" class="ne-p" style="text-align: center"><span class="ne-text">辣椒炒平菇</span></p><p id="u45e432fb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1656819580848-fd5bd076-3c27-42ea-a245-7b61b3aaf83c.jpeg" width="2736" id="u739306bc" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>鸡蛋水煮面</title>
      <link href="/essay/zky9eg/"/>
      <url>/essay/zky9eg/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ol class="ne-ol"><li id="u61a3cb19"><span class="ne-text">准备好配菜：辣椒，大蒜……切好</span></li><li id="ucfb13558"><span class="ne-text">用稍微烧开的水（80℃）泡面条，让其软化</span></li><li id="ua55b3d2a"><span class="ne-text">锅里面放油烧一会，然后把配菜放进去，然后再舀点水进去，这过程中可以放鸡蛋进去，然后机会差不多放盐下去</span></li></ol><p id="u1e1298dd" class="ne-p"><span class="ne-text"></span></p><p id="u0fecea96" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1656818758889-aaba7431-98fc-4cb0-b052-40ac338b3034.jpeg" width="912" id="QLQYX" class="ne-image"></p><p id="u78b8f5c7" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《山茶文具店》小记</title>
      <link href="/essay/tegfte/"/>
      <url>/essay/tegfte/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u3a5582c3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653571677209-7e72abde-e202-4913-b4fc-4e89285d0779.jpeg" width="270" id="u836fe5f8" class="ne-image"></p><p id="u063179c3" class="ne-p"><span class="ne-text">前言：书中的代笔文字还有文具店在四季所渲染的氛围，很能让人安静下来。另外很多场景都像是自己以前读书，独自的对生活感悟的别种形式的外露……</span></p><h2 id="d4b37c9f"><span class="ne-text">夏</span></h2><p id="u3dd36323" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653570370540-3d102396-6f1f-45ca-a7dd-5951a5c05a4d.jpeg" width="401.9907531738281" id="flM7L" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653570419276-697b6192-1806-4de2-9667-0743f020a122.jpeg" width="398.98614501953125" id="uf11d2c4e" class="ne-image"></p><p id="ua5387e97" class="ne-p"><span class="ne-text">真诚且坦诚……</span></p><p id="u6eea89c6" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="ufad10353" class="ne-p"><span class="ne-text">夏日的夕阳把门外的巷子染成一片橘色。</span></p></div><p id="u3065b135" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="u8cbd818a" class="ne-p"><span class="ne-text">夏蝉在白天聒噪地叫个不停，入夜后便安静下来，四周一片寂静，简直就像身处深山秘境，只不过仍然闷热不已。</span></p></div><p id="u4a900465" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="u043208f1" class="ne-p"><span class="ne-text">“因为我自己写的话，一下子就会看出是小孩子写的。我只要让老师知道我的心意就好。婆婆告诉我，这里的阿嬷可以帮人写很出色的信。”</span></p></div><p id="ud0ecec50" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="uf00df4c8" class="ne-p"><span class="ne-text">“她为我写了一封打动我老公的情书，所以我们才会结婚哦。”</span></p></div><p id="u571e3bcf" class="ne-p"><span class="ne-text">文字的浪漫……以至于我现在就想去二餐打印店买一纸山师信封，书写起浪漫情话……</span></p><p id="ucee381b6" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="uece9be26" class="ne-p"><span class="ne-text">我忍不住冷静思考，为什么在这么热的天气里，我还要刻苦练习这些自己根本不喜欢的书法？打从出生起便一直闷在内心的愤怒和疑问，就像岩浆般一口气喷了出来，就连我自己也无法阻止。</span></p></div><p id="ufe7f8245" class="ne-p"><br></p><p id="u8f507211" class="ne-p"><span class="ne-text">桀</span></p><div class="ne-quote"><p id="u404df461" class="ne-p"><span class="ne-text">敬致关爱我们的各位：夏阳高照的季节来临，镰仓的绿意也更加蓬勃。不知各位是否别来无恙？在鹤冈八幡宫举行婚礼至今，转眼已过十五载，不禁感叹时光流逝如此匆匆。能在各位的见证下，于樱花飘舞的庄严气氛中共结连理，堪称人生之大幸。平日，我们各自努力工作；假日，则常偕同前往海边或山野健行。生活虽然平淡，但夫妻共同享受了日常的平凡幸福，我们都希望能随着岁月的累积，加深彼此的理解和情感。虽然我们无缘得子，但也因此邂逅了爱犬汉娜，我们视她如己出，疼爱有加。回想起来，带着汉娜一起去冲绳旅行的时光，是我们一家人无可取代的美好回忆。此次提笔，是为了向各位报告一件遗憾的事：我们在七月底解除了夫妻关系，正式离婚。虽然我们花费很长时间沟通，摸索是否能找到继续相处的方法；也曾请亲密的友人提供协助，努力寻求最完善的方式，希望走向圆满的结局。但是，前妻希望能与新的伴侣共度未来的人生，无悔活出自我的意志也相当坚定。最后，我们决定分道扬镳，各奔前程。虽然我们无法携手相伴到白头，但仍将默默支持彼此的第二人生。因此，如蒙各位认为我们为了追求幸福的人生，做出富有勇气的决定，我们将深感万幸。各位温暖地守护我们夫妻，如今却辜负了各位的期待，为此着实深感痛苦。衷心感谢各位至今为止的亲切和关爱，有幸和各位结缘，带给我们莫大的鼓励和安慰。虽然我们决定迈向不同的人生，但仍希望能够维持与各位之间的缘分，这也是我们的共同心愿。希望有朝一日，能笑着谈论今天。满怀感恩之心。敬颂崇祺</span></p></div><p id="uda19d251" class="ne-p"><span class="ne-text"></span></p><h2 id="fdf31ff3"><span class="ne-text">秋</span></h2><div class="ne-quote"><p id="uc7781e82" class="ne-p"><span class="ne-text">最近的天空已经有了秋天的味道。山茶文具店也到了差不多该使用火炉的时候，否则太冷了。</span></p></div><p id="ue2c6964c" class="ne-p"><br></p><p id="uc97892b1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653571236427-fb03c188-941e-4200-a318-c0bb40656720.jpeg" width="672" id="u6ce68298" class="ne-image"></p><p id="u3bd18e88" class="ne-p"><span class="ne-text">作为曾经许诺的对象，我想看到这的反应不是遗憾，反而是喜极而泣……</span></p><p id="u5420a3bc" class="ne-p"><br></p><div class="ne-quote"><p id="u6430457b" class="ne-p"><span class="ne-text">用几乎快超出信封的大字写得很有气势。</span></p></div><p id="uc42d71d4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653571439352-fa11a7d7-e50a-4a87-b775-b5254b726155.jpeg" width="1102" id="u95115f11" class="ne-image"></p><p id="u972f33e4" class="ne-p"><span class="ne-text">这个手写正楷字真的好看。</span></p><p id="ua3614e66" class="ne-p"><br></p><p id="u5b5ed240" class="ne-p"><span class="ne-text">读书期间，写字最好看的往往不是学习最好的，而学习极好的同学，反而写的字，不怎么样。。</span></p><div class="ne-quote"><p id="uad2e3e8d" class="ne-p"><span class="ne-text">我一直以为，字能够反映书写者的人品，但这种认识并不正确。有不少人像花莲小姐一样，即使下了苦功，仍然无法写出漂亮的字。如果认为因为心丑才会字丑，未免太武断了。</span></p></div><p id="uad196e47" class="ne-p"><span class="ne-text"></span></p><p id="u398430bf" class="ne-p"><span class="ne-text">代笔这个职业，突然让我想到日本很多影视里面神女这一角色，千恋万花</span></p><div class="ne-quote"><p id="u7ab224f9" class="ne-p"><span class="ne-text">接着用右手轻轻握住花莲小姐的右手，闭着眼睛，像深呼吸般在卡片上写字。</span></p><p id="u1c2fa90c" class="ne-p"><span class="ne-text">当我缓缓睁开眼睛时，发现卡片上的字很陌生，简直不像出自我的手。决定用圆珠笔写这张卡片是正确的决定，从这些文字中，可以感受到花莲小姐的恭谨有礼和纯洁。我把写好的卡片装进信封。</span></p><p id="ud5a18a74" class="ne-p"><span class="ne-text">晚上七点多，花莲小姐再度来到山茶文具店。看起来质料很好的深蓝色大衣和白色围巾在她身上很好看。</span></p><p id="uaf2136af" class="ne-p"><span class="ne-text">“我呈现了这样的感觉……”</span></p><p id="ub5723d0e" class="ne-p"><span class="ne-text">我战战兢兢地递上卡片。花莲小姐一看到卡片，立刻欢呼起来。</span></p><p id="u9bcc617e" class="ne-p"><span class="ne-text">“简直就像我自己写的！谢谢你！”</span></p><p id="u9c7d60e4" class="ne-p"><span class="ne-text">她像少女般兴奋不已。</span></p></div><p id="u115ee3ee" class="ne-p"><span class="ne-text"></span></p><p id="uf6346e17" class="ne-p"><span class="ne-text">这就是典型的“少女字体”了，我影响里面，初中我的后桌还有高中一同学写的字就是这类型的</span></p><div class="ne-quote"><p id="uc27297e0" class="ne-p"><span class="ne-text">“我一直想写这样的字。”</span></p></div><p id="ua2fcc069" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653622953005-24a78b92-4ed4-477d-8d79-8ce1638244e6.png" width="577.7778185934716" id="u2e939874" class="ne-image"></p><h2 id="w6g2f"><span class="ne-text">冬</span></h2><p id="ua012243b" class="ne-p"><span class="ne-text"></span></p><p id="udb726e07" class="ne-p"><span class="ne-text">等到以后，我的小屋门外也要种一棵大树</span></p><p id="u5cb3a4cf" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="ud0e61f16" class="ne-p"><span class="ne-text">据说山茶文具店门口的那棵山茶树，是用由比若宫的山茶树树枝扦插而来的。不知道是上代还是上上代，把被台风吹断的树枝带回家，试着种在家门口，没想到它竟牢牢地扎了根、长成了大树。</span></p></div><p id="u64cfecf6" class="ne-p"><span class="ne-text"></span></p><p id="uc3b64e45" class="ne-p"><span class="ne-text">她深深地爱着她父亲，激动且神秘……</span></p><div class="ne-quote"><p id="u80343284" class="ne-p"><span class="ne-text">“所以她吵着要回去。看到她那样，我真的很难过，忍不住想象她总是背着年纪还小的我们去查看信箱的样子。我猜那是无法让我们姐弟看到的、秘密的爱。”</span></p></div><p id="ud98031d1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653626050743-85c10c68-abc6-4c21-9f53-bc5a8943e3a9.png" width="554.8148540083464" id="VWBdz" class="ne-image"></p><p id="u3e327b4b" class="ne-p"><span class="ne-text">人会成长，所写出的字也会有所成长，虽然不好说这个成长是朝着好的还是邋遢的，但，总归是成长</span></p><div class="ne-quote"><p id="u3365484e" class="ne-p"><span class="ne-text">一个人写的字会随着年岁增长渐渐成熟。即便是同一个人，小学时写的字，和高中时写的字当然不一样；二十多岁时所写的字，和四十多岁时所写的字也不一样。到了七八十岁，差异就更大了。就算是十几岁时写字圆滚滚的少女，变成老太太之后，当然也不会再写那样的字。文字，也会随着年龄变化。</span></p></div><p id="u880ec97e" class="ne-p"><br></p><h2 id="MhZg1"><span class="ne-text">春</span></h2><p id="u8b33dafe" class="ne-p"><span class="ne-text"></span></p><p id="u9b3d697b" class="ne-p"><span class="ne-text">代笔</span></p><div class="ne-quote"><p id="ud8f8688c" class="ne-p"><span class="ne-text">但我内心很犹豫，觉得是否该拒绝这个委托。代笔工作是为了协助他人得到幸福，这是我身为代笔人的坚持。更何况，有必要写伤害对方的信吗？然而，工作就是工作。从另一个角度思考，代笔人这份工作并不是做义工，眼前这位匿名小姐是客人，只要她高兴，那又何妨呢？两种完全相反的想法在内心天人交战，发出咔嚓咔嚓的声音。</span></p></div><p id="u0fdcb288" class="ne-p"><span class="ne-text"></span></p><p id="ubd9d6186" class="ne-p"><span class="ne-text">失去的是妻子，后悔所说过的话，可是，庆幸的是女儿还在身旁，妻子已不再人世……</span></p><div class="ne-quote"><p id="udef19c2b" class="ne-p"><span class="ne-text">“与其苦苦追寻失去的东西，还不如好好珍惜自己眼前拥有的东西。”</span></p></div><p id="u5b75b5c3" class="ne-p"><span class="ne-text"></span></p><p id="u2b1cf01e" class="ne-p"><span class="ne-text">这个场景，和《世界上所有的夜晚》文末那个夜晚是同样的，夜景一样，思绪一样……</span></p><div class="ne-quote"><p id="ue38e9ff0" class="ne-p"><span class="ne-text">小小的亮光穿越黑暗。是萤火虫。没错，每年都有萤火虫在这条河边飞舞。许多人都站在小桥上看萤火虫。</span></p></div><p id="u943d789c" class="ne-p"><span class="ne-text"></span></p><p id="u90fb3804" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>任务执行机制（事件循环EventLoop）</title>
      <link href="/blog/lz7xgx/"/>
      <url>/blog/lz7xgx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u47c8e8b4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653573417541-44275572-06ee-41fc-ab54-6683e2510450.png" width="1960" id="ude4d9e36" class="ne-image"></p><h2 id="bAXj8"><span class="ne-text">理解js里面的任务执行机制</span></h2><p id="332c93badf205d7dbec2fc4bb439ccd8" class="ne-p"><span class="ne-text">相关概念</span></p><ul class="ne-tl"><li id="25f6921c40f36cb9183b5ac9914c72c8"><span class="ne-text">异步编程</span></li><li id="84238ef1389fc242d28b3209c1cc984f"><span class="ne-text">Javascript的事件循环</span></li><li id="3830d9a804ba1333d7c0209cd6453f71"><span class="ne-text">任务队列</span></li><li id="78162f7d0b18bb874d9f86a4e93919f6"><span class="ne-text">微任务队列</span></li><li id="ab3efeb0e9335101781bcb6ddc50b1d0"><span class="ne-text">……</span></li></ul><p id="870aeb34cf2ebdc1ae86c0be1cb94c70" class="ne-p"><br></p><p id="3e08c0f557c4d2bdd04533e6c92d61f5" class="ne-p"><span class="ne-text">以下代码执行的结果是什么？</span></p><pre data-language="javascript" id="optG6" class="ne-codeblock language-javascript">console.log(1);<p>setTimeout(function () {<br>console.log(3);<br>}, 3000);</p><p>console.log(2);</pre><p id="7f33acd50044a8441a7a84f42160dc38" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616040077613-888913ee-a30f-453e-8ebf-c0fd62fde8ea.png" width="507" id="neUVv" class="ne-image"></p><p id="af00a96125ffa9acc489f3e1e3119a07" class="ne-p"><span class="ne-text">以下代码执行的结果是什么？</span></p><pre data-language="javascript" id="YChTy" class="ne-codeblock language-javascript">console.log(1);</p><p>setTimeout(function () {<br>console.log(3);<br>}, 0);</p><p>console.log(2);</pre><p id="7fdc25979693132d07627fd2f1691025" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616040090596-2a14e894-a341-48a9-ba3e-71bbf0d66045.png" width="510.5" id="bnEfE" class="ne-image"></p><h3 id="YbZ5l"><span class="ne-text">啥是单线程</span></h3><p id="f1d3ed0bd3a5c6d021480b6ba4deb401" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364671-590b3d5b-f91b-481d-9102-3e8caa4c6075.png" width="726" id="ZFI00" class="ne-image"></p><p id="b785073ad0b4241b17542f923c68bd89" class="ne-p"><span class="ne-text">单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</span></p><p id="3d43a0c5e81cf4c6a691e5b8ace584c7" class="ne-p"><span class="ne-text"> 这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</span></p><h3 id="IF7ut"><span class="ne-text">同步任务和异步任务</span></h3><p id="175d9c82a2892ec08ad8c92559dfbb4e" class="ne-p"><span class="ne-text"> 单线程导致的问题就是后面的任务等待前面任务完成，如果前面任务很耗时（比如读取网络数据），后面任务不得不一直等待！！</span></p><p id="7c83c84c2c296316bc3f3c1cf7756e53" class="ne-p"><span class="ne-text"> </span><span class="ne-text" style="color: #F5222D">为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。于是，JS 中出现了</span><strong><span class="ne-text" style="color: #F5222D">同步任务</span></strong><span class="ne-text" style="color: #F5222D">和</span><strong><span class="ne-text" style="color: #F5222D">异步任务</span></strong><span class="ne-text" style="color: #F5222D">。</span></p><div class="ne-quote"><p id="u16f8cc8f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1622775361143-bbbae322-0d9e-4dff-bb5f-9c727a926563.gif" width="42" id="q4R2o" class="ne-image"><strong><span class="ne-text">操作系统忘完了</span></strong></p></div><p id="117599905a41f3d8f10cacf311ff90ce" class="ne-p"><br></p><p id="u09384c3b" class="ne-p"><span class="ne-text">JS 中所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</span></p><p id="u3ce49fcb" class="ne-p"><strong><span class="ne-text">【同步任务】</span></strong><span class="ne-text">指的是：</span></p><p id="u72d0afa4" class="ne-p"><span class="ne-text"> 在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</span></p><p id="ued477c02" class="ne-p"><strong><span class="ne-text">【异步任务】</span></strong><span class="ne-text">指的是：</span></p><p id="ue76f9d64" class="ne-p"><span class="ne-text"> 不进入主线程、而进入</span><strong><span class="ne-text">“任务队列”</span></strong><span class="ne-text">的任务，当主线程中的任务运行完了，才会从”任务队列”取出异步任务放入主线程执行。</span></p><p id="e47073c75a8f04a857eaf80defefb256" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364776-7168ea9f-39dc-4395-9d07-0a72969f568d.png" width="746" id="uGzao" class="ne-image"></p><h3 id="bNQzi"><span class="ne-text">JS 执行机制（事件循环）</span></h3><p id="9f459d9375de30e9fa482f5e71f1345e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364833-4eb43c01-9779-4e8d-99a7-2f651cafb1b3.png" width="768" id="MDARJ" class="ne-image"></p><p id="98cea38e14f8231d1e70179d69e8c21e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364890-56fd3e4e-9faa-48d5-a69f-85f0d3bfec1f.png" width="819" id="nvj0H" class="ne-image"></p><p id="383409b7ae67ce3494f7340f3736af3c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364949-71e82dea-e99d-4755-bb73-1c4d68acf4eb.png" width="838" id="mZ4Kh" class="ne-image"></p><div class="ne-quote"><p id="u391cb498" class="ne-p"><span class="ne-text">例子</span></p></div><pre data-language="javascript" id="1sAB5" class="ne-codeblock language-javascript">console.log("主线程：第一个");<br>document.onclick = function() {<br>console.log('点击事件开始');<br>}<br>setTimeout(function() {<br>console.log("定时器 3s");<br>}, 3000)<br>setTimeout(function() {<br>console.log("定时器 1s");<br>}, 1000)<br>console.log("主线程：最后一个");</pre><p id="5c3d645adf706f0b2f1bd76bf4dca621" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622776526386-add5d6e7-7b7f-4e5c-98af-f9189c7282ca.png" width="398" id="u6ef71c6b" class="ne-image"></p><p id="ubf9a6acd" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622776561826-eb27e6c9-623e-4bc1-85b4-78ee987e86d5.png" width="461" id="u5336dfef" class="ne-image"></p><h3 id="tDUjC"><span class="ne-text">JS 创建异步任务枚举</span></h3><div class="ne-quote"><p id="u4fad5977" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u0a198903"><a href="https://juejin.cn/post/6844903832388894727" data-href="https://juejin.cn/post/6844903832388894727" target="_blank" class="ne-link"><span class="ne-text">理解 JavaScript 概念系列–异步任务</span></a></li><li id="u6681cbd9"><a href="https://juejin.cn/post/6844903760280420366" data-href="https://juejin.cn/post/6844903760280420366" target="_blank" class="ne-link"><span class="ne-text">JS 异步编程六种方案</span></a></li></ul></div><h3 id="UtGum"><span class="ne-text">期约 Promise</span></h3><ul class="ne-ul"><li id="a99cda5ed5e730071769cb09ddfa5d97"><a href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html" data-href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html" target="_blank" class="ne-link"><span class="ne-text">大白话讲解 Promise（一）</span></a></li></ul><p id="uf7f91dc4" class="ne-p"><br></p><p id="u829cabcc" class="ne-p"><br></p><h3 id="vmJrc"><span class="ne-text">调用栈、消息队列、微任务队列</span></h3><ul class="ne-ul"><li id="u93f09517"><span class="ne-text">调用栈：遇到函数调用就把函数压入栈内</span></li><li id="ue4f9d192"><span class="ne-text">消息队列（宏任务）：</span></li><li id="u6b5ba9e1"><span class="ne-text">微任务队列：</span></li></ul><p id="uf0be3e95" class="ne-p"><br></p><p id="u25a29757" class="ne-p"><span class="ne-text">Promise、Async、await 不是很理解</span></p><p id="u1683c695" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u5ca8e4d3"><a href="https://www.bilibili.com/video/BV1kf4y1U7Ln" data-href="https://www.bilibili.com/video/BV1kf4y1U7Ln" target="_blank" class="ne-link"><span class="ne-text">https://www.bilibili.com/video/BV1kf4y1U7Ln</span></a></li><li id="u73804503"><a href="https://juejin.cn/post/7050637649123475487" data-href="https://juejin.cn/post/7050637649123475487" class="ne-link"><span class="ne-text">靠做题 📝 来掌握 Promise/async/await</span></a></li></ul><h3 id="X8bdj"><span class="ne-text">综合测试题</span></h3><pre data-language="javascript" id="pOM4H" class="ne-codeblock language-javascript">async function a1 () {<br>console.log('a1 start')<br>await a2()<br>console.log('a1 end')<br>}<br>async function a2 () {<br>console.log('a2')<br>}</p><p>console.log(‘script start’)</p><p>setTimeout(() =&gt; {<br>console.log(‘setTimeout’)<br>}, 0)</p><p>Promise.resolve().then(() =&gt; {<br>console.log(‘promise1’)<br>})</p><p>a1()</p><p>let promise2 = new Promise((resolve) =&gt; {<br>resolve(‘promise2.then’)<br>console.log(‘promise2’)<br>})</p><p>promise2.then((res) =&gt; {<br>console.log(res)<br>Promise.resolve().then(() =&gt; {<br>console.log(‘promise3’)<br>})<br>})<br>console.log(‘script end’)</pre><p id="u4c7f7a55" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651219112856-f0a4bb85-c46f-454f-93da-73eb1610e5b8.png" width="211.66665825578934" id="u4d8425df" class="ne-image"></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>客户端检测</title>
      <link href="/blog/gnyhrv/"/>
      <url>/blog/gnyhrv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u0da261e9" class="ne-p"><span class="ne-text">前言：用于客户端检测的工具函数记录</span></p><h3 id="XNybz"><span class="ne-text">是否为IOS设备</span></h3><pre data-language="javascript" id="tCi0x" class="ne-codeblock language-javascript">let isIos = () => {<p>var u = navigator.userAgent<br>if (u.indexOf(‘Android’) &gt; -1 || u.indexOf(‘Linux’) &gt; -1) {<br>//安卓手机<br>// return “Android”;<br>return false<br>} else if (u.indexOf(‘iPhone’) &gt; -1) {<br>//苹果手机<br>// return “iPhone”;<br>return true<br>} else if (u.indexOf(‘iPad’) &gt; -1) {<br>//iPad<br>// return “iPad”;<br>return false<br>} else if (u.indexOf(‘Windows Phone’) &gt; -1) {<br>//winphone 手机<br>// return “Windows Phone”;<br>return false<br>} else {<br>return false<br>}<br>}</pre><h3 id="Tp09f"><span class="ne-text">是否为 PC 设备</span></h3><pre data-language="javascript" id="tOqoO" class="ne-codeblock language-javascript">let isPC = () => {<br>//是否为 PC 端<br>var userAgentInfo = navigator.userAgent<br>var Agents = [<br>'Android',<br>'iPhone',<br>'SymbianOS',<br>'Windows Phone',<br>'iPad',<br>'iPod',<br>]<br>var flag = true<br>for (var v = 0; v < Agents.length; v++) {<br>if (userAgentInfo.indexOf(Agents[v]) > 0) {<br>flag = false<br>break<br>}<br>}<br>return flag<br>}</pre><h3 id="wNkaL"><span class="ne-text">浏览器类型</span></h3><pre data-language="javascript" id="HhDiO" class="ne-codeblock language-javascript">let browserType = () => {<br>var userAgent = navigator.userAgent //取得浏览器的 userAgent 字符串<br>var isOpera = userAgent.indexOf('Opera') > -1 //判断是否 Opera 浏览器<br>var isIE =<br>userAgent.indexOf('compatible') > -1 &&<br>userAgent.indexOf('MSIE') > -1 &&<br>!isOpera //判断是否 IE 浏览器<br>var isIE11 =<br>userAgent.indexOf('Trident') > -1 && userAgent.indexOf('rv:11.0') > -1<br>var isEdge = userAgent.indexOf('Edge') > -1 && !isIE //判断是否 IE 的 Edge 浏览器<br>var isFF = userAgent.indexOf('Firefox') > -1 //判断是否 Firefox 浏览器<br>var isSafari =<br>userAgent.indexOf('Safari') > -1 && userAgent.indexOf('Chrome') == -1 //判断是否 Safari 浏览器<br>var isChrome =<br>userAgent.indexOf('Chrome') > -1 && userAgent.indexOf('Safari') > -1 //判断 Chrome 浏览器</p><p>if (isIE) {<br>var reIE = new RegExp(‘MSIE (\d+\.\d+);’)<br>reIE.test(userAgent)<br>var fIEVersion = parseFloat(RegExp[‘$1’])<br>if (fIEVersion == 7) return ‘IE7’<br>else if (fIEVersion == 8) return ‘IE8’<br>else if (fIEVersion == 9) return ‘IE9’<br>else if (fIEVersion == 10) return ‘IE10’<br>else return ‘IE7 以下’ //IE 版本过低<br>}<br>if (isIE11) return ‘IE11’<br>if (isEdge) return ‘Edge’<br>if (isFF) return ‘FF’<br>if (isOpera) return ‘Opera’<br>if (isSafari) return ‘Safari’<br>if (isChrome) return ‘Chrome’<br>}</pre><p id="u03ce0130" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653026051837-a36a45e0-2b92-48d9-8b88-63c35e2babd2.png" width="369.99998529752156" id="ucbd2b3d7" class="ne-image"></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小满：故人叹物</title>
      <link href="/essay/avyy9v/"/>
      <url>/essay/avyy9v/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u4b0d8d20" class="ne-p"><strong><span class="ne-text">物质</span></strong></p><p id="ua70271b8" class="ne-p"><span class="ne-text">我好像对物质没有太多的追求</span></p><p id="u21579c9c" class="ne-p"><span class="ne-text">努力一份好工作，也只是让自己不成为一个无能的人罢了</span></p><p id="u3718dd8b" class="ne-p"><span class="ne-text">在家人朋友想要的时候，无能会让人变得无比遗憾</span></p><p id="u6261cdee" class="ne-p"><span class="ne-text">我不想让所有的不利因素都归咎于无能之下</span></p><p id="ub7baf720" class="ne-p"><span class="ne-text">没有太多的物质追求，只求爱我我爱的人过的开心就好</span></p><p id="u1dc90ba2" class="ne-p"><span class="ne-text"></span></p><p id="u3d941a94" class="ne-p"><strong><span class="ne-text">相处</span></strong></p><p id="uadbd427d" class="ne-p"><span class="ne-text"> 用到理科的取反、就简、取极限原则</span></p><p id="u739267d4" class="ne-p"><span class="ne-text">与人相处也可以定义成如何和你讨厌的人相处</span></p><p id="u231730c4" class="ne-p"><span class="ne-text">懂得了这个</span></p><p id="uda2bd5bf" class="ne-p"><span class="ne-text">很多事情就变得明朗起来了</span></p><p id="u8b509d99" class="ne-p"><span class="ne-text"></span></p><p id="u93a72975" class="ne-p"><strong><span class="ne-text">成长</span></strong></p><p id="uaa460629" class="ne-p"><span class="ne-text">很多时候，如果不是因为一件大事</span></p><p id="u8d704de3" class="ne-p"><span class="ne-text">一个人的成长确实是根据时间、环境来决定的</span></p><p id="u8ab0b2d2" class="ne-p"><span class="ne-text">很多时候我就会想成长和成熟的区别</span></p><p id="ubc1131ce" class="ne-p"><span class="ne-text">我的答案是：没有区别</span></p><p id="ub4dc793f" class="ne-p"><span class="ne-text">也可以说成两者互为充要条件吧</span></p><p id="uf2e5220c" class="ne-p"><span class="ne-text"></span></p><p id="u4469a85d" class="ne-p"><strong><span class="ne-text">没有意义的事情</span></strong></p><p id="u3644fc4b" class="ne-p"><span class="ne-text">如果你所做的所有事情都是没有意义的。</span></p><p id="ucc2ecd3f" class="ne-p"><span class="ne-text">当你做了一些事情，到了一定时候</span></p><p id="u7c5ab5e2" class="ne-p"><span class="ne-text">你发现</span></p><p id="ufa655cb3" class="ne-p"><span class="ne-text">你曾经做过的所有事情</span></p><p id="u90a28096" class="ne-p"><span class="ne-text">都是没有意义的</span></p><p id="u1428405f" class="ne-p"><span class="ne-text">是多么的孤寂</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原始值+引用值+浅拷贝+深拷贝</title>
      <link href="/blog/lwi9wr/"/>
      <url>/blog/lwi9wr/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="sEWoQ"><span class="ne-text">原始值和引用值</span></h2><p id="be789bab58359dda0d9df532eb85cd7a" class="ne-p"><span class="ne-text">这里面Java和JavaScript都是只有引用的概念，但是在C/C++里面，就有指针的概念</span></p><p id="185ad2ff8b1c9fccb24c3ec65e95156f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617868682681-90191ec3-c5b2-415f-9e38-df2706301e0c.png" width="465.5" id="dmTBK" class="ne-image"></p><ul class="ne-ul"><li id="u7ae02f1b"><span class="ne-text">原始值： </span><strong><span class="ne-text">存储在栈中的简单数据段</span></strong><span class="ne-text">，即他们的值直接存储在变量访问的位置。</span></li></ul><p id="u4c8c2b5b" class="ne-p"><span class="ne-text">包括：undefined、null、boolean、number、string。</span></p><p id="u2f8d3de3" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="u1cc91305"><span class="ne-text">引用值：</span><strong><span class="ne-text">存储在堆中的对象</span></strong><span class="ne-text">，即存储在变量处的值是一个指针，只想存储对象的内存处。</span></li></ul><p id="uc6a34d30" class="ne-p"><span class="ne-text">包括：object、array、function等</span></p><p id="u602c0ed7" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="ud38b6f2e"><span class="ne-text">两者的区别：</span></li></ul><p id="u02a3d07c" class="ne-p"><span class="ne-text">原始变量及他们的值储存在栈中，当把一个原始变量传递给另一个原始变量时，是把一个栈房间的东西复制到另一个栈房间，且这两个原始变量互不影响。</span><strong><span class="ne-text">引用值是把引用变量的名称储存在栈中，但是把其实际对象储存在堆中</span></strong><span class="ne-text">，且存在一个指针由变量名指向储存在堆中的实际对象，当把引用对象传递给另一个变量时，复制的其实是指向实际对象的指针，此时两者指向的是同一个数据，若通过方法改变其中一个变量的值，则访问另一个变量时，其值也会随之加以改变；但若不是通过方法而是通过重新赋值，此时，相当于重新开了一个房间，该值的原指针改变，则另外一个值不会随他的改变而改变。</span></p><pre data-language="javascript" id="XsjnT" class="ne-codeblock language-javascript">let s = '基本类型'<p>let s_test = s<br>s_test = ‘改变之后不影响 s’<br>console.log(s)<br>console.log(s_test)</p><p>let arr = [‘原始数组值’]<br>arr_test = arr<br>arr_test[0] = ‘改变值’<br>console.log(arr)<br>console.log(arr_test)</p><p>//基本类型<br>//改变之后不影响 s<br>//[ ‘改变值’ ]<br>//[ ‘改变值’ ]</pre><ul class="ne-ul"><li id="570fd75c2e87aa222daa905fbf6ce98d"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/u012443286/article/details/79496742" data-href="https://blog.csdn.net/u012443286/article/details/79496742" target="_blank" class="ne-link"><span class="ne-text">谈谈 JavaScript 中的变量、指针和引用</span></a></li></ul><h2 id="iEowI"><span class="ne-text">深拷贝与浅拷贝 </span></h2><h3 id="ZYo3B"><span class="ne-text">区分概念</span></h3><ul class="ne-ul"><li id="ube942d08"><span class="ne-text">浅拷贝：直接赋值，还是指向同一个堆</span></li><li id="u9305c0f0"><span class="ne-text">深拷贝：相当于重新创建一个对象，新开存储空间</span></li><li id="u1bfcb188"><span class="ne-text">参考：</span><a href="https://segmentfault.com/a/1190000016440069" data-href="https://segmentfault.com/a/1190000016440069" class="ne-link"><span class="ne-text">js 浅拷贝与深拷贝方法</span></a></li></ul><p id="ud233259a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651305177480-c971984f-5aa2-48af-9d4b-3eee50afffee.png" width="291" id="u19a4acf0" class="ne-image"><span class="ne-text">、</span></p><h3 id="UY983"><span class="ne-text">浅拷贝实现</span></h3><ol class="ne-ol"><li id="u6df7d29e"><span class="ne-text">直接等号赋值</span></li></ol><pre data-language="javascript" id="R6ax6" class="ne-codeblock language-javascript">let obj = {<br>ss: 'ss',<br>hh: 'hh',<br>}</p><p>let obj_qian = obj<br>obj_qian.ss = ‘sss’<br>obj_qian.hh = ‘hhh’<br>console.log(obj) //{ ss: ‘sss’, hh: ‘hhh’ }<br>console.log(obj_qian) //{ ss: ‘sss’, hh: ‘hhh’ }</pre><h3 id="qhGMP"><span class="ne-text">深拷贝实现</span></h3><ol class="ne-ol"><li id="ubad15add"><span class="ne-text">直接创建一个同类型的数据结构，然后将原值一个个复制过来（数组）</span></li><li id="ue460b0a1"><span class="ne-text">JSON 方法（对象）</span></li></ol><pre data-language="javascript" id="cOCqz" class="ne-codeblock language-javascript">let obj = {<br>ss: 'ss',<br>hh: 'hh',<br>}</p><p>let obj_shen_JSON = JSON.parse(JSON.stringify(obj))<br>obj_shen_JSON.ss = ‘sssss’<br>obj_shen_JSON.hh = ‘hhhhh’<br>console.log(obj) //{ ss: ‘ss’, hh: ‘hh’ }<br>console.log(obj_shen_JSON) // { ss: ‘sssss’, hh: ‘hhhhh’ }</pre><h3 id="uFYnE"><span class="ne-text">手写深拷贝</span></h3><pre data-language="javascript" id="jGkPq" class="ne-codeblock language-javascript">let clone = target => {<br>if (typeof target === 'object') {<br>let cloneTarget = Array.isArray(target) ? [] : {}<br>for (const key in target) {<br>cloneTarget[key] = clone(target[key])<br>}<br>return cloneTarget<br>} else {<br>return target<br>}<br>}</p><p>let obj_1 = {<br>c: ‘c’,<br>d: {<br>d1: ‘d1’,<br>d2: ‘d2’,<br>},<br>}<br>let obj_my = clone(obj_1)<br>obj_1.c = ‘ccccccc’<br>obj_1.d.d1 = ‘dsdddddddd’<br>console.log(obj_1)<br>console.log(obj_my)</pre><p id="u7d570bdc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652416167805-60ef8c07-9bba-4d43-a2e2-349b986c3c35.png" width="454.1666486197055" id="u1714696c" class="ne-image"></p><h3 id="zkjl4"><span class="ne-text">Object.assign({}, obj)</span></h3><ul class="ne-ul"><li id="u2318572f"><strong><span class="ne-text">assign 既可以是深拷贝，也可以是浅拷贝</span></strong></li></ul><ul class="ne-ul"><li id="ud6dd0dff"><span class="ne-text">Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</span></li><li id="u7f8ba952"><span class="ne-text">对于 Object.assign()而言，如果对象的属性值为简单类型（string，number），通过 Object.assign({},srcobj);得到的新对象为深拷贝；如果属性值为对象或其他引用类型，那对于这个对象而言其实是浅拷贝的</span></li></ul><pre data-language="javascript" id="gGCRd" class="ne-codeblock language-javascript">let obj = {<br>a: 'a',<br>b: 'b',<br>}</p><p>let obj_deep = Object.assign({}, obj)<br>obj.a = ‘aa’<br>console.log(obj)<br>console.log(obj_deep)</p><p>console.log(‘——————————–’)<br>let obj_obj = {<br>c: ‘c’,<br>d: {<br>d1: ‘d1’,<br>d2: ‘d2’,<br>},<br>}</p><p>let obj_qian = Object.assign({}, obj_obj)<br>obj_obj.c = ‘cc’<br>obj_obj.d.d1 = ‘d1111’<br>console.log(obj_obj)<br>console.log(obj_qian)</pre><p id="u3956ee6e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652415857368-38e9203a-1178-4fc4-b53d-a6059c212ad0.png" width="421.6666499111394" id="u6b2eae5b" class="ne-image"></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>442. 数组中重复的数据🔖数组🔖哈希表</title>
      <link href="/blog/cp993p/"/>
      <url>/blog/cp993p/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u76be6687"><a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" data-href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/</span></a></li></ul><p id="ud3fca973" class="ne-p"><span class="ne-text"></span></p><h3 id="Q81xz"><span class="ne-text">暴力解法</span></h3><pre data-language="javascript" id="qhWGh" class="ne-codeblock language-javascript">/**<ul><li>@param {number[]} nums</li><li>@return {number[]}<br>*/<br>var findDuplicates = function(nums) {<br>let arr =[]<br>let result =[]<br>nums.forEach(data=&gt;{<br>arr.includes(data) ? result.push(data) : arr.push(data)<br>})<br>return result<br>};</pre><p id="u4d402b58" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015297299-44ac1ea9-f775-483d-b762-d57c71ff32c9.png" width="629.9999749660502" id="u730a2960" class="ne-image"></p><h3 id="BCCAk"><span class="ne-text">哈希表</span></h3><pre data-language="javascript" id="geS0x" class="ne-codeblock language-javascript">/**</li><li>@param {number[]} nums</li><li>@return {number[]}<br>*/<br>var findDuplicates = function(nums) {<br>const map = new Map()<br>const arr = []</li></ul><p>for(let i = 0; i &lt; nums.length; i++) {<br>if (map.has(nums[i])) {<br>arr.push(nums[i])<br>map.delete(nums[i])<br>} else {<br>map.set(nums[i])<br>}<br>}</p><p>return arr<br>};</pre><p id="u93e02786" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015256459-e3d10aa5-79a4-4ea5-b8c2-edb2ffd6abe1.png" width="626.6666417651716" id="ue83dc54e" class="ne-image"></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人鬼如梦</title>
      <link href="/essay/otaot9/"/>
      <url>/essay/otaot9/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u79092823" class="ne-p"><span class="ne-text">不知什么时候，我特别喜欢梦这个意象</span></p><p id="u3e51b264" class="ne-p"><span class="ne-text">人鬼殊途，却是美好的意境</span></p><p id="u74a9daeb" class="ne-p"><span class="ne-text">醒来一无所有</span></p><p id="u64ba1061" class="ne-p"><span class="ne-text">我宁愿生活一个小小梦里面，快乐纯真的守护</span></p><p id="u20fa5a6b" class="ne-p"><span class="ne-text">只守护，不求功与名</span></p><p id="u338e73c1" class="ne-p"><span class="ne-text">只愿守护所爱</span></p><p id="u7a03d462" class="ne-p"><span class="ne-text">人鬼殊途，却也美好梦一场</span></p><p id="u067baa19" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1651989959347-a078aca1-56b2-4421-a8cd-8e10516c166f.jpeg" width="1950" id="uef1688dd" class="ne-image"></p><p id="u00743ca7" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1823. 找出游戏的获胜者🔖递归</title>
      <link href="/blog/ucz0sz/"/>
      <url>/blog/ucz0sz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u2561afec"><a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/" data-href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/</span></a></li></ul><p id="ua1522be6" class="ne-p"><span class="ne-text"></span></p><p id="uc655ed76" class="ne-p"><span class="ne-text">其中12行代码是根据数学找规律得出来的（滑稽</span></p><p id="uee099d02" class="ne-p"><span class="ne-text"></span></p><p id="ud70ea673" class="ne-p"><span class="ne-text">感觉这个题目还有用循环链表，队列啥的写，但是力扣我至今还不知道他有没有预设这些js不内置的数据结构，一直都是题目有啥用啥……</span></p><pre data-language="javascript" id="T4xXN" class="ne-codeblock language-javascript">/**<ul><li>@param {number} n</li><li>@param {number} k</li><li>@return {number}<br>*/<br>var findTheWinner = function(n, k) {<br>let arr = []<br>for (let i = 0; i&lt;n; i++) arr.push(i+1)<br>let searchP = (arr, k, pre) =&gt; {<br>if (arr.length &gt; 1) {<br>pre = k + pre - 1<br>while (pre &gt; arr.length-1) pre = pre - arr.length<br>arr.splice(pre, 1)<br>searchP(arr, k, pre)<br>}<br>}<br>searchP(arr, k, 0)<br>return arr[0]<br>};</pre><p id="ue12db441" class="ne-p"><span class="ne-text"></span></p><p id="u378010d0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651647527838-774b7fe0-fbba-44d7-8fa2-b7a1af828bdb.png" width="670.8333066768128" id="u874494ca" class="ne-image"></p></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>905. 按奇偶排序数组🔖数组</title>
      <link href="/blog/sp649k/"/>
      <url>/blog/sp649k/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u0934bc91"><a href="https://leetcode-cn.com/problems/sort-array-by-parity/" data-href="https://leetcode-cn.com/problems/sort-array-by-parity/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/sort-array-by-parity/</span></a></li></ul><p id="u4bbd8d43" class="ne-p"><span class="ne-text"></span></p><p id="ue01bb5d1" class="ne-p"><span class="ne-text">暴力解法</span></p><pre data-language="javascript" id="w0qyS" class="ne-codeblock language-javascript">/**<ul><li>@param {number[]} nums</li><li>@return {number[]}<br>*/<br>var sortArrayByParity = function(nums) {<br>let arr = []<br>nums.forEach(data =&gt; {data % 2 === 0 ? arr.unshift(data) : arr.push(data)})<br>return arr<br>};</pre><p id="uc66ff315" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651567846491-0c978678-9a40-4ee4-b77b-22dc5284ef37.png" width="617.4999754627555" id="ubb08a31d" class="ne-image"></p><p id="uceba6cc9" class="ne-p"><br></p></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>908. 最小差值 I🔖数组</title>
      <link href="/blog/vmdef7/"/>
      <url>/blog/vmdef7/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ueaf52d85"><a href="https://leetcode-cn.com/problems/smallest-range-i/" data-href="https://leetcode-cn.com/problems/smallest-range-i/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/smallest-range-i/</span></a></li></ul><p id="ue34d2f17" class="ne-p"><span class="ne-text">主要分析出规律就好解了</span></p><ul class="ne-ul"><li id="ud251fd6e"><span class="ne-text">对第一个和最后一个元素进行相减比较</span></li><li id="u1817570f"><span class="ne-text">去重</span></li></ul><pre data-language="javascript" id="gGxw8" class="ne-codeblock language-javascript">/**<ul><li>@param {number[]} nums</li><li>@param {number} k</li><li>@return {number}<br>_/<br>var smallestRangeI = function(nums, k) {<br>let arr = Array.from(new Set(nums.sort((a, b) =&gt; {return a - b})))<br>if (arr.length === 1) return 0<br>return arr[arr.length - 1] - arr[0] - 2 _ k &lt;= 0 ? 0 : arr[arr.length - 1] - arr[0] -2 * k<br>};</pre><p id="u5d9cf971" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015419001-5fb4bfd2-befa-43a7-a309-2962b8d2fee1.png" width="624.9999751647323" id="u9619e698" class="ne-image"></p></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1305. 两棵二叉搜索树中的所有元素🔖DFS🔖数组</title>
      <link href="/blog/rxfz11/"/>
      <url>/blog/rxfz11/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u46abc578"><a href="https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/" data-href="https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/</span></a></li></ul><p id="u6f0ad162" class="ne-p"><span class="ne-text"></span></p><pre data-language="javascript" id="Gs83M" class="ne-codeblock language-javascript">/**<ul><li>Definition for a binary tree node.</li><li>function TreeNode(val, left, right) {</li><li><pre><code>this.val = (val===undefined ? 0 : val)</code></pre></li><li><pre><code>this.left = (left===undefined ? null : left)</code></pre></li><li><pre><code>this.right = (right===undefined ? null : right)</code></pre></li><li>}<br>*/<br>/**</li><li>@param {TreeNode} root1</li><li>@param {TreeNode} root2</li><li>@return {number[]}<br>*/<br>var getAllElements = function(root1, root2) {<br>let arr_left = []<br>let arr_right = []<br>let dfs = (data, arr) =&gt; {<br>if (data) {<br>dfs(data.left, arr)<br>dfs(data.right, arr)<br>arr.push(data.val)<br>}<br>}<br>dfs(root1, arr_left)<br>dfs(root2, arr_right)<br>return arr_left.concat(arr_right).sort((a, b) =&gt; {return a - b})<br>};</pre><p id="u25b22db4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651564651594-33c9e8d9-889d-4560-858a-8d9f15021e99.png" width="635.8333080675877" id="u429a9901" class="ne-image"></p></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3. 无重复字符的最长子串</title>
      <link href="/blog/sutafh/"/>
      <url>/blog/sutafh/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u742c0868"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" data-href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</span></a></li></ul><p id="ub473188b" class="ne-p"><span class="ne-text">暴力解法</span></p><pre data-language="javascript" id="DLa4C" class="ne-codeblock language-javascript">/**<ul><li><p>@param {string} s</p></li><li><p>@return {number}<br>*/<br>var lengthOfLongestSubstring = function(s) {<br>let result = 1<br>if (s.length === 0) return 0<br>if (s.length === 1) return 1<br>for(let i=0;i&lt;s.length-1;i++){<br>for(let j=i+1;j&lt;s.length;j++){<br>let arr = s.substr(i,j-i+1).split(‘’)<br>let set = new Set(arr)</p><pre><code>        if(arr.length !==[...set].length)&#123;            break        &#125; else &#123;            result = result &gt;= arr.length ? result : arr.length        &#125;    &#125;&#125;return result</code></pre><p>};</pre><p id="u41603835" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651544911564-558d66b8-bbf2-4a53-9afe-c3c92e0b8051.png" width="634.999974767368" id="uf5f7c443" class="ne-image"></p><p id="udf417444" class="ne-p"><span class="ne-text">这个结果太拉跨了……</span></p><p id="ue8529b0c" class="ne-p"><strong><span class="ne-text">todo：滑动窗口</span></strong></p></div></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🥢KMP类算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>n级阶梯1步2步走问题</title>
      <link href="/blog/ik7g6a/"/>
      <url>/blog/ik7g6a/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u07d0ee9b" class="ne-p"><span class="ne-text">题目：一个长阶梯有n级，可以一次走1级，一次走2级，一共有多少种走法？</span></p><p id="uba61458f" class="ne-p"><span class="ne-text"></span></p><p id="u0a864803" class="ne-p"><span class="ne-text">经典的动态规划问题，从结果来看：</span></p><ul class="ne-ul"><li id="ucab5f525"><span class="ne-text">到达第n层阶梯的方式只有两种，走一步然后结束，或者走两步然后结束。</span></li><li id="uae554292"><span class="ne-text">到达第n-1层阶梯的方式只有两种，走一步然后结束，或者走两步然后结束。</span></li><li id="u010a4305"><span class="ne-text">……</span></li></ul><p id="u28f22cd8" class="ne-p"><span class="ne-text"></span></p><p id="uc65816a0" class="ne-p"><span class="ne-text">抽离于动态规划模型，动态规划解题主要是解决两点（一般难题也就从这两个点来设置）</span></p><ol class="ne-ol"><li id="u69701fa9"><span class="ne-text">动态方程</span></li><li id="u2f7d9b2d"><span class="ne-text">边界条件</span></li></ol><p id="u8901ae16" class="ne-p"><span class="ne-text"></span></p><pre data-language="javascript" id="mh7b0" class="ne-codeblock language-javascript">let arr = new Array(n).fill(0)<p>// 边界条件<br>arr[0] = 1<br>arr[1] = 2</p><p>for (let i = 2; i&lt;arr.length; i++) {<br>// 动态方程<br>arr[i] = arr[i-1] + arr[i-2]<br>}</p><p>console.log(arr[n-1])</pre><p id="u72d9cfa6" class="ne-p"><br></p><p id="ud8d6c79c" class="ne-p"><span class="ne-text">还可以用递归（不建议用，复杂度太高指数级，但是因为和递归看起来有点像，所以写出来作为比较）</span></p><pre data-language="javascript" id="kkI7v" class="ne-codeblock language-javascript">let jie = n => {<br>if(n === 1) return 1;<br>if(n === 2) return 2;<br>if(n > 2) return jie(n-1) + jie(n-2);<br>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>todo：63. 不同路径 II🔖DP</title>
      <link href="/blog/hny8e9/"/>
      <url>/blog/hny8e9/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ue13427c7"><a href="https://leetcode-cn.com/problems/unique-paths-ii/solution/" data-href="https://leetcode-cn.com/problems/unique-paths-ii/solution/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/unique-paths-ii/solution/</span></a></li></ul><p id="u236ad41b" class="ne-p"><span class="ne-text"></span></p><div data-type="danger" class="ne-alert"><p id="ue5200779" class="ne-p" style="text-align: center"><span class="ne-text">代码还没有完成</span></p><ul class="ne-tl"><li checked="true" id="u37341c24"><span class="ne-text">动态方程</span></li><li id="ub08bdea2"><span class="ne-text">边界情况：</span><strong><span class="ne-text">对于目标位置arr[m-1][n-1]的周围被围绕这个边界情况遗漏了</span></strong><span class="ne-text">。</span></li></ul></div><p id="ue75f2f7d" class="ne-p"><span class="ne-text"></span></p><pre data-language="javascript" id="i2ehV" class="ne-codeblock language-javascript">/**<ul><li><p>@param {number[][]} obstacleGrid</p></li><li><p>@return {number}<br>*/<br>var uniquePathsWithObstacles = function(obstacleGrid) {<br>let m = obstacleGrid.length<br>let n = obstacleGrid[0].length</p><pre><code>if (m === 1 &amp;&amp; n === 1) return obstacleGrid[0][0] === 0 ? 1 : 0if (m === 1) return obstacleGrid[0].includes(1) ? 0 : 1if (n === 1) &#123;    for (let i = 0; i&lt;m; i++) &#123;        if (obstacleGrid[i][0] === 1) return 0    &#125;&#125;if (obstacleGrid[0][0] === 1 || obstacleGrid[m-1][n-1] === 1) return 0for (let i = 0; i&lt;m; i++) obstacleGrid[i][0] = obstacleGrid[i][0] === 0 ? 1 : 0for (let i = 0; i&lt;n; i++) obstacleGrid[0][i] = obstacleGrid[0][i] === 0 ? 1 : 0for (let i = 1; i&lt;m; i++) &#123;    for (let j = 1; j&lt;n; j++) &#123;        obstacleGrid[i][j] === 1            ? obstacleGrid[i][j] = 0            : obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]    &#125;&#125;return obstacleGrid[m-1][n-1]</code></pre><p>};</pre></div></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>62. 不同路径🔖DP</title>
      <link href="/blog/lc1dfa/"/>
      <url>/blog/lc1dfa/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ub6d0c2df"><a href="https://leetcode-cn.com/problems/unique-paths/" data-href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/unique-paths/</span></a></li></ul><p id="u087f2747" class="ne-p"><span class="ne-text"></span></p><p id="uefa1dac2" class="ne-p"><span class="ne-text">动态规划题目需要找到两点：</span></p><ul class="ne-ul"><li id="ua95065ea"><strong><span class="ne-text">动态方程：动态方程抽离问题的共同解决方程</span></strong></li><li id="u942a84e5"><strong><span class="ne-text">边界情况：相当于对于上述动态方程的特殊情况的枚举</span></strong></li></ul><p id="u30bca93f" class="ne-p"><br></p><pre data-language="javascript" id="m3rVC" class="ne-codeblock language-javascript">/**<ul><li>@param {number} m</li><li>@param {number} n</li><li>@return {number}<br>*/<br>var uniquePaths = function(m, n) {<br>let arr = new Array(m).fill(0).map(() =&gt; new Array(n).fill(0))<br>// 边界情况<br>for (let i = 0; i&lt;m; i++) arr[i][0] = 1<br>for (let i = 0; i&lt;n; i++) arr[0][i] = 1<br>// 动态方程<br>for (let i = 1; i&lt;m; i++) {<br>for (let j = 1; j&lt;n; j++) {<br>arr[i][j] = arr[i-1][j] + arr[i][j-1]<br>}<br>}<br>return arr[m-1][n-1]<br>};</pre><p id="u014e65a9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015457078-4895e20f-7f29-463d-aaa7-97715d3dcd54.png" width="628.333308365611" id="u516534aa" class="ne-image"></p></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>112. 路径总和🔖DFS</title>
      <link href="/blog/alrzw2/"/>
      <url>/blog/alrzw2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ua36bd7a2"><a href="https://leetcode-cn.com/problems/path-sum/" data-href="https://leetcode-cn.com/problems/path-sum/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/path-sum/</span></a></li></ul><p id="u349f23d1" class="ne-p"><span class="ne-text"></span></p><pre data-language="javascript" id="U3R92" class="ne-codeblock language-javascript">/**<ul><li>Definition for a binary tree node.</li><li>function TreeNode(val, left, right) {</li><li><pre><code>this.val = (val===undefined ? 0 : val)</code></pre></li><li><pre><code>this.left = (left===undefined ? null : left)</code></pre></li><li><pre><code>this.right = (right===undefined ? null : right)</code></pre></li><li>}<br>*/<br>/**</li><li>@param {TreeNode} root</li><li>@param {number} targetSum</li><li>@return {boolean}<br>*/<br>var hasPathSum = function(root, targetSum) {<br>let result = false<br>let dfs = (data, presum, tar) =&gt; {<br>if (data) {<br>presum = data.val + presum<br>if (!data.left &amp;&amp; !data.right) {<br>if (presum == tar) {<br>result = true<br>}<br>}<br>dfs(data.left, presum, tar)<br>dfs(data.right, presum, tar)<br>}<br>}<br>dfs(root, 0, targetSum)<br>return result<br>};</pre><p id="ubb6e5da4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651412804694-76d5dacc-2cbe-4170-a04f-4af28bfa1d6f.png" width="719.9999713897716" id="ud5bb75fc" class="ne-image"></p></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>100. 相同的树🔖BFS🔖DFS</title>
      <link href="/blog/imt8ld/"/>
      <url>/blog/imt8ld/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u4caaba6d"><a href="https://leetcode-cn.com/problems/same-tree/" data-href="https://leetcode-cn.com/problems/same-tree/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/same-tree/</span></a></li></ul><p id="u88c6e409" class="ne-p"><span class="ne-text"></span></p><h3 id="h4eM0"><span class="ne-text">BFS</span></h3><pre data-language="javascript" id="mcmxz" class="ne-codeblock language-javascript">/**<ul><li><p>Definition for a binary tree node.</p></li><li><p>function TreeNode(val, left, right) {</p></li><li><pre><code>this.val = (val===undefined ? 0 : val)</code></pre></li><li><pre><code>this.left = (left===undefined ? null : left)</code></pre></li><li><pre><code>this.right = (right===undefined ? null : right)</code></pre></li><li><p>}<br>*/<br>/**</p></li><li><p>@param {TreeNode} p</p></li><li><p>@param {TreeNode} q</p></li><li><p>@return {boolean}<br>*/<br>var isSameTree = function(p, q) {<br>if (p === null &amp;&amp; q === null) return true<br>if (p === null || q === null) return false</p><pre><code>let que_1 = [p]let que_2 = [q]while(que_1.length !== 0) &#123;    let que_1_size = que_1.length    let que_2_size = que_2.length    if (que_1_size !== que_2_size) return false    for (let i = 0; i&lt;que_1_size; i++) &#123;        let mp1 = que_1.shift()        let mp2 = que_2.shift()        if (mp1.val !== mp2.val) return false        if (mp1.left &amp;&amp; mp2.left) &#123;            que_1.push(mp1.left)            que_2.push(mp2.left)        &#125; else if(!mp1.left &amp;&amp; !mp2.left)&#123;&#125; else &#123;            return false        &#125;        if (mp1.right &amp;&amp; mp2.right) &#123;            que_1.push(mp1.right)            que_2.push(mp2.right)        &#125; else if(!mp1.right &amp;&amp; !mp2.right)&#123;&#125; else &#123;            return false        &#125;    &#125;&#125;return true</code></pre><p>};</pre><p id="u2a1b40a8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015502900-ce25f41b-27ba-42d1-aba5-574187e8e2b8.png" width="630.8333082662698" id="u588d5535" class="ne-image"></p><h3 id="fOcqM"><span class="ne-text">DFS</span></h3><p id="ud9083096" class="ne-p"><span class="ne-text">肝不动了，直接暴力 run ok 就行</span></p><pre data-language="javascript" id="px4sF" class="ne-codeblock language-javascript">/**</p></li><li><p>Definition for a binary tree node.</p></li><li><p>function TreeNode(val, left, right) {</p></li><li><pre><code>this.val = (val===undefined ? 0 : val)</code></pre></li><li><pre><code>this.left = (left===undefined ? null : left)</code></pre></li><li><pre><code>this.right = (right===undefined ? null : right)</code></pre></li><li><p>}<br>*/<br>/**</p></li><li><p>@param {TreeNode} p</p></li><li><p>@param {TreeNode} q</p></li><li><p>@return {boolean}<br>*/<br>var isSameTree = function(p, q) {<br>let result = true<br>if (p === null &amp;&amp; q === null) return result<br>if (p === null || q === null) return !result<br>let arr_1 = []<br>let arr_2 = []<br>let dfs = (data, arr) =&gt; {<br>if (data) {<br>arr.push(data.val)<br>if (data.left) {<br>dfs(data.left, arr)<br>} else {<br>arr.push(99999)<br>}<br>if (data.right) {<br>dfs(data.right, arr)<br>} else {<br>arr.push(99999)<br>}</p><pre><code>    &#125;&#125;dfs(p, arr_1)dfs(q, arr_2)if (arr_1.length !== arr_2.length) result = falsearr_1.forEach((data, index) =&gt; &#123;    if (data !== arr_2[index]) &#123;        result = false    &#125;&#125;)return result</code></pre><p>};</pre><p id="ufa7f6e11" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015520028-ccb54006-a5de-4448-8501-d6570716c111.png" width="636.6666413678073" id="u4ffec31d" class="ne-image"></p></div></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>102. 二叉树的层序遍历🔖BFS</title>
      <link href="/blog/by7bg0/"/>
      <url>/blog/by7bg0/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u33c6c359"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" data-href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</span></a></li></ul><p id="uf4f66dda" class="ne-p"><span class="ne-text">广度优先搜索</span></p><p id="u901c812d" class="ne-p"><span class="ne-text"></span></p><pre data-language="javascript" id="TAgPs" class="ne-codeblock language-javascript">/**<ul><li><p>Definition for a binary tree node.</p></li><li><p>function TreeNode(val, left, right) {</p></li><li><pre><code>this.val = (val===undefined ? 0 : val)</code></pre></li><li><pre><code>this.left = (left===undefined ? null : left)</code></pre></li><li><pre><code>this.right = (right===undefined ? null : right)</code></pre></li><li><p>}<br>*/<br>/**</p></li><li><p>@param {TreeNode} root</p></li><li><p>@return {number[][]}<br>*/<br>var levelOrder = function(root) {<br>if(!root) return []<br>let result = []<br>let que = []<br>que.push(root)<br>while(que.length !== 0) {<br>let init_size = que.length<br>let temp = []<br>for (let i = 0; i&lt;init_size; i++) {<br>let mp = que.shift()<br>if(mp.left) que.push(mp.left)<br>if(mp.right) que.push(mp.right)<br>temp.push(mp.val)<br>}<br>result.push(temp)<br>}</p><pre><code>return result</code></pre><p>};</pre><p id="u50a3c995" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015568860-91161da1-00e3-41d8-9024-9d860fa22e9c.png" width="630.8333082662698" id="ucd610f2e" class="ne-image"></p></div></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>129. 求根节点到叶节点数字之和🔖DFS</title>
      <link href="/blog/thy7mx/"/>
      <url>/blog/thy7mx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u6a1cce50"><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" data-href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/</span></a></li></ul><p id="ufc5039cc" class="ne-p"><span class="ne-text"></span></p><h3 id="dyUoI"><span class="ne-text">dfs</span></h3><pre data-language="javascript" id="hWrGB" class="ne-codeblock language-javascript">/**<ul><li>Definition for a binary tree node.</li><li>function TreeNode(val, left, right) {</li><li><pre><code>this.val = (val===undefined ? 0 : val)</code></pre></li><li><pre><code>this.left = (left===undefined ? null : left)</code></pre></li><li><pre><code>this.right = (right===undefined ? null : right)</code></pre></li><li>}<br>*/<br>/**</li><li>@param {TreeNode} root</li><li>@return {number}<br>_/<br>var sumNumbers = function(root) {<br>if (!root) return root<br>let arr = []<br>let result = 0<br>let dfs = (data, presum) =&gt; {<br>if (data) {<br>presum = data.val + presum _ 10<br>if (!data.left &amp;&amp; !data.right)<br>arr.push(presum)<br>else {<br>dfs(data.left, presum)<br>dfs(data.right, presum)<br>}<br>}<br>}<br>dfs(root, 0)<br>result = arr.reduce((a, b) =&gt; {return a + b})<br>return result<br>};</pre><p id="u6922ddff" class="ne-p"><span class="ne-text">优化一下得到：</span></p><pre data-language="javascript" id="vEREk" class="ne-codeblock language-javascript">/**</li><li>Definition for a binary tree node.</li><li>function TreeNode(val, left, right) {</li><li><pre><code>this.val = (val===undefined ? 0 : val)</code></pre></li><li><pre><code>this.left = (left===undefined ? null : left)</code></pre></li><li><pre><code>this.right = (right===undefined ? null : right)</code></pre></li><li>}<br>*/<br>/**</li><li>@param {TreeNode} root</li><li>@return {number}<br>_/<br>var sumNumbers = function(root) {<br>let dfs = (data, presum) =&gt; {<br>if (data === null) return 0<br>presum = data.val + presum _ 10<br>if (!data.left &amp;&amp; !data.right) {<br>return presum<br>}<br>return dfs(data.left, presum) + dfs(data.right, presum)<br>}<br>return dfs(root, 0)<br>};</pre><p id="ub2e4a533" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015642635-9c156952-829a-4fe0-9659-13773d03152d.png" width="620.8333086636342" id="u5238ad6b" class="ne-image"></p></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>222. 完全二叉树的节点个数🔖DFS</title>
      <link href="/blog/ktp9xg/"/>
      <url>/blog/ktp9xg/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u07a8ac51"><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" data-href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/count-complete-tree-nodes/</span></a></li></ul><p id="ub8a1fd4e" class="ne-p"><span class="ne-text"></span></p><p id="ua0193dda" class="ne-p"><span class="ne-text">思路：</span></p><p id="ude5f7034" class="ne-p"><span class="ne-text">通法就是递归，其他方法暂不考虑</span></p><pre data-language="javascript" id="hBMgc" class="ne-codeblock language-javascript">/**<ul><li>Definition for a binary tree node.</li><li>function TreeNode(val, left, right) {</li><li><pre><code>this.val = (val===undefined ? 0 : val)</code></pre></li><li><pre><code>this.left = (left===undefined ? null : left)</code></pre></li><li><pre><code>this.right = (right===undefined ? null : right)</code></pre></li><li>}<br>*/<br>/**</li><li>@param {TreeNode} root</li><li>@return {number}<br>*/<br>var countNodes = function(root) {<br>let result = 0<br>let nodes = data =&gt; {<br>if (data) {<br> nodes(data.left)<br>nodes(data.right)<br>result++<br>}<br>}<br>nodes(root)<br>return result<br>};</pre><p id="u665d3829" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015619370-5b367d0f-0a6d-4017-92cd-d370355d74bc.png" width="628.333308365611" id="ud7655360" class="ne-image"></p></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>922. 按奇偶排序数组 II🔖暴力</title>
      <link href="/blog/hfqwr9/"/>
      <url>/blog/hfqwr9/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ud64ba08c"><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/" data-href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/sort-array-by-parity-ii/</span></a></li></ul><p id="u964fd2bb" class="ne-p"><br></p><p id="u9d6469a0" class="ne-p"><span class="ne-text">思路：我特喵的直接暴力解法</span></p><p id="u019aab45" class="ne-p"><span class="ne-text"></span></p><pre data-language="javascript" id="doRaU" class="ne-codeblock language-javascript">/**<ul><li>@param {number[]} nums</li><li>@return {number[]}<br>_/<br>var sortArrayByParityII = function(nums) {<br>let arr = []<br>let arr_ou = []<br>let arr_ji = []<br>nums.forEach(data =&gt; {<br>data % 2 === 0 ? arr_ou.push(data) : arr_ji.push(data)<br>})<br>for (let i = 0; i&lt;arr_ji.length ;i++) {<br>arr[i _ 2] = arr_ou[i]<br>arr[i * 2 + 1] = arr_ji[i]<br>}<br>return arr<br>};</pre><p id="u3219963b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651392122716-c4681176-5009-40b5-958f-e5221988a605.png" width="664.1666402750556" id="u4d6b42ad" class="ne-image"></p></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📊查找排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>164. 最大间距🔖排序🔖array.sort🔖冒泡排序</title>
      <link href="/blog/szmcwf/"/>
      <url>/blog/szmcwf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u3630a41a"><a href="https://leetcode-cn.com/problems/maximum-gap/" data-href="https://leetcode-cn.com/problems/maximum-gap/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/maximum-gap/</span></a></li></ul><p id="u740a0366" class="ne-p"><span class="ne-text"></span></p><h3 id="liEvF"><span class="ne-text">array.sort</span></h3><pre data-language="javascript" id="PdfI4" class="ne-codeblock language-javascript">/**<ul><li>@param {number[]} nums</li><li>@return {number}<br>*/<br>var maximumGap = function(nums) {<br>let result = 0<br>if(nums.length &lt; 2) return result<br>nums.sort((a, b) =&gt; {return a - b}).forEach((data, index) =&gt; {<br>if (index &lt; nums.length - 1) {<br>result = result &gt; nums[index + 1] - data ? result : nums[index + 1] - data<br>}<br>})<br>return result<br>};</pre><p id="u579e3795" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651388338749-eedd3c62-5fa2-47c1-b44d-76a007fe023f.png" width="624.1666418645127" id="u4ad07262" class="ne-image"></p><h3 id="hoahQ"><span class="ne-text">冒泡排序</span></h3><p id="u0d4555f0" class="ne-p"><span class="ne-text">也可以利用冒泡排序，在最后两项排完，比较差值然后与 result 对比</span></p></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📊查找排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>148. 排序链表🔖链表🔖js初始化单链表</title>
      <link href="/blog/cput4h/"/>
      <url>/blog/cput4h/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="fsJ6t"><span class="ne-text">148. 排序链表</span></h3><ul class="ne-ul"><li id="u102e7213"><a href="https://leetcode-cn.com/problems/sort-list/" data-href="https://leetcode-cn.com/problems/sort-list/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/sort-list/</span></a></li></ul><pre data-language="javascript" id="hUpnw" class="ne-codeblock language-javascript">/**<ul><li>Definition for singly-linked list.</li><li>function ListNode(val, next) {</li><li><pre><code>this.val = (val===undefined ? 0 : val)</code></pre></li><li><pre><code>this.next = (next===undefined ? null : next)</code></pre></li><li>}<br>*/<br>/**</li><li>@param {ListNode} head</li><li>@return {ListNode}<br>*/<br>var sortList = function(head) {<br>if (head === null) return head<br>let arr = []<br>while (head !== null) {<br>arr.push(head.val)<br>head = head.next<br>}<br>let result = arr.sort((a, b) =&gt; {return a - b})<br>let result_head = new ListNode(result[0], null)<br>let test = result_head<br>result.forEach((data, index) =&gt; {<br>if (index !== 0) {<br>let temp = new ListNode(data,null)<br>test.next = temp<br>test = temp<br>}<br>})<br>return result_head<br>};</pre><h3 id="YQj2X"><span class="ne-text">js 初始化单链表</span></h3><pre data-language="javascript" id="J20Y9" class="ne-codeblock language-javascript">// 节点<br>class Node {<br>constructor(value) {<br>this.val = value<br>this.next = null<br>}<br>}</li></ul><p>// 利用数组来初始化单链表<br>class NodeList {<br>constructor(arr) {<br>let head = new Node(arr.shift())<br>let next = head<br>arr.forEach(data =&gt; {<br>next.next = new Node(data)<br>next = next.next<br>})<br>return head<br>}<br>}</p><p>let test = new NodeList([1, 2, 3, 4])<br>while (test !== null) {<br>console.log(test.val)<br>test = test.next<br>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📎线结构：链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>集成ESLint和Prettier代码校验格式化环境（npm包和vscode插件）</title>
      <link href="/blog/mkn98t/"/>
      <url>/blog/mkn98t/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u12b64d5c" class="ne-p"><span class="ne-text">搞清楚这些逻辑</span></p><p id="u60b62379" class="ne-p"><span class="ne-text">vscode eslint prettier vue eslint-config-prettier</span></p><p id="u01d6fcdf" class="ne-p"><a href="https://github.com/wztlink1013/plan/blob/main/package.json" data-href="https://github.com/wztlink1013/plan/blob/main/package.json" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wztlink1013/plan/blob/main/package.json</span></a></p><h2 id="sFMfa"><span class="ne-text">vscode插件</span></h2><h3 id="h0Bj3"><span class="ne-text">ESLint</span></h3><p id="u4c54dfd4" class="ne-p"><span class="ne-text">格式化检测工具：会给出警告抑或是报错，但不会修改</span></p><h3 id="qq5f8"><span class="ne-text">Prettier - Code formatter</span></h3><p id="u2bc455ee" class="ne-p"><span class="ne-text">代码格式化插件：按照所需配置直接格式化代码</span></p><h2 id="o9fJW"><span class="ne-text">npm包</span></h2><h3 id="EHhwf"><span class="ne-text">eslint-plugin-html</span></h3><p id="u84ebd259" class="ne-p"><span class="ne-text">目的是为了检测html文件中的js代码，全局下载，让设备非node项目也能使用</span></p><pre data-language="bash" id="ssMLw" class="ne-codeblock language-bash">npm install -g eslint-plugin-html</pre><p id="u43b1986c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640400558364-b89c0585-1302-4515-b27a-bdb053cf8701.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_47%2Ctext_5bC86YeH6Iis5Zyw5oqS5oOF%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" width="828" id="uc4ceedb9" class="ne-image"></p><p id="u8bca4c3c" class="ne-p"><span class="ne-text">每次打开html，eslint就会报错：</span></p><pre data-language="plain" id="BogCY" class="ne-codeblock language-plain">'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.</pre><p id="u075e0d78" class="ne-p"><span class="ne-text">官网issues </span><a href="https://github.com/microsoft/vscode-eslint/issues/1376" data-href="https://github.com/microsoft/vscode-eslint/issues/1376" target="_blank" class="ne-link"><span class="ne-text">https://github.com/microsoft/vscode-eslint/issues/1376</span></a><span class="ne-text"> 中貌似也并未给出根治方法，暂时禁用：</span></p><p id="uad85479a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640401735422-2e618454-6752-4b2e-9020-8788d0ad114d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_5bC86YeH6Iis5Zyw5oqS5oOF%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" width="365" id="u7b0c7db1" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>维</title>
      <link href="/essay/hq3fcy/"/>
      <url>/essay/hq3fcy/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u96c35fa4" class="ne-p"><span class="ne-text">意念是多维化的体现。</span></p><p id="uba8fa4b2" class="ne-p"><span class="ne-text"></span></p><p id="u2d275003" class="ne-p"><span class="ne-text">在宇宙的浩瀚星辰中，难以被人们所定义的是空间，空间的等价转化则是维度，换言之，维度是人类难以捕捉的而又不时出现在我们日常生活中。 </span></p><p id="u697a6245" class="ne-p"><span class="ne-text"></span></p><p id="ue16ebb28" class="ne-p"><span class="ne-text">冥想是即达多维空间目的地的不错选择，冥想让我们建立思维上的楼阁，看是虚无，实则通往多维空间。 </span></p><p id="u04a7864a" class="ne-p"><span class="ne-text"></span></p><p id="uc3a69b06" class="ne-p"><span class="ne-text">任何事物都需要沟通，人类文明创立以来，进制是创先河之例，打开了与计算机沟通的大门。其实此则不然，在永恒事物变相中，有一种沟通方式可以让万物联系——多维化零进制。</span></p><p id="u59bd2bab" class="ne-p"><span class="ne-text"></span></p><p id="u3189b74e" class="ne-p"><span class="ne-text">那是谁拾起探索的光辉？又是谁如先驱们般开始质疑身边的科学，一切的一切由维度引起——多维化平行宇宙空间……</span></p><p id="u7749951d" class="ne-p"><span class="ne-text"></span></p><p id="ude271eae" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>645. 错误的集合🔖数组</title>
      <link href="/blog/vvs5xy/"/>
      <url>/blog/vvs5xy/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u8d9d555a"><a href="https://leetcode-cn.com/problems/set-mismatch/" data-href="https://leetcode-cn.com/problems/set-mismatch/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/set-mismatch/</span></a></li></ul><p id="uf83dc93a" class="ne-p"><span class="ne-text">想着中午写道简单题，喵的，丧失一天学习心情……</span></p><p id="u4e2b75ae" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648964102729-2472a01f-8d16-416d-9f17-f8f9ff9acd52.png" width="268.015625" id="ufbf4071b" class="ne-image"></p><pre data-language="typescript" id="oWz5v" class="ne-codeblock language-typescript">function findErrorNums(nums: number[]): number[] {<pre><code>let result: any = []nums.sort((a: number, b:number) =&gt; &#123; return a - b &#125;)nums.forEach((data: number, index: number) =&gt; &#123;    // 重复的值    if (data === nums[index - 1]) &#123;        result.unshift(data)        nums.splice(index, 1)        nums.push(0)        // 丢失的值        for (let i: number = 0; i &lt; nums.length; i++) &#123;            if(i + 1 !== nums[i]) &#123;                result.push(i + 1)                break            &#125;        &#125;    &#125;&#125;)return result</code></pre><p>};</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TODO: 30. 串联所有单词的子串🔖递归</title>
      <link href="/blog/lgg15d/"/>
      <url>/blog/lgg15d/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u923bba18"><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" data-href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/</span></a></li></ul><p id="uc4ca95dc" class="ne-p"><span class="ne-text"></span></p><h3 id="eY8Jl"><span class="ne-text">思路</span></h3></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>93. 复原 IP 地址🔖递归</title>
      <link href="/blog/aucxuf/"/>
      <url>/blog/aucxuf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u548cf5a7"><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" data-href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/restore-ip-addresses/</span></a></li></ul><p id="u300a127c" class="ne-p"><span class="ne-text"></span></p><h3 id="Uh8J5"><span class="ne-text">思路</span></h3><ul class="ne-ul"><li id="u123f0828"><span class="ne-text">长度为12位：最小单元位3</span></li><li id="u999a712f"><span class="ne-text">长度为11位：最小单元位2</span></li><li id="u00b89315"><span class="ne-text">其他情况的最小单元位有可能是1</span></li></ul><p id="u07aa0710" class="ne-p"><span class="ne-text"></span></p><h3 id="P81a3"><span class="ne-text">ts代码</span></h3><pre data-language="typescript" id="vAKCa" class="ne-codeblock language-typescript">function restoreIpAddresses(s: string): string[] {<p>// 保存所有符合条件的 IP 地址<br>let r: any[] = []<br>// 分四步递归处理 ip 分段<br>let search = (cur: any, sub: any) =&gt; {<br>if (sub.length &gt; 12) return</p><pre><code>// 边界条件if (cur.length === 4 &amp;&amp; cur.join(&#39;&#39;) === s) &#123;  r.push(cur.join(&#39;.&#39;))&#125; else &#123;  // 正常的处理过程  for (let i = 0, len = Math.min(3, sub.length), tmp; i &lt; len; i++) &#123;    tmp = sub.substr(0, i + 1)    if (tmp - 256 &lt; 0) &#123;      // 转换下数据类型，如 01为1（LeetCode测试用例）      search(cur.concat([tmp * 1]), sub.substr(i + 1))    &#125;  &#125;&#125;</code></pre><p>}<br>search([], s)<br>return r<br>}</p><p>console.log(restoreIpAddresses(‘101023’))</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TODO: 10. 正则表达式匹配🔖正则</title>
      <link href="/blog/qg73ng/"/>
      <url>/blog/qg73ng/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u3ed91f86"><a href="https://leetcode-cn.com/problems/regular-expression-matching/" data-href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/regular-expression-matching/</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>459. 重复的子字符串🔖正则🔖字符串</title>
      <link href="/blog/rqcfeh/"/>
      <url>/blog/rqcfeh/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u683cc527"><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" data-href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/repeated-substring-pattern/</span></a></li></ul><p id="ubdc16351" class="ne-p"><span class="ne-text"></span></p><h3 id="QfRo2"><span class="ne-text">思路</span></h3><p id="u85e94159" class="ne-p"><span class="ne-text">基本正则模式匹配</span></p><h3 id="uDb1q"><span class="ne-text">ts代码</span></h3><pre data-language="typescript" id="RAm8X" class="ne-codeblock language-typescript">function repeatedSubstringPattern(s: string): boolean {<p>let reg: RegExp = /^(\w+)\1+$/<br>return reg.test(s)<br>}</p><p>console.log(repeatedSubstringPattern(‘abcabcabcabc’))</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>682. 棒球比赛🔖栈</title>
      <link href="/blog/srz8lz/"/>
      <url>/blog/srz8lz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u898cb1c6"><a href="https://leetcode-cn.com/problems/baseball-game/" data-href="https://leetcode-cn.com/problems/baseball-game/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/baseball-game/</span></a></li></ul><p id="ua5f6f7e4" class="ne-p"><span class="ne-text"></span></p><h3 id="FFVha"><span class="ne-text">思路</span></h3><p id="u706c01da" class="ne-p"><span class="ne-text">没啥好说的——栈的最基本理解</span></p><p id="uff6e69a2" class="ne-p"><span class="ne-text">js的栈实现是利用Array的push和pop……</span></p><p id="udae4c03c" class="ne-p"><span class="ne-text"></span></p><pre data-language="typescript" id="a08iT" class="ne-codeblock language-typescript">function calPoints(ops: string[]): number {<p>let sta: Array<number> = []<br>ops.forEach((data: string) =&gt; {<br>switch (data) {<br>case ‘+’:<br>sta.push(sta[sta.length - 1] + sta[sta.length - 2])<br>break<br>case ‘D’:<br>sta.push(sta[sta.length - 1] * 2)<br>break<br>case ‘C’:<br>sta.pop()<br>break<br>default:<br>sta.push(Number(data))<br>}<br>})</p><p>return sta.reduce((result: number, index: number) =&gt; {<br>return result + index<br>})<br>}</p><p>console.log(calPoints([‘5’, ‘-2’, ‘4’, ‘C’, ‘D’, ‘9’, ‘+’, ‘+’]))</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11. 盛最多水的容器🔖数组🔖双指针</title>
      <link href="/blog/amgx01/"/>
      <url>/blog/amgx01/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ub9ee704f"><a href="https://leetcode-cn.com/problems/container-with-most-water/" data-href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/container-with-most-water/</span></a></li></ul><p id="ub4ceec83" class="ne-p"><span class="ne-text"></span></p><h3 id="wvuOt"><span class="ne-text">思路</span></h3><h4 id="zm5Lb"><span class="ne-text">暴力循环解决</span></h4><ul class="ne-ul"><li id="u9e4d4ab9"><span class="ne-text">对数组各个元素进行第一遍遍历，在此之中</span><strong><span class="ne-text">以该元素为基准</span></strong><span class="ne-text">对</span><strong><span class="ne-text">该元素后面的所有元素进行遍历</span></strong><span class="ne-text">，进行</span><code class="ne-code"><span class="ne-text">两者最短高度 * （后面元素下标 - 该元素下标）</span></code><span class="ne-text">运算，遍历完成即可得到上述值的最大值result。</span></li><li id="ub9c5a2fb"><span class="ne-text">该元素后面的所有元素进行遍历：这个循环是指定开始索引的位置往后进行的遍历，使用传统for循环或是for in循环</span></li></ul><p id="ub507a9bd" class="ne-p"><span class="ne-text"></span></p><p id="u3d71db66" class="ne-p"><span class="ne-text">这种解法会超时，写的时候我就感觉到了数组的双循环八成是超时，即便我是第二个循环不找全部元素，但还是超时n^2逃不掉</span><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1648709054571-cb914e0d-2a17-4e20-bdb3-d0f105bec0fe.jpeg" width="52" id="u4K1n" class="ne-image"></p><pre data-language="typescript" id="k2hFv" class="ne-codeblock language-typescript">function maxArea(height: number[]): number {<p>let result: number = 0<br>height.forEach((data: number, index: number) =&gt; {<br>if (index !== height.length - 1) {<br>for (let i: number = index + 1; i &lt; height.length; i++) {<br>let result_temp = Math.min(height[i], data) * (i - index)<br>result &gt; result_temp ? (result = result) : (result = result_temp)<br>}<br>}<br>})<br>return result</p><p></pre><p id="u903f225f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648707457045-2a083f7a-faab-4354-91bf-7a6b9e45c867.png" width="1300.8332816428629" id="uc882220e" class="ne-image"></p><h4 id="bpe3H"><span class="ne-text">两端双指针移动解决</span></h4><ul class="ne-ul"><li id="u7385276d"><span class="ne-text">探究解决办法的规律来解决问题，利用双指针在首末端往中间靠，每次移动arr[指针]小的，然后在此次与result相比较。</span></li><li id="u3f46a4a7"><span class="ne-text">这样只需要遍历一遍即可，时间复杂度为n</span></li></ul><p id="u80e14356" class="ne-p"><span class="ne-text"></span></p><pre data-language="typescript" id="VRgYM" class="ne-codeblock language-typescript">function maxArea(height: number[]): number {<br>  let head: number = 0<br>  let back: number = height.length - 1<br>  const result_fun = (head: number, back: number): number => {<br>    return Math.min(height[head], height[back]) * (back - head)<br>  }<br>  let result = result_fun(head, back)</p><p>while (head !== back) {<br>height[head] &lt; height[back] ? head++ : back–<br>if(result &lt;= result_fun(head, back) ) result = result_fun(head, back)<br>}</p><p>return result<br>}</pre><p id="u36e90195" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648710814761-4255d705-1462-47ed-8a96-ad66c4bf25a6.png" width="599.999976158143" id="u401ae785" class="ne-image"></p><p id="u7cc03987" class="ne-p"><span class="ne-text"></span></p><p id="ucf47e7f1" class="ne-p"><span class="ne-text"></span></p><p id="u45d2fc7b" class="ne-p"><span class="ne-text"></span></p><p id="u85afaab6" class="ne-p"><span class="ne-text"></span></p><p id="u31ad7968" class="ne-p"><span class="ne-text"></span></p><p id="u3ea57d64" class="ne-p"><span class="ne-text"></span></p><p id="ucbf45dc3" class="ne-p"><span class="ne-text"></span></p><p id="u0d5526ac" class="ne-p"><span class="ne-text"></span></p><p id="ua16ce551" class="ne-p"><span class="ne-text"></span></p><p id="u1a516ef3" class="ne-p"><span class="ne-text"></span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>疫情下的空城与花海</title>
      <link href="/essay/gvzzcs/"/>
      <url>/essay/gvzzcs/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ud8bce089" class="ne-p"><span class="ne-text">我们总喜欢作为旁观者去看待未能触及到自身的悲景，而这个世界上最悲观的身旁之物我想应该就是死亡了。</span></p><p id="u8d57e81f" class="ne-p"><span class="ne-text"></span></p><p id="u973b2519" class="ne-p"><strong><span class="ne-text">空城</span></strong></p><p id="u7c61ba01" class="ne-p"><span class="ne-text"></span></p><p id="ufb565da6" class="ne-p"><span class="ne-text">到现在已有两年之久的心冠疫情，或许就是近些年来让我们体会到死亡的传使者，生命变得消亡，聚集场所变得暗淡，像是给我们笼罩一层未能看见的阴霾，我很讨厌这么一个微小生生物为生活所带来的暗色调。</span></p><p id="u8fbaffd3" class="ne-p"><span class="ne-text"></span></p><p id="u4ec1ac32" class="ne-p"><span class="ne-text">东方航空MU5735的坠毁。在学校和家里的来往，我常坐飞机这一交通形式，我体验过飞机通过强气流带来的机体剧烈晃动，飞机失事的情况，我想，那几分钟是很绝望的，你只能坐在自己座椅上，被飞机下坠的惯性将自己身体硬拽在靠椅上，窗边呼啸的气流声，让你面无神色。我很讨厌大自然偶尔的霸道无理的脾气。</span></p><p id="u4140cd6c" class="ne-p"><span class="ne-text"></span></p><p id="uf876e599" class="ne-p"><strong><span class="ne-text">花海</span></strong></p><p id="ue1302591" class="ne-p"><span class="ne-text"></span></p><p id="u8508c042" class="ne-p"><span class="ne-text">学校的三月是一个有花的季节，成片的花香与色彩遍布整个校园。</span></p><p id="u2d0758a0" class="ne-p"><span class="ne-text">成片的花海是我22年觉得最美的一件事物，她将周围的灰色染成五彩斑斓的景色。</span></p><p id="u7d66b47e" class="ne-p"><span class="ne-text"></span></p><p id="uf6e113a6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1648700562531-b0b2bf77-4d97-40e1-a7b0-880d8d188c60.jpeg" width="1216" id="rGCAP" class="ne-image"></p><p id="u89ecd93d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1648700589001-880ca871-1ae5-4ab0-8093-5b09c50f8f63.jpeg" width="1216" id="yMKAc" class="ne-image"></p><p id="u7631b671" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1648700686067-283184da-ffb4-4ff7-84b3-465dbcdfa76b.jpeg" width="1216" id="dblVL" class="ne-image"></p><p id="uf5316d82" class="ne-p"><span class="ne-text"></span></p><p id="u0296b290" class="ne-p"><span class="ne-text">花会枯萎，树会凋零，一瞬的美好终会陨落</span></p><p id="ue354674b" class="ne-p"><span class="ne-text">一瞬美好存于此的的意义会是什么呢</span></p><p id="u2e9b7c93" class="ne-p"><span class="ne-text">我不曾知道，也未曾想过</span></p><p id="ue4180be1" class="ne-p"><span class="ne-text">可是这些一个月的美丽都不曾保留的美丽，让我些许顿悟</span></p><p id="u3c7db598" class="ne-p"><span class="ne-text">美好的意义或许就是美好本身，她不需要太多的形容</span></p><p id="u86939c2e" class="ne-p"><span class="ne-text">你会因为她的绽放感到开心、感到愉悦、感到这世上原来还有这么美好的事物</span></p><p id="u98e389c4" class="ne-p"><span class="ne-text"></span></p><p id="ub40bc1ea" class="ne-p"><span class="ne-text">任何事物的存在都必然伴随着其存在的意义</span></p><p id="u28a79194" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从输入 URL 到页面加载完成，发生了什么？在此流程中做优化！</title>
      <link href="/blog/lvs755/"/>
      <url>/blog/lvs755/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u2fc17575" class="ne-p"><span class="ne-text">前言：从输入 URL 到页面加载完成，发生了什么？</span></p><p id="uddb4c6a5" class="ne-p"><span class="ne-text"></span></p><p id="uc5de653e" class="ne-p"><span class="ne-text">输入URL，浏览器会先处理输入的信息是搜索信息还是URL请求连接，这个过程需要浏览器的URL解析操作；然后我们需要通过 DNS（域名解析系统）将 URL 解析为对应的 IP 地址，然后与这个 IP 地址确定的那台服务器建立起 TCP 网络连接，随后我们向服务端抛出我们的 HTTP 请求，服务端处理完我们的请求之后，把目标数据放在 HTTP 响应里返回给客户端，拿到响应数据的浏览器就可以开始走一个渲染的流程。渲染完毕，页面便呈现给了用户，并时刻等待响应用户的操作。</span></p><p id="uc80a875b" class="ne-p"><span class="ne-text"></span></p><p id="u561ad2be" class="ne-p"><span class="ne-text">具体大致过程如下：</span></p><ol class="ne-ol"><li id="u067f5cbc"><span class="ne-text">URL解析</span></li><li id="uc53e72f2"><span class="ne-text">DNS解析</span></li><li id="u2b6e56f3"><span class="ne-text">TCP连接</span></li><li id="uce68944d"><span class="ne-text">客户端发送请求</span></li><li id="u46165cd2"><span class="ne-text">服务端处理请求，响应请求</span></li><li id="uae7019d8"><span class="ne-text">客户端和服务端断开连接</span></li><li id="u1a074c0e"><span class="ne-text">浏览器拿到响应数据，解析响应内容，把解析的结果渲染展示给用户</span></li></ol><p id="ub70b78cb" class="ne-p"><span class="ne-text"></span></p><p id="u01bae1f7" class="ne-p"><span class="ne-text">而前端性能优化，就是把这 5 个过程滴水不漏地考虑到自己的性能优化方案内、反复权衡，从而打磨出用户满意的速度。</span></p><p id="u19e8d619" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="u3c39882e" class="ne-p"><span class="ne-text">文章参考以下两个文章，基于以下文章并做出部分自己的修改：</span></p><ul class="ne-ul"><li id="u14c64fe7"><a href="https://www.kancloud.cn/sllyli/performance/1242194" data-href="https://www.kancloud.cn/sllyli/performance/1242194" target="_blank" class="ne-link"><span class="ne-text">前端性能优化原理与实践</span></a></li><li id="u66e796d7"><a href="https://juejin.cn/post/6844904194801926157" data-href="https://juejin.cn/post/6844904194801926157" class="ne-link"><span class="ne-text">从输入URL到渲染全过程</span></a></li><li id="ue1c40704"><a href="https://segmentfault.com/a/1190000017184701" data-href="https://segmentfault.com/a/1190000017184701" target="_blank" class="ne-link"><span class="ne-text">从URL输入到页面展现到底发生什么？</span></a></li></ul></div><h2 id="fkLx5"><span class="ne-text">一、URL解析</span></h2><h3 id="sBzKf"><span class="ne-text">地址解析和编码</span></h3><p id="ub827738a" class="ne-p"><span class="ne-text">我们输入URL后，浏览器会解析输入的字符串，判断是URL还是搜索关键字，如果是URL就开始编码。<p></span></p><p id="udef58a97" class="ne-p"><span class="ne-text">一般来说 URL 只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号，所以，如果 URL 中有文字就必须编码后使用。但是 URL 编码很混乱，不同的操作系统、浏览器、网页字符集，会导致不同的编码结果。所以我们需要使用 JavaScript 先对 URL 编码，然后提交给服务器，不给浏览器插手的机会。我们通常会使用 encodeURI()函数或者 encodeURIComponent()函数来编码 URL</span></p><h3 id="IMnj6"><span class="ne-text">HSTS</span></h3><p id="uc5ae8a65" class="ne-p"><span class="ne-text">HSTS(HTTP Strict TransportSecurity)是一种新的 Web 安全协议，HSTS 的作用是强制客户端使用 HTTPS 与服务器创建连接。比如你在地址栏输入 <a href="http://xxx/%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%B0%86">http://xxx/，浏览器会自动将</a> http 转写成 https，然后直接向</span><span class="ne-text"><a href="https://xxx/">https://xxx/</a></span><span class="ne-text"> 发送请求。</span></p><h3 id="h3tJI"><span class="ne-text">缓存检查</span></h3><p id="uff4993aa" class="ne-p"><span class="ne-text">浏览器在发送请求之前先检查有没有缓存，过程如下： </span><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653193882930-3c261c9c-875f-4ee5-994b-e8fcf22272ee.webp" width="556" id="ue084b2ed" class="ne-image"></p><p id="u9a262410" class="ne-p"><span class="ne-text">浏览器会先去查看强缓存（Expires 和 cache-control）判断是否过期，如果强缓存生效，直接从缓存中读取资源；若不生效则进行协商缓存(Last-Modified / If-Modified-Since 和 Etag/If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回 200，并重新返回资源和缓存标识，再次存入浏览器缓存中；生效则返回 304，并从缓存中读取资源。（协商缓存之前要经过 DNS 域名解析，之后建立 TCP 链接）</span></p><p id="u05f4739d" class="ne-p"><span class="ne-text"></span></p><p id="u40bf2323" class="ne-p"><span class="ne-text">那么浏览器缓存的位置在哪呢？</span></p><ul class="ne-ul"><li id="u2a691d56"><span class="ne-text">Service Worker：浏览器独立线程进行缓存</span></li><li id="ub192ead7"><span class="ne-text">Memory Cache：内存缓存</span></li><li id="ue8f5ead7"><span class="ne-text">Disk Cache：硬盘缓存</span></li><li id="u7ec40f81"><span class="ne-text">Push Cache：推送缓存（HTTP/2 中的）</span></li></ul><p id="u702a4534" class="ne-p"><span class="ne-text"></span></p><p id="uca2781b8" class="ne-p"><strong><span class="ne-text">注意</span></strong><span class="ne-text">：输入网址之后，会查找内存缓存，没有再找硬盘，都没有就发生网络请求。 普通刷新（F5）：因为 TAB 没有关闭，所以内存缓存可用，如果匹配上会被优先使用，其次是磁盘缓存 强制刷新（Ctrl+F5）：浏览器不使用缓存，因此发送的请求头均带有 Cache-control：no-cache,服务器直接返回 200 和最新内容。</span></p><h2 id="rq2lt"><span class="ne-text">二、DNS 解析</span></h2><h3 id="Ods3i"><span class="ne-text">DNS</span></h3><ul class="ne-ul"><li id="u366d3502"><span class="ne-text">DNS：把域名和 ip 地址相互映射分布式数据库，让用户能更方便的访问互联网，DNS 协议运行在 UDP 协议之上</span></li><li id="u6affd3cd"><span class="ne-text">DNS 解析：通过域名最终得到对应 ip 地址的过程。</span></li><li id="u18654d17"><span class="ne-text">DNS 缓存：浏览器，操作系统，路由器，本地 DNS，根域名服务器都会对 DNS 结果作出一定的缓存</span></li></ul><h3 id="qAZgt"><span class="ne-text">DNS 解析过程</span></h3><ol class="ne-ol"><li id="u2ecc5cd1"><span class="ne-text">首先搜索浏览器自身的 DNS 缓存，有缓存直接返回;</span></li><li id="ue9619d95"><span class="ne-text">浏览器自身 DNS 不存在，浏览器就会调用一个类似 gethostbyname 的库函数,此函数会先去检测本地 hosts 文件，查看是否有对应 ip。</span></li><li id="ub5969738"><span class="ne-text">如果本地 hosts 文件不存在映射关系，就会查询路由缓存，路由缓存不存在就去查找本地 DNS 服务器（一般 TCP/IP 参数里会设首选 DNS 服务器，通常是 8.8.8.8)(客户端到本地 DNS 服务器是递归过程）</span></li><li id="ue13d369c"><span class="ne-text">如果本地 DNS 服务器还没找到就会向根服务器发出请求。（DNS 服务器之间是迭代过程）</span></li></ol><p id="u9c37fde4" class="ne-p"><br></p><p id="ub4d0dd01" class="ne-p"><span class="ne-text">具体过程：<br></span></p><ul class="ne-ul"><li id="u63850f02"><span class="ne-text">本地 DNS 服务器代我们的浏览器发起迭代 DNS 解析请求，首先它会找根域的 DNS 的 IP 地址（全球 13 台哟，可惜中国没有！）。找到根域的 DNS 地址,就会向其发起请求（请问<a href="http://www.baidu.com这个域名的IP地址是多少呀？）；">www.baidu.com这个域名的IP地址是多少呀？）；</a><br></span></li><li id="uc68a7e80"><span class="ne-text">根域发现这是一个顶级域 com 域的一个域名，于是告诉本地 DNS 服务器我不知道这个域名的 IP 地址,但是我知道 com 域的 IP 地址，你去找它去吧；<br></span></li><li id="ua40604c7"><span class="ne-text">于是本地 DNS 服务器就得到了 com 域的 IP 地址，又向 com 域的 IP 地址发起了请求（请问<a href="http://www.baidu.com这个域名的ip地址是多少呀/?%EF%BC%89,%E4%BA%8E%E6%98%AFcom%E5%9F%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%8A%E8%AF%89%E6%9C%AC%E5%9C%B0DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93www.baidu.com%E8%BF%99%E4%B8%AA%E5%9F%9F%E5%90%8D%E7%9A%84IP%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%BD%86%E6%98%AF%E6%88%91%E7%9F%A5%E9%81%93baidu.com%E8%BF%99%E4%B8%AA%E5%9F%9F%E7%9A%84DNS%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%BD%A0%E5%8E%BB%E6%89%BE%E5%AE%83%E5%8E%BB">www.baidu.com这个域名的IP地址是多少呀?）,于是com域服务器告诉本地DNS服务器我不知道www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去</a>;<br></span></li><li id="ufaa1d0a0"><span class="ne-text">于是本地 DNS 服务器又向 baidu.com 这个域名的 DNS 地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问<a href="http://www.baidu.com这个域名的IP地址是多少？），这个时候baidu.com域的DNS服务器一查，呀！果真在我这耶，于是就把找到的结果发送给本地DNS服务器">www.baidu.com这个域名的IP地址是多少？），这个时候baidu.com域的DNS服务器一查，呀！果真在我这耶，于是就把找到的结果发送给本地DNS服务器</a>;<br></span></li><li id="u8cf01fe8"><span class="ne-text">这个时候本地 DNS 服务器就拿到了<a href="http://www.baidu.com这个域名对应的ip地址./">www.baidu.com这个域名对应的IP地址。</a></span></li></ul><p id="u0fbd0b32" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653195503382-8d0d2c0b-904d-4f6f-ab2a-a41fde109da2.png" width="732" id="u07bfc271" class="ne-image"></p><h3 id="lkiXv"><span class="ne-text">DNS 优化</span></h3><p id="u91118b2b" class="ne-p"><span class="ne-text">DNS 也是开销，通常浏览器查找一个给定域名的 IP 地址要花费 20~120 毫秒，在完成域名解析之前，浏览器不能从服务器加载到任何东西。那么如何减少域名解析时间，加快页面加载速度呢？</span></p><ul class="ne-ul"><li id="ua58ce1cb"><span class="ne-text">减少 DNS 请求次数</span></li><li id="ufc2a45bc"><span class="ne-text">DNS 预获取,DOM 还没开始，浏览器预解析地址，把解析好的地址放在本地缓存里面，DOM 树生成完，要加载图片类的发现 DNS 已经解析好了，再发送请求。&lt;link rel=’dns-prefetch’href=’//dfns.tanx.com’&gt;<br></span><span class="ne-text">（主要对图片资源）</span></li><li id="u41a1cadd"><span class="ne-text">DNS 查询的过程经历了很多的步骤，如果每次都如此，会耗费太多的时间、资源。所以我们应该尽早的返回真实的 IP 地址:（减少查询过程，也就是 DNS 缓存。浏览器获取到 IP 地址后，一般都会缓存到浏览器的缓存中，本地的 DNS 缓存服务器，也可以去记录。另外，每天几亿网名的访问需求，一秒钟几千万的请求域名服务器如何满足？就是 DNS 负载均衡。通常我们的网站应用各种云服务，或者各种服务商提供类似的服务，由他们去帮我们处理这些问题。 DNS 系统根据每台机器的负载量，地理位置的限制（长距离的传输效率）等等，去提供高效快速的 DNS 解析服务。</span></li><li id="ub53fb360"><span class="ne-text">当客户端 DNS 缓存（浏览器和操作系统）缓存为空时，DNS 查找的数量与要加载的 Web 页面中唯一主机名的数量相同，包括页面 URL、脚本、样式表、图片、Flash 对象等的主机名。减少主机名的数量就可以减少 DNS 查找的数量；</span></li><li id="u27ac4863"><span class="ne-text">减少唯一主机名的数量会潜在减少页面中并行下载的数量（HTTP1.1 规范建议从每个主机名并行下载两个组件，但实际上可以多个）；但是减少主机名和并行下载的方案会产生矛盾，需要大家自己权衡。建议将组件放到至少两个但不多于 4 个主机名下，减少 DNS 查找的同时也允许高度并行下载。</span></li></ul><p id="u9b351d9d" class="ne-p"><strong><span class="ne-text">DNS 解析后会把域名的解析权交给 cname()指向的内容分发（CDN）专用的 DNS 服务器。CDN 专用的 DNS 服务器把 CDN 的全局负载均衡设备的 ip 地址返回给用户</span></strong><span class="ne-text">。</span></p><h3 id="eX2Gt"><span class="ne-text">CDN</span></h3><p id="u43c690d3" class="ne-p"><span class="ne-text">举个例子：以前坐火车买票，都要到火车站买，所有人都去火车站买票，火车站售票厅的压力可想而知有多大。</span></p><p id="ufa4b6417" class="ne-p"><span class="ne-text">后来火车票代售点出现了，分布在各个城市，城镇，我们只需要去距离我们最近的火车票售卖点买票就可以了。 卖火车票的代理售票点（缓存服务器），为买票者提供了方便，帮助他们在最近的地方（最近的 CDN 节点）， 用最短的时间（最短的请求时间）买到票（拿到资源）。减轻了售票大厅的压力（起到分流作用，减轻服务器负载压力）</span></p><h4 id="UZbAn"><span class="ne-text">CDN 缓存</span></h4><p id="uf2a937d7" class="ne-p"><span class="ne-text">在浏览器本地缓存失效后，浏览器会像 CDN 边缘节点发起请求，类似浏览器缓存，CDN 边缘节点也存在一套缓存机制，</span></p><ul class="ne-ul"><li id="uef250afb"><span class="ne-text">CDN 边缘节点缓存策略因服务商不同而不同，通过 http 响应头中的 cache-control：max-age 字段设置 CDN 边缘节点数据缓存时间。</span></li><li id="u701c37ab"><span class="ne-text">当浏览器向 CDN 节点请求数据时，CDN 节点会判断缓存数据是否过期，若缓存数据过期，CDN 会向服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端，CDN 服务商一般会提供基于文件后缀，目录多个维度来指定 CDN 缓存时间，为用户提供更精细化的缓存管理。</span></li></ul><h4 id="S0HlG"><span class="ne-text">CDN 工作方式</span></h4><p id="u748269ee" class="ne-p"><span class="ne-text">（1）、当你点击网站页面的 url 时，经过本 DNS 解析，DNS 解析后会把域名的解析权交给 cname()指向的内容分发专用的 DNS 服务器。内容分发专用的 DNS 服务器把内容分发的全局负载均衡（GSLB）设备的 ip 地址返回给用户。<br></span><span class="ne-text">（2）、当你向 CDN 的全局负载均衡设备的 ip 地址发起 url 访问请求，CDN 的全局负载均衡设备会为你选择一台合适的缓存服务器提供服务。<br></span></p><ul class="ne-ul"><li id="u62d633c9"><span class="ne-text">选择的依据：用户的 ip 地址，判断哪台服务器距离用户最近，根据用户请求的 url 中携带的内容名称判断哪台服务器上有用户要的数据，查询各个服务器当前负载情况，判断哪台服务器有服务能力。<br></span></li><li id="u55721196"><span class="ne-text">分配：基于这些条件综合分析后，区域负载均衡设备会向全局负载均衡设备请求返回一台缓存服务器的 IP 地址。全局负载均衡设备返回服务器 IP 地址，用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端，如果这台缓存服务器没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。域名解析服务器根据用户 ip 地址，把域名解析成相应节点的缓存服务器 ip 地址，实现用户就近访问，使用 CDN 服务的网站，只要将其域名解析权交给 CDN 的全局负载均衡设备，将需要分发的内容注入到 CDN 就可以实现内容加速了。</span></li></ul><h4 id="zodWC"><span class="ne-text">CDN 优势</span></h4><p id="uec018701" class="ne-p"><span class="ne-text">（1）、CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；<br></span><span class="ne-text">（2）、大部分请求在 CDN 边缘节点完成，CDN 起到分流作用，减轻了源服务器的负载。</span></p><h4 id="toj6z"><span class="ne-text">CDN 劣势</span></h4><p id="u72ad3543" class="ne-p"><span class="ne-text">（1）、当网站更新时，如果 CDN 节点上数据没有及时更新，即便用户在浏览器使用 Ctrl +F5 的方式使浏览器端的缓存失效，也会因为 CDN 边缘节点没有同步最新数据而导致用户访问异常。<br></span><span class="ne-text">（2）、CDN 不同的缓存时间会对“回源率”产生直接的影响：</span></p><ul class="ne-ul"><li id="ud3847853"><span class="ne-text">如果缓存时间短，CDN 边缘节点的内容经常失效，导致频繁回源。不仅增加服务器压力，也增加了用户访问时间。</span></li><li id="u8134ca1a"><span class="ne-text">如果缓存时间长，数据更新了，边缘节点的内容都还没更新，开发者对特定的任务做特定的数据缓存时间管理。</span></li></ul><h4 id="r5Rk6"><span class="ne-text">CDN 刷新缓存</span></h4><p id="u417fd3e2" class="ne-p"><span class="ne-text">CDN 边缘节点对开发者是透明的，相比于浏览器 Ctrl+F5 的强制刷新来使浏览器本地缓存失效，开发者可以通过 CDN 服务商提供的“刷新缓存”接口来达到清理 CDN 边缘节点缓存的目的。这样开发者在更新数据后，可以使用“刷新缓存”功能来强制 CDN 节点上的数据缓存过期，保证客户端在访问时，拉取到最新的数据。 |</span></p><h4 id="volWx"><span class="ne-text">CDN 优化</span></h4><p id="u94a8c92b" class="ne-p"><span class="ne-text">（1）、前端需要被加速的文件大致包括：</span></p><p id="u68ee3330" class="ne-p"><span class="ne-text">js、css、图片、视频、和页面等文件。页面文件有动态和静态之分。这些文件和页面（比如 html）最大的区别是：这些文件都是静态的，改动比较小，这类静态文件适合做 CDN 加速。我们把这些静态文件通过 CDN 分发到世界各地的节点，用户可以在距离最近的边缘节点拿到需要的内容，从而提升内容下载速度加快网页打开速度。页面分为动态页面和静态页面，动态页面不适合做 CDN 缓存，因为页面是动态的话，内容的有效期就比较活跃。边缘节点的数据经常失效要回源，造成源服务器压力。</span></p><p id="ue916f043" class="ne-p"><span class="ne-text">（2）、减少资源请求的等待时间</span></p><p id="uc64d549d" class="ne-p"><span class="ne-text">不同浏览器的并发数量不一样：IE11 、IE10 、chrome、Firefox 的并发连接数是 6 个，IE9 是 10 个。如果页面静态资源（图片等）过多（大于 6 个）会存在资源请求等待的情况。目前现实状况是大多用户带宽越来越大，但是我们的静态资源并非那么大，很多文件都是几 k 或者几十 k，6 个文件加起来都小于带宽。这样就导致了资源的浪费。</span></p><ul class="ne-ul"><li id="u2f5c8e34"><span class="ne-text">解决方案是：用多个不同 IP 的服务器来存储这些文件，并在页面中通过绝对路径的方式引用（要求同一 IP 的文件不超过 6 个）。这样就可以尽可能的减少资源请求等待的情况。</span></li></ul><p id="u09f49834" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="ub2704e18" class="ne-p"><strong><span class="ne-text">至此，你已经获取到缓存服务器的 IP 地址，并且准备向这个 IP 地址发送请求了。</span></strong></p><p id="u22b1278d" class="ne-p"><span class="ne-text"></span></p><h2 id="C0RQK"><span class="ne-text">三、TCP 连接</span></h2><h3 id="hloA5"><span class="ne-text">TCP</span></h3><ul class="ne-ul"><li id="ua56b69d6"><span class="ne-text">TCP 是一种面向连接的，可靠的，基于字节流的传输层通信协议。</span></li><li id="u8d6b838e"><span class="ne-text">建立 TCP 连接需要进行三次握手。过程如下：</span></li></ul><p id="ubcd3106f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653194429604-83b7eccb-7572-4c7b-826e-c9b9fe62c4b4.webp" width="465.99542236328125" id="u757bb214" class="ne-image"></p><p id="u42b8f525" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653194443274-6c98150b-79e8-4075-adb5-9f05ca79decb.webp" width="434.99542236328125" id="u1fd5e20c" class="ne-image"></p><h3 id="kqyTN"><span class="ne-text">TCP 握手过程</span></h3><ol class="ne-ol"><li id="u12e06ce3"><span class="ne-text">客户端发送带有 SYN 标识（SYN=1，seq=x）的请求报文段，然后进入 SYN_SEND 状态，等待服务端确认;</span></li><li id="u1b40cbc8"><span class="ne-text">服务端接收到客户端 SYN 报文段后，需要发送 ACK 信息对这个 SYN 进行确认，同时还要发送自己的 SYN 信息（SYN=1，ACK=1，seq=y，ack=x+1）服务端把这些信息放在一个报文段中（（SYN+ACK 报文段），一并发给客户端，此时客户端进入 SYN_RECV 状态;</span></li><li id="u9b0cb1c5"><span class="ne-text">客户端接收到服务端的 SYN+ACK 报文段后会向服务端发送 ACK（ACK=1，seq=x+，ack=y+1）确认报文段，这个报文段发送后，客户端和服务端都进入 ESTABLISHED 状态，完成三次握手。</span></li></ol><p id="u825b3e7a" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="ufbd5f6d3"><span class="ne-text">第一次握手： 客户端向服务端携带有客户端数据通讯初始序列号的报文，并进入 SYN-SENT 状态，当客户端收到数据时证明服务端知道：客户端的发送能力、服务端的接受能力正常。</span></li><li id="u03131e7d"><span class="ne-text">第二次握手： 服务端将响应客户端数据通讯初始序列号和服务端数据通讯初始序列号放入报文中一起发送给客户端。发送结束后服务端进入 SYN-RECEIVED 状态。当客户端接受到数据证明在客户端的角度上知道：客户端和服务端的发送、接收能力是正常的。</span></li><li id="u58ae2ea7"><span class="ne-text">第三次握手： 客户端向服务端发送一个确认应答，并进入 ESTABLISHED 状态，服务端收到应答后也进入 ESTABLISHED 状态完成三次握手。这时候在服务端知道：服务端的发送能力、客户端的接收能力正常。</span></li></ul><p id="ufaa3bb3d" class="ne-p"><span class="ne-text"></span></p><h3 id="saWty"><span class="ne-text" style="color: rgb(51, 51, 51)">为什么 TCP 建立是三次握手？</span></h3><ul class="ne-ul"><li id="u4bdbc399"><span class="ne-text">双方要明确对方接收能力都是正常的，（客户端发之后，服务端可以确定客户端发送能力正常，服务端发送给客户端，客户端可以确定服务端的接收和发送能力正常，最后客户端发送确认，来确定客户端的接收能力。</span></li><li id="udd590ea5"><strong><span class="ne-text">为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</span></strong><span class="ne-text">。</span></li><li id="ue1d939b1"><span class="ne-text">第三次握手除了让服务端知道，服务端发送能力和客户端的接收能力正常之外，还可以防止数据报延迟带来的不必要的资源消耗：当客户端发起 tcp 第一次握手的请求时，因为网络问题滞留在网络中，这时候客户端因为等待太久没有响应所以自动重发了握手请求并完成了所有数据请求关闭了与服务端的链接，这时候服务端才接收到第一次滞留在网络中的握手请求，服务端会向客户端发送第二次握手并处于等待第 3 次握手状态，客户端接收到第二次握手请求后发现是过期的请求就可以通过停止发送第三次握手，服务端一段时间没接到第三次握手请求会自动关闭请求监听。</span></li></ul><h3 id="qlDE4"><span class="ne-text">TLS（HTTPS）</span></h3><ul class="ne-ul"><li id="ufc9b5ca0"><strong><span class="ne-text">如果是 HTTP 连接，三次握手成功后，便建立起链接，如果是 HTTPS 连接，还需要传输层安全性协议（TLS）</span></strong></li></ul><p id="u9212e87f" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="ub8934ba0" class="ne-p"><span class="ne-text">TLS 工作于传输层之上，应用层之下，默认作用于服务端的 443 端口,在 TLS 中可以分成两种加密技术：</span></p><ul class="ne-ul"><li id="u953bb96d"><strong><span class="ne-text">对称性加密</span></strong><span class="ne-text">：客户端和服务端拥有相同的密钥，通过密钥对密文解密。用于密文通讯</span></li><li id="u22948b5f"><strong><span class="ne-text">非对称性加密</span></strong><span class="ne-text">：在该模式下，密钥分为公钥和私钥，用公钥加密的数据必须用私钥解密，用私钥加密的数据需要用公钥解密，公钥可以通过服务端发送给各个客户端，私钥则只由服务端持有，所有该模式主要用于传递对称性密钥阶段。</span><span class="ne-text">加密流程如下图：</span></li></ul><p id="uef1141f4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653195667430-9725fd8f-69c1-4691-acae-9aea61ff7e4a.webp" width="371.99542236328125" id="u62e8caf3" class="ne-image"></p><p id="u1beab470" class="ne-p"><span class="ne-text">其中数字证书是由服务端生成的非对称加密公钥和数字签名组成加密形成，数字签名是服务器在第三方机构注册校验服务器身份的数据，当客户端接收到数字证书是可以通过比对第三方机构注册的信息从而判断该报文是否是从目标服务器中传出来，从而确定公钥是否被调包。如果比对成功，客户端会生成对称性加密的密钥通过服务端派发的公钥进行加密传输给服务端，之后的信息传递就通过这个密钥进行对称性加密传输。</span></p><p id="uffe13a3e" class="ne-p"><span class="ne-text"></span></p><h2 id="cQNOT"><span class="ne-text">四、客户端发送请求</span></h2><p id="u26855b84" class="ne-p"><span class="ne-text">TCP 三次握手建立连接成功后，客户端按照</span><strong><span class="ne-text">指定的格式</span></strong><span class="ne-text">开始向服务端发送 HTTP 请求。</span></p><h3 id="hds73"><span class="ne-text">请求报文结构</span></h3><p id="ud1d43de5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196268394-7d03589e-0451-42d8-a460-7165186625a6.png" width="616" id="ua22d4039" class="ne-image"></p><h4 id="NPCpT"><span class="ne-text" style="color: rgb(33, 37, 41)">请求报头</span></h4><p id="u6604c20f" class="ne-p"><span class="ne-text" style="color: rgb(33, 37, 41); font-size: 16px">请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。<br>PS: 客户端不一定特指浏览器，有时候也可使用 Linux 下的 CURL 命令以及 HTTP 客户端测试工具等。<br>常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent 等。</span></p><p id="uda7247c5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196015114-144aaadd-3f62-429d-a4ad-ba31e48a49dd.png" width="381.99542236328125" id="u41a7308a" class="ne-image"></p><p id="ua7a5e432" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196053367-789ac83b-4ea6-4f5c-ab5b-71064638eaca.png" width="380.99542236328125" id="u1d78f2c8" class="ne-image"></p><p id="u84000e8c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196074822-50723931-5917-4a05-ab3b-cffa30bcdc1d.png" width="377.99542236328125" id="udc2cc044" class="ne-image"></p><p id="u2873aeb8" class="ne-p"><span class="ne-text" style="color: rgb(33, 37, 41); font-size: 16px">从图中可以看出，请求报头中使用了 Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie 等字段。Accept 用于指定客户端用于接受哪些类型的信息，Accept-Encoding 与 Accept 类似，它用于指定接受的编码方式。Connection 设置为 Keep-alive 用于告诉客户端本次 HTTP 请求结束之后并不需要关闭 TCP 连接，这样可以使下次 HTTP 请求使用相同的 TCP 通道，节省 TCP 连接建立的时间。</span></p><h4 id="E8Sxo"><span class="ne-text" style="color: rgb(33, 37, 41)">请求正文</span></h4><p id="ufd1f0e54" class="ne-p"><span class="ne-text" style="color: rgb(33, 37, 41); font-size: 16px">当使用 POST, PUT 等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的 Web 应用通常采用 Rest 架构，请求的数据格式一般为 json。这时就需要设置 Content-Type: application/json。</span></p><h3 id="DqH1p"><span class="ne-text">请求过程优化</span></h3><p id="uf0e4804e" class="ne-p"><span class="ne-text">减少 HTTP 请求次数和请求资源大小</span></p><ul class="ne-ul"><li id="u02134826"><span class="ne-text">资源合并压缩</span></li><li id="u886220e4"><span class="ne-text">字体图标（精灵图基本不是好的优化方式了，不好维护）</span></li><li id="u8b151eb8"><span class="ne-text">base64</span></li><li id="ua7b8b235"><span class="ne-text">Gzip（一般文件能压缩 60%）</span></li><li id="u99c5abac"><span class="ne-text">图片懒加载</span></li><li id="uc970e0e4"><span class="ne-text">数据延迟分批加载</span></li><li id="ufd8dc50e"><span class="ne-text">CDN 资源</span></li></ul><h2 id="onDoy"><span class="ne-text">五、服务端响应请求</span></h2><p id="u9add36bd" class="ne-p"><span class="ne-text">服务器端收到请求后由 web 服务器（准确说应该是 http 服务器）处理请求，诸如 Apache、Ngnix、IIS 等。web 服务器解析用户请求，了解了要调度哪些资源文件，再通过响应的资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过 web 服务器返回给浏览器客户端。</span></p><h4 id="LLf4p"><span class="ne-text">响应报文</span></h4><p id="u04a9f76d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196402673-6ece40f2-645b-4af5-b395-a715c756cbfc.png" width="407" id="u5b68bb44" class="ne-image"></p><p id="ua856dee2" class="ne-p"><span class="ne-text" style="font-size: 14px; color: rgb(85, 85, 85)">(1) 响应行包含：协议版本，状态码，状态码描述</span></p><p id="uab81c005" class="ne-p"><span class="ne-text" style="font-size: 14px; color: rgb(85, 85, 85)">状态码规则如下：</span></p><ul class="ne-ul"><li id="u4c4449bb"><span class="ne-text" style="font-size: 14px; color: rgb(85, 85, 85)">1xx：指示信息–表示请求已接收，继续处理。</span></li><li id="u852e2b6d"><span class="ne-text" style="font-size: 14px; color: rgb(85, 85, 85)">2xx：成功–表示请求已被成功接收、理解、接受。</span></li><li id="u565492be"><span class="ne-text" style="font-size: 14px; color: rgb(85, 85, 85)">3xx：重定向–要完成请求必须进行更进一步的操作。</span></li><li id="u953abe37"><span class="ne-text" style="font-size: 14px; color: rgb(85, 85, 85)">4xx：客户端错误–请求有语法错误或请求无法实现。</span></li><li id="ua9b5aa59"><span class="ne-text" style="font-size: 14px; color: rgb(85, 85, 85)">5xx：服务器端错误–服务器未能实现合法的请求。</span></li></ul><p id="uebc59aa3" class="ne-p"><span class="ne-text" style="font-size: 14px; color: rgb(85, 85, 85)">(2) 响应头部包含响应报文的附加信息，由 名/值 对组成</span></p><p id="u40542035" class="ne-p"><span class="ne-text" style="font-size: 14px; color: rgb(85, 85, 85)">(3) 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据</span></p><h2 id="NehWg"><span class="ne-text">六、断开连接</span></h2><p id="u9d963443" class="ne-p"><span class="ne-text">服务器响应完客户端请求之后，解除 TCP 连接，释放过程（四次挥手过程）如下：</span></p><p id="u5e730653" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653194694500-6c0090b0-4c78-407c-83df-3355a71b80f2.webp" width="553" id="u85962d21" class="ne-image"></p><h3 id="jtmls"><span class="ne-text">四次挥手过程</span></h3><ul class="ne-ul"><li id="uc2d8a23c"><span class="ne-text">客户端发送标记为 FIN=1（finished 的缩写，表示接收完成，请求释放连接），同时生成一个 Seq=u 的序列号，之后进入 FIN-WAIT-1 半关闭阶段（此时客户端到服务端发送数据的通道已经关闭，但是仍然可以接收服务端发过来的数据）；</span></li><li id="u247f273a"><span class="ne-text">服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。</span></li><li id="ue1ad1b6a"><span class="ne-text">客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</span></li><li id="u463cbbe2"><span class="ne-text">服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。</span></li><li id="u63903dcf"><span class="ne-text">客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。</span></li><li id="u05d367ba"><span class="ne-text">服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态，就结束了这次的 TCP 连接。</span></li></ul><h3 id="PQWm7"><span class="ne-text">为什么是四次挥手？</span></h3><p id="u2d321eec" class="ne-p"><span class="ne-text">因为建立一旦连接，双方既是发送方，又是接收方，为了保证在最后断开的时候，客户端发送的最后一个 ACK 报文段能够被服务器接收到。如果客户端在收到服务器给它的断开连接的请求之后，回应完服务器就直接断开连接的话，服务器就会因为一直没得到客户端响应而一直等待，所以客户端要等待两个最长报文段寿命的时间，以便于服务器没有收到请求之后重新发送请求。</span></p><h2 id="PuVWe"><span class="ne-text">七、浏览器解析并渲染响应内容</span></h2><p id="u6b3bcdf2" class="ne-p"><span class="ne-text">在这之前我们先来补充一点基础知识：</span></p><h3 id="Y3sRj"><span class="ne-text">浏览器的渲染引擎组成（列举的是基本组成）</span></h3><ul class="ne-ul"><li id="u4f5545dd"><span class="ne-text">HTML 解析器:将 HTML 解析成 DOM 树。</span></li><li id="udf4937dd"><span class="ne-text">CSS 解析器: 为 DOM 中各个元素对象计算出样式信息，为布局提供基础设施。</span></li><li id="udf477ef9"><span class="ne-text">JavaScript 引擎:解析并执行 javascript 代码。</span></li><li id="ue875f9b1"><span class="ne-text">布局 layout 模块:在 DOM 树创建后，webkit 需要将其中的元素对象同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能表达这所有信息的模型。 </span></li><li id="uc18ad7e3"><span class="ne-text">绘图模块:使用图形库将布局计算后的各个网页的节点绘制成图像的结果。</span></li></ul><h3 id="C9lpK"><span class="ne-text">渲染过程</span></h3><ol class="ne-ol"><li id="u6c4588f4"><span class="ne-text">浏览器拿到文件后（拿到的是一些字节码）通过编码方式（一般是 utf-8）转换为对应的字符。</span></li><li id="ub2d2ec6f"><span class="ne-text">浏览器至上而下解析文档，遇见 HTML 标记，调用 HTML 解析器解析为对应的 tocken，tocken 就是标签文本的序列号，将 tocken 按词法解析解析成具体的标记结构，这个过程已经构建出一颗有标签，有层级，有结构的 DOM 树（就是一块内存，这块内存实际就是一个个 Tocken 构成的）；</span></li><li id="u639829da"><span class="ne-text">遇见 style/link 标记，调用 CSS 解析器处理 CSS 标记并构建 CSSOM 样式树；</span></li><li id="u07b96400"><span class="ne-text">遇见 script 标记，调用 javascript 解析器处理，绑定事件、修改 DOM 树/CSS 树等；</span></li><li id="ue58b131b"><span class="ne-text">将 DOM 树和 CSSOM 树合并成一颗 render 树（渲染树）。</span></li><li id="u73abb46c"><span class="ne-text">根据渲染树来渲染，计算每个节点的几何信息（这一过程要依赖图形库）；</span></li><li id="ub992e54d"><span class="ne-text">将各个节点绘制到屏幕上。 如果用户操作页面，会触发第（6）或者第（7）步骤，也就是重排和重绘</span></li></ol><h3 id="n0mqK"><span class="ne-text">阻塞渲染</span></h3><p id="u2490e0f2" class="ne-p"><span class="ne-text">（1）style 标签的样式：<br></span></p><ul class="ne-ul"><li id="ub2f903aa"><span class="ne-text">由 HTML 解析器解析(异步解析）；</span></li><li id="u86069d2d"><span class="ne-text">不阻塞浏览器渲染（可能会出现闪屏（解析一点，显示一点现象）；</span></li><li id="u4b62c3fd"><span class="ne-text">不阻塞 DOM 解析。</p><p></span></li></ul><p id="ub27776db" class="ne-p"><span class="ne-text">（2）link 引入的外部 css 样式（推荐使用）<br></span></p><ul class="ne-ul"><li id="uc1f96d69"><span class="ne-text">由 CSS 解析器解析（同步解析）；</span></li><li id="u442b235d"><span class="ne-text">阻塞浏览器渲染（可以利用这种阻塞避免闪屏);</span></li><li id="u2fc09f64"><span class="ne-text">阻塞其后 js 语句的执行：<br></span></li></ul><p id="u0ded7235" class="ne-p"><strong><span class="ne-text">原因</span></strong><span class="ne-text">：如果后面 js 的内容是获取元素的样式，例如宽高等属性,如果不等样式解析完毕，后面的 js 就获得了错误的信息,由于浏览器也不知道后续 js 的具体内容，所以只好等前面所有样式解析完毕，再执行 js。例如：firefox 在样式加载和解析过程，会禁止所有脚本。（webkit 内核的浏览器只会在 js 尝试访问样式属性或者可能受到未加载的样式影响时才会禁止脚本。<br></span></p><ul class="ne-ul"><li id="u98e3fdcf"><span class="ne-text">不阻塞 DOM 的解析：<br></span></li></ul><p id="uf65ebb4c" class="ne-p"><strong><span class="ne-text">原因</span></strong><span class="ne-text">：DOM 解析和 CSS 解析是两个并行的线程。<br></span></p><p id="ub8e95fc3" class="ne-p"><span class="ne-text">（3）、优化核心概念：尽可能快的提高外部 css 加载速度。<br></span></p><ul class="ne-ul"><li id="u9f885f50"><span class="ne-text">使用 CDN 节点进行外部资源打包；<br></span></li><li id="u7ad07643"><span class="ne-text">对 css 进行压缩（利用打包工具，比如 webpack，glup 等；<br></span></li><li id="u55539e7b"><span class="ne-text">减少对 http 请求数量，将多个 css 文件合并；<br></span></li><li id="u0a4d8d88"><span class="ne-text">优化样式的代码。<br></span></li></ul><p id="ue451fcf6" class="ne-p"><span class="ne-text">（4）js 阻塞：<br></span></p><ul class="ne-ul"><li id="u9b069c20"><span class="ne-text">阻塞 DOM 解析：<br></span></li></ul><p id="u45b8cf6d" class="ne-p"><strong><span class="ne-text">原因</span></strong><span class="ne-text">：浏览器不知道后续脚本的内容，如果先去解析了下面的 DOM，而随后 js 删除了后面的所有 DOM，做了无用功。浏览器无法预估脚本具体做了什么操作，索性全部暂停，等脚本执行完，浏览器再继续向下解析。<br></span></p><ul class="ne-ul"><li id="u5b8e0121"><span class="ne-text">阻塞页面的渲染：<br></span></li></ul><p id="ufded32f2" class="ne-p"><strong><span class="ne-text">原因</span></strong><span class="ne-text">：js 中也可以给 DOM 设置样式，浏览器同样等该脚本执行完再继续干活，避免做无用功。<br></span></p><ul class="ne-ul"><li id="ufde261d3"><span class="ne-text">阻塞后续 js 的执行：<br></span></li></ul><p id="ua9990fc1" class="ne-p"><strong><span class="ne-text">原因</span></strong><span class="ne-text">：维护依赖关系，例如：必须先引入 jQuery 再引入 bootstrap。<br></span></p><ul class="ne-ul"><li id="u817784ec"><span class="ne-text">如果 script 脚本加了 defer：浏览器会发送请求加载 js，但是不会阻塞 DOM 解析，等 DOM 解析完，再执行 js。</span></li><li id="uc0787f7b"><span class="ne-text">如果 script 加了 async：浏览器会发送请求加载 js，不阻塞 DOM 解析，等 js 加载过来了，就先停止 DOM 解析，去执行 js（谁先回来先执行谁），等 js 执行完，继续 DOM 解析。</span></li></ul><h3 id="V1IES"><span class="ne-text">渲染过程优化</span></h3><p id="u6ce002c5" class="ne-p"><span class="ne-text">（1）标签语义化（使用合适的标签，如果不是 w3c 规定的标签，Tocken 令牌和词法解析语法得识别分析，是不是 wc3 规定的）<br></span><span class="ne-text">（2）减少标签嵌套（生成结构树嵌套太多，就得递归（在 DOM 树构建时候快可以一点）<br></span><span class="ne-text">（3）样式尽可能少的层级嵌套（使用与编译器的时候，层级嵌套要慎用。CSS 选择器渲染从右到左，.box a{}会 比 a{} 慢<br></span><span class="ne-text">（4）尽早把 CSS 下载到客户端（充分利用 HTTP 多请求并发机制）<br></span><span class="ne-text">（5）避免阻塞 js 放在底部<br></span><span class="ne-text">（6）减少回流<br></span></p><ul class="ne-ul"><li id="u97bf37ab"><span class="ne-text">放弃传统操作 DOM 时代，基于 vue/react 开始数据影响试图模式<br></span></li><li id="u81ab9b58"><span class="ne-text">样式集中改变<br></span></li><li id="u4559a3fe"><span class="ne-text">缓存布局信息，<br></span></li><li id="u480222f8"><span class="ne-text">动画效果应用到 position 属性为 absolute 或 fixed 的元素上（脱离文档流）</span></li><li id="u371676b0"><span class="ne-text">CSS3 硬件加速（比起考虑如何减少回流重绘，更期望不要回流重绘：transform、opacity、filters 这些属性会触发硬件加速，不会引发回流重绘（过多使用占用大量内存，性能消耗严重<br></span></li><li id="uefa5351d"><span class="ne-text">避免使用 table 布局和使用 css 的 js 表达式</span></li></ul><p id="u8b1b1567" class="ne-p"><span class="ne-text"></span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web性能优化方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]浏览器工作原理</title>
      <link href="/blog/vkgoaq/"/>
      <url>/blog/vkgoaq/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uc476a18c" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u94f3a8a8"><a href="https://www.yuque.com/handshell/kygzse" data-href="https://www.yuque.com/handshell/kygzse" target="_blank" class="ne-link"><span class="ne-text">https://www.yuque.com/handshell/kygzse</span></a></li></ul><p id="ue45fdca2" class="ne-p"><span class="ne-text"></span></p><h1 id="GNXt0"><span class="ne-text" style="color: rgb(51, 51, 51)">简介</span></h1><p id="u15ad5d23" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">网络浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们会了解到，从您在地址栏输入 google.com 直到您在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么。</span></p><h2 id="p8KMY"><span class="ne-text" style="color: rgb(51, 51, 51)">浏览器的主要功能</span></h2><p id="uc37e486b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。</span></p><p id="u8834f380" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。</span></p><p id="uc3d5ef38" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。</span></p><p id="u2cd4c280" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器的用户界面有很多彼此相同的元素，其中包括：</span></p><ul class="ne-ul"><li id="uc9ec74bf"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用来输入 URI 的地址栏</span></li><li id="u1bb410a5"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">前进和后退按钮</span></li><li id="u6734b820"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">书签设置选项</span></li><li id="u00a223f7"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用于刷新和停止加载当前文档的刷新和停止按钮</span></li><li id="u2e86b7d9"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用于返回主页的主页按钮</span></li></ul><p id="ua33b564a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器。</span></p><h2 id="J3Aw2"><span class="ne-text" style="color: rgb(51, 51, 51)">浏览器的高层结构</span></h2><p id="u14837635" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器的主要组件为</span></p><ol class="ne-ol"><li id="ue247f201"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</span></li><li id="u9c5271b0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器引擎 - 在用户界面和呈现引擎之间传送指令。</span></li><li id="u1c8351af"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</span></li><li id="u97a55487"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</span></li><li id="uc6227a35"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</span></li><li id="ub7edcbcf"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">JavaScript 解释器。用于解析和执行 JavaScript 代码。</span></li><li id="ufe548681"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</span></li></ol><p id="u60d23fd6" class="ne-p"><a href="https://blog.towavephone.com/static/2021-07-20-01-39-18-4d2efb6ba6e0c185fa557cbfdc53ca2c-28759.png" target="_blank" id="u221cabc3" class="ne-image-link" style="color: rgb(210, 54, 105); font-size: 16px"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647955363695-c77ab531-56d2-4703-b760-10b2a357e13e.png" width="500" class="ne-image"></a></p><p id="udb1c4838" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</span></p><h1 id="zlQIi"><span class="ne-text" style="color: rgb(51, 51, 51)">呈现引擎</span></h1><p id="u03c20d1f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现引擎的作用就是在浏览器的屏幕上显示请求的内容。</span></p><p id="u8b873811" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。</span></p><p id="u6833104e" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。</span></p><p id="ud73dbeda" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。</span></p><h2 id="nhQGa"><span class="ne-text" style="color: rgb(51, 51, 51)">主流程</span></h2><p id="u3fe8d72f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</span></p><p id="u98e4588f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">然后进行如下所示的基本流程：</span></p><p id="u0c26b84e" class="ne-p"><a href="https://blog.towavephone.com/static/2021-07-20-01-41-38-dba2da5da3c0b45fb5977e4418996051-81a6c.png" target="_blank" id="uaff40621" class="ne-image-link" style="color: rgb(210, 54, 105); font-size: 16px"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647955363670-09c68a6a-43bf-4918-bcec-1b15f46e982d.png" width="600" class="ne-image"></a></p><p id="u9ef421fe" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。</span></p><p id="ueb8436dd" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</span></p><p id="u782d810b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</span></p><p id="uc5bf0356" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</span></p><h2 id="f1Vdv"><span class="ne-text" style="color: rgb(51, 51, 51)">主流程示例</span></h2><p id="u70693807" class="ne-p"><a href="https://blog.towavephone.com/static/2021-07-20-01-43-09-b2b81d9cf1c9a7547a05e02c3d96d537-37d31.png" target="_blank" id="u8697360d" class="ne-image-link" style="color: rgb(210, 54, 105); font-size: 16px"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647955363669-1f06ef06-1aff-4c66-9d0c-8a80cc24a0d2.png" width="624" class="ne-image"></a></p><p id="u449dd883" class="ne-p"><a href="https://blog.towavephone.com/static/2021-07-20-01-43-20-b62fa3cb50eec54e4215a86e1ce83f85-37d31.png" target="_blank" id="u1c601d5c" class="ne-image-link" style="color: rgb(210, 54, 105); font-size: 16px"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647955363715-948ad36b-e794-4de4-aabd-c2d6ffd71247.png" width="624" class="ne-image"></a></p><p id="u2198ee71" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">可以看出，虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。</span></p><p id="u0f1e60f2" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它由“呈现对象”组成。对于元素的放置，WebKit 使用的术语是“布局”，而 Gecko 称之为“重排”。</span></p><p id="u529b6783" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。有一个细微的非语义差别，就是 Gecko 在 HTML 与 DOM 树之间还有一个称为“内容槽”的层，用于生成 DOM 元素。我们会逐一论述流程中的每一部分：</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ant Design Vue</title>
      <link href="/blog/qnrknt/"/>
      <url>/blog/qnrknt/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="We5uH"><code class="ne-code"><span class="ne-text">ant-design-vue</span></code><span class="ne-text"> UI库的引入与使用</span></h2><ul class="ne-ul"><li id="uc428e98f"><code class="ne-code"><span class="ne-text" style="text-decoration: line-through">element-plus</span></code><span class="ne-text" style="text-decoration: line-through">：</span><a href="https://element-plus.gitee.io/zh-CN/" data-href="https://element-plus.gitee.io/zh-CN/" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">https://element-plus.gitee.io/zh-CN/</span></a><span class="ne-text">（该UI库用过，换用一个新的UI库使用）</span></li><li id="uf7b97884"><code class="ne-code"><span class="ne-text">ant-design-vue</span></code><span class="ne-text"> UI库：</span><a href="https://antdv.com/docs/vue/introduce-cn/" data-href="https://antdv.com/docs/vue/introduce-cn/" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">https://antdv.com/docs/vue/introduce-cn/</span></a><span class="ne-text" style="text-decoration: line-through">（老版本）</span></li></ul><p id="u14d12e06" class="ne-p"><span class="ne-text">最新版本：</span><a href="https://next.antdv.com/components/overview-cn" data-href="https://next.antdv.com/components/overview-cn" target="_blank" class="ne-link"><span class="ne-text">https://next.antdv.com/components/overview-cn</span></a><a href="https://element-plus.gitee.io/zh-CN/" data-href="https://element-plus.gitee.io/zh-CN/" target="_blank" class="ne-link"><span class="ne-text"><p></span></a></p><p id="ufd33142d" class="ne-p"><code class="ne-code"><span class="ne-text">ant-design-vue</span></code><span class="ne-text"> UI 库的引入和使用</span></p><h3 id="Tkwmc"><span class="ne-text">全局引入的方式</span></h3><p id="u03fb72db" class="ne-p"><span class="ne-text">在 main.ts 文件中如下修改：</span></p><pre data-language="typescript" id="fKqVc" class="ne-codeblock language-typescript">/*</p><ul><li>@Descripttion:</li><li>@Date: 2021-12-07 10:05:32</li><li>@LastEditTime: 2022-01-10 10:18:18<br>*/</li></ul><p>import {createApp} from ‘vue’<br>import App from ‘./App.vue’<br>import router from ‘./router’<br>// 全局引入全部组件及样式 ant-design-vue UI 库(但是官网不推推荐，影响性能)<br>import Antd from ‘ant-design-vue’<br>import ‘ant-design-vue/dist/antd.css’</p><p>createApp(App).use(Antd).use(router).mount(‘#app’)</pre><p id="u789000d5" class="ne-p"><code class="ne-code"><strong><span class="ne-text">TODO</span></strong></code><strong><span class="ne-text">: </span></strong><span class="ne-text">全局引入会打包所有 UI 组件，所以采用局部引用的方式来使用</span></p><h3 id="HNzPs"><span class="ne-text">icon 图标的使用</span></h3><p id="u8682fa55" class="ne-p"><span class="ne-text">需要先下载 相应的包</span></p><pre data-language="bash" id="nTMgr" class="ne-codeblock language-bash">cnpm install --save @ant-design/icons-vue</pre><p id="u7d525611" class="ne-p"><span class="ne-text">然后使用到 icon 的时候，按需导入，上面的组件如果按需导入也是用这种方式，但是组件使用情况比 icon 实用得多，所以全局使用 UI 组件但不全局使用 icon。</span></p><pre data-language="vue" id="jv9Cm" class="ne-codeblock language-vue"><template></p><div class="icons-list"><span>icon 组件</span><up-circle-two-tone /><home-outlined /><setting-filled /><smile-outlined /><sync-outlined spin /><smile-outlined :rotate="180" /><loading-outlined /></div></template><script lang="ts">import {  UpCircleTwoTone,  HomeOutlined,  SettingFilled,  SmileOutlined,  SyncOutlined,  LoadingOutlined,} from '@ant-design/icons-vue'</script><style scoped>.icons-list :deep(.anticon) {  margin-right: 6px;  font-size: 24px;}</style></pre><h2 id="oLD8b"><span class="ne-text">定制主题</span></h2><p id="ubbf72f83" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u9c01c963"><a href="https://www.jianshu.com/p/a42f58fc3f92" data-href="https://www.jianshu.com/p/a42f58fc3f92" target="_blank" class="ne-link"><span class="ne-text">https://www.jianshu.com/p/a42f58fc3f92</span></a></li><li id="u9534bc71"><a href="https://juejin.cn/post/6962078064364748808" data-href="https://juejin.cn/post/6962078064364748808" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6962078064364748808</span></a></li></ul><p id="u1619a6fa" class="ne-p"><br></p><p id="u97abd54f" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>水平/垂直居中总结</title>
      <link href="/blog/dubn5y/"/>
      <url>/blog/dubn5y/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="Q1iqa"><span class="ne-text">水平居中</span></h2><p id="u1757acd2" class="ne-p"><br></p><h2 id="SBJoD"><span class="ne-text">垂直居中</span></h2><ul class="ne-ul"><li id="u19dac5dd"><a href="https://juejin.cn/post/6844903550909153287" data-href="https://juejin.cn/post/6844903550909153287" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6844903550909153287</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 布局 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS实现上下浮动动画</title>
      <link href="/blog/pu2dxs/"/>
      <url>/blog/pu2dxs/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue09c7540" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648018096319-db408c92-c6e3-4678-b773-bf084efbdc41.png" width="546.015625" id="u0cee8aad" class="ne-image"></p><p id="u6119638d" class="ne-p"><span class="ne-text">lyrics项目里面自己设计首页需要当前视窗高度有一个箭头上下浮动的效果，按照如下方式实现：</span></p><pre data-language="css" id="pIqqp" class="ne-codeblock language-css">  .home-row-foward {<pre><code>animation: heart 0.5s ease-in-out 2.7s infinite alternate;height: 30px;font-size: 25px;color: #1890ff;text-align: center;position: relative;bottom: 25px;</code></pre><p>}<br>@keyframes heart {<br>from {<br>transform: translate(0, 0);<br>}<br>to {<br>transform: translate(0, 15px);<br>}<br>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 动画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模块化（es6+nodejs+typescript）</title>
      <link href="/blog/psazge/"/>
      <url>/blog/psazge/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="m4URw"><span class="ne-text">es6模块的导入导出</span></h2><ul class="ne-ul"><li id="ua79a7f7f"><a href="https://zhuanlan.zhihu.com/p/60374345" data-href="https://zhuanlan.zhihu.com/p/60374345" target="_blank" class="ne-link"><span class="ne-text">ES6专题—class与模块化（10）</span></a></li></ul><h3 id="ZD7DO"><span class="ne-text">export</span></h3><pre data-language="javascript" id="shz4I" class="ne-codeblock language-javascript">const checkStr = (str, type) => {<p>// 等内容<br>}</p><p>module.exports = {<br>checkStr,<br>}</pre><pre data-language="typescript" id="GpfNA" class="ne-codeblock language-typescript">export const updateInfo: any = (data: any) => {<br>return fetch({<br>method: 'post',<br>url: <code>/*****************</code>,<br>data: data,<br>})<br>}</pre><h3 id="ugT9l"><span class="ne-text">import</span></h3><pre data-language="typescript" id="yZuhj" class="ne-codeblock language-typescript">import fetch from '../utils/fetch'</pre><h3 id="asQNS"><span class="ne-text">与 class 结合</span></h3><pre data-language="typescript" id="K3pdW" class="ne-codeblock language-typescript">/*</p><ul><li>@Author: wztlink1013</li><li>@Date: 2022-03-09 09:56:11</li><li>@LastEditTime: 2022-03-09 10:22:32</li><li>@Description:<br>*/<br>class StorageFn {<br>ls: Storage<br>ss: Storage<br>constructor() {<br>this.ls = window.localStorage<br>this.ss = window.sessionStorage<br>}<br>/*设置 cookie*/<br>setCookie(name: any, value: any, day: any) {}<br>// 等内容<br>}</li></ul><p>export default StorageFn</pre><h2 id="FPo3f"><span class="ne-text">node 模块的导入导出</span></h2><h3 id="zliG3"><span class="ne-text">nodejs 不能使用 es6 的模块导入导出</span></h3><p id="u7db76df1" class="ne-p"><span class="ne-text">node.js 使用 commonjs 规范，es6 module 的推出和完善，node 从 v13 开始原生支持 es6 module。</span></p><p id="ue8d24af1" class="ne-p"><br></p><p id="u4278c4b6" class="ne-p"><span class="ne-text">在 node 环境下是不能使用 es6 语法中 import export 导入导出语法的，解决办法有 babel 转义，或者如下面的一种新方法（需要 Node.js 版本 13.x.x 以上），个人推荐最好还是用 babel 配置 babel 配置文件在转义，因为可以自行一些配置。</span></p><p id="ufc430aaf" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="u5255562b"><span class="ne-text">解决方案一：Node.js 版本 13.x.x 以上的版本，使用 </span><a href="https://nodejs.org/api/esm.html#esm_enabling" data-href="https://nodejs.org/api/esm.html#esm_enabling" target="_blank" class="ne-link"><span class="ne-text">官方推荐的方法</span></a><span class="ne-text"> 在 </span><code class="ne-code"><span class="ne-text">package.json</span></code><span class="ne-text"> 文件中设置 </span><code class="ne-code"><span class="ne-text">"type": "module"</span></code><span class="ne-text">。</span></li></ul><pre data-language="json" id="M8w65" class="ne-codeblock language-json">{<br>"type": "module"<br>}</pre><ul class="ne-ul"><li id="ucc5b9fa1"><span class="ne-text">解决方案二：使用 </span><a href="https://babeljs.io/" data-href="https://babeljs.io/" target="_blank" class="ne-link"><span class="ne-text">babeljs</span></a><span class="ne-text"> ，然后在项目中添加相关配置即可，具体可以查阅相关教程。</span></li></ul><h3 id="AUPhS"><span class="ne-text">导入导出</span></h3><p id="u005929a6" class="ne-p"><strong><span class="ne-text">导出</span></strong></p><div class="ne-quote"><p id="u759296b3" class="ne-p"><span class="ne-text">【</span><span class="ne-text">第一种方式</span><span class="ne-text">】</span></p></div><ul class="ne-ul"><li id="u16b2123c"><span class="ne-text">就是在模块里面定义好变量/方法，然后利用 </span><code class="ne-code"><span class="ne-text">exports.let_1= let_1;</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">exports.fun_1 = fun_1;</span></code><span class="ne-text">这种形式，一个个导出</span></li></ul><p id="ua6ee028c" class="ne-p"><br></p><p id="u5f0a15f7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618149585979-d1ff5498-d0e1-46ce-b115-ceeadf7f0df9.png" width="432.5" id="wPvzv" class="ne-image"></p><div class="ne-quote"><p id="u0218893a" class="ne-p"><span class="ne-text">【</span><span class="ne-text">第二种方式</span><span class="ne-text">】module.exports.version = version;</span></p></div><p id="u6e55ca49" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618149597438-9300a103-0fd7-42df-9307-06079ef423c0.png" width="422" id="GcxFA" class="ne-image"></p><p id="u6e8aa9e0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618149609536-ea32c674-9e2d-48fb-92bc-d2c7bf0d294c.png" width="465.5" id="uO0Zi" class="ne-image"></p><p id="uf13a0d00" class="ne-p"><strong><span class="ne-text">导入</span></strong></p><p id="u381d0a06" class="ne-p"><span class="ne-text">const a = require(‘文件路径’);</span></p><h3 id="omVOT"><span class="ne-text">模块的查找规则</span></h3><p id="0dfd3e5079a2c71c7d3261384c4328d9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618118075531-995293d3-ee92-4f22-a49c-cb5114639b20.png" width="432" id="IaKuE" class="ne-image"></p><p id="d05ad99aaeabd2061fb3401a7b8be9b1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618118082503-8414faae-297b-4cd7-a304-c80f7a635a35.png" width="384.5" id="SJfTf" class="ne-image"></p><h2 id="Tpd21"><span class="ne-text">ts 的模块导入导出</span></h2><ul class="ne-ul"><li id="u59ffb711"><a href="https://blog.csdn.net/qq_43340929/article/details/107034432" data-href="https://blog.csdn.net/qq_43340929/article/details/107034432" target="_blank" class="ne-link"><span class="ne-text">TypeScript 模块导入终极解决方案</span></a></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>696. 计数二进制子串🔖字符串</title>
      <link href="/blog/sueiwv/"/>
      <url>/blog/sueiwv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u62f590fc" class="ne-p"><span class="ne-text">题目链接：</span></p><ul class="ne-ul"><li id="u79899ad5"><a href="https://leetcode-cn.com/problems/count-binary-substrings/" data-href="https://leetcode-cn.com/problems/count-binary-substrings/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/count-binary-substrings/</span></a></li></ul><h3 id="gs1qv"><span class="ne-text">解决思路</span></h3><ul class="ne-ul"><li id="u80a880bd"><span class="ne-text">数学规律就是将字符串按照</span><strong><span class="ne-text">一整个0或1</span></strong><span class="ne-text">切割开来，将其放入数组arr，然后arr中相邻的元素（字符串）进行字符串长度比较大小，取小的，最后所有相邻的元素比较后的所有相加就是所需结果</span></li><li id="u86427819"><span class="ne-text">将字符串按照</span><strong><span class="ne-text">一整个0或1</span></strong><span class="ne-text">切割开来：先对字符串遍历，找到异元素，记录其下标，存为数组arr；然后利用splice方法＋arr数组进行切割为目标数组</span></li></ul><h3 id="KZHav"><span class="ne-text">代码实现</span></h3><p id="u1b748dff" class="ne-p"><span class="ne-text">将上述解决思路用代码实现如下：</span></p><pre data-language="typescript" id="GbNzD" class="ne-codeblock language-typescript">function countBinarySubstrings(s: string): number {<p>let flag: string = s[0]<br>let arr: number[] = []<br>let arr_target: string[] = []<br>for (let i: number = 0; i &lt; s.length; i++) {<br>if (s[i] !== flag) {<br>arr.push(i)<br>flag = s[i]<br>}<br>}<br>arr.forEach((data: number, index: number) =&gt; {<br>if (index === 0) {<br>arr_target.push(String(s.slice(0, data)))<br>// 分割数组只有一个元素情况下<br>if (arr.length === 1) arr_target.push(String(s.slice(data, s.length)))<br>} else if (index === arr.length - 1) {<br>arr_target.push(String(s.slice(arr[index - 1], data)))<br>arr_target.push(String(s.slice(data, s.length)))<br>} else {<br>arr_target.push(String(s.slice(arr[index - 1], data)))<br>}<br>})<br>let result: number = 0<br>arr_target.forEach((data: string, index: number) =&gt; {<br>if (index &lt; arr_target.length - 1)<br>result += Math.min(<br>String(data).length,<br>String(arr_target[index + 1]).length<br>)<br>})<br>return result<br>}</p><p>console.log(countBinarySubstrings(‘1100’))</p><p></pre><ul class="ne-ul"><li id="u239fffbf"><strong><span class="ne-text" style="color: #E8323C">对上述逻辑的小优化</span></strong><span class="ne-text">：上面是利用arr还转换为原只含0、1的数组，但是可以利用arr直接进行求算结果</span></li></ul><pre data-language="typescript" id="BAqOK" class="ne-codeblock language-typescript">function countBinarySubstrings(s: string): number {<br>  let flag: string = s[0]<br>  let arr: number[] = []<br>  let result: number = 0<br>  for (let i: number = 0; i < s.length; i++) {<br>    if (s[i] !== flag) {<br>      arr.push(i)<br>      flag = s[i]<br>    }<br>  }<br>  arr.forEach((data: number, index: number) => {<br>    if (index === 0) {<br>      arr.length === 1<br>        ? (result += Math.min(data, s.length - data))<br>        : (result += Math.min(data, arr[index + 1] - data))<br>    } else if (index === arr.length - 1) {<br>      result += Math.min(data - arr[index - 1], s.length - data)<br>    } else {<br>      result += Math.min(arr[index + 1] - data, data - arr[index - 1])<br>    }<br>  })<br>  return result<br>}</pre><p id="u2dadfbee" class="ne-p"><span class="ne-text">最后优化效果如下</span></p><p id="ueb92bbd2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647944556161-5866cbd8-f97b-4fdc-9e84-9d3dc2ebc571.png" width="699.9999721845002" id="u40ceee23" class="ne-image"></p><h3 id="FNmDD"><span class="ne-text">优化方案</span></h3><p id="u6015cfa7" class="ne-p"><span class="ne-text">在官网解决方案中，看到其他的解决方案：</span></p><h4 id="bouKe"><span class="ne-text">利用正则表达式来切换原字符串</span></h4><pre data-language="typescript" id="RqF5v" class="ne-codeblock language-typescript">s.match(/([1]+)|([0]+)/g)</pre><p id="u3bc26102" class="ne-p"><span class="ne-text">上面的正则表达式就能实现如下效果…………</span></p><pre data-language="javascript" id="lfSId" class="ne-codeblock language-javascript">[ '00', '11', '00', '11' ]</pre><p id="u581d3060" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1647945287324-1f4f1d3f-6731-4794-a023-ba9ebb97397c.jpeg" width="75" id="BFxC7" class="ne-image"><span class="ne-text">正则表达式太重要了！！</span></p><p id="u3fa4a566" class="ne-p"><span class="ne-text">得到上述数组再进行数组内相邻元素比较元素字符串长度取小值，然后相加，类似上面方法即可。</span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript笔记</title>
      <link href="/blog/xigb8k/"/>
      <url>/blog/xigb8k/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="O8Yta"><span class="ne-text">学习</span></h3><p id="udcfaf747" class="ne-p"><span class="ne-text">安装：</span><code class="ne-code"><span class="ne-text">npm install -g typescript</span></code></p><p id="ue89624dc" class="ne-p"><span class="ne-text">编译：</span><code class="ne-code"><span class="ne-text">tsc helloworld.ts</span></code></p><p id="u099a9ea6" class="ne-p"><span class="ne-text"></span></p><p id="uc1bd4d7b" class="ne-p"><span class="ne-text">学习网站：</span></p><ul class="ne-ul"><li id="u5f9fffd9"><a href="https://www.tslang.cn/docs/home.html" data-href="https://www.tslang.cn/docs/home.html" target="_blank" class="ne-link"><span class="ne-text">https://www.tslang.cn/docs/home.html</span></a></li><li id="u185795a9"><a href="https://ts.xcatliu.com/introduction/what-is-typescript.html" data-href="https://ts.xcatliu.com/introduction/what-is-typescript.html" target="_blank" class="ne-link"><span class="ne-text">https://ts.xcatliu.com/introduction/what-is-typescript.html</span></a></li><li id="u43c55bd3"><a href="https://segmentfault.com/a/1190000038959316" data-href="https://segmentfault.com/a/1190000038959316" target="_blank" class="ne-link"><span class="ne-text">https://segmentfault.com/a/1190000038959316</span></a></li></ul><p id="u37fca0fa" class="ne-p"><span class="ne-text">相关教程：</span></p><ul class="ne-ul"><li id="uf10c6fcd"><a href="https://www.cnblogs.com/wisewrong/p/13717287.html" data-href="https://www.cnblogs.com/wisewrong/p/13717287.html" target="_blank" class="ne-link"><span class="ne-text">Vue3.x 从零开始（一）—— Vue-cli or Vite 构建 TypeScript 项目</span></a></li><li id="ub7db25fb"><a href="https://segmentfault.com/a/1190000019661168" data-href="https://segmentfault.com/a/1190000019661168" target="_blank" class="ne-link"><span class="ne-text">在Typescript项目中，如何优雅的使用ESLint和Prettier</span></a></li><li id="u44ecc001"><a href="https://segmentfault.com/a/1190000022809326" data-href="https://segmentfault.com/a/1190000022809326" target="_blank" class="ne-link"><span class="ne-text">了不起的 tsconfig.json 指南</span></a></li><li id="u2aab100f"><a href="https://cn.eslint.org/" data-href="https://cn.eslint.org/" target="_blank" class="ne-link"><span class="ne-text">官网：ESLint 可组装的JavaScript和JSX检查工具</span></a></li><li id="u03ef9124"><a href="https://www.jianshu.com/p/ad1e46faaea2" data-href="https://www.jianshu.com/p/ad1e46faaea2" target="_blank" class="ne-link"><span class="ne-text">Eslint 超简单入门教程</span></a></li><li id="u1bf0223d"><a href="https://segmentfault.com/a/1190000020168436" data-href="https://segmentfault.com/a/1190000020168436" target="_blank" class="ne-link"><span class="ne-text">在Vue项目中使用Eslint+Prettier+Stylelint</span></a></li><li id="u40c48b5a"><a href="https://segmentfault.com/a/1190000019905650" data-href="https://segmentfault.com/a/1190000019905650" target="_blank" class="ne-link"><span class="ne-text">使用Vue-cli3搭建Vue+TypeScript项目</span></a></li><li id="u32dbd40a"><a href="https://www.cnblogs.com/suwanbin/p/13583717.html" data-href="https://www.cnblogs.com/suwanbin/p/13583717.html" target="_blank" class="ne-link"><span class="ne-text">prettier - vscode 保存代码自动格式化插件安装与配置项备注</span></a></li></ul><h3 id="NnIDg"><span class="ne-text">ts遍历对象</span></h3><p id="udbfd75c6" class="ne-p"><span class="ne-text">ts遍历对象不要使用</span><code class="ne-code"><span class="ne-text">for···in</span></code><span class="ne-text">，使用</span><code class="ne-code"><span class="ne-text">for···of</span></code></p><ul class="ne-ul"><li id="u33f536a9"><span class="ne-text">理由：</span><a href="https://stackoverflow.com/questions/65300784/declare-key-type-of-for-in-loop-in-typescript" data-href="https://stackoverflow.com/questions/65300784/declare-key-type-of-for-in-loop-in-typescript" target="_blank" class="ne-link"><span class="ne-text">https://stackoverflow.com/questions/65300784/declare-key-type-of-for-in-loop-in-typescript</span></a></li><li id="u6f5fa005"><span class="ne-text">遍历的其他方式参考：</span><a href="https://juejin.cn/post/6844904147146260488" data-href="https://juejin.cn/post/6844904147146260488" target="_blank" class="ne-link"><span class="ne-text">TypeScript小状况之遍历对象属性</span></a></li></ul><pre data-language="typescript" id="NynpO" class="ne-codeblock language-typescript">const disabled = computed(() => {<p>let flag = true<br>for (const [key, val] of Object.entries(formState)) {<br>if (!val) {<br>flag = true<br>break<br>} else {<br>flag = false<br>}<br>}<br>return flag<br>})</pre><h3 id="LPHWx"><span class="ne-text" style="color: rgb(37, 41, 51)">nodemon 运行 ts 文件</span></h3><ul class="ne-ul"><li id="ua905c7c7"><span class="ne-text">参考：</span><a href="https://juejin.cn/post/7035637086451400734" data-href="https://juejin.cn/post/7035637086451400734" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/7035637086451400734</span></a></li><li id="u00182bfe"><span class="ne-text">todo：关于 ts 的配置文件，不是很清楚</span></li></ul><p id="ubc2e9483" class="ne-p"><br></p><h3 id="b8zqb"><span class="ne-text">vue3 选项式 API</span></h3><p id="u00389256" class="ne-p"><br></p><p id="uf9b41ba3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1656489860490-7ceda888-678e-400e-86ce-b8b5eb752b26.png" width="1549" id="u38d89f0f" class="ne-image"></p><p id="u78d43851" class="ne-p"><br></p><p id="uda05cad1" class="ne-p"><br></p><h2 id="SibGi"><span class="ne-text">报错：</span></h2><h3 id="jy5ub"><span class="ne-text">类型“string | null”的参数不能赋给类型“string”的参数。 不能将类型“null”分配给类型“string”</span></h3><pre data-language="plain" id="xEAGn" class="ne-codeblock language-plain">类型“string | null”的参数不能赋给类型“string”的参数。 不能将类型“null”分配给类型“string”</pre><p id="uaf33ba99" class="ne-p"><span class="ne-text">上面报错是因为 16 行代码之前没有</span><code class="ne-code"><span class="ne-text">|| ''</span></code><span class="ne-text">ts 的赋值较为严格，以此例警戒。</span></p><p id="u4e58388f" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="u8e30fd85"><span class="ne-text">另外本例子中还需要转换字符串，undefined,null 等转化为””。不然数据回显会显示为 undefined。</span></li><li id="u1ed4d4c4"><span class="ne-text">另外还有一个类似问题：</span><a href="https://segmentfault.com/q/1010000039940940" data-href="https://segmentfault.com/q/1010000039940940" target="_blank" class="ne-link"><span class="ne-text">vue3 中的 reactive 对象赋值问题</span></a></li></ul><pre data-language="typescript" id="HbYxp" class="ne-codeblock language-typescript">interface FormState {<br>input_id: string<br>password: string<br>remember: boolean<br>}</p><p>// undefined,null 等转化为””<br>const praseStrEmpty = (str: any) =&gt; {<br>if (!str || str == ‘undefined’ || str == ‘null’) {<br>return ‘’<br>}<br>return str<br>}</p><p>let formState = reactive<FormState>({<br>input_id: praseStrEmpty(String(route.query.user_id) || ‘’),<br>password: praseStrEmpty(String(route.query.password) || ‘’),<br>remember: true,<br>})</pre><h3 id="NkBtO"><span class="ne-text">Property ‘replaceAll’ does not exist on type ‘string’</span></h3><ul class="ne-ul"><li id="uc593baff"><span class="ne-text">ts 不能使用 js 的 String 的 API：replaceAll 方法</span></li></ul><ul class="ne-ul"><li id="u5431a587"><span class="ne-text">解决：使用其他字符串 api 来达到该目的，</span><a href="https://stackoverflow.com/questions/63616486/property-replaceall-does-not-exist-on-type-string" data-href="https://stackoverflow.com/questions/63616486/property-replaceall-does-not-exist-on-type-string" target="_blank" class="ne-link"><span class="ne-text">https://stackoverflow.com/questions/63616486/property-replaceall-does-not-exist-on-type-string</span></a></li><li id="uf8124841"><span class="ne-text">todo：可能原因还有可能是自己的配置文件没有配置好</span></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Express框架</title>
      <link href="/blog/tdgoby/"/>
      <url>/blog/tdgoby/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="SZZM1"><span class="ne-text">express框架</span></h2><p id="u3d4ac39a" class="ne-p"><span class="ne-text">express框架相当于再http模块加上一个中间件合集。</span><strong><span class="ne-text">中间件</span></strong><span class="ne-text">的含义就相当于处理http请求的处理函数，而express相当于调用多个中间件，这么一个框架。</span></p><p id="u8f6b3063" class="ne-p"><br></p><p id="uda9de047" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u84242c89"><a href="https://javascript.ruanyifeng.com/nodejs/express.html" data-href="https://javascript.ruanyifeng.com/nodejs/express.html" target="_blank" class="ne-link"><span class="ne-text">Express框架 来自《JavaScript 标准参考教程（alpha）》，by 阮一峰</span></a></li><li id="u29e2fce3"><a href="https://juejin.cn/post/6844904023380721678" data-href="https://juejin.cn/post/6844904023380721678" target="_blank" class="ne-link"><span class="ne-text">一杯茶的时间，上手 Express 框架开发</span></a></li></ul><p id="u3f1842ae" class="ne-p"><span class="ne-text"></span></p><p id="u39af97d3" class="ne-p"><span class="ne-text">相关文档：</span></p><ul class="ne-ul"><li id="u74927218"><a href="http://expressjs.jser.us/" data-href="http://expressjs.jser.us/" target="_blank" class="ne-link"><span class="ne-text">http://expressjs.jser.us/</span></a></li></ul><p id="u85187766" class="ne-p"><span class="ne-text"></span></p><p id="u79d28551" class="ne-p"><span class="ne-text">项目下载使用：</span></p><pre data-language="bash" id="HBZf4" class="ne-codeblock language-bash">cnpm install express --save</pre><h3 id="bvAQ0"><span class="ne-text">express路由结构化</span></h3><p id="u57d10c9d" class="ne-p"><a href="https://expressjs.com/zh-cn/guide/routing.html" data-href="https://expressjs.com/zh-cn/guide/routing.html" target="_blank" class="ne-link"><span class="ne-text">https://expressjs.com/zh-cn/guide/routing.html</span></a></p><h3 id="aGSGq"><span class="ne-text">express里http.createServer</span></h3><pre data-language="javascript" id="Ctf12" class="ne-codeblock language-javascript">  const app = express()<p>app.use(bodyParser.json({ limit: ‘10mb’ }))<br>app.use(<br>bodyParser.urlencoded({<br>extended: false,<br>})<br>)<br>const server = http.createServer(app)</pre><p id="uff13f501" class="ne-p"><span class="ne-text">第 9 行代码这样写好处有：</span></p><p id="u10abaaf7" class="ne-p"><span class="ne-text">用 http 封装不但可以使用 express 的属性和方法，而且还可以使用 http 的属性和方法</span></p><p id="u2c79cc69" class="ne-p"><span class="ne-text">具体可以参考这段讨论：</span><a href="https://cnodejs.org/topic/5396cd60c3ee0b5820f00e2a" data-href="https://cnodejs.org/topic/5396cd60c3ee0b5820f00e2a" target="_blank" class="ne-link"><span class="ne-text">express 里 http.createServer 和 app.listen 有什么区别？</span></a></p><h3 id="maJie"><span class="ne-text">express 常用 API</span></h3><h4 id="PFv2f"><span class="ne-text">use 方法和中间件</span></h4><ul class="ne-ul"><li id="u3d50a3b4"><span class="ne-text">注册中间件，返回的是函数。注意第三个参数 next，如果写</span><code class="ne-code"><span class="ne-text">next()</span></code><span class="ne-text">语句则执行完该中间件，前往下一个中间件执行下一个中间件，如果不写，则执行完该中间件，就停止运行中间件。</span></li><li id="u8f2e76c8"><span class="ne-text">中间件，如果注册了路由，则只显示路由内容，所以使用的时候，中间件的 url 不应该是具体路由，而是一层路由，其他的二层路由则是具体内容路由。</span></li></ul><pre data-language="javascript" id="iIAUF" class="ne-codeblock language-javascript">/*</p><ul><li>@Author: wztlink1013</li><li>@Date: 2022-01-10 20:15:30</li><li>@LastEditTime: 2022-01-11 10:26:35</li><li>@Description:<br>*/<br>let express = require(‘express’)<br>let app = express()</li></ul><p>// 路由<br>app.get(‘/‘, function (req, res) {<br>res.send(‘Hello world’)<br>})<br>app.get(‘/customer’, function (req, res) {<br>res.send(‘customer page’)<br>})<br>// app.get(‘/admin’, function (req, res) {<br>// console.log(‘—————————-‘)<br>// res.send(‘admin page’)<br>// })</p><p>// 中间件<br>// 如果注册了路由，则只显示路由内容<br>app.use(‘/admin’, function (request, response, next) {<br>response.writeHead(200, { ‘Content-Type’: ‘text/plain’ })<br>response.end(‘Welcome to the admin page!\n’)<br>})</p><p>app.listen(3000)<br>console.log(‘to <a href="http://localhost:3000/&#39;">http://localhost:3000/&#39;</a>)</pre><h4 id="yJMJU"><span class="ne-text">get 方法</span></h4><ul class="ne-ul"><li id="uc076919a"><span class="ne-text">注册路由，用于指定不同的访问路径所对应的回调函数。由于 get 方法没有 next 回调函数，所以按照执行顺序，当地一个 get 方法执行了（根据匹配成功参数路径），后续的都不会执行了</span></li></ul><div class="ne-quote"><p id="ue5d6d127" class="ne-p"><span class="ne-text">put()post()put()del()类似 get()使用（delete 是 JavaScript 保留字，所以改叫 del）</span></p></div><p id="uc807da1e" class="ne-p"><span class="ne-text">对于第一个参数，也就是路径参数，有不同的匹配规则</span></p><pre data-language="javascript" id="y9aPl" class="ne-codeblock language-javascript">app.get('/customer/:who', function (req, res) {<br>res.send('都能访问 /' + req.params.who + ' 该路径')<br>})</pre><p id="udeb39565" class="ne-p"><span class="ne-text">访问 </span><a href="http://localhost:3000/customer/fa" data-href="http://localhost:3000/customer/fa" target="_blank" class="ne-link"><span class="ne-text">http://localhost:3000/customer/fa</span></a><span class="ne-text"> 返回 </span><code class="ne-code"><span class="ne-text">都能访问 /fa 该路径</span></code></p><p id="u5886c758" class="ne-p"><span class="ne-text">访问</span><a href="http://localhost:3000/customer/ad" data-href="http://localhost:3000/customer/ad" target="_blank" class="ne-link"><span class="ne-text">http://localhost:3000/customer/ad</span></a><span class="ne-text"> 返回 </span><code class="ne-code"><span class="ne-text">都能访问 /ad 该路径</span></code></p><p id="ud73bb228" class="ne-p"><span class="ne-text">不能访问</span><a href="http://localhost:3000/customer" data-href="http://localhost:3000/customer" target="_blank" class="ne-link"><span class="ne-text">http://localhost:3000/customer</span></a></p><p id="u8257ffd5" class="ne-p"><span class="ne-text">如果是:who? 则成为可选路径</span></p><h4 id="GoJ2E"><span class="ne-text">set 方法</span></h4><ul class="ne-ul"><li id="ube09ff24"><span class="ne-text">指定变量的值</span></li></ul><pre data-language="javascript" id="FElEq" class="ne-codeblock language-javascript">// 告诉 express 框架模板的位置<br>app.set('views', path.join(__dirname, 'views'))<br>// 告诉 express 框架模板的默认后缀是什么<br>app.set('view engine', 'art');</pre><h4 id="tCcvQ"><span class="ne-text">response 对象</span></h4><p id="uc267f8b7" class="ne-p"><span class="ne-text">response.redirect 方法允许网址的重定向。</span></p><p id="uf70b4e36" class="ne-p"><span class="ne-text">response.sendFile 方法用于发送文件。</span></p><p id="u2bffa3d7" class="ne-p"><span class="ne-text">response.render 方法用于渲染网页模板。</span></p><h4 id="YSrGP"><span class="ne-text">request 对象</span></h4><h4 id="KIPOO"><span class="ne-text">搭建 HTTPS 环境</span></h4><p id="udbceda63" class="ne-p"><span class="ne-text">上传 crt 和 key 文件</span></p><pre data-language="javascript" id="cRKSB" class="ne-codeblock language-javascript">var fs = require('fs');<br>var options = {<br>key: fs.readFileSync('E:/ssl/myserver.key'),<br>cert: fs.readFileSync('E:/ssl/myserver.crt'),<br>passphrase: '1234'<br>};</p><p>var https = require(‘https’);<br>var express = require(‘express’);<br>var app = express();</p><p>app.get(‘/‘, function(req, res){<br>res.send(‘Hello World Expressjs’);<br>});</p><p>var server = https.createServer(options, app);<br>server.listen(8084);<br>console.log(‘Server is running on port 8084’);</pre><h3 id="JlltX"><span class="ne-text">express 写 API 接口</span></h3><h4 id="NEOTJ"><span class="ne-text">References</span></h4><ul class="ne-ul"><li id="u95bf99da"><a href="https://blog.csdn.net/m0_48375854/article/details/122447235" data-href="https://blog.csdn.net/m0_48375854/article/details/122447235" target="_blank" class="ne-link"><span class="ne-text">Node.js—使用 Express 写接口</span></a></li></ul><h4 id="ZRE1G"><span class="ne-text">response 对象 json 方法写接口</span></h4><p id="u7bd04614" class="ne-p"><span class="ne-text">内置 json 响应的方式：</span></p><pre data-language="javascript" id="FErlx" class="ne-codeblock language-javascript">/*</p><ul><li>@Author: wztlink1013</li><li>@Date: 2022-01-11 11:04:38</li><li>@LastEditTime: 2022-01-11 11:21:17</li><li>@Description:<br>*/<br>let obj = {<br>1: {<br>id: 1234,<br>name: ‘张三’,<br>college: ‘计算机科学与工程学院’,<br>grade: 2018,<br>classes: 2,<br>age: 21,<br>},<br>2: {<br>id: 5678,<br>name: ‘李四’,<br>college: ‘计算机科学与工程学院’,<br>grade: 2018,<br>classes: 2,<br>age: 21,<br>},<br>}</li></ul><p>exports.index = function (req, res) {<br>res.status(200).json(obj)<br>}</pre><pre data-language="javascript" id="GVYMP" class="ne-codeblock language-javascript">// 接口的使用<br>let userinfo = require('./api/userinfo.js')<br>app.get('/api/userinfo', userinfo.index)</pre><h4 id="zzaxG"><span class="ne-text">js 使用接口的一些方法</span></h4><ul class="ne-ul"><li id="u43b7106d"><span class="ne-text">用之前总结的使用接口一些方法：</span><a href="https://github.com/wztlink1013/web-learn-notes/tree/gh-pages/learn-interface" data-href="https://github.com/wztlink1013/web-learn-notes/tree/gh-pages/learn-interface" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wztlink1013/web-learn-notes/tree/gh-pages/learn-interface</span></a></li></ul><h4 id="mwKb2"><span class="ne-text">跨域问题的解决</span></h4><p id="uf6998da1" class="ne-p"><span class="ne-text">解法一：手写（但是有看到网上说会有设备（iPhone6）不兼容等问题）</span></p><pre data-language="javascript" id="kdgjd" class="ne-codeblock language-javascript">// 跨域设置<br>app.all("<em>", function(req, res, next) {<br>res.header("Access-Control-Allow-Credentials", true);<br>res.header("Access-Control-Allow-Origin", "</em>");<br>res.header("Access-Control-Allow-Headers", "X-Requested-With");<br>res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");<br>res.header("Content-Type", "application/json;charset=utf-8");<br>next();<br>});</pre><p id="u3807f4e8" class="ne-p"><span class="ne-text">解法二：直接使用 npm 里面的 cors 包</span></p><pre data-language="html" id="vAQT6" class="ne-codeblock language-html"><!--</p><ul><li><p>@Descripttion: learn axios</p></li><li><p>@Date: 2021-12-21 09:40:36</p></li><li><p>@LastEditTime: 2022-01-11 11:25:28<br>–&gt;</p><!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta http-equiv="X-UA-Compatible" content="IE=edge" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <title>Document</title>    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>  </head>  <body>    <script>      // 配置公共的请求头      axios.defaults.baseURL = 'http://localhost:3000/'      // 配置 超时时间      axios.defaults.timeout = 2500      // 配置公共的请求头      // axios.defaults.headers.common["Authorization"] =      //   "token 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"      // axios.defaults.headers.common["Accept"] = "application/vnd.github.v3+json"      // 配置公共的 post 的 Content-Type      axios.defaults.headers.post['Content-Type'] = 'application/json'<pre><code>  // 请求/响应 拦截器的配置  axios.interceptors.request.use(    config =&gt; &#123;      console.log(&#39;请求拦截器: &#39;)      config.headers.Accept = &#39;application/vnd.github.v3+json&#39;      config.headers.Authorization =        &#39;token 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&#39;      console.log(config)      return config    &#125;,    err =&gt; &#123;      console.log(err)    &#125;  )  axios.interceptors.response.use(    data =&gt; &#123;      console.log(&#39;响应拦截器: &#39;)      console.log(data.data)      return data.data    &#125;,    err =&gt; &#123;      console.log(err)    &#125;  )  // 请求数据  axios.get(&#39;api/userinfo&#39;).then(data =&gt; &#123;    console.log(data)  &#125;)&lt;/script&gt;</code></pre>  </body></html></pre><p id="ub187bf50" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641872349891-229b5dc9-c17f-4a3b-bbef-98611971015f.png" width="569.5" id="g5VY5" class="ne-image"></p><h4 id="RIBJU"><span class="ne-text">Postman 测试API工具</span></h4><p id="u76413f3c" class="ne-p"><span class="ne-text">如果是本地写的接口，也就是localhost类的，在web postman上是不能测试的，只能下载Postman PC应用来测试。</span></p><h3 id="HdYAo"><span class="ne-text">body-parser模块</span></h3><p id="u3898d1c9" class="ne-p"><span class="ne-text">body-parser为express框架的中间件，其作用就是对post请求的请求体进行解析。</span></p><p id="u0ca951ed" class="ne-p"><span class="ne-text">下载使用：</span></p><pre data-language="bash" id="WtvzQ" class="ne-codeblock language-bash">cnpm install body-parser</pre><h4 id="JrfFg"><span class="ne-text">bodyParser.json( )与bodyParser.urlencoded( )</span></h4><ul class="ne-ul"><li id="u374ee14f"><span class="ne-text">limit参数（json）：控制请求体最大尺寸</span></li><li id="u160b544d"><span class="ne-text">extended参数（urlencoded）：</span></li></ul><p id="ub4779aaa" class="ne-p"><code class="ne-code"><span class="ne-text">extended: false</span></code><span class="ne-text">：表示使用系统模块querystring来处理，也是官方推荐的</span></p><p id="ub7c93c26" class="ne-p"><code class="ne-code"><span class="ne-text">extended: true</span></code><span class="ne-text">：表示使用第三方模块qs来处理</span></p><p id="u6b87a5c0" class="ne-p"><span class="ne-text">从功能性来讲，qs比querystring要更强大，所以这里可以根据项目的实际需求来考虑</span></p><p id="ub39513a2" class="ne-p"><span class="ne-text">详见：</span><a href="https://github.com/expressjs/body-parser/#extended" data-href="https://github.com/expressjs/body-parser/#extended" target="_blank" class="ne-link"><span class="ne-text">https://github.com/expressjs/body-parser/#extended</span></a></p><h4 id="RAcgG"><span class="ne-text">References</span></h4><ul class="ne-ul"><li id="u024103cd"><span class="ne-text"></span><a href="https://github.com/expressjs/body-parser/" data-href="https://github.com/expressjs/body-parser/" target="_blank" class="ne-link"><span class="ne-text">https://github.com/expressjs/body-parser/</span></a></li><li id="u4c67161c"><a href="https://www.cnblogs.com/chyingp/p/nodejs-learning-express-body-parser.html" data-href="https://www.cnblogs.com/chyingp/p/nodejs-learning-express-body-parser.html" target="_blank" class="ne-link"><span class="ne-text">Nodejs 进阶：Express 常用中间件 body-parser 实现解析 </span></a></li><li id="ue3e4885a"><a href="https://segmentfault.com/a/1190000004407008" data-href="https://segmentfault.com/a/1190000004407008" target="_blank" class="ne-link"><span class="ne-text">bodyParser中间件的研究</span></a></li></ul><h3 id="H76rt"><span class="ne-text">express-session模块</span></h3><p id="e5a83eec75d9703913b34f5a57c6c0e2" class="ne-p"><span class="ne-text">设置Cookie，</span><code class="ne-code"><span class="ne-text">app.use(session(&#123;secret: 'secret key'&#125;));</span></code></p><p id="668b82e8367ae7ff8268aa4fba2d1143" class="ne-p"><span class="ne-text">当参数为secret时候，通过设置的secret字符串，来计算hash值并放在cookie中，使产生的signedCookie防篡改</span></p><p id="96273afa9f3a7693cd6a47e0ad7ac5ae" class="ne-p"><br></p><p id="ec1e13fd45edd3c0f24876ef7e7914d6" class="ne-p"><span class="ne-text">还有其他的参数：</span></p><ul class="ne-ul"><li id="a790486bd5a810616c3cf007ec2ac6aa"><span class="ne-text">name: 设置cookie中，保存session的字段名称，默认为connect.sid</span></li><li id="872441e9f2d437c3d2c811e72cc7e213"><span class="ne-text">store: session的存储方式，默认为存放在内存中，我们可以自定义redis等</span></li><li id="a7b14914a20f582ee51f69406a07fd35"><span class="ne-text">genid: 生成一个新的session_id时，默认为使用uid2这个npm包</span></li><li id="b25a9619e55805dadbef4599663a29d3"><span class="ne-text">rolling: 每个请求都重新设置一个cookie，默认为false</span></li><li id="1fa877bdbea80baa1648088af27de7bf"><span class="ne-text">resave: 即使session没有被修改，也保存session值，默认为true</span></li><li id="bca8d2e03acc9f1b4960caaf7bb67ed4"><span class="ne-text">saveUninitialized：强制未初始化的session保存到数据库</span></li><li id="92596e74df5537944f8fc2acb7e8c36c"><span class="ne-text">secret: 通过设置的secret字符串，来计算hash值并放在cookie中，使产生的signedCookie防篡改</span></li><li id="d35772ab8f12660bf32fe38e9ad0d7e7"><span class="ne-text">cookie : 设置存放sessionid的cookie的相关选项</span></li></ul></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mongoose操作MongoDB数据库</title>
      <link href="/blog/xfn7hy/"/>
      <url>/blog/xfn7hy/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ud43c3a98"><span class="ne-text">GitHub：</span><a href="https://github.com/Automattic/mongoose" data-href="https://github.com/Automattic/mongoose" target="_blank" class="ne-link"><span class="ne-text">https://github.com/Automattic/mongoose</span></a></li><li id="ud396ccb4"><span class="ne-text">英文文档：</span><a href="https://mongoosejs.com/docs/guide.html" data-href="https://mongoosejs.com/docs/guide.html" target="_blank" class="ne-link"><span class="ne-text">https://mongoosejs.com/docs/guide.html</span></a></li><li id="ucd4684f0"><span class="ne-text">中文文档：</span><a href="http://www.mongoosejs.net/docs/guide.html" data-href="http://www.mongoosejs.net/docs/guide.html" target="_blank" class="ne-link"><span class="ne-text">http://www.mongoosejs.net/docs/guide.html</span></a></li><li id="uea71dde7"><a href="https://zhuanlan.zhihu.com/p/56030432" data-href="https://zhuanlan.zhihu.com/p/56030432" target="_blank" class="ne-link"><span class="ne-text">如何使用nodejs写一个接口 - MySQL版</span></a></li></ul><p id="ue53bab1a" class="ne-p"><span class="ne-text"></span></p><p id="u2a1cce22" class="ne-p"><span class="ne-text">shardb-mongodb模块操作数据库不好去使用，比如查询，新建等，所以这个模块只用作ot服务那边；</span></p><p id="ue31486e0" class="ne-p"><span class="ne-text">另外使用mongoose去操作数据库方便写接口</span></p><ul class="ne-ul"><li id="ud603d93e"><a href="https://github.com/share/sharedb-mongo" data-href="https://github.com/share/sharedb-mongo" target="_blank" class="ne-link"><span class="ne-text">https://github.com/share/sharedb-mongo</span></a></li><li id="u387c569c"><a href="https://www.jianshu.com/p/46f06896c9cd" data-href="https://www.jianshu.com/p/46f06896c9cd" target="_blank" class="ne-link"><span class="ne-text">Mongoose 查询结果为空</span></a></li></ul><p id="u59f5e9b2" class="ne-p"><span class="ne-text">schema的相关配置为connection</span></p><ul class="ne-ul"><li id="uc952063f"><span class="ne-text">之前的增删改查笔记：</span><a href="https://github.com/wztlink1013/web-learn-notes/blob/gh-pages/learn-nodejs/express/model/connect.js" data-href="https://github.com/wztlink1013/web-learn-notes/blob/gh-pages/learn-nodejs/express/model/connect.js" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wztlink1013/web-learn-notes/blob/gh-pages/learn-nodejs/express/model/connect.js</span></a></li><li id="u8ee35e52"><a href="https://segmentfault.com/a/1190000019201081" data-href="https://segmentfault.com/a/1190000019201081" target="_blank" class="ne-link"><span class="ne-text">mongoose踩坑笔记： Cannot overwrite `` model once compiled.</span></a></li></ul><h2 id="UocgJ"><span class="ne-text">安装</span></h2><h3 id="VZPAG"><span class="ne-text">MongoDB以及可视化工具Navicat</span></h3><p id="u9f7c554d" class="ne-p"><span class="ne-text">参考之前写的文章：</span><a href="https://www.yuque.com/wztlink1013/blog/nwt63v" data-href="https://www.yuque.com/wztlink1013/blog/nwt63v" target="_blank" class="ne-link"><span class="ne-text">MongoDB下载及使用+Navicat使用+服务器上的配置</span></a></p><h3 id="uwCTa"><span class="ne-text">安装mongoose</span></h3><pre data-language="bash" id="hDgU8" class="ne-codeblock language-bash">cnpm install mongoose -S</pre><h2 id="YR98P"><span class="ne-text">使用</span></h2><h3 id="CuLRf"><span class="ne-text">连接数据库语句</span></h3><pre data-language="javascript" id="wKCav" class="ne-codeblock language-javascript">// 连接数据库<p>mongoose<br>.connect(‘mongodb://127.0.0.1:27017/test-mongoose’, {<br>useNewUrlParser: true,<br>useUnifiedTopology: true,<br>})<br>.then(() =&gt; {<br>console.log(‘数据库连接成功’)<br>})<br>.catch(() =&gt; {<br>console.log(‘数据库连接失败’)<br>})</pre><p id="c9c95a662d6bdc8dfc56fe5b2a44cf39" class="ne-p"><span class="ne-text">然后再将这个 js 文件 require 到 app.js 里面使用</span></p><pre data-language="javascript" id="kCAt4" class="ne-codeblock language-javascript">// 数据库连接<br>require('./model/connect')</pre><h3 id="q5hLU"><span class="ne-text">创建集合</span></h3><ul class="ne-ul"><li id="7d037472da9784ef7d33551a40fc00d8"><span class="ne-text">先利用函数 mongoose 的 schema 函数构建一个规则</span></li><li id="30e3a9d06838927e8d7b6185651b5f25"><span class="ne-text">然后利用 model 函数创建一个集合并且用上这个规则</span></li></ul><pre data-language="javascript" id="ywJb9" class="ne-codeblock language-javascript">// Schema：数据库集合的结构对象。<br>// 创建一个集合(相当于 sql 里面的设定一个表)规则<br>let TestSchema = new mongoose.Schema({<br>name: { type: String },<br>age: { type: Number, default: 0 },<br>email: { type: String },<br>time: { type: Date, default: Date.now },<br>})</p><dl><dt>// Model ：由 Schema 构造而成，可操作数据库。<br>// 创建一个集合(并且应用上面的规则)<br>let TestModel = mongoose.model(‘schema’, TestSchema)</pre><h3 id="lC5j4"><span class="ne-text">增加文档</span></h3><ul class="ne-ul"><li id="c1ebd2524e4df9a8bc19d7366ca3792c"><span class="ne-text">第一个参数：create 函数</span></li><li id="399e7ec053484186a0799b2639092da0"><span class="ne-text">第二个参数：可以打印相关信息（doc 和 err）</span></li></ul><pre data-language="javascript" id="YoyaU" class="ne-codeblock language-javascript">// 创建（创建完执行以便之后就注释掉，不然会一直重复创建）<br>TestModel.create(<br>[<br>{ name: 'test-1', age: 8 },<br>{ name: 'test-2', age: 18 },<br>{ name: 'test-3', age: 28 },<br>{ name: 'test-4', age: 38 },<br>{ name: 'test-5', age: 48 },<br>{ name: 'test-6', age: 58, email: '<a href="mailto:&#x74;&#116;&#x74;&#x74;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;">&#x74;&#116;&#x74;&#x74;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;</a>' },<br>{ name: 'test-7', age: 68, email: '<a href="mailto:&#115;&#x73;&#115;&#115;&#64;&#x71;&#x71;&#46;&#x63;&#x6f;&#x6d;">&#115;&#x73;&#115;&#115;&#64;&#x71;&#x71;&#46;&#x63;&#x6f;&#x6d;</a>' },<br>{ name: 'test-8', age: 18 },<br>{ name: 'test-9', age: 18, email: '<a href="mailto:&#114;&#114;&#114;&#x72;&#64;&#113;&#113;&#x2e;&#99;&#x6f;&#109;">&#114;&#114;&#114;&#x72;&#64;&#113;&#113;&#x2e;&#99;&#x6f;&#109;</a>' },<br>{ name: 'test-10', age: 18 },<br>],<br>(error, docs){<br>if (error) {<br>console.log(error)<br>} else {<br>console.log('save ok')<br>console.log(docs)<br>}<br>}<br>)</pre><ul class="ne-ul"><li id="a41addd210d7686d49f6ebcc93cf8e30"><span class="ne-text">也可以创建一个对象赋值给一个变量，然后该变量利用函数 save 即可保存到数据库</span></li></ul><div data-type="danger" class="ne-alert"><p id="u59cd1a38" class="ne-p"><span class="ne-text">创建完执行以便之后就注释掉，不然会一直重复创建</span></p></div><h3 id="vvKaw"><span class="ne-text">查询文档</span></h3><ul class="ne-ul"><li id="u47e0fb62"><span class="ne-text">查询函数</span><code class="ne-code"><span class="ne-text">findOne</span></code><span class="ne-text">：返回第一条数据</span></li><li id="u7c9bc1e0"><span class="ne-text">查询函数</span><code class="ne-code"><span class="ne-text">find</span></code><span class="ne-text">：查询所有包含条件的数据</span></li></ul><pre data-language="javascript" id="XXoWO" class="ne-codeblock language-javascript">// 查询<br>TestModel.find(<br>// 28<= age <48<br>{ age: { $gte: 28, $lt: 48 } },<br>  // 1为指定字段，0为排除字段<br>  { name: 1, age: 1, _id: 0 },<br>  function (err, docs) {<br>    if (err) {<br>      console.log('查询出错: ' + err)<br>    } else {<br>      console.log('$gte,$lte 查询结果为: ')<br>console.log(docs)<br>}<br>}<br>)</pre><h3 id="xa1jM"><span class="ne-text">mongoose 条件查询</span></h3><p id="u5d586ab7" class="ne-p"><span class="ne-text">键为变量时用</span></p><p id="u520d896c" class="ne-p"><span class="ne-text">中括号括起来就行了</span></p><pre data-language="javascript" id="T2hyC" class="ne-codeblock language-javascript">checkStr(data.type_id, 'email')<br>? (type_str = 'email')</dt><dd>(type_str = 'user_id')<br>Model_user.find({ [type_str]: data.type_id }, {}, (err, docs) => {}</pre><p id="u847b6a58" class="ne-p"><span class="ne-text"></span></p><p id="ub924cbe9" class="ne-p"><span class="ne-text">逻辑查询</span></p><p id="uaded3def" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u60000458"><span class="ne-text">文档：</span><a href="http://mongoosejs.net/docs/queries.html" data-href="http://mongoosejs.net/docs/queries.html" target="_blank" class="ne-link"><span class="ne-text">http://mongoosejs.net/docs/queries.html</span></a></li><li id="u8661ef16"><a href="https://segmentfault.com/a/1190000021010300" data-href="https://segmentfault.com/a/1190000021010300" target="_blank" class="ne-link"><span class="ne-text">mongoose 系列之一 find 查询</span></a></li></ul><pre data-language="javascript" id="EFyWT" class="ne-codeblock language-javascript">Model_user.find(<br>{ $or: [{ email: obj.email }, { user_id: obj.user_id }] },<br>{},<br>(err, docs) => {}<br>)</pre><h3 id="lVQsg"><span class="ne-text">更新文档</span></h3><p id="ue3e09cc1" class="ne-p"><code class="ne-code"><span class="ne-text">User.updateOne(&#123;查询条件&#125;, &#123;要修改的值&#125;).then(result => console.log(result))</span></code></p><ul class="ne-ul"><li id="ua77d93c9"><span class="ne-text">updateOne：更新单个</span></li><li id="ua869ce75"><span class="ne-text">updateMany：更新多个</span></li></ul><pre data-language="javascript" id="kbyTO" class="ne-codeblock language-javascript">// 更新<br>let conditions_1 = { name: 'test-3' }<br>let update = { $set: { age: 11 } }<br>TestModel.updateOne(conditions_1, update, function (error) {<br>if (error) {<br>console.log(error)<br>} else {<br>console.log('Update success!')<br>TestModel.find(<br>{ name: 'test-3' },<br>{ name: 1, age: 1, _id: 0 },<br>function (err, docs) {<br>if (err) {<br>console.log('查询出错: ' + err)<br>} else {<br>console.log('更新 test-3 后的查询结果为: ')<br>console.log(docs)<br>}<br>}<br>)<br>}<br>})</pre><h3 id="juiBb"><span class="ne-text">删除文档</span></h3><ul class="ne-ul"><li id="uf64adeb5"><span class="ne-text">删除单个：</span><code class="ne-code"><span class="ne-text">User.findOneAndDelete(&#123;&#125;)then(result => console.log(result))</span></code></li><li id="u3ecf60ad"><span class="ne-text">删除多个：</span><code class="ne-code"><span class="ne-text">User.deleteMany(&#123;&#125;).then(result => console.log(result))</span></code></li><li id="u2a8122d7"><span class="ne-text">deleteOne：删除单个</span></li></ul><pre data-language="javascript" id="gvlH0" class="ne-codeblock language-javascript">// 删除<br>let conditions_2 = { name: 'test-2' }<br>TestModel.deleteOne(conditions_2, function (error) {<br>if (error) {<br>console.log(error)<br>} else {<br>console.log('Delete success!')<br>TestModel.find(<br>{ name: 'test-2' },<br>{ name: 1, age: 1, _id: 0 },<br>function (err, docs) {<br>if (err) {<br>console.log('查询出错: ' + err)<br>} else {<br>console.log('删除 test-2 后的查询结果为: ')<br>console.log(docs)<br>}<br>}<br>)<br>}<br>})</dd></dl><p></pre><h3 id="NvcCP"><span class="ne-text">mongoose验证</span></h3><p id="6768b794faaf2f60036a6c1c2be309ab" class="ne-p"><br></p><p id="8ab6701f4a72f8e0af41382696760cfa" class="ne-p"><span class="ne-text">required: true 必传字段</span></p><p id="90378084bf4da9d8b82c9cd3712c60a5" class="ne-p"><span class="ne-text">minlength：3 字符串最小长度</span></p><p id="a97cb1cb66346a2d92bcd163175b37da" class="ne-p"><span class="ne-text">maxlength: 20 字符串最大长度</span></p><p id="8ec377a0a479a76429e2dd9201a85ac0" class="ne-p"><span class="ne-text">min: 2 数值最小为2</span></p><p id="7407fc8f50616d578f6683c6eca44f5a" class="ne-p"><span class="ne-text">max: 100 数值最大为100</span></p><p id="6a0c063a60a1416474477e1ef7fd4917" class="ne-p"><span class="ne-text">enum: [‘html’, ‘css’, ‘javascript’, ‘node.js’]</span></p><p id="dbdb49fa5f9fdc7cd81252f2533703c5" class="ne-p"><span class="ne-text">trim: true 去除字符串两边的空格</span></p><p id="4ad5cb8f78d2a95c5e3991b01f3519e6" class="ne-p"><span class="ne-text">validate: 自定义验证器</span></p><p id="fa2c27ed12d7ac7ad1b48f59c2f5a599" class="ne-p"><span class="ne-text">default: 默认值</span></p><p id="9ae5494a2609fbfaf10e59aa78fbd07a" class="ne-p"><br></p><p id="a018ee404ec903f0043c1b7fa65017d9" class="ne-p"><span class="ne-text">获取错误信息：error.errors[‘字段名称’].message</span></p><h3 id="Fa0Tc"><span class="ne-text">整体代码</span></h3><pre data-language="javascript" id="CAWaK" class="ne-codeblock language-javascript">/*</p><ul><li>@Author: wztlink1013</li><li>@Date: 2022-01-11 12:43:02</li><li>@LastEditTime: 2022-01-11 16:44:13</li><li>@Description:</li><li>/<br>const mongoose = require(‘mongoose’)</li></ul><p>// 连接数据库<br>mongoose<br>.connect(‘mongodb://127.0.0.1:27017/test-mongoose’, {<br>useNewUrlParser: true,<br>useUnifiedTopology: true,<br>})<br>.then(() =&gt; {<br>console.log(‘数据库连接成功’)<br>})<br>.catch(() =&gt; {<br>console.log(‘数据库连接失败’)<br>})</p><p>// Schema：数据库集合的结构对象。<br>let TestSchema = new mongoose.Schema({<br>name: { type: String },<br>age: { type: Number, default: 0 },<br>email: { type: String },<br>time: { type: Date, default: Date.now },<br>})</p><p>// Model ：由 Schema 构造而成，可操作数据库。<br>let TestModel = mongoose.model(‘schema’, TestSchema)</p><p>// Entity：由 Model 创建的实体，可操作数据库。<br>// let TestEntity = new TestModel({<br>// name: ‘helloworld’,<br>// age: 28,<br>// email: ‘<a href="mailto:&#104;&#101;&#x6c;&#108;&#111;&#x77;&#111;&#x72;&#108;&#100;&#x40;&#113;&#113;&#46;&#99;&#111;&#109;">&#104;&#101;&#x6c;&#108;&#111;&#x77;&#111;&#x72;&#108;&#100;&#x40;&#113;&#113;&#46;&#99;&#111;&#109;</a>‘,<br>// })<br>// console.log(TestEntity)</p><p>// 创建（创建完执行以便之后就注释掉，不然会一直重复创建）<br>// TestModel.create(<br>// [<br>// { name: ‘test-1’, age: 8 },<br>// { name: ‘test-2’, age: 18 },<br>// { name: ‘test-3’, age: 28 },<br>// { name: ‘test-4’, age: 38 },<br>// { name: ‘test-5’, age: 48 },<br>// { name: ‘test-6’, age: 58, email: ‘<a href="mailto:&#116;&#116;&#x74;&#116;&#x40;&#113;&#x71;&#x2e;&#x63;&#111;&#x6d;">&#116;&#116;&#x74;&#116;&#x40;&#113;&#x71;&#x2e;&#x63;&#111;&#x6d;</a>‘ },<br>// { name: ‘test-7’, age: 68, email: ‘<a href="mailto:&#x73;&#115;&#x73;&#115;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#x6d;">&#x73;&#115;&#x73;&#115;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#x6d;</a>‘ },<br>// { name: ‘test-8’, age: 18 },<br>// { name: ‘test-9’, age: 18, email: ‘<a href="mailto:&#114;&#114;&#x72;&#114;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#114;&#114;&#x72;&#114;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a>‘ },<br>// { name: ‘test-10’, age: 18 },<br>// ],<br>// function (error, docs) {<br>// if (error) {<br>// console.log(error)<br>// } else {<br>// // console.log(‘save ok’)<br>// // console.log(docs)<br>// }<br>// }<br>// )</p><p>// 查询<br>TestModel.find(<br>// 28&lt;= age &lt;48<br>{ age: { $gte: 28, $lt: 48 } },<br>  // 1为指定字段，0为排除字段<br>  { name: 1, age: 1, _id: 0 },<br>  function (err, docs) {<br>    if (err) {<br>      console.log(‘查询出错: ‘ + err)<br>    } else {<br>      console.log(‘$gte,$lte 查询结果为: ‘)<br>console.log(docs)<br>}<br>}<br>)<br>// 更新<br>let conditions_1 = { name: ‘test-3’ }<br>let update = { $set: { age: 11 } }<br>TestModel.updateOne(conditions_1, update, function (error) {<br>if (error) {<br>console.log(error)<br>} else {<br>console.log(‘Update success!’)<br>TestModel.find(<br>{ name: ‘test-3’ },<br>{ name: 1, age: 1, _id: 0 },<br>function (err, docs) {<br>if (err) {<br>console.log(‘查询出错: ‘ + err)<br>} else {<br>console.log(‘更新 test-3 后的查询结果为: ‘)<br>console.log(docs)<br>}<br>}<br>)<br>}<br>})<br>// 删除<br>let conditions_2 = { name: ‘test-2’ }<br>TestModel.deleteOne(conditions_2, function (error) {<br>if (error) {<br>console.log(error)<br>} else {<br>console.log(‘Delete success!’)<br>TestModel.find(<br>{ name: ‘test-2’ },<br>{ name: 1, age: 1, _id: 0 },<br>function (err, docs) {<br>if (err) {<br>console.log(‘查询出错: ‘ + err)<br>} else {<br>console.log(‘删除 test-2 后的查询结果为: ‘)<br>console.log(docs)<br>}<br>}<br>)<br>}<br>})</pre><p id="ube00435c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641879796743-f8670ed9-0562-4e6d-ab68-79418d34424f.png" width="373.49537658691406" id="ddiif" class="ne-image"></p><p id="ub82dbb10" class="ne-p"><br></p><p id="u29316754" class="ne-p"><br></p><p id="ud4ff2363" class="ne-p"><br></p><h3 id="Uz4XW"><span class="ne-text">其他</span></h3><ul class="ne-ul"><li id="u362fd903"><a href="https://blog.csdn.net/youhebuke225/article/details/106872122" data-href="https://blog.csdn.net/youhebuke225/article/details/106872122" target="_blank" class="ne-link"><span class="ne-text">mongoose 查询到的对象无法读取问题</span></a></li></ul><h3 id="k5mRE"><span class="ne-text">mongodb 创建集合</span></h3><p id="u50abd338" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>校内实习Springboot+Ajax全栈在线考试管理系统</title>
      <link href="/blog/aeavli/"/>
      <url>/blog/aeavli/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ub9d15cdc" class="ne-p"><span class="ne-text">校内实习笔记</span></p><h2 id="Zn9ho"><span class="ne-text">开发环境搭建</span></h2><h3 id="W6hhP"><span class="ne-text">MySQL下载安装</span></h3><ul class="ne-ul"><li id="ub2863bab"><span class="ne-text">下载地址：</span><a href="https://www.mysql.com/downloads/" data-href="https://www.mysql.com/downloads/" target="_blank" class="ne-link"><span class="ne-text">https://www.mysql.com/downloads/</span></a></li><li id="ub5f47daf"><span class="ne-text">安装下载教程：</span><a href="https://blog.csdn.net/Kindergarten_Sir/article/details/109274396" data-href="https://blog.csdn.net/Kindergarten_Sir/article/details/109274396" target="_blank" class="ne-link"><span class="ne-text">MySQL的下载与安装教程--超详细</span></a></li></ul><p id="u3d6edb70" class="ne-p"><span class="ne-text"></span></p><p id="u97153148" class="ne-p"><span class="ne-text">成功如下：</span></p><p id="u2f594951" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645420397245-3062da09-70ef-47cb-94a0-1169ed942a1a.png" width="789.9999686082217" id="uf3cb7e10" class="ne-image"></p><p id="u8e210634" class="ne-p"><span class="ne-text">再配置环境变量（和java环境变量配置一样）</span></p><p id="u78a15551" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645670861710-ec8aa52e-ae51-41d7-a008-03b385f5a189.png" width="576.666643751993" id="u53489e49" class="ne-image"></p><p id="u6d3eac2f" class="ne-p"><br></p><h3 id="eI3gv"><span class="ne-text">IDEA下载安装</span></h3><p id="ub40be899" class="ne-p"><span class="ne-text">IDEA下载：</span><a href="https://www.jetbrains.com.cn/idea/download/#section=windows" data-href="https://www.jetbrains.com.cn/idea/download/#section=windows" target="_blank" class="ne-link"><span class="ne-text">https://www.jetbrains.com.cn/idea/download/#section=windows</span></a></p><h3 id="cbjTa"><span class="ne-text">java下载安装</span></h3><p id="uea56c2b2" class="ne-p"><span class="ne-text">需要下载1.8版本的，之前版本删掉</span></p><p id="uaf99547c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645497764451-167842e2-5328-446e-bf72-a806cd4ba938.png" width="679.1666396790091" id="u7491a2a7" class="ne-image"></p><h3 id="SbzEb"><span class="ne-text">Maven下载安装</span></h3><p id="u15abe63a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645495772713-46fcc17d-68a0-4c2a-8901-87bc114cfe59.png" width="806.6666346126145" id="ua6d1ef1a" class="ne-image"></p><p id="uc0678083" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645495819742-223ad090-3f07-4b04-95b2-e5262d74b394.png" width="822.4999673167878" id="ue1ef2b60" class="ne-image"></p><p id="u5d0ad3e5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645495723226-f5c72ffc-05cb-4b1c-99dc-cce4ec7667bf.png" width="813.3333010143717" id="u3a1d182d" class="ne-image"></p><h2 id="lcNBZ"><span class="ne-text">创建springboot应用程序</span></h2><h3 id="Gg6R5"><span class="ne-text">Maven模板快速创建项目</span></h3><p id="u93aa0b73" class="ne-p"><span class="ne-text">找到下面的选项快速创建</span></p><p id="ud8a8be20" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645496306314-3c77ca31-a9e7-4e1e-96de-4e26ff1a98c6.png" width="1364.1666124595558" id="uceef7a43" class="ne-image"></p><p id="u54ceb27a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645496453507-1473a2e0-520a-4d7a-a0b6-cb2723f22ec5.png" width="1364.1666124595558" id="u6251fbd7" class="ne-image"></p><p id="u8c6b137c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645496663531-f043939a-6d4a-4c33-90cf-99ad93d71f0d.png" width="1364.1666124595558" id="u5fe0c9bc" class="ne-image"></p><h3 id="KDIfG"><span class="ne-text">配置Maven的settings文件</span></h3><p id="ufc3930b7" class="ne-p"><span class="ne-text">关于cong文件夹中的settings.xml文件（</span><code class="ne-code"><span class="ne-text">D:\maven\conf</span></code><span class="ne-text">）：</span></p><ul class="ne-ul"><li id="u5d834c39"><span class="ne-text">maven用来构建项目</span></li><li id="ubac99ee9"><span class="ne-text">java需要外部的jar包，外网的中央仓库，下载本地仓库</span></li></ul><ul class="ne-ul"><li id="ueb522d1d"><span class="ne-text">setting.xml文件里面的盘符注意</span></li></ul><pre data-language="xml" id="P4HSP" class="ne-codeblock language-xml"><localRepository>D:/lib_repo/repository</localRepository></pre><ul class="ne-ul"><li id="u6cc8534f"><span class="ne-text">用阿里的源站下载</span></li></ul><pre data-language="xml" id="ZaRVK" class="ne-codeblock language-xml">  <mirrors><pre><code> &lt;!-- 这里使用的是阿里的远程maven镜像，目前国内大多数都使用它 --&gt; &lt;mirror&gt;     &lt;id&gt;alimaven&lt;/id&gt;    &lt;name&gt;aliyun maven&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt;</code></pre><p></mirrors></pre><h3 id="mVcaE"><span class="ne-text">添加 src/main/java 目录</span></h3><p id="u721ad001" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645498371242-a283bfdb-f00f-4c4a-8cce-548dc8f1245f.png" width="304.16665458016973" id="uUlRT" class="ne-image"></p><h3 id="VD278"><span class="ne-text">pom.xml 添加项目依赖 jar 包</span></h3><p id="uc65a0fda" class="ne-p"><span class="ne-text">打开 pom.xml 文件，改配置文件，添加依赖项，具体修改为如下：</span></p><pre data-language="xml" id="Na4lO" class="ne-codeblock language-xml"><?xml version="1.0" encoding="UTF-8"?><br><project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><br><modelVersion>4.0.0</modelVersion><br><parent><br><groupId>org.springframework.boot</groupId><br><artifactId>spring-boot-starter-parent</artifactId><br><version>2.6.2</version><br><relativePath/> <!-- lookup parent from repository --><br></parent><br><groupId>com.cn.shicun</groupId><br><artifactId>emis</artifactId><br><version>1.0-SNAPSHOT</version></p><pre><code>&lt;name&gt;emis&lt;/name&gt;&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;&lt;/build&gt;</code></pre><p></project></pre><p id="u1bdef055" class="ne-p"><span class="ne-text">点击右上角蓝色更新按钮</span></p><p id="uaa3e09a1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645757724190-8b4ba45a-8ac4-48c9-a306-b63d8936c87d.png" width="1216.666618320679" id="u0495e1bc" class="ne-image"></p><p id="ue8ab886d" class="ne-p"><span class="ne-text">然后 idea 会自动下载这些 jar 包（Maven 优势之一，就是会自动下载 jar 包）</span></p><p id="u0671e5f1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645498601439-0aa7238f-2ea2-4158-8bb8-61e355c5bb1e.png" width="1599.9999364217147" id="ud93f9cb0" class="ne-image"></p><p id="u03769508" class="ne-p"><span class="ne-text">下载成功如下所示：</span></p><p id="uf55c1abd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645498687230-217fcf65-9ed3-4888-bc04-b1b08d423a92.png" width="179.671875" id="ub991bc27" class="ne-image"></p><h2 id="YNfUv"><span class="ne-text">运行 springboot 应用程序</span></h2><h3 id="QUxg1"><span class="ne-text">测试代码</span></h3><p id="u4992ca59" class="ne-p"><span class="ne-text">如下位置写入如下代码：</span></p><p id="u22d45b72" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645511526582-4dd0440d-2caf-4137-b544-f487045eb46f.png" width="300.015625" id="u6e9df4ef" class="ne-image"></p><pre data-language="java" id="Mxeya" class="ne-codeblock language-java">package com.cn.shixun;</p><p>import org.springframework.boot.SpringApplication;<br>import org.springframework.boot.autoconfigure.SpringBootApplication;</p><p>@SpringBootApplication<br>public class App<br>{<br>public static void main( String[] args )<br>{<br>SpringApplication.run(App.class);<br>}<br>}</pre><h3 id="fzUO5"><span class="ne-text">静态资源</span></h3><p id="ufac7f9e4" class="ne-p"><span class="ne-text">然后在 resources 新建文件夹 static，在其中写入 index.html 文件，然后运行 App 代码</span></p><p id="u48dab530" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645513209905-d82808a5-87e0-4d1d-a44f-7bd84bf14e48.png" width="689.9999725818645" id="u08e7d5a8" class="ne-image"></p><p id="ubbaeef4f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645513163237-543a369b-f027-4a23-a54b-16d5396317e7.png" width="740.8333038952627" id="u649359b3" class="ne-image"></p><h3 id="R4FjW"><span class="ne-text">idea 实时刷新前端代码设置</span></h3><p id="u75569296" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645513254386-91ff5733-2ee8-4bba-a306-3e0ae0a82189.png" width="809.9999678134931" id="u857aff52" class="ne-image"></p><p id="u32ec23c5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645513246554-dda6481d-a454-497b-a90f-66700b3df752.png" width="811.6666344139323" id="u8bb3fd04" class="ne-image"></p><h2 id="b0Yyp"><span class="ne-text">前后端架构</span></h2><p id="u1dc3bbfa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645602574923-49da96c6-764f-4141-af8b-b6d8fe8bc584.png" width="840.8332999216199" id="u65920461" class="ne-image"></p><h2 id="UzUhw"><span class="ne-text">前端</span></h2><h3 id="LL54d"><span class="ne-text">jQuery 的 Ajax 的使用</span></h3><p id="u6e7b9fc3" class="ne-p"><span class="ne-text">jQuery 其他相关笔记之前已经学过，不做赘述，此文只做 Ajax 相关的笔记</span></p><p id="uf756364e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1629125564200-d6272b27-ffcf-4f6d-b7f8-f1ccc7660b0c.png" width="609.4973754882812" id="pBacN" class="ne-image"></p><pre data-language="javascript" id="OVASc" class="ne-codeblock language-javascript">// Ajax ===============================================================<br>let ajaxDemo = function(){<br>$.ajax({<br>type : "post",<br>url : "<a href="https://127.0.0.1:8080/test/demo2&quot;">https://127.0.0.1:8080/test/demo2&quot;</a>,<br>data : {<br>"name" : "李四",<br>"age" : 14<br>},<br>// dataType : "json",<br>success : function(data) {// 后端的返回值<br>alert(data);<br>}<br>});<br>}</pre><pre data-language="html" id="zCcE2" class="ne-codeblock language-html"><input type="button" value="ajax点击按钮" onclick="ajaxDemo();"></pre><p id="u0b442196" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645600461044-6f9411a0-aaf9-4f27-bc88-9d590544a9de.png" width="578.3333103524324" id="KCZBi" class="ne-image"></p><h3 id="GmKZL"><span class="ne-text">原生 JavaScript 的 Ajax 使用</span></h3><p id="ueee0275d" class="ne-p"><br></p><pre data-language="javascript" id="4irzg" class="ne-codeblock language-javascript">function ajax (options) {<br>// 默认值<br>var defaults = {<br>type: 'get',<br>url: '',<br>data: {},<br>header: {<br>'Content-Type': 'application/x-www-form-urlencoded'<br>},<br>success: function () {},<br>error: function () {}<br>}<br>// 使用用户传递的参数替换默认值参数<br>Object.assign(defaults, options);<br>// 创建 ajax 对象<br>var xhr = new XMLHttpRequest();<br>// 参数拼接变量<br>var params = '';<br>// 循环参数<br>for (var attr in defaults.data) {<br>// 参数拼接<br>params += attr + '=' + defaults.data[attr] + '&';<br>// 去掉参数中最后一个&<br>params = params.substr(0, params.length-1)<br>}<br>// 如果请求方式为 get<br>if (defaults.type == 'get') {<br>// 将参数拼接在 url 地址的后面<br>defaults.url += '?' + params;<br>}</p><pre><code>// 配置ajax请求xhr.open(defaults.type, defaults.url);// 如果请求方式为postif (defaults.type == &#39;post&#39;) &#123;    // 设置请求头    xhr.setRequestHeader(&#39;Content-Type&#39;, defaults.header[&#39;Content-Type&#39;]);    // 如果想服务器端传递的参数类型为json    if (defaults.header[&#39;Content-Type&#39;] == &#39;application/json&#39;) &#123;        // 将json对象转换为json字符串        xhr.send(JSON.stringify(defaults.data))    &#125;else &#123;        // 发送请求        xhr.send(params);    &#125;&#125; else &#123;    xhr.send();&#125;// 请求加载完成xhr.onload = function () &#123;    // 获取服务器端返回数据的类型    var contentType = xhr.getResponseHeader(&#39;content-type&#39;);    // 获取服务器端返回的响应数据    var responseText = xhr.responseText;    // 如果服务器端返回的数据是json数据类型    if (contentType.includes(&#39;application/json&#39;)) &#123;        // 将json字符串转换为json对象        responseText = JSON.parse(responseText);    &#125;    // 如果请求成功    if (xhr.status == 200) &#123;        // 调用成功回调函数, 并且将服务器端返回的结果传递给成功回调函数        defaults.success(responseText, xhr);    &#125; else &#123;        // 调用失败回调函数并且将xhr对象传递给回调函数        defaults.error(responseText, xhr);    &#125;&#125;// 当网络中断时xhr.onerror = function () &#123;    // 调用失败回调函数并且将xhr对象传递给回调函数    defaults.error(xhr);&#125;</code></pre><p>}</pre><p id="u300e0036" class="ne-p"><br></p><h3 id="N5NMf"><span class="ne-text">AdminLTE 框架</span></h3><p id="ueea8d4ed" class="ne-p"><span class="ne-text">文档：</span><a href="https://adminlte.io/" data-href="https://adminlte.io/" target="_blank" class="ne-link"><span class="ne-text">https://adminlte.io/</span></a></p><p id="ue40fc851" class="ne-p"><span class="ne-text">下载 adminlte 及其依赖放到静态文件夹</span></p><p id="uf0622b47" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645520275251-6ba0c4e2-026d-4289-8519-2a67d7d0e2af.png" width="254.015625" id="vP941" class="ne-image"></p><p id="u409ab831" class="ne-p"><span class="ne-text">使用 jsDelivr 外链来构建</span></p><p id="u833a101c" class="ne-p"><a href="https://cdn.jsdelivr.net/npm/admin-lte@3.2/dist/css/adminlte.min.css" data-href="https://cdn.jsdelivr.net/npm/admin-lte@3.2/dist/css/adminlte.min.css" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/npm/admin-lte@3.2/dist/css/adminlte.min.css</span></a></p><p id="u588423b2" class="ne-p"><a href="https://cdn.jsdelivr.net/npm/admin-lte@3.2/plugins/fontawesome-free/css/all.min.css" data-href="https://cdn.jsdelivr.net/npm/admin-lte@3.2/plugins/fontawesome-free/css/all.min.css" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/npm/admin-lte@3.2/plugins/fontawesome-free/css/all.min.css</span></a></p><h3 id="SiaT0"><span class="ne-text">构建管理类系统的静态页模板</span></h3><p id="u0a4932c1" class="ne-p"><strong><span class="ne-text">利用 AdminLTE UI 模板搭建出项目所需的目的页面（在 static 里面写出想要的各种效果）</span></strong></p><p id="u20404070" class="ne-p"><span class="ne-text">管理类系统的页面类型大概有以下几类：</span></p><ol class="ne-ol"><li id="uac303bec"><span class="ne-text">登录页（大多数的管理类系统都没有注册页，需要通过用户管理模块增加用户）。</span></li></ol><p id="u174c34cd" class="ne-p"><a href="http://127.0.0.1:8080/pages/login.html" data-href="http://127.0.0.1:8080/pages/login.html" target="_blank" class="ne-link"><span class="ne-text">http://127.0.0.1:8080/pages/login.html</span></a></p><ol start="2" class="ne-ol"><li id="u69390ba2"><span class="ne-text">欢迎页，登录成功后进入的首页。</span></li></ol><p id="ub9e1b6bd" class="ne-p"><a href="http://127.0.0.1:8080/pages/index.html" data-href="http://127.0.0.1:8080/pages/index.html" target="_blank" class="ne-link"><span class="ne-text">http://127.0.0.1:8080/pages/index.html</span></a></p><ol start="3" class="ne-ol"><li id="ufe14e726"><span class="ne-text">列表页，展示数据集合的表格，一般带分页和查询功能，展示的每行数据的最后会有可以点击的“修改”和“删除”功能。</span></li><li id="u2d115db2"><span class="ne-text">新增/修改页，一个 form 表单，同一个的功能模块的新增/修改页的表单元素是一致的，只是修改页需要回填数据。</span></li><li id="u0eda6d8e"><span class="ne-text">其他特殊页，例如在线答题页、数据统计页、文件上传页等等，这些在管理类系统中的占比很小。</span></li></ol><h2 id="KEUvQ"><span class="ne-text">后端：Springboot 学习</span></h2><p id="ufa54678d" class="ne-p"><span class="ne-text">记录一下框架的 API 使用</span></p><h3 id="lbTOb"><span class="ne-text">参考资料</span></h3><ul class="ne-ul"><li id="u92531a69"><a href="https://www.springcloud.cc/spring-boot.html" data-href="https://www.springcloud.cc/spring-boot.html" target="_blank" class="ne-link"><span class="ne-text">Spring Boot 参考指南</span></a></li><li id="ucf561286"><a href="http://c.biancheng.net/spring_boot/" data-href="http://c.biancheng.net/spring_boot/" target="_blank" class="ne-link"><span class="ne-text">Spring Boot 框架入门教程（快速学习版）</span></a></li></ul><hr id="mk2s4" class="ne-hr"><p id="udb96359f" class="ne-p"><span class="ne-text">vscode 运行 springboot 项目</span></p><ul class="ne-ul"><li id="u276e0432"><a href="https://juejin.cn/post/7036643751896285220" data-href="https://juejin.cn/post/7036643751896285220" target="_blank" class="ne-link"><span class="ne-text">demo5：如何优雅的在 vscode 里面跑 springboot 工程</span></a></li></ul><hr id="EJTKd" class="ne-hr"><p id="u5f30a343" class="ne-p"><span class="ne-text">SpringBoot 编写接口</span></p><ul class="ne-ul"><li id="u0f65099a"><a href="https://blog.csdn.net/qq_28336351/article/details/79327357" data-href="https://blog.csdn.net/qq_28336351/article/details/79327357" target="_blank" class="ne-link"><span class="ne-text">用 Spring Boot 开发 API 接口</span></a></li></ul><hr id="GKXgn" class="ne-hr"><h3 id="k4e1H"><span class="ne-text">@SpringBootApplication</span></h3><p id="u3adda718" class="ne-p"><span class="ne-text">主要方法是通过调用 run 来委托 Spring Boot 的 SpringApplication 类。</span></p><p id="u35e4e33f" class="ne-p"><span class="ne-text">SpringApplication 引导我们的应用程序，从 Spring 开始，然后启动自动配置的 Tomcat Web 服务器。</span></p><p id="u6a37736e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645749879910-2701fc28-b68f-446f-81e8-4dabe66e43e7.png" width="1599.9999364217147" id="u835cf579" class="ne-image"></p><p id="u62c67ac3" class="ne-p"><span class="ne-text">我们需要将 Example.class 作为参数传递给 run 方法，以告诉 SpringApplication 哪个是主要的 Spring 组件。</span></p><p id="u673dd8a7" class="ne-p"><span class="ne-text">还会传递 args 数组以公开任何命令行参数。</span></p><p id="u44cb04c0" class="ne-p"><span class="ne-text">springboot 的启动类是有作用范围的</span></p><h3 id="Sutl6"><span class="ne-text">@Controller</span></h3><p id="u4a604ad2" class="ne-p"><span class="ne-text">所创建的类是一个 web </span><code class="ne-code"><span class="ne-text">@Controller</span></code><span class="ne-text">，所以 Spring</span><strong><span class="ne-text">在处理传入的 Web 请求时会考虑它</span></strong><span class="ne-text">。</span></p><h3 id="I634I"><span class="ne-text">@RequestMapping(“test”)</span></h3><p id="u88beba0f" class="ne-p"><span class="ne-text">@RequestMapping 注释提供“路由”信息。它告诉 Spring 任何带有/test 路径的 HTTP 请求都应该映射到所写的 test 方法。</span></p><h3 id="ZaabW"><span class="ne-text">@responseBody</span></h3><p id="u9066e349" class="ne-p"><span class="ne-text">@responseBody 注解的作用是将 controller 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到 response 对象的 body 区，通常用来返回 JSON 数据回格式是 text/json（或者是 XML）数据，需要注意的呢，在使用此注解之后不会再走试图处理器，而是直接将数据写入到输入流中，他的效果等同于通过 response 对象输出指定格式的数据。</span></p><h3 id="hGDuj"><span class="ne-text">@RestController</span></h3><p id="ue2601dba" class="ne-p"><span class="ne-text">类上写上注解 @RestController，那么此 Controller 返回格式就都是 text/json</span></p><p id="u8566e37a" class="ne-p"><br></p><h2 id="EMKFp"><span class="ne-text">后端：数据库学习</span></h2><h3 id="wFOt8"><span class="ne-text">表关系</span></h3><p id="uee74ef3a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645751601318-ffb24061-6e8d-4c67-a6e2-666bf0acd9d1.png" width="679.9999729792288" id="u5aec88ce" class="ne-image"></p><p id="ue90a0795" class="ne-p"><span class="ne-text"></span></p><p id="uf471721e" class="ne-p"><span class="ne-text">权限控制：</span></p><p id="u1368d99a" class="ne-p"><span class="ne-text">RBAC，role based access control，基于角色的访问控制</span></p><p id="u9e7d7ac2" class="ne-p"><span class="ne-text">用户，角色，功能（项目的粒度到二级菜单即可）</span></p><p id="ue4daa310" class="ne-p"><span class="ne-text"></span></p><p id="u18d3a9c8" class="ne-p"><span class="ne-text">user，user<em>role，role，role_menu，menu<br></span><span class="ne-text">用户</em>角色组，角色则，角色组_角色</span></p><p id="u6491602a" class="ne-p"><br></p><h3 id="oXMNq"><span class="ne-text">数据表的初始化</span></h3><p id="u3d552a0f" class="ne-p"><span class="ne-text">连接本地数据库</span></p><p id="ubb96c3f1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645753130016-3d2056bc-ece0-43e8-b97a-f6ccfbc13587.png" width="306.33331298828125" id="uffe98a1a" class="ne-image"></p><p id="u49fdcae2" class="ne-p"><span class="ne-text">按照教程初始化各个数据库</span></p><p id="u16099470" class="ne-p"><span class="ne-text"></span></p><hr id="fjzNz" class="ne-hr"><p id="u647d8e29" class="ne-p"><span class="ne-text">构建实体类—如果手动构建，需要单独给每个表生成 Getter Setter，所以使用下面讲的 mybits 逆向工程构建。</span></p><h2 id="DzvDK"><span class="ne-text">MyBatis 逆向工程</span></h2><h3 id="NP9Pp"><span class="ne-text">添加数据库账户及授权</span></h3><p id="u3e6a3632" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/weixin_33400820/article/details/81976424" data-href="https://blog.csdn.net/weixin_33400820/article/details/81976424" target="_blank" class="ne-link"><span class="ne-text">navicat 创建用户以及设置权限</span></a></p><p id="u7d231e21" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645757383547-2e71e1ab-c656-4362-af9c-03055d1cdd04.png" width="415.015625" id="u067b447b" class="ne-image"></p><p id="u07d66762" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645757505559-1082ac8d-ea6e-4462-bf75-dee340fbec59.png" width="345.015625" id="u2db9f02f" class="ne-image"></p><p id="u995fe687" class="ne-p"><span class="ne-text">账号密码都是：mybatis</span></p><p id="ufdf8e3c7" class="ne-p"><span class="ne-text">创建成功后如下：</span></p><p id="u45411967" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645757562274-1c280235-ee05-4629-863f-aca7b76b5a4a.png" width="408.33331298828125" id="u4644ce1e" class="ne-image"></p><h3 id="iv1p7"><span class="ne-text">pom.xml 添加依赖</span></h3><pre data-language="xml" id="eJCfG" class="ne-codeblock language-xml"> <dependency><br><groupId>org.mybatis.spring.boot</groupId><br><artifactId>mybatis-spring-boot-starter</artifactId><br><version>2.2.1</version><br></dependency><br><dependency><br><groupId>mysql</groupId><br><artifactId>mysql-connector-java</artifactId><br><scope>runtime</scope></p><!--        1、如果你的数据库是mysql8，这段<version>5.1.32</version>不用管        2、如果你的数据库是mysql5.x，放开<version>5.1.32</version>这段注释        --><p><version>5.1.32</version><br></dependency><br><dependency><br><groupId>org.mybatis.generator</groupId><br><artifactId>mybatis-generator-core</artifactId><br><version>1.4.0</version><br></dependency></pre><h3 id="jLmYH"><span class="ne-text">编写逆向工程的配置文件 generatorConfig.xml 和 Generator.java</span></h3><p id="u28931f65" class="ne-p"><span class="ne-text">运行 Generator 类的 main 方法生成实体类、mapper 接口和 mapper 的 xml 文件</span></p><p id="ua7af06b3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645771323003-02719bd5-ad39-43c6-91f8-c9c3d58f68b5.png" width="209.6666259765625" id="u6276f1f8" class="ne-image"></p><p id="u98f8cbda" class="ne-p"><strong><span class="ne-text">每次生成逆向工程之前，要把之前生成的文件全部删除</span></strong><span class="ne-text">。</span></p><p id="ud61f556f" class="ne-p"><br></p><pre data-language="html" id="gVLha" class="ne-codeblock language-html"><dependency><br><groupId>com.alibaba</groupId><br><artifactId>fastjson</artifactId><br><version>1.2.73</version><br></dependency></pre><p id="uce896a9a" class="ne-p"><br></p><h2 id="DgwiD"><span class="ne-text">报错</span></h2><h3 id="u7wxz"><span class="ne-text">SpringBoot 启动报错 Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured</span></h3><pre data-language="java" id="B1QP3" class="ne-codeblock language-java">Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.<br>2022-02-27 20:30:12.439 ERROR 12672 --- [ main] o.s.b.d.LoggingFailureAnalysisReporter :</p><hr><p>APPLICATION FAILED TO START</p><hr><p>Description:</p><p>Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured.</p><p>Reason: Failed to determine a suitable driver class</p><p>Action:</p><p>Consider the following:<br>If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.<br>If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).</p><p>Process finished with exit code 1</pre><p id="u877d8a83" class="ne-p"><span class="ne-text">启动类添加如下：</span></p><pre data-language="java" id="hNoR7" class="ne-codeblock language-java">@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})</pre><p id="uc454574c" class="ne-p"><span class="ne-text">参考：</span><a href="https://www.panziye.com/java/1873.html" data-href="https://www.panziye.com/java/1873.html" target="_blank" class="ne-link"><span class="ne-text">https://www.panziye.com/java/1873.html</span></a></p><h3 id="CCgIJ"><span class="ne-text">Consider defining a bean of type ‘com.cn.shixun.mapper.UserMapper’ in your configuration.</span></h3><p id="u161eed12" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645965307851-1a6aeb4e-786d-453c-8f19-cf25c41156eb.png" width="788.3333020077824" id="u345021ed" class="ne-image"></p><p id="uc1c4402f" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/zzldm/article/details/116534419" data-href="https://blog.csdn.net/zzldm/article/details/116534419" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/zzldm/article/details/116534419</span></a></p><p id="ue6c6492c" class="ne-p"><span class="ne-text"></span></p><h3 id="y7JI1"><span class="ne-text">nio-8080-exec-1</span></h3><p id="u6fbfe2d8" class="ne-p"><span class="ne-text">属于正常情况</span></p><pre data-language="java" id="EIHOh" class="ne-codeblock language-java"> . _<strong>_ _ ** _ _<br>/\ / <strong><em>'</em> ** _ <em>(</em>)_ __ __ _ \ \ \ <br>( ( )_</strong> | '_ | '<em>| | '</em> / _` | \ \ \ <br> \/ _</strong>)| |<em>)| | | | | || (</em>| | ) ) ) )<br>' |_<strong>_| .</strong>|<em>| |</em>|<em>| |</em>_<em>, | / / / /<br>=========|</em>|==============|<em>__/=/</em>/<em>/</em>/<br>:: Spring Boot :: (v2.6.2)</p><p>2022-02-27 20:46:14.796 INFO 9608 — [ main] com.App : Starting App using Java 1.8.0_151 on DESKTOP-QTVR7IE with PID 9608 (D:\projects\emis\target\classes started by wztli in D:\projects\emis)<br>2022-02-27 20:46:14.799 INFO 9608 — [ main] com.App : No active profile set, falling back to default profiles: default<br>2022-02-27 20:46:16.451 INFO 9608 — [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)<br>2022-02-27 20:46:16.464 INFO 9608 — [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat]<br>2022-02-27 20:46:16.464 INFO 9608 — [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.56]<br>2022-02-27 20:46:16.582 INFO 9608 — [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext<br>2022-02-27 20:46:16.582 INFO 9608 — [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1721 ms<br>2022-02-27 20:46:16.996 INFO 9608 — [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path ‘’<br>2022-02-27 20:46:17.010 INFO 9608 — [ main] com.App : Started App in 2.708 seconds (JVM running for 3.193)<br>2022-02-27 20:46:17.075 INFO 9608 — [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring DispatcherServlet ‘dispatcherServlet’<br>2022-02-27 20:46:17.075 INFO 9608 — [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Initializing Servlet ‘dispatcherServlet’<br>2022-02-27 20:46:17.076 INFO 9608 — [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Completed initialization in 1 ms</p><p></pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket学习笔记</title>
      <link href="/blog/pp1d2p/"/>
      <url>/blog/pp1d2p/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="D4CnP"><span class="ne-text">一些链接</span></h3><ul class="ne-ul"><li id="u99cd15f2"><span class="ne-text">WebSocket在线调试：</span><a href="http://www.easyswoole.com/wstool.html" data-href="http://www.easyswoole.com/wstool.html" target="_blank" class="ne-link"><span class="ne-text">http://www.easyswoole.com/wstool.html</span></a></li><li id="u24e7cbb7"><span class="ne-text">express笔记：</span><a href="https://www.yuque.com/wztlink1013/projects/tdgoby" data-href="https://www.yuque.com/wztlink1013/projects/tdgoby" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/projects/tdgoby</span></a></li><li id="uef57eea0"><span class="ne-text">相关文档：</span><a href="http://expressjs.jser.us/" data-href="http://expressjs.jser.us/" target="_blank" class="ne-link"><span class="ne-text">http://expressjs.jser.us/</span></a></li></ul><h3 id="Iw2Vp"><span class="ne-text">mongodb和sharedb-mongo</span></h3><ul class="ne-ul"><li id="u97fcf52f"><a href="https://rain120.github.io/sharedb-zh/sharedb/sharedb" data-href="https://rain120.github.io/sharedb-zh/sharedb/sharedb" target="_blank" class="ne-link"><span class="ne-text">ShareDB中文文档</span></a></li><li id="ud175fc61"><a href="https://rain120.github.io/sharedb-zh/sharedb-mongo/sharedb-mongo" data-href="https://rain120.github.io/sharedb-zh/sharedb-mongo/sharedb-mongo" target="_blank" class="ne-link"><span class="ne-text">sharedb-mongo文档</span></a></li></ul><h3 id="nD9eJ"><span class="ne-text">WebSocket长连接概念</span></h3><p id="ud2e71363" class="ne-p"><span class="ne-text">什么是WebSocket？</span></p><p id="ub718ef9c" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u44927020"><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096" data-href="https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096" target="_blank" class="ne-link"><span class="ne-text">WebSocket 廖雪峰的官方网站</span></a></li><li id="u14123397"><a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html" data-href="https://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" class="ne-link"><span class="ne-text">WebSocket 教程 作者： 阮一峰</span></a></li></ul><p id="u4d2f3080" class="ne-p"><span class="ne-text"></span></p><p id="u753b6170" class="ne-p"><span class="ne-text">为什么需要WebSocket呢？</span></p><p id="u5e0df92f" class="ne-p"><span class="ne-text">因为网络请求，有请求响应，浏览器的请求，还需要有服务端的响应，需要时刻进行数据通信，明显上述不行，因为上述强调一个“主动”，也就是客户端如果不发送请求，服务端就不会进行响应，对协同而言明显不行，比如说，a用户修改了一个部分，这个时候就需要服务端主动将修改后的内容推送到其他客户，这样才能实现实时协同。再比如多人聊天室。</span></p><p id="u052e2fa6" class="ne-p"><span class="ne-text">所以需要一个在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。</span></p><p id="udcb34ff6" class="ne-p"><span class="ne-text"></span></p><p id="u0aab99b2" class="ne-p"><span class="ne-text">使用的时候还需要注意，只有浏览器支持WebSocket协议，才能够使用该协议，兼容的浏览器种类及版本如下：</span></p><pre data-language="plain" id="LCxak" class="ne-codeblock language-plain">Chrome<p>Firefox<br>IE &gt;= 10<br>Sarafi &gt;= 6<br>Android &gt;= 4.4<br>iOS &gt;= 8</pre><p id="u4ddd2859" class="ne-p"><span class="ne-text"></span></p><p id="u6a07008b" class="ne-p"><span class="ne-text">Node.js 中，使用最广泛的 WebSocket 模块是 ws，以下学习笔记：</span></p><h3 id="ug2x1"><span class="ne-text">Node.js 的 WebSocket 模块 ws 的使用</span></h3><p id="u7e3c0ddd" class="ne-p"><span class="ne-text">地址：</span><a href="https://github.com/websockets/ws" data-href="https://github.com/websockets/ws" target="_blank" class="ne-link"><span class="ne-text">https://github.com/websockets/ws</span></a></p><p id="ube1e9f07" class="ne-p"><span class="ne-text">下载</span></p><pre data-language="bash" id="RekVc" class="ne-codeblock language-bash">cnpm i ws --save</pre><ul class="ne-ul"><li id="uab17cfd1"><span class="ne-text">connection：</span><a href="https://github.com/websockets/ws/blob/master/doc/ws.md#event-connection" data-href="https://github.com/websockets/ws/blob/master/doc/ws.md#event-connection" target="_blank" class="ne-link"><span class="ne-text">https://github.com/websockets/ws/blob/master/doc/ws.md#event-connection</span></a></li><li id="uc72b7f0d"><span class="ne-text">addEventListener：</span><a href="https://github.com/websockets/ws/blob/master/doc/ws.md#websocketaddeventlistenertype-listener-options" data-href="https://github.com/websockets/ws/blob/master/doc/ws.md#websocketaddeventlistenertype-listener-options" target="_blank" class="ne-link"><span class="ne-text">https://github.com/websockets/ws/blob/master/doc/ws.md#websocketaddeventlistenertype-listener-options</span></a></li></ul><h3 id="g8Imx"><span class="ne-text">@teamwork/websocket-json-stream</span></h3><p id="u0e87606a" class="ne-p"><a href="https://www.npmjs.com/package/@teamwork/websocket-json-stream" data-href="https://www.npmjs.com/package/@teamwork/websocket-json-stream" target="_blank" class="ne-link"><span class="ne-text">https://www.npmjs.com/package/@teamwork/websocket-json-stream</span></a></p><p id="u62af2ec5" class="ne-p"><span class="ne-text"></span></p><p id="u4d204ccf" class="ne-p"><span class="ne-text">用于 WebSocket 连接的 nodejs 流包装器。它也适用于浏览器 WebSockets。</span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web其他知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node.js使用</title>
      <link href="/blog/gxh14f/"/>
      <url>/blog/gxh14f/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="jPu5t"><span class="ne-text">Node.js使用</span></h2><p id="ude9bec7a" class="ne-p"><span class="ne-text">Node.js环境说白了就和浏览器一样，用来运行js，node借助终端，浏览器借助展示HTML文件来展示js功能。具体运行在js文件的所在文件目录下运行 </span><code class="ne-code"><span class="ne-text">node xx.js</span></code><span class="ne-text">即可。</span></p><p id="u651d3898" class="ne-p"><span class="ne-text">不过一般全局下载nodemon三方模块，其作用是当js文件被改动，终端会再次执行该js文件，后续模块处再讲。</span></p><p id="udfde50a5" class="ne-p"><span class="ne-text"></span></p><p id="u2579aadd" class="ne-p"><span class="ne-text">模块化开发分为两种：</span></p><ol class="ne-ol"><li id="u612c8573"><span class="ne-text">前端网页使用JavaScript外链</span></li><li id="ue5f5485d"><span class="ne-text">使用nodejs加载模块化开发构建</span></li></ol><p id="ud282aa20" class="ne-p"><span class="ne-text"></span></p><p id="uafd4d725" class="ne-p"><span class="ne-text">Node.js实际上是模块化开发，由以下两方面组成：</span></p><ol class="ne-ol"><li id="u17a2121f"><span class="ne-text">ECMAScript</span></li><li id="u186314d7"><span class="ne-text">Node的模块API（又分为内置模块和三方模块）</span></li></ol><h3 id="lfQzP"><span class="ne-text">node环境的一些特性</span></h3><p id="u38e53630" class="ne-p"><span class="ne-text">异步式I/O：提高效率，防止阻塞这种情况</span></p><p id="ubb6b1657" class="ne-p"><span class="ne-text">事件式编程：注意事件循环机制</span></p><h3 id="DktHv"><span class="ne-text">node模块化及其使用</span></h3><p id="ued3f4eb0" class="ne-p"><span class="ne-text">参考之前写的文章：</span><a href="https://www.yuque.com/wztlink1013/blog/psazge#FPo3f" data-href="https://www.yuque.com/wztlink1013/blog/psazge#FPo3f" target="_blank" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/blog/psazge#FPo3f</span></a></p><h3 id="NtVpl" style="text-align: left"><span class="ne-text">process.env环境变量</span></h3><p id="u173ea7e9" class="ne-p"><span class="ne-text">nodejs的顶层对象process下的环境变量设置与使用</span></p><ul class="ne-ul"><li id="u080a734f"><span class="ne-text">参考：</span><a href="https://juejin.cn/post/6972466143445385223" data-href="https://juejin.cn/post/6972466143445385223" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6972466143445385223</span></a></li></ul><h3 id="sEPZO"><span class="ne-text">nodejs中的try...catch</span></h3><p id="u91e15a9b" class="ne-p"><span class="ne-text">写异常的捕获的时候，要时刻注意一些异步执行的代码，比如一种场景是try里面的代码是异步操作，那么再执行异步的时候，就已经执行了catch里面的报警语句了，学会查看捕获的目标代码是哪段。</span></p><p id="u74b6719d" class="ne-p"><span class="ne-text"></span></p><p id="u6f855426" class="ne-p"><span class="ne-text">具体参考：</span><a href="https://www.cnblogs.com/surfer/p/10291609.html" data-href="https://www.cnblogs.com/surfer/p/10291609.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/surfer/p/10291609.html</span></a></p><h2 id="gFFTO"><span class="ne-text">Node.js内置模块</span></h2><h3 id="XltiP"><span class="ne-text">全局对象global</span></h3><p id="07f0cf1cc1320a19ca5fd8c6bf9d1e1f" class="ne-p"><span class="ne-text">Node.js和之前学过的浏览器对象区分之就是，浏览器中全局对象是window，但是Node.js的全局对象是global（也可以不写、省略）。</span></p><p id="u7bcf8117" class="ne-p"><br></p><ul class="ne-ul"><li id="ufaa9c230"><span class="ne-text">process对象：关于进程的一个对象，也是global的属性之一，是一个和操作系统的简单接口。重点了解nextTick()函数，这个函数可以将事件循环设置一个任务，提高运行效率</span></li></ul><p id="5d524ac20f9f30a8882e3bfa05b35241" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622768098753-4f933f75-ea23-41d9-80d3-c8dd46f2e123.png" width="457" id="jU6pu" class="ne-image"></p><ul class="ne-ul"><li id="u2a3558c1"><span class="ne-text">console对象：log在控制台中输出；error输出错误信息；trace输出错误信息调用栈（就是错在什么地方）</span></li></ul><ul class="ne-ul"><li id="6ec87b332d7805f01cc811abc4c3f120"><span class="ne-text">setTimeout()     设置超时</span><strong><span class="ne-text">定时器</span></strong></li><li id="26e9a03d59b9dc4f0cc709c7e08d1a91"><span class="ne-text">clearTimeout()  清除超时时定时器</span></li><li id="018d9cf8b1048488fc71c0182cb29f2c"><span class="ne-text">setInterval()      设置间歇</span><strong><span class="ne-text">定时器</span></strong></li><li id="e854f2fbf93acc3fea5490515cac7481"><span class="ne-text">clearInterval()   清除间歇定时器</span></li></ul><h3 id="Yi0DH"><span class="ne-text">http;fs;url;querystring;path模块</span></h3><p id="u7aeed8b6" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.guowenfh.com/2016/10/15/node-http" data-href="https://blog.guowenfh.com/2016/10/15/node-http" target="_blank" class="ne-link"><span class="ne-text">https://blog.guowenfh.com/2016/10/15/node-http</span></a></p><p id="u647c3ea8" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="u2567b226"><span class="ne-text">http，原生创建web服务</span></li></ul><ul class="ne-ul"><li id="u6a740703"><span class="ne-text">url解析url，querystring处理url参数，搭配使用</span></li><li id="u6b4062f3"><span class="ne-text">fs模块用来读取文件、写入文件等</span></li><li id="u59e7e2df"><span class="ne-text">path路径操作，一般都是路径字符串拼接join，</span><code class="ne-code"><span class="ne-text">__dirname</span></code><span class="ne-text">当前目录名</span></li></ul><pre data-language="javascript" id="gsPUY" class="ne-codeblock language-javascript">/*<ul><li>@Author: wztlink1013</li><li>@Date: 2022-01-10 16:26:41</li><li>@LastEditTime: 2022-01-10 19:49:43</li><li>@Description:<br>*/<br>let http = require(‘http’)<br>let url = require(‘url’)<br>let fs = require(‘fs’)<br>let queryString = require(‘querystring’)</li></ul><p>let server = http.createServer()<br>// 读取我们当前文件所在的目录下的 html 文件夹<br>let HtmlDir = __dirname + ‘/html/‘</p><p>server.on(‘request’, function (req, res) {<br>let urlObj = url.parse(req.url)<br>console.log(‘【请求 url 信息】’, urlObj)<br>let params = queryString.parse(urlObj.query)<br>console.log(‘【url 参数】’, JSON.stringify(params))</p><p>switch (urlObj.pathname) {<br>case ‘/‘:<br>//首页<br>sendData(HtmlDir + ‘index.html’, req, res)<br>break<br>case ‘/user’:<br>//用户首页<br>sendData(HtmlDir + ‘user.html’, req, res)<br>break<br>default:<br>//处理其他情况<br>sendData(HtmlDir + ‘err.html’, req, res)<br>break<br>}<br>})</p><p>/**</p><ul><li>读取 html 文件，响应数据，发送给浏览器</li><li>@param {String} file 文件路径</li><li>@param {Object} req request</li><li>@param {Object} res response 对象<br>*/<br>function sendData(file, req, res) {<br>fs.readFile(file, function (err, data) {<br>if (err) {<br>res.writeHead(404, {<br>‘content-type’: ‘text/html;charset=utf-8’,<br>})<br>res.end(‘<h1>你要找的页面不见了～</h1>‘)<br>} else {<br>res.writeHead(200, {<br>‘content-type’: ‘text/html;charset=utf-8’,<br>})<br>res.end(data)<br>}<br>})<br>}<br>server.listen(8888)<br>console.log(‘Server is running at <a href="http://127.0.0.1:8888/&#39;">http://127.0.0.1:8888/&#39;</a>)</pre><h3 id="oG39o"><span class="ne-text">util+chalk 美化</span></h3><ul class="ne-tl"><li id="7896925bf1161e320ccb9b5a02f94749"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">util.inherits</span></li></ul><p id="52f3596b6ec4580aab2aa8e6b0170d3f" class="ne-p"><span class="ne-text">不过感觉这个已经没有多大必要了，这个是实现原型间继承的相关封装，但是现在 ES6 已经有了 class 的概念了（虽然底层还是之前那套），这个工具用的不多</span></p><ul class="ne-tl"><li id="4614b24cd9ec95c3548092d2af20ed75"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">util.inspect</span></li></ul><p id="3f8573b6edf04047f6d8ac2a9afe0d76" class="ne-p"><span class="ne-text">目的就是将对象转换为字符串，比如将错误信息更加美观的展示在控制台，就可以自定义，但是可以直接用 chalk 模块在实现这个美化控制台输出的工作。</span></p><pre data-language="javascript" id="hINlv" class="ne-codeblock language-javascript">'use strict';</li></ul><p>const chalk = require(‘chalk’);</p><p>module.exports = {<br>info(…args) {<br>const prefix = chalk.green(‘[INFO]’);<br>args.unshift(prefix);<br>console.log.apply(console, args);<br>},<br>warn(…args) {<br>const prefix = chalk.yellow(‘[WARNING]’);<br>args.unshift(prefix);<br>console.log.apply(console, args);<br>},<br>error(…args) {<br>const prefix = chalk.red(‘[ERROR]’);<br>args.unshift(prefix);<br>console.log.apply(console, args);<br>},<br>};</pre><pre data-language="javascript" id="P5fPv" class="ne-codeblock language-javascript">out.info(<code>Current yuque-hexo-lyrics version is $&#123;chalk.yellow(pkg.version)&#125;, and the latest version is $&#123;chalk.green(update.latest)&#125;. Please update!</code>);<br>out.info('View more detail: <a href="https://github.com/wztlink1013/yuque-hexo-lyrics#changelog&#39;">https://github.com/wztlink1013/yuque-hexo-lyrics#changelog&#39;</a>);</pre><h2 id="WVWdM"><span class="ne-text">Node.js 三方模块</span></h2><p id="ub7b7e0ff" class="ne-p"><span class="ne-text">第三方模块的两种存在形式：</span></p><ol class="ne-ol"><li id="uea902046"><span class="ne-text">以 js 文件的形式存在，提供实现项目具体功能的 API 接口。</span></li></ol><p id="u42057a3d" class="ne-p"><span class="ne-text">比如使用 jQuery，html 中引入 CDN 超链接即可使用。</span></p><ol start="2" class="ne-ol"><li id="ued707d01"><span class="ne-text">以命令行工具形式存在，辅助项目开发。</span></li></ol><p id="u7246d05b" class="ne-p"><span class="ne-text">比如 VUE-CLI 工具。</span></p><div class="ne-quote"><p id="u9fdfbea6" class="ne-p"><span class="ne-text">npm 是用来管理模块的一个 node 工具，它会伴随着 node 的下载而一同下载。</span></p></div><p id="ufbcd196a" class="ne-p"><br></p><p id="u886c8835" class="ne-p"><span class="ne-text">node 生态的繁荣多益于很多优秀的三方模块的存在，具体可以查看 </span><a href="https://nodersurvey.github.io/reporters/index.html" data-href="https://nodersurvey.github.io/reporters/index.html" target="_blank" class="ne-link"><span class="ne-text">NoderSurvey 2021 年度报告</span></a><span class="ne-text"> 的相关统计与调研。在此记录一下在学习以及实际开发过程中自己所学习到的三方模块，特别地，express 三方模块是一个 web 应用框架，需要学习的点较多，单独拿出来详细学习。</span></p><h3 id="svJmx"><span class="ne-text">cnpm+淘宝镜像</span></h3><p id="u527ed771" class="ne-p"><span class="ne-text">因为 npm 是处于国外的服务器，下载模块有时候可能会较慢，特别是文件比较多的模块。以下是临时使用淘宝镜像下载的命令。</span></p><pre data-language="bash" id="dzpS3" class="ne-codeblock language-bash">npm --registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> install</pre><p id="u73b4aa0d" class="ne-p"><span class="ne-text">如果不想改变 npm 源，也可以直接使用 cnpm（推荐）</span></p><pre data-language="bash" id="fFh1Y" class="ne-codeblock language-bash">// 安装 cnpm 命令,不会改变 npm 的源<br>npm install -g cnpm --registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p><p>//使用<br>cnpm install</p><p>//查看源，可以看到设置过的所有的源<br>npm config get registry</pre><ul class="ne-ul"><li id="u78c7f576"><span class="ne-text">参考：</span><a href="https://www.cnblogs.com/sese/p/9297028.html" data-href="https://www.cnblogs.com/sese/p/9297028.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/sese/p/9297028.html</span></a></li></ul><h3 id="ezaPQ"><span class="ne-text">nodemon 模块</span></h3><pre data-language="bash" id="wqKcP" class="ne-codeblock language-bash">cnpm install nodemon –g</pre><p id="77b64508eb62a74429490cc85bb3d580" class="ne-p"><span class="ne-text">作用：在开发过程中，修改了文件，控制台命令行就会根据文件的修改自动运行</span></p><p id="d7ebe048620778843516822109d90a9e" class="ne-p"><span class="ne-text">使用方法：将运行命令中的 node 换成 nodemon</span></p><h3 id="TqQTy"><span class="ne-text">gulp 模块</span></h3><p id="1ac1057d577258f93e05b60382bfbee0" class="ne-p"><span class="ne-text">基于 node 平台开发的前端构建工具，将机械化操作编写成任务，想要执行机械化操作时执行一个命令行命令任务就能自动执行了，用机器代替手工，提高开发效率。</span></p><p id="ude5bb27b" class="ne-p"><span class="ne-text">具体的还有 webpack，后续继续学习。</span></p><p id="9710a896a46943e194f42cee882559a2" class="ne-p"><br></p><p id="5ce68255f05a334bfc100c5fc86e9095" class="ne-p"><span class="ne-text">作用：</span></p><ul class="ne-ul"><li id="b8c516f632c3ccb2822f0eade960b320"><span class="ne-text">项目上线，HTML、CSS、JS 文件压缩合并</span></li><li id="6729897eaa4fff1e51427e6ab63ebe1a"><span class="ne-text">语法转换（es6、less …）</span></li><li id="ce83ec1bfaf4a135a60a2037cb367500"><span class="ne-text">公共文件抽离</span></li><li id="8eb5fa1547b0b864f5385548a15c90f2"><span class="ne-text">修改文件浏览器自动刷新</span></li></ul><p id="058615d0670c54f7b034065dfebd2c95" class="ne-p"><br></p><p id="2227bf834848ccf297622d3c5527848c" class="ne-p"><span class="ne-text">glup 本身提供的 api 函数很少，官网到目前更新只有下面几个，具体使用方法，使用的时候去查</span></p><ul class="ne-ul"><li id="53491b21545dab643185de554b201e55"><a href="https://github.com/gulpjs/gulp" data-href="https://github.com/gulpjs/gulp" target="_blank" class="ne-link"><span class="ne-text">https://github.com/gulpjs/gulp</span></a></li><li id="dd1aff95a8401b1918ac05a8549b6a9a"><a href="https://gulpjs.com/docs/en/getting-started/quick-start" data-href="https://gulpjs.com/docs/en/getting-started/quick-start" target="_blank" class="ne-link"><span class="ne-text">https://gulpjs.com/docs/en/getting-started/quick-start</span></a><span class="ne-text"></span></li></ul><p id="1c646168bbaefd2634c677af0e29a0ba" class="ne-p"><br></p><p id="7a8349872f1c8ff64f06aacdd754bbab" class="ne-p"><span class="ne-text">gulp 生态也有很多插件，根据插件下载相应需要的功能插件</span></p><ul class="ne-ul"><li id="2b6d96e782679dd6a14e43de42a2efe2"><span class="ne-text">gulp-htmlmin ：html 文件压缩</span></li><li id="2fb6cabb8d39f31b4ec63f466092027f"><span class="ne-text">gulp-csso ：压缩 css</span></li><li id="2590af36e2d20fc8af4017d8c8423ed8"><span class="ne-text">gulp-babel ：JavaScript 语法转化</span></li><li id="75ace6bedd13bf4569184a59c9a86e72"><span class="ne-text">gulp-less: less 语法转化</span></li><li id="37aa37302d2cda9ca969b28e81fcbbed"><span class="ne-text">gulp-uglify ：压缩混淆 JavaScript</span></li><li id="44d0eb8f741da42560a8e881421cf825"><span class="ne-text">gulp-file-include 公共文件包含</span></li><li id="11764dcc7c9f1857a65577cb328be98b"><span class="ne-text">browsersync 浏览器实时同步</span></li></ul><h3 id="xZVvy"><span class="ne-text">ws 模块</span></h3><p id="u89f1b846" class="ne-p"><span class="ne-text">ws（</span><a href="https://github.com/websockets/ws" data-href="https://github.com/websockets/ws" target="_blank" class="ne-link"><span class="ne-text">GitHub 地址</span></a><span class="ne-text">）是 Node.js 的 npm 实现，以便在项目中使用。</span></p><p id="u43f70903" class="ne-p"><span class="ne-text"></span></p><p id="u240583f3" class="ne-p"><span class="ne-text">什么是 WebSocket？</span></p><p id="u9fc6f3a0" class="ne-p"><span class="ne-text">WebSocket 是一个长连接，客户端可以给服务端发送消息，服务端也可以给客户端发送消息，两者频繁的发送消息，全双工通信模式。</span></p><p id="u448539b7" class="ne-p"><span class="ne-text"></span></p><p id="uf12bb042" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/LiMubai_CN/article/details/81844156" data-href="https://blog.csdn.net/LiMubai_CN/article/details/81844156" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/LiMubai_CN/article/details/81844156</span></a></p><h3 id="m5eli"><span class="ne-text">cross-env 模块</span></h3><p id="u9e9a3659" class="ne-p"><span class="ne-text">windows 不支持 NODE_ENV=development 的设置方式</span></p><p id="u447e7abf" class="ne-p"><span class="ne-text">所以使用该模块来进行跨平台地使用环境变量，兼容各平台使用</span></p><h3 id="lbsH2"><span class="ne-text">sharedb 模块</span></h3><p id="u936c3000" class="ne-p"><span class="ne-text">ShareDB 是一个整合了前后端的 OT 框架，可以很方便地自行搭建服务端和客户端。框架基于 Node.JS 实现。</span></p><p id="uda193c76" class="ne-p"><br></p><div class="ne-quote"><p id="u3f3ccd7e" class="ne-p"><span class="ne-text">OT（Operational transformation）是一种支持高级协作软件系统中的一系列协作功能的技术。OT 最初是为了在纯文本文档的协作编辑中实现一致性维护和并发控制而发明的。它的功能已得到扩展，其应用程序已扩展至包括组撤消、锁定、冲突解决、操作通知和压缩、组感知、HTML/XML 和树状结构文档编辑、协作办公生产力工具、应用程序共享和协作计算机- 辅助媒体设计工具。[1] 2009 年，OT 被采用为 Apache Wave 协作功能背后的核心技术和谷歌文档。</span></p></div><p id="u1c9fe8ff" class="ne-p"><span class="ne-text"></span></p><h3 id="mjgBJ"><span class="ne-text">sharedb-mongo 模块</span></h3><h3 id="g4QEg"><span class="ne-text">uuid 模块</span></h3><p id="uda44248d" class="ne-p"><span class="ne-text">生成唯一的一个字符串</span></p><ul class="ne-ul"><li id="u017203c1"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">v3：基于名字的 用相同的名字，会生成相同的 uuid 出来</span></li></ul><p id="ud4e0d654" class="ne-p"><a href="https://juejin.cn/post/6844903708799533064" data-href="https://juejin.cn/post/6844903708799533064" target="_blank" class="ne-link"><span class="ne-text">npm 的 node-uuid 和 uuid</span></a></p><ul class="ne-ul"><li id="u73a40e55"><span class="ne-text">官网配置教程：</span><a href="https://editor.aomao.com/zh-CN/config/ot#%E5%8D%8F%E5%90%8C%E6%95%B0%E6%8D%AE" data-href="https://editor.aomao.com/zh-CN/config/ot#%E5%8D%8F%E5%90%8C%E6%95%B0%E6%8D%AE" target="_blank" class="ne-link"><span class="ne-text">https://editor.aomao.com/zh-CN/config/ot</span></a></li><li id="u2be25db8"><span class="ne-text">运行方式：将</span><code class="ne-code"><span class="ne-text">ot-server</span></code><span class="ne-text">文件夹复制到项目根目录，将其处于运行状态，然后再运行主项目（localhost 实质上就是指向 127.0.0.1 这个本地 IP 地址。）</span></li></ul><h3 id="sHnMR"><span class="ne-text">使用 nanoid 模块生成随机路径</span></h3><p id="u2972908b" class="ne-p"><span class="ne-text">因为 uuid 生成的字符串太长，不便于作为 url 路径使用，所以使用 nanoid 来作为随机 url 路径</span></p><ul class="ne-ul"><li id="ueb682cd3"><a href="https://www.npmjs.com/package/nanoid" data-href="https://www.npmjs.com/package/nanoid" target="_blank" class="ne-link"><span class="ne-text">https://www.npmjs.com/package/nanoid</span></a></li><li id="u5b5164c2"><a href="https://github.com/ai/nanoid/blob/HEAD/README.zh-CN.md" data-href="https://github.com/ai/nanoid/blob/HEAD/README.zh-CN.md" target="_blank" class="ne-link"><span class="ne-text">https://github.com/ai/nanoid/blob/HEAD/README.zh-CN.md</span></a></li></ul><h2 id="Hbxw1"><span class="ne-text">Node.js 异步的解决策略</span></h2><p id="u5df15c0c" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u1856099b"><a href="https://segmentfault.com/a/1190000019418510" data-href="https://segmentfault.com/a/1190000019418510" target="_blank" class="ne-link"><span class="ne-text">Node.js 异步处理的各种写法</span></a></li></ul><p id="u706e8227" class="ne-p"><br></p><ul class="ne-ul"><li id="u1b38d376"><span class="ne-text">传统的解决方案：async await 等</span></li><li id="u4bc51a10"><span class="ne-text">嵌套使用</span></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Commit 的优化</title>
      <link href="/blog/dvkqhm/"/>
      <url>/blog/dvkqhm/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u03591007" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640570522971-b4d4a696-55c0-496b-a81d-deeb3e83a111.png" width="900" id="u4339158d" class="ne-image"></p><p id="u2d28a016" class="ne-p"><span class="ne-text"></span></p><p id="ubbfe2e60" class="ne-p"><span class="ne-text">前言：在使用git提交代码过程中，git commit的规范常不被大多数人注意，然而版本管理工具中，代码的提交规范对项目的后续维护有着很重要的作用。故本文从以下几个方面展开述说工程开发中git commit优化的几个工具：</span></p><ul class="ne-ul"><li id="ucc09ec77"><span class="ne-text">commitizen：简单的 commit 规范</span></li><li id="ufbab311b"><span class="ne-text">cz-conventional-changelog：执行会将项目npm发布新版本，并自动生成CHANGELOG.md文件</span></li></ul><ul class="ne-ul"><li id="u82705670"><span class="ne-text">commitlint：格式校验工具</span></li><li id="u419914ec"><span class="ne-text">husky：Git的钩子，在此作用为代码的提交规范和规范的校验</span></li></ul><ul class="ne-ul"><li id="u1fd40f0a"><span class="ne-text">standard-version：辅助 cz-conventional-changelog 打 version 等功能</span></li></ul><h3 id="Ttl7l"><span class="ne-text">commitizen和cz-conventional-changelog</span></h3><p id="u6c3b2139" class="ne-p"><span class="ne-text">下载cz-conventional-changelog commitizen</span></p><pre data-language="bash" id="lpbeV" class="ne-codeblock language-bash">cnpm i -D commitizen cz-conventional-changelog</pre><p id="u65da1f08" class="ne-p"><span class="ne-text">package.json添加配置信息</span></p><pre data-language="json" id="EWjvg" class="ne-codeblock language-json">"scripts": {<p>…,<br>“commit”: “git status &amp;&amp; git add . &amp;&amp; git-cz”,<br>},<br>,<br>“config”: {<br>“commitizen”: {<br>“path”: “node_modules/cz-conventional-changelog”<br>}<br>}</pre><p id="u37926c96" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640510064091-ff75df38-e750-452f-8a16-6e6930f8505b.png" width="470.5" id="ua1b3c4e2" class="ne-image"></p><p id="u6b5ae494" class="ne-p"><span class="ne-text">成功提交之后</span></p><p id="u44e5300c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640510234956-c68282df-e059-4a8b-b118-0932250a7420.png" width="587" id="ue703c449" class="ne-image"></p><p id="uf283b9bd" class="ne-p"><br></p><h3 id="Ag1Il"><span class="ne-text">Commitlint 及 husky</span></h3><pre data-language="bash" id="I91lf" class="ne-codeblock language-bash">cnpm i -D husky @commitlint/config-conventional @commitlint/cli</pre><p id="u14464e93" class="ne-p"><span class="ne-text">项目根目录新建 commitlint.config.js</span></p><pre data-language="javascript" id="BKunN" class="ne-codeblock language-javascript">module.exports = { extends: ['@commitlint/config-conventional']}</pre><p id="u0d788f8b" class="ne-p"><span class="ne-text">package.json 添加如下</span></p><pre data-language="json" id="SW0Pa" class="ne-codeblock language-json"># package.json</p><p>…,<br>“husky”: {<br>“hooks”: {<br>“commit-msg”: “commitlint -E $HUSKY_GIT_PARAMS” }<br>}</p><p></pre><p id="u2563d439" class="ne-p"><span class="ne-text">执行命令 npm run commit</span></p><pre data-language="plain" id="dxbYZ" class="ne-codeblock language-plain">1.Select the type of change that you're committing 选择改动类型 (<type>)</p><p>2.What is the scope of this change (e.g. component or file name)? 填写改动范围 (<scope>)</p><p>3.Write a short, imperative tense description of the change: 写一个精简的描述 (<subject>)</p><p>4.Provide a longer description of the change: (press enter to skip) 对于改动写一段长描述 (<body>)</p><p>5.Are there any breaking changes? (y/n) 是破坏性修改吗？默认 n (<footer>)</p><p>6.Does this change affect any openreve issues? (y/n) 改动修复了哪个问题？默认 n (<footer>)</pre><p id="u24586855" class="ne-p"><span class="ne-text">生成如下格式</span></p><pre data-language="plain" id="cQNro" class="ne-codeblock language-plain"><type>(<scope>): <subject><br><BLANK LINE></p><body><BLANK LINE><footer></pre><p id="uad666844" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640515038577-11c2fbe0-0e7e-4ec4-8836-2c49553151c0.png" width="241.5" id="ub44884a1" class="ne-image"></p><p id="u915a5ef0" class="ne-p"><span class="ne-text">其中各自含义为</span></p><ul class="ne-ul"><li id="u6aada6e4"><span class="ne-text">scope 指 commit 的范围（哪些模块进行了修改）</span></li><li id="u54a150bc"><span class="ne-text">subject 指 commit 的简短描述</span></li></ul><ul class="ne-ul"><li id="u290da520"><span class="ne-text">body 指 commit 主体内容（长描述）</span></li><li id="u6a10d0a9"><span class="ne-text">footer 指 commit footer 信息</span></li></ul><ul class="ne-ul"><li id="ue4e2d962"><span class="ne-text">type 指当前 commit 类型，一般有下面几种可选类型：</span></li></ul><p id="u7e7f121a" class="ne-p"><br></p><pre data-language="plain" id="c25Cc" class="ne-codeblock language-plain"># 主要typefeat:     增加新功能fix:      修复bug<h1 id="特殊-type"><a href="#特殊-type" class="headerlink" title="特殊 type"></a>特殊 type</h1><p>docs: 只改动了文档相关的内容<br>style: 不影响代码含义的改动，例如去掉空格、改变缩进、增删分号<br>build: 构造工具的或者外部依赖的改动，例如 webpack，npm<br>refactor: 代码重构时使用<br>revert: 执行 git revert 打印的 message</p><h1 id="暂不使用-type"><a href="#暂不使用-type" class="headerlink" title="暂不使用 type"></a>暂不使用 type</h1><p>test: 添加测试或者修改现有测试<br>perf: 提高性能的改动<br>ci: 与 CI（持续集成服务）有关的改动<br>chore: 不修改 src 或者 test 的其余修改，例如构建过程或辅助工具的变动</pre><h3 id="yQnaq"><span class="ne-text">standard-version: 自动生成 CHANGELOG</span></h3><p id="u109f02e4" class="ne-p"><span class="ne-text">下载插件</span></p><pre data-language="bash" id="hsUqT" class="ne-codeblock language-bash">cnpm i --save-dev standard-version</pre><p id="u9bbba48e" class="ne-p"><span class="ne-text">package.json 添加如下</span></p><pre data-language="json" id="E390b" class="ne-codeblock language-json">{<br>"scripts": {<br>"release": "standard-version"<br>}<br>}</pre><p id="u453f6cbd" class="ne-p"><span class="ne-text">执行 npm run release，在根目录会生成 CHANGELOG.md 文件</span></p><p id="u9255ba0b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640515612285-57b296de-7def-4ef9-b022-286ac9ef1ac2.png" width="554.5" id="u715cd9c7" class="ne-image"></p><h3 id="zi86S"><span class="ne-text">总 package.json</span></h3><pre data-language="json" id="YlQL0" class="ne-codeblock language-json">{<br>"name": "web-learn-notes",<br>"version": "1.1.0",<br>"description": "web 学习笔记仓库",<br>"main": "index.js",<br>"scripts": {<br>"commit": "git status && git add . && git-cz",<br>"release": "standard-version",<br>"test": "echo &quot;Error: no test specified&quot; && exit 1"<br>},<br>"repository": {<br>"type": "git",<br>"url": "git+<a href="https://github.com/wztlink1013/web-learn-notes.git&quot;">https://github.com/wztlink1013/web-learn-notes.git&quot;</a><br>},<br>"keywords": [<br>"web",<br>"学习",<br>"笔记"<br>],<br>"author": "wztlink1013",<br>"license": "ISC",<br>"bugs": {<br>"url": "<a href="https://github.com/wztlink1013/web-learn-notes/issues&quot;">https://github.com/wztlink1013/web-learn-notes/issues&quot;</a><br>},<br>"homepage": "<a href="https://github.com/wztlink1013/web-learn-notes#readme&quot;">https://github.com/wztlink1013/web-learn-notes#readme&quot;</a>,<br>"devDependencies": {<br>"@commitlint/cli": "^16.0.0",<br>"@commitlint/config-conventional": "^16.0.0",<br>"commitizen": "^4.2.4",<br>"cz-conventional-changelog": "^3.3.0",<br>"husky": "^7.0.4",<br>"standard-version": "^9.3.2"<br>},<br>"config": {<br>"commitizen": {<br>"path": "node_modules/cz-conventional-changelog"<br>}<br>},<br>"husky": {<br>"hooks": {<br>"commit-msg": "commitlint -E $HUSKY_GIT_PARAMS"<br>}<br>}<br>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-CLI搭建Vue3.x+TypeScript项目</title>
      <link href="/blog/blhxct/"/>
      <url>/blog/blhxct/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u30ed37f0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640572147933-73df2b83-c74d-4391-a90c-c8006aba471e.png" width="900" id="u1d7f2957" class="ne-image"></p><p id="u19218eee" class="ne-p"><span class="ne-text"></span></p><p id="u661f3c9b" class="ne-p"><span class="ne-text">前言：前端工程化开发总结，使用Vue-CLI脚手架搭建Vue3.x + Typescript项目，整体项目的环境配置。</span></p><p id="uebe97bf6" class="ne-p"><br></p><h2 id="RxoB1"><span class="ne-text">下载安装Vue-CLI</span></h2><ul class="ne-ul"><li id="ucd9aee0e"><span class="ne-text">官方文档：</span><a href="https://cli.vuejs.org/zh/guide/" data-href="https://cli.vuejs.org/zh/guide/" target="_blank" class="ne-link"><span class="ne-text">Vue CLI 🛠️ Vue.js 开发的标准工具</span></a></li></ul><pre data-language="bash" id="setxM" class="ne-codeblock language-bash">npm install -g @vue/cli<h1 id="or"><a href="#or" class="headerlink" title="or"></a>or</h1><p>yarn global add @vue/cli</p><h1 id="or-1"><a href="#or-1" class="headerlink" title="or"></a>or</h1><p>cnpm install -g @vue/cli</pre><p id="uab298ae3" class="ne-p"><span class="ne-text">查看版本：</span><code class="ne-code"><span class="ne-text">vue --version</span></code></p><p id="ufc4cf0bc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640413980237-9582e32f-7515-40b8-80a7-f678456ac739.png" width="188.5" id="ua167aa8d" class="ne-image"></p><h2 id="CV67S"><span class="ne-text">创建项目</span></h2><p id="u343d2c0c" class="ne-p"><span class="ne-text">新建并初始化项目文件夹</span></p><pre data-language="bash" id="MeN8s" class="ne-codeblock language-bash">vue create vue3-cli-demo</pre><p id="uc0b5b0b6" class="ne-p"><span class="ne-text">选择最后一项自定义相关配置</span></p><p id="uf40af224" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640414187756-6ebbf844-853d-4a66-b0d6-f401003c1fe8.png" width="234.5" id="ub11023b3" class="ne-image"></p><p id="u9158133b" class="ne-p"><span class="ne-text">全配置搭建测试</span></p><p id="ub5de8728" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640414751376-5215b4c4-3e85-4be2-9ce8-6e304bd5b70f.png" width="403.5" id="ud9b0ef21" class="ne-image"></p><h2 id="ftrVD"><span class="ne-text">vue.config.js</span></h2><p id="u7f1cc1f4" class="ne-p"><span class="ne-text">Vue 项目的配置文件（详查：</span><a href="https://cli.vuejs.org/zh/config/#vue-config-js" data-href="https://cli.vuejs.org/zh/config/#vue-config-js" target="_blank" class="ne-link"><span class="ne-text">https://cli.vuejs.org/zh/config/#vue-config-js</span></a><span class="ne-text">）</span></p><pre data-language="javascript" id="O7WJD" class="ne-codeblock language-javascript">module.exports = {<br>// 打包的目录<br>outputDir: 'dist',<br>// 在保存时校验格式<br>lintOnSave: true,<br>// 生产环境是否生成 SourceMap<br>productionSourceMap: false,<br>devServer: {<br>// 启动服务后是否打开浏览器<br>open: true,<br>// 错误信息展示到页面<br>overlay: {<br>warnings: true,<br>errors: true<br>},<br>host: '0.0.0.0',<br>port: 8066, // 服务端口<br>https: false,<br>hotOnly: false,<br>// proxy: { // 设置代理<br>// '/api': {<br>// target: host,<br>// changeOrigin: true,<br>// pathRewrite: {<br>// '/api': '/',<br>// }<br>// },<br>// },<br>},<br>}</pre><h2 id="iilBk"><span class="ne-text">[单元测试]Jest</span></h2><h3 id="esZbn"><span class="ne-text">Vue3.x+TypeScript 项目下的 jest 单元测试</span></h3><p id="ue1eeafde" class="ne-p"><span class="ne-text">官网 API：</span><a href="https://next.vue-test-utils.vuejs.org/api/" data-href="https://next.vue-test-utils.vuejs.org/api/" target="_blank" class="ne-link"><span class="ne-text">https://next.vue-test-utils.vuejs.org/api/</span></a></p><h4 id="ZD3XX"><span class="ne-text">jest.config.js</span></h4><p id="u4b92032a" class="ne-p"><span class="ne-text">项目搭建成功之后的默认配置如下：</span></p><pre data-language="javascript" id="efKL5" class="ne-codeblock language-javascript">module.exports = {<br>preset: '@vue/cli-plugin-unit-jest/presets/typescript-and-babel',<br>transform: {<br>'^.+\.vue$': 'vue-jest',<br>},<br>}</pre><p id="u53eadf7c" class="ne-p"><span class="ne-text">更改如下配置</span></p><pre data-language="javascript" id="MPDTO" class="ne-codeblock language-javascript">/*</p><ul><li>@Author: wztlink1013</li><li>@Date: 2021-12-25 14:49:37</li><li>@LastEditTime: 2021-12-26 14:56:39</li><li>@Description:<br><em>/<br>module.exports = {<br>preset: ‘@vue/cli-plugin-unit-jest/presets/typescript-and-babel’,<br>// 测试的文件类型<br>moduleFileExtensions: [‘js’, ‘jsx’, ‘json’, ‘vue’, ‘ts’, ‘tsx’],<br>// 转化方式<br>transform: {<br>‘^.+\.vue$’: ‘<rootDir>/node_modules/vue-jest’,<br>  ‘.+\.(css|styl|less|sass|scss|svg|png|jpg|ttf|woff|woff2)$’:<br>‘<rootDir>/node_modules/jest-transform-stub’,<br>‘^.+\.jsx?$’: ‘<rootDir>/node_modules/babel-jest’,<br>  ‘^.+\.tsx?$’: ‘<rootDir>/node_modules/ts-jest’,<br>},<br>// 不进行匹配的目录<br>transformIgnorePatterns: [‘<rootDir>/node_modules/‘],<br>// 匹配哪些文件进行测试<br>testMatch: [‘<strong>/tests/unit/</strong>/</em>.spec.[jt]s?(x)’, ‘*<em>/<strong>tests</strong>/</em>.[jt]s?(x)’],<br>// @符号 表示当前项目下的 src<br>moduleNameMapper: {<br>‘^@/(.<em>)$’: ‘<rootDir>/src/$1’,<br>},<br>// 将保存的快照测试结果进行序列化，使得其更美观<br>snapshotSerializers: [‘jest-serializer-vue’],<br>}</pre><h4 id="DMmo5"><span class="ne-text">单个文件的单元测试</span></h4><p id="u084e8f38" class="ne-p"><span class="ne-text">项目下运行单元测试命令 </span><code class="ne-code"><span class="ne-text">test:unit</span></code><span class="ne-text"> 默认测试所有测试文件，不能指定文件进行单元测试。</span></p><p id="u05bd7eb5" class="ne-p"><span class="ne-text"></span></p><p id="u2602c250" class="ne-p"><span class="ne-text">在本地下载全局 jest 然后指定命令去执行项目的单个文件单个测试</span></p><pre data-language="bash" id="dteZZ" class="ne-codeblock language-bash">cnpm install jest --global</pre><p id="uc0dae2b7" class="ne-p"><span class="ne-text">然后执行</span></p><pre data-language="bash" id="mFlcY" class="ne-codeblock language-bash">jest ./tests/unit/jestTest.spec.ts</pre><p id="u914c5b2e" class="ne-p"><span class="ne-text">或</span></p><pre data-language="plain" id="o5ihB" class="ne-codeblock language-plain">npx jest ./tests/unit/jestTest.spec.ts</pre><p id="u8f69b25c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640502745377-c5d57f26-13d6-4701-b7fd-aa1fb0b4312f.png" width="297.5" id="u261c3a42" class="ne-image"></p><h3 id="J5fSq"><span class="ne-text">空白项目下的 jest 单元测试</span></h3><h4 id="H1tup"><span class="ne-text">初始化 npm 插件项目</span></h4><pre data-language="bash" id="Ew0Kw" class="ne-codeblock language-bash">npm init -y</pre><h4 id="N2udI"><span class="ne-text">下载 Jest 和 babel 依赖</span></h4><pre data-language="bash" id="SIGRK" class="ne-codeblock language-bash">cnpm i @babel/core @babel/preset-env <a href="mailto:&#106;&#101;&#115;&#116;&#64;&#x32;&#x34;&#x2e;&#56;&#46;&#48;">&#106;&#101;&#115;&#116;&#64;&#x32;&#x34;&#x2e;&#56;&#46;&#48;</a> -D</pre><h4 id="hMIFh"><span class="ne-text">创建测试文件</span></h4><p id="u09ce622a" class="ne-p"><span class="ne-text">创建测试框架用的文件 index.js 和 index.test.js 两个文件</span></p><p id="ua1d89b6c" class="ne-p"><code class="ne-code"><span class="ne-text">index.js</span></code></p><pre data-language="javascript" id="ozJKD" class="ne-codeblock language-javascript">/</em></li><li>@Descripttion:</li><li>@Date: 2021-12-07 20:08:15</li><li>@LastEditTime: 2021-12-07 20:08:16<br>*/<br>export const add = (a, b) =&gt; {<br>return a + b;<br>};</li></ul><p>export const reduce = (a, b) =&gt; {<br>return a - b;<br>};</pre><p id="ud972a05a" class="ne-p"><code class="ne-code"><span class="ne-text">index.test.js</span></code></p><pre data-language="javascript" id="cgjLz" class="ne-codeblock language-javascript">/*</p><ul><li>@Descripttion:</li><li>@Date: 2021-12-07 20:08:31</li><li>@LastEditTime: 2021-12-07 20:45:17<br>*/<br>import { add, reduce } from “./index”</li></ul><p>// toBe 数字<br>test(“测试 add 函数”, () =&gt; {<br>expect(add(1, 2)).toBe(3)<br>})<br>test(“测试 add 函数（函数功能出错===打印）”, () =&gt; {<br>expect(add(1, 2)).toBe(4)<br>})<br>test(“测试 reduce 函数”, () =&gt; {<br>expect(reduce(3, 2)).toBe(1)<br>})</p><p></pre><p id="u5a934f21" class="ne-p"><span class="ne-text">不能运行是node环境不能直接使用es6语法，需要只用babel来转换</span></p><p id="uf28fecec" class="ne-p"><span class="ne-text">新建</span><code class="ne-code"><span class="ne-text">.babelrc</span></code><span class="ne-text">文件</span></p><pre data-language="bash" id="vervB" class="ne-codeblock language-bash">// .babelrc<br>{<br>    "presets": [<br>            ["@babel/preset-env", {<br>                "targets": "> 5%"<br>            }]<br>    ]<br>}</pre><h4 id="uA7SI"><span class="ne-text">运行</span></h4><p id="u01cd9433" class="ne-p"><span class="ne-text">运行npm run test 就可以测试了</span></p><p id="u63633d80" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1638881167559-731c4af0-07c1-4d1b-b3d2-9273ab358fcb.png" width="826.5" id="Bt95b" class="ne-image"></p><h3 id="lociY"><span class="ne-text">Jest API及相关命令</span></h3><ul class="ne-ul"><li id="u70974d24"><span class="ne-text">官方文档：</span><a href="https://jestjs.io/zh-Hans/docs/getting-started" data-href="https://jestjs.io/zh-Hans/docs/getting-started" target="_blank" class="ne-link"><span class="ne-text">https://jestjs.io/zh-Hans/docs/getting-started</span></a></li></ul><p id="u645cac91" class="ne-p"><span class="ne-text">相关教程：</span></p><ul class="ne-ul"><li id="uab34ba30"><a href="https://juejin.cn/post/6844904114753634317" data-href="https://juejin.cn/post/6844904114753634317" target="_blank" class="ne-link"><span class="ne-text">Jest前端自动化测试入门</span></a></li><li id="u3fc45678"><a href="https://xie.infoq.cn/article/f743bf48dc9ea09e5cbd7285c" data-href="https://xie.infoq.cn/article/f743bf48dc9ea09e5cbd7285c" target="_blank" class="ne-link"><span class="ne-text">搭建基本 Jest 测试框架，解读覆盖率实现原理</span></a></li></ul><ul class="ne-ul"><li id="ud641ceff"><a href="https://juejin.cn/post/6844904082516377607" data-href="https://juejin.cn/post/6844904082516377607" target="_blank" class="ne-link"><span class="ne-text">vue项目搭建jest单元测试及采坑</span></a></li><li id="ua6daf3d6"><a href="https://cloud.tencent.com/developer/article/1602142" data-href="https://cloud.tencent.com/developer/article/1602142" target="_blank" class="ne-link"><span class="ne-text">Vue-Test-Utils + Jest 单元测试入门与实践</span></a></li></ul><ul class="ne-ul"><li id="ua2ad2660"><span class="ne-text">eslint就可以使用：</span><a href="https://www.npmjs.com/package/eslint-plugin-jest" data-href="https://www.npmjs.com/package/eslint-plugin-jest" target="_blank" class="ne-link"><span class="ne-text">eslint-plugin-jest</span></a></li></ul><h4 id="nASi3"><span class="ne-text">Jest API</span></h4><ul class="ne-ul"><li id="u64eb9bc4"><code class="ne-code"><span class="ne-text">test()</span></code><span class="ne-text">类似请求后端接口一样，请求成功或失败的判断</span></li><li id="u2e2cd57b"><code class="ne-code"><span class="ne-text">expect()</span></code><span class="ne-text">则是判断和预期的值是否一样，然后执行相应的操作</span></li></ul><ul class="ne-ul"><li id="ud2ddc9b0"><code class="ne-code"><span class="ne-text">toBe()</span></code><span class="ne-text">就是写入预期值来判断是否和自己写的代码值是否一样</span></li><li id="u3251118b"><code class="ne-code"><span class="ne-text">describe</span></code><span class="ne-text"> 描述, decribe会形成一个作用域</span></li></ul><ul class="ne-ul"><li id="u74302817"><code class="ne-code"><span class="ne-text">it</span></code><span class="ne-text"> 断言</span></li></ul><h4 id="nr2aO"><span class="ne-text">jest –coverage</span></h4><p id="u966bb14b" class="ne-p"><span class="ne-text">查看覆盖率命令</span></p><p id="uafec70e4" class="ne-p"><span class="ne-text">该命令可以可视化展示，也可以在浏览器打开可视化结果网页</span></p><p id="ub8b54fff" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640503326529-c0e50682-a7d0-4e47-9be3-df6c5e71b8e3.png" width="581.5" id="u1305df8b" class="ne-image"></p><h2 id="RCTVi"><span class="ne-text">[单元测试]e2e-cypress</span></h2><p id="u7eaa1147" class="ne-p"><span class="ne-text">插眼：日后再深入了解</span></p><p id="u9c33b81a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1640504518665-55a6bd16-bb69-411d-bc9b-de4b6e2db2cc.jpeg" width="79" id="nTdFS" class="ne-image"></p><p id="u6b49e626" class="ne-p"><span class="ne-text">Vue官方插件地址：</span></p><ul class="ne-ul"><li id="u89b7da36"><span class="ne-text"></span><a href="https://www.npmjs.com/package/@vue/cli-plugin-e2e-cypress" data-href="https://www.npmjs.com/package/@vue/cli-plugin-e2e-cypress" target="_blank" class="ne-link"><span class="ne-text">https://www.npmjs.com/package/@vue/cli-plugin-e2e-cypress</span></a></li></ul><p id="uc4e81d13" class="ne-p"><span class="ne-text">参考教程：</span></p><ul class="ne-ul"><li id="u06cfad14"><a href="https://www.jianshu.com/p/459612488233" data-href="https://www.jianshu.com/p/459612488233" target="_blank" class="ne-link"><span class="ne-text">Vue项目采用Cypress做e2e自动化测试，手把手一撸到底</span></a></li></ul><h2 id="wYveI"><span class="ne-text">Vue3+TypeScript项目搭建过程中报错 </span></h2><h3 id="pirTY"><span class="ne-text">VSCode插件ESLint+Prettier+vetur代码格式化冲突</span></h3><p id="ue95c4747" class="ne-p"><span class="ne-text">这三者是代码校验和格式化的插件，当vue3.x项目搭建成功之后</span></p><p id="u603aa0dd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640422446727-53aab258-0454-486d-b2e7-f4c181c7b404.png" width="285.5" id="W9mzl" class="ne-image"></p><p id="u799823b7" class="ne-p"><span class="ne-text">该行配置需要注释，不然代码保存之后，会经过Prettier和vetur两者之间的来回格式化顺序，导致不能正常格式化。</span></p><p id="u67f0d11d" class="ne-p"><span class="ne-text"></span></p><p id="u43374fc9" class="ne-p"><span class="ne-text">具体矛盾原因：</span></p><ul class="ne-ul"><li id="u13878e26"><a href="https://zhuanlan.zhihu.com/p/101241781" data-href="https://zhuanlan.zhihu.com/p/101241781" target="_blank" class="ne-link"><span class="ne-text">解决vscode eslint与prettier冲突</span></a></li><li id="u6d1958fd"><a href="https://zhuanlan.zhihu.com/p/347339865" data-href="https://zhuanlan.zhihu.com/p/347339865" target="_blank" class="ne-link"><span class="ne-text">VSCode中ESLint、Prettier 配置冲突问题原因及解决方案</span></a></li></ul><ul class="ne-ul"><li id="ue1e225a1"><a href="https://www.cnblogs.com/wangpenghui522/p/13727990.html" data-href="https://www.cnblogs.com/wangpenghui522/p/13727990.html" target="_blank" class="ne-link"><span class="ne-text">VSCode-Prettier和ESLint如何和睦共处? </span></a></li><li id="u43160271"><a href="https://cloud.tencent.com/developer/article/1802491" data-href="https://cloud.tencent.com/developer/article/1802491" target="_blank" class="ne-link"><span class="ne-text">Vue 基于VSCode结合Vetur+ESlint+Prettier统一Vue代码风格</span></a></li></ul><p id="u7face581" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="u433654bc"><span class="ne-text">Prettier插件：一定要留，能保存所有文件，按照自己规则进行格式化</span></li><li id="u411ced4f"><span class="ne-text">ESLint插件</span></li></ul><ul class="ne-ul"><li id="u7d95cb10"><span class="ne-text">vetur插件</span></li><li id="u81822d9f"><span class="ne-text">Vue项目中的prettier插件</span></li></ul><ul class="ne-ul"><li id="u17721640"><span class="ne-text">Vue项目中的eslint插件</span></li><li id="u82fcf70a"><span class="ne-text">Vue项目中的eslint的各个子插件</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u277c5a88"><span class="ne-text">eslint-plugin-prettier：这个就是typescript项目中上述冲突的缘由</span></li><li id="u77b8d609"><span class="ne-text">eslint-config-prettier</span></li></ul></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u48b7feb0"><span class="ne-text">……</span></li></ul></ul><h3 id="i6BcM"><span class="ne-text">Error: Cannot find module ‘vue-loader-v16/package.json’</span></h3><p id="ub55684c9" class="ne-p"><span class="ne-text">在导入Vue3 + TypeScript的项目</span></p><ol class="ne-ol"><li id="u1a42696e"><span class="ne-text">升级npm</span></li></ol><p id="u83a95ccd" class="ne-p"><span class="ne-text">使用cnpm的也要升级一下cnpm</span></p><pre data-language="bash" id="u0V6H" class="ne-codeblock language-bash">cnpm i -g cnpm</pre><ol start="2" class="ne-ol"><li id="uc1f116bd"><span class="ne-text">重新安装node_modules依赖包</span></li></ol><pre data-language="bash" id="WKePx" class="ne-codeblock language-bash">cnpm i // 重新安装</pre><ol start="3" class="ne-ol"><li id="u1e7e4d28"><span class="ne-text">重新下载</span></li></ol><pre data-language="bash" id="qP1JW" class="ne-codeblock language-bash">cnpm i -D vue-loader-v16</pre><h3 id="LwYwy"><span class="ne-text">[vue/no-multiple-template-root]The template root requires exactly one element.eslint-plugin-vue</span></h3><p id="u59224a56" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640357960271-5a2b291c-9a75-45eb-90c7-181a081cd1b3.png" width="524" id="LDxro" class="ne-image"></p><h3 id="JDa5v"><span class="ne-text">找不到模块“”@aomao/engine””或其相应的类型声明。ts(2307)</span></h3><div data-type="danger" class="ne-alert"><p id="ub4ceac5d" class="ne-p"><span class="ne-text">报错信息</span></p></div><pre data-language="bash" id="v8bSN" class="ne-codeblock language-bash">找不到模块“"@aomao/engine"”或其相应的类型声明。ts(2307)</pre><pre data-language="bash" id="HorNd" class="ne-codeblock language-bash">模块“"@aomao/engine"”没有导出的成员“PluginEntry”。ts(2305)</pre><div data-type="success" class="ne-alert"><p id="uac4b1750" class="ne-p"><span class="ne-text">按照网上找的一些方法，都无法解决这个问题</span></p><p id="u1c0d7a79" class="ne-p"><span class="ne-text">重启可以解决，插件用的太多===太卡顿</span></p></div><h3 id="R8rjd"><span class="ne-text">‘vue/comment-directive’ — error in the end of public/index.html just after vue-cli installation</span></h3><p id="uc3e1dea7" class="ne-p"><span class="ne-text">public文件夹次啊的index.html文件末尾会有该报错，解决办法就是配置相关rule</span></p><p id="udac104c0" class="ne-p"><a href="https://github.com/vuejs/eslint-plugin-vue/issues/1355" data-href="https://github.com/vuejs/eslint-plugin-vue/issues/1355" target="_blank" class="ne-link"><span class="ne-text">https://github.com/vuejs/eslint-plugin-vue/issues/1355</span></a></p><h3 id="JvlUf"><span class="ne-text">Delete <code>␍</code>eslintprettier/prettier</span></h3><p id="u7ec44cd7" class="ne-p"><span class="ne-text">将代码push到GitHub仓库，新拉取下来，文件的每行代码会有此报错</span></p><p id="u10654bf9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644376958819-fecf2dc0-76f0-4a31-b2a8-269dd345223d.png" width="536" id="ua5af1e6f" class="ne-image"></p><p id="ua74cd873" class="ne-p"><span class="ne-text"></span></p><p id="u33be619f" class="ne-p"><span class="ne-text">报错原因：文本文件的换行符不一致</span></p><p id="uaf340915" class="ne-p"><span class="ne-text">具体参考：</span><a href="https://juejin.cn/post/6844904069304156168#heading-6" data-href="https://juejin.cn/post/6844904069304156168#heading-6" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6844904069304156168#heading-6</span></a></p><p id="ue63cf88e" class="ne-p"><span class="ne-text">解决办法：</span></p><ol class="ne-ol"><li id="u200bacee"><span class="ne-text">【治标】如果只有少个文件，将vscode右下角处改为LF即可</span></li></ol><p id="u56edc332" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644377438548-8db15f94-e644-43ac-bad4-2f4ce86eb274.png" width="449" id="u08d40637" class="ne-image"></p><ol start="2" class="ne-ol"><li id="u841e15fc"><span class="ne-text">【治本】在windows环境下，全局关掉转换行</span></li></ol><pre data-language="bash" id="brkkK" class="ne-codeblock language-bash">git config --global core.autocrlf false</pre><p id="u4f4aac5e" class="ne-p"><span class="ne-text">然后再将刚刚拉取到本地的项目删掉，重新从GitHub拉取到本地，就不会出现该报错了</span></p><ol start="3" class="ne-ol"><li id="uf14bc6be"><span class="ne-text">另外，在vscode设置中设置如下，可以达到新建文件就是LF转换行的效果了</span></li></ol><p id="u33b96b28" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644377676559-12ee984b-e189-4dcf-8a72-59e37198b974.png" width="362" id="u84528446" class="ne-image"></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>炒青菜</title>
      <link href="/essay/cook_greens/"/>
      <url>/essay/cook_greens/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>炒鸡肉</title>
      <link href="/essay/cook_chicken/"/>
      <url>/essay/cook_chicken/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u5bd9b07e"><span class="ne-text">切块，炒</span></li></ul><div class="ne-quote"><p id="u602b9986" class="ne-p"><span class="ne-text">目的就是把鸡肉身体里面的水分去掉</span></p></div><p id="ubbfbe04a" class="ne-p"><span class="ne-text">具体的操作步骤：</span></p><p id="u7e1f8b56" class="ne-p"><span class="ne-text">① 倒入香油，待香油表面的一层油花去掉，再将鸡肉导入</span></p><p id="u8051678a" class="ne-p"><span class="ne-text">② 炒到鸡肉大部分水分已经去掉了，放入生姜，小米椒，放盐……</span></p><p id="u60f18ddb" class="ne-p"><span class="ne-text">（此时放盐，只是以便待会炖好可以直接吃，也可以放在待会放的）</span></p><ul class="ne-ul"><li id="ua47473f0"><span class="ne-text">锅炖</span></li></ul><p id="u4042d85e" class="ne-p"><span class="ne-text">锅下面放入适量的水，不能过多，不然溢到鸡肉里面就不能吃了</span></p><p id="ucd693c30" class="ne-p"><span class="ne-text">同时还需要用个小盖子将鸡肉盖住，这样一面汽水浸入鸡肉里面，也不能吃</span></p><p id="ua7fc2bbb" class="ne-p"><span class="ne-text"></span></p><p id="ub4b0bb70" class="ne-p"><span class="ne-text">这个时候理论上是可以直接吃的，但是如果自己觉得荤味太重，也可以再拿出来，再放入一点点香油小炒小烩</span></p><p id="u92332ea5" class="ne-p"><br></p><p id="ufe3269cc" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1639711573828-ce9f3075-2dbc-465e-921f-121f56bb00e0.jpeg" width="60" id="YodIL" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——害怕</title>
      <link href="/essay/ifuuic/"/>
      <url>/essay/ifuuic/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u0c684b80" class="ne-p"><strong><span class="ne-text">被误会</span></strong></p><p id="u5259f535" class="ne-p"><span class="ne-text">两个同事和一个老人，那个老人迷迷糊糊 缓缓 进到我们房子里面，然后不知道一直在干嘛，最后是我的室友A不知道哪来的一把特别特别锋利的刀无意间割伤那位老人的大腿，导致大量失血，最终死了</span></p><p id="ua367cb5b" class="ne-p"><span class="ne-text">然后第二天，有班主任来追究这件事，我不知道怎么的，对质的时候，我正好不在，他们两个被叫去对质，听别人说，他们对质的时候说的答案不一样，反正最后，被误会成是我，我有理说不清，那个老人不是我杀的，但是我的内心又不想说是那个室友做的，于是一直耽搁，我的心里很矛盾，最终，他们统一和班主任说，看到我在那位老人面前用刀…我不知道怎么的，明明不是我，可我在逃避，我不知道在怕什么，可能是全世界都以为我是凶手，可我不是，我争辩不了，那种无力感，那种委屈，那种害怕…</span></p><p id="u9a1faadb" class="ne-p"><span class="ne-text"></span></p><p id="uc1511c19" class="ne-p"><strong><span class="ne-text">妈妈失忆</span></strong></p><p id="u187f7768" class="ne-p"><span class="ne-text">一切的落魄，我又回到那个房子里，又有一个老人走到我面前，那是我妈妈，我不知道妈妈怎么就突然瞬间变老了，样子还是一样，但是已经失忆了，我妈妈不记得我了…我哭，一直哭，我一直说，我是你儿子呀，可是我在我妈妈面前就是一个陌生人，我好伤心，一直哭，我妈妈还对房子外面的路过的街坊邻居说，你们看，这个孩子真懂事，而我呆呆地站在那，伤心到形神分离…</span></p><p id="ud91394e3" class="ne-p"><span class="ne-text"></span></p><p id="ua77c9a07" class="ne-p"><span class="ne-text"></span></p><p id="u6793d2ad" class="ne-p"><span class="ne-text">梦醒了，脚在抽搐，抽搐的那块被子特别冰凉，原来是没关窗户，十二月的冷风吹进来了……</span></p><p id="u387f48f1" class="ne-p"><span class="ne-text">2021.12.03  07:04</span></p><p id="u8eec700e" class="ne-p"><span class="ne-text"></span></p><p id="u6867dcf4" class="ne-p"><span class="ne-text"></span></p><p id="u83c1bde3" class="ne-p"><span class="ne-text">后记：</span></p><p id="u1c39052d" class="ne-p"><span class="ne-text">一个人最失意甚至死亡的时候，脑子里面浮现的，其实是亲人，在小的时候，有次和小伙伴去湖里面游泳，那是我第一次下水游泳，当时差点淹死，我至今都清楚地记得我倒在水里面的时候，一直呛水那会，脑子里面想的其实就是家里厨房，客厅，还有熟悉的我妈叫我吃饭那声音……</span></p><p id="u8e4196db" class="ne-p"><span class="ne-text"></span></p><p id="uff11e36a" class="ne-p"><span class="ne-text">很多人说我很冷，可我其实不是，相处之后，我觉得我还是比较重感情的，我挺感谢这个梦的…</span></p><p id="u17e1677c" class="ne-p"><span class="ne-text"></span></p><p id="ufe496009" class="ne-p"><span class="ne-text">人其实都有两面，一面是原本流露真情的自我，一面是这个世界这个周围环境甚至自身经历所塑造的自己，可能沉稳，冷静，等等这些都是他人所看到的，然而人的还有一面，就像迟子建笔下的杨二嫂一般，将丈夫的尸体锁在冰柜，深夜独自买醉，因为这可能就是对自我感情的一种救赎，因为到了白天，当周围不再是黑夜，人们不再抒情，用坚强的外壳去跻身于这个不好不坏，不完美却也没有大缺陷的世界中…</span></p><p id="ua3c54a2a" class="ne-p"><span class="ne-text"></span></p><p id="u6a31b4e8" class="ne-p"><span class="ne-text"></span></p><p id="ua2c293ac" class="ne-p"><span class="ne-text"></span></p><p id="u572d5056" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1638506128821-fd0914a3-839b-4cb9-9e0b-a79b4d557a1e.jpeg" width="1176" id="u8c4a114e" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx常用命令</title>
      <link href="/blog/kz2il6/"/>
      <url>/blog/kz2il6/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><pre data-language="nginx" id="e4Vci" class="ne-codeblock language-nginx">cd e:\Nginx<p>cd nginx-1.16.1<br>start nginx<br>tasklist /fi “imagename eq nginx.exe” //查看进程<br>nginx -t -c ./conf/nginx.conf //检查配置文件<br>nginx -s reload //重启服务<br>nginx -s stop //快速停止<br>nginx -s quit //完整有序的停止</p><p>server {<br>listen 80;<br>server_name tf.local.msshuo.cn;<br>#server_name kf.local.msshuo.cn;</p><pre><code>    #charset koi8-r;    #access_log  logs/host.access.log  main;    location / &#123;        root   E:\\mly\\ad_dist;        #root   E:\mly\kf_dist;        index  index.html index.htm;    &#125;    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   html;    &#125;</code></pre><p></pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14种设计模式</title>
      <link href="/blog/figfyg/"/>
      <url>/blog/figfyg/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>axios发送请求报错：Cannot read property &#39;cancelToken&#39; of undefined</title>
      <link href="/blog/d75374fb-d238-4bcb-9146-e8b182b66752/"/>
      <url>/blog/d75374fb-d238-4bcb-9146-e8b182b66752/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u4b1373b2" class="ne-p"><img src="https://img2020.cnblogs.com/blog/1269599/202005/1269599-20200520145553205-2092514210.png" width="955" id="qbL6v" class="ne-image"></p><p id="u2a5b580b" class="ne-p"><br></p><p id="u9ace7404" class="ne-p"><span class="ne-text">bug原因：在使用 axios 的拦截器时，没有添加返回值  return  config</span></p><p id="u0434ea32" class="ne-p"><span class="ne-text">解决方法：在请求拦截器中添加 return config，  （！！！注意响应拦截器中也要添加返回值）</span></p><p id="u273189db" class="ne-p"><br></p><p id="u89bc622e" class="ne-p"><img src="https://img2020.cnblogs.com/blog/1269599/202005/1269599-20200520145902689-569364923.png" width="738" id="kjLXK" class="ne-image"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《华丽人生》原文摘录</title>
      <link href="/essay/algh82/"/>
      <url>/essay/algh82/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ub1eee640" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639824740044-5fc3d698-c9be-4993-ad8d-688ea9a6947d.png" width="1080" id="u8defc980" class="ne-image"></p><p id="u10b35ccf" class="ne-p"><span class="ne-text"></span></p><p id="uf0aec04d" class="ne-p"><span class="ne-text">我放弃抵抗人生。这世上有一股巨大的潮流，就算反抗那股潮流，终究还是会被推着走。如果能理解我们活着的背后有一股巨大的力量，那就没什么好怕的，也不需要逃避。就算我们自以为靠着自我压抑和选择过日子，其实也不过就是"被迫活着"而已，不是吗？” …… “是海洋啊。”黑泽耸耸肩说道，“人生是既没有路线也没有标志的茫茫大海啊。我们只是身在其中，紧紧抓住一条大鱼，委身于巨大的海流罢了</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组去重🔖JavaScript🔖数组</title>
      <link href="/blog/array-deduplication/"/>
      <url>/blog/array-deduplication/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u5d074287" class="ne-p"><span class="ne-text">总结来看，去重分三种思路：</span></p><ul class="ne-ul"><li id="u17946e66"><span class="ne-text">es6的 Set 数据结构</span></li><li id="u6cded952"><span class="ne-text">Array的各类api</span></li><li id="u21d8c1a5"><span class="ne-text">利用对象的属性</span></li></ul><p id="u417f068d" class="ne-p"><span class="ne-text">文章参考：</span><a href="https://segmentfault.com/a/1190000016418021" data-href="https://segmentfault.com/a/1190000016418021" target="_blank" class="ne-link"><span class="ne-text">https://segmentfault.com/a/1190000016418021</span></a></p><h2 id="d03bbbd3"><span class="ne-text">一、利用 ES6 Set 去重（ES6 中最常用）</span></h2><p id="ud6962878" class="ne-p"><br></p><pre data-language="javascript" id="55de5695" class="ne-codeblock language-javascript">arr_test = [0,0,999,999,'字符串','字符串',true,true,false,false,undefined,undefined,null,null,NaN,NaN,{},{},[],[],]<p>let unique_set = arr =&gt; {<br>return Array.from(new Set(arr))<br>}</p><p>console.log(unique_set(arr_test))</pre><p id="u3bf4bff7" class="ne-p"><span class="ne-text">或者……</span></p><pre data-language="javascript" id="QnOQO" class="ne-codeblock language-javascript">console.log([...new Set(arr_test)])</pre><p id="u57699b53" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651548685623-2a8e3fb9-2f10-4f98-bb4d-bede8276712f.png" width="232.49999076128043" id="u5b9461cf" class="ne-image"></p><div data-type="danger" class="ne-alert"><p id="u719146d8" class="ne-p"><span class="ne-text">去不掉</span></p><ul class="ne-ul"><li id="ua00300a4"><span class="ne-text">{}</span></li><li id="u8b5646db"><span class="ne-text">[]</span></li></ul></div><p id="u54caacdc" class="ne-p"><br></p><h2 id="d67f434e"><span class="ne-text">二、利用 for 嵌套 for，然后 splice 去重（ES5 中最常用）</span></h2><p id="u5aec723e" class="ne-p"><br></p><pre data-language="javascript" id="4d621b05" class="ne-codeblock language-javascript">arr_test = [0,0,999,999,'字符串','字符串',true,true,false,false,undefined,undefined,null,null,NaN,NaN,{},{},[],[],]</p><p>let unique_for_for_splice = arr =&gt; {<br>for (let i = 0; i &lt; arr.length; i++) {<br>for (let j = i + 1; j &lt; arr.length; j++) {<br>if (arr[i] === arr[j]) {<br>arr.splice(j, 1)<br>}<br>}<br>}<br>return arr<br>}<br>console.log(unique_for_for_splice(arr_test))</pre><p id="u9daeb974" class="ne-p"><br></p><p id="uc4605d05" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651548810144-b36aa36d-87c9-4879-bd0a-12f3c4f55295.png" width="228.33332426018222" id="u8b1b4557" class="ne-image"></p><div data-type="danger" class="ne-alert"><p id="u250668ab" class="ne-p"><span class="ne-text">去不掉</span></p><ul class="ne-ul"><li id="uaf872f04"><span class="ne-text">NaN</span></li></ul><ul class="ne-ul"><li id="u2816b937"><span class="ne-text">{}</span></li><li id="u33792e49"><span class="ne-text">[]</span></li></ul></div><h2 id="f59a2b27"><span class="ne-text">三、利用 includes/indexOf 去重</span></h2><p id="ued10258d" class="ne-p"><br></p><pre data-language="javascript" id="5f6a8f97" class="ne-codeblock language-javascript">let unique_includes = arr => {<br>let result = []<br>arr.forEach(data => {<br>if (!result.includes(data)) result.push(data)<br>})<br>return result<br>}<br>console.log(unique_includes(arr_test))</pre><pre data-language="javascript" id="qfQZs" class="ne-codeblock language-javascript">let unique_indexof = arr => {<br>let result = []<br>arr.forEach(data => {<br>if (result.indexOf(data) === -1) result.push(data)<br>})<br>return result<br>}<br>console.log(unique_indexof(arr_test))</pre><p id="u0fa4d157" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651549129756-b5675fd2-1851-4b74-923a-6bd90675fcd4.png" width="236.66665726237864" id="uda11904a" class="ne-image"></p><p id="ub4301d4e" class="ne-p"><br></p><h2 id="801e89a1"><span class="ne-text">四、利用 sort()</span></h2><p id="u7411e574" class="ne-p"><br></p><pre data-language="javascript" id="6d750e3a" class="ne-codeblock language-javascript">let unique_sort = arr => {<br>arr.sort().forEach((data, index) => {<br>if (data === arr[index + 1] && index < arr.length - 1)<br>arr.splice(index + 1, 1)<br>})<br>return arr<br>}<br>console.log(unique_indexof(arr_test))</pre><p id="u0fba8d32" class="ne-p"><br></p><p id="u7612ecf9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651549585258-df18b8b6-1a2f-4345-a7a2-db2635e84b13.png" width="284.1666553748983" id="u150d350e" class="ne-image"></p><h2 id="wP0wd"><span class="ne-text">五、利用 filter</span></h2><p id="u93c6e9db" class="ne-p"><br></p><pre data-language="javascript" id="Lgbzs" class="ne-codeblock language-javascript">let unique_filter = arr => {<br>return arr.filter((data, index, arr) => {<br>return arr.indexOf(data, 0) === index;<br>})<br>}<br>console.log(unique_filter(arr_test))</pre><p id="u1abe8c53" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651550392520-a342d7c0-9102-49db-b672-3c70b887d258.png" width="296.66665487819296" id="nMX9A" class="ne-image"></p><h2 id="RfLwD"><span class="ne-text">六、利用 reduce</span></h2><p id="u587b9a1e" class="ne-p"><br></p><pre data-language="javascript" id="k8wre" class="ne-codeblock language-javascript">let unique_reduce = arr => {<br>return arr.reduce((a, b) => (a.includes(b) ? a : [...a, b]), [])<br>}<br>console.log(unique_reduce(arr_test))</pre><p id="u918f047a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651550878738-7acdd3ef-54cd-4572-97e6-0e8c43b5719e.png" width="304.16665458016973" id="jhDy7" class="ne-image"></p><h2 id="f4fc8f4e"><span class="ne-text">利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）</span></h2><p id="ua72da46c" class="ne-p"><br></p><pre data-language="plain" id="06ace6c8" class="ne-codeblock language-plain">function unique(arr) {<br>if (!Array.isArray(arr)) {<br>console.log('type error!')<br>return<br>}<br>var arrry= [];<br>var obj = {};<br>for (var i = 0; i < arr.length; i++) {<br>if (!obj[arr[i]]) {<br>arrry.push(arr[i])<br>obj[arr[i]] = 1<br>} else {<br>obj[arr[i]]++<br>}<br>}<br>return arrry;<br>}<br>var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];<br>console.log(unique(arr))<br>//[1, "true", 15, false, undefined, null, NaN, 0, "a", {…}] //两个 true 直接去掉了，NaN 和{}去重</pre><p id="u2aa60d02" class="ne-p"><br></p><h2 id="65722c0d"><span class="ne-text">利用 hasOwnProperty</span></h2><p id="ufc660d37" class="ne-p"><br></p><pre data-language="plain" id="e8d5480d" class="ne-codeblock language-plain">function unique(arr) {<br>var obj = {};<br>return arr.filter(function(item, index, arr){<br>return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)<br>})<br>}<br>var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];<br>console.log(unique(arr))<br>//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}] //所有的都去重了</pre><p id="u409ad723" class="ne-p"><br></p><p id="u5496097d" class="ne-p"><span class="ne-text">利用 hasOwnProperty 判断是否存在对象属性</span></p><p id="uf1ae4dc2" class="ne-p"><br></p><h2 id="37828459"></h2><h2 id="0d78e14f"><span class="ne-text">利用递归去重</span></h2><p id="u7ad84673" class="ne-p"><br></p><pre data-language="plain" id="3aa79291" class="ne-codeblock language-plain">function unique(arr) {<br>var array= arr;<br>var len = array.length;</p><pre><code>array.sort(function(a,b)&#123;   //排序后更加方便去重    return a - b;&#125;)function loop(index)&#123;    if(index &gt;= 1)&#123;        if(array\[index\] === array\[index\-1\])&#123;            array.splice(index,1);        &#125;        loop(index - 1);    //递归loop，然后数组去重    &#125;&#125;loop(len\-1);return array;</code></pre><p>}<br>var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];<br>console.log(unique(arr))<br>//[1, “a”, “true”, true, 15, false, 1, {…}, null, NaN, NaN, “NaN”, 0, “a”, {…}, undefined]</pre><p id="uc875115e" class="ne-p"><br></p><h2 id="ad4d0c86"><span class="ne-text">利用 Map 数据结构去重</span></h2><p id="ud6cfc1de" class="ne-p"><br></p><pre data-language="plain" id="8c2d2e5a" class="ne-codeblock language-plain">function arrayNonRepeatfy(arr) {<br>let map = new Map();<br>let array = new Array(); // 数组用于返回结果<br>for (let i = 0; i < arr.length; i++) {<br>if(map .has(arr[i])) { // 如果有该 key 值<br>map .set(arr[i], true);<br>} else {<br>map .set(arr[i], false); // 如果没有该 key 值<br>array .push(arr[i]);<br>}<br>}<br>return array ;<br>}<br>var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];<br>console.log(unique(arr))<br>//[1, "a", "true", true, 15, false, 1, {…}, null, NaN, NaN, "NaN", 0, "a", {…}, undefined]</pre><p id="u698485f0" class="ne-p"><br></p><p id="ude7ca7ea" class="ne-p"><span class="ne-text">创建一个空 Map 数据结构，遍历需要去重的数组，把数组的每一个元素作为 key 存到 Map 中。由于 Map 中不会出现相同的 key 值，所以最终得到的就是去重后的结果。</span></p><p id="u3373844e" class="ne-p"><br></p><h2 id="b21c06bc"></h2><p id="ubcc0d98a" class="ne-p"><br></p><p id="ud9f30771" class="ne-p"><span class="ne-text">PS：有些文章提到了 foreach+indexOf 数组去重的方法，个人觉得都是大同小异，所以没有写上去。<br></span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue下载指定url图片</title>
      <link href="/blog/na8588/"/>
      <url>/blog/na8588/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="XXVKm"><span class="ne-text">一、转换base64编码</span></h2><pre data-language="javascript" id="WQqHq" class="ne-codeblock">// 下载图标点击事件<p>downloadIcon() {<br>let downloadUrl =<br>‘<a href="https://xxx.com&/#39;">https://xxx.com&#39;</a> +<br>this.gameInfoData.gameIcon.replace(‘_thumb’, ‘’)<br>this.downloadImg(downloadUrl, this.gameInfoData.gameName + ‘-icon’)<br>},<br>// 功能代码<br>downloadImg(imgsrc, name) {<br>var image = new Image()<br>// 解决跨域 Canvas 污染问题<br>image.setAttribute(‘crossOrigin’, ‘anonymous’)<br>image.onload = function() {<br>var canvas = document.createElement(‘canvas’)<br>canvas.width = image.width<br>canvas.height = image.height<br>var context = canvas.getContext(‘2d’)<br>context.drawImage(image, 0, 0, image.width, image.height)<br>var url = canvas.toDataURL() //得到图片的 base64 编码数据<br>var a = document.createElement(‘a’) // 生成一个 a 元素<br>var event = new MouseEvent(‘click’) // 创建一个单击事件<br>a.download = name || ‘photo’ // 设置图片名称<br>a.href = url // 将生成的 URL 设置为 a.href 属性<br>a.dispatchEvent(event) // 触发 a 的单击事件<br>}<br>image.src = imgsrc<br>}</pre><p id="ud02f7906" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/z9061/article/details/84882353" data-href="https://blog.csdn.net/z9061/article/details/84882353" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/z9061/article/details/84882353</span></a></p><h2 id="DxbB5"><span class="ne-text">二、下载文件</span></h2><p id="udb64243d" class="ne-p"><br></p><p id="u4b80fa45" class="ne-p"><span class="ne-text">参考：</span><a href="https://segmentfault.com/a/1190000020540788" data-href="https://segmentfault.com/a/1190000020540788" target="_blank" class="ne-link"><span class="ne-text">https://segmentfault.com/a/1190000020540788</span></a></p><p id="u7edfb5e2" class="ne-p"><span class="ne-text"></span></p><p id="u2a382572" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1636381118828-028d764d-cc8c-4910-a280-9c1037ae0ae4.gif" width="218" id="Oaany" class="ne-image"><span class="ne-text"> 插个眼，日后再去摸索摸索这方面的功能</span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue中几种组件通信方式</title>
      <link href="/blog/qwv5oz/"/>
      <url>/blog/qwv5oz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="ucc0fb243" class="ne-p"><span class="ne-text">本文转载自：</span><a href="https://juejin.cn/post/6844903887162310669" data-href="https://juejin.cn/post/6844903887162310669" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6844903887162310669</span></a></p><p id="uc7462431" class="ne-p"><span class="ne-text">（部分内容自行添加/修改）</span></p></div><p id="u3db2dde9" class="ne-p"><br></p><div class="ne-quote"><p id="32eedc2270d806d3471c57346ba7968f_p_0" class="ne-p"><span class="ne-text">之前写了一篇关于 vue 面试总结的文章, 有不少网友提出组件之间通信方式还有很多, 这篇文章便是专门总结组件之间通信的</span></p></div><p id="4838965d80065e01b01bcecbc05930c6_p_1" class="ne-p"><br></p><p id="16360e46c710de3897b34be2da8f3c34_p_2" class="ne-p"><span class="ne-text">作者简介：koala，专注完整的 Node.js 技术栈分享，从 JavaScript 到 Node.js, 再到后端数据库，祝您成为优秀的高级 Node.js 工程师。【程序员成长指北】作者，Github 博客开源项目 </span><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fkoala-coding%2FgoodBlog" data-href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fkoala-coding%2FgoodBlog" target="_blank" class="ne-link"><span class="ne-text">https://github.com/koala-coding/goodBlog</span></a></p><p id="804b58e6d41ad7fb2480630c3092516e_p_3" class="ne-p"><br></p><p id="497144d8506882a2db679d679af2acea_p_4" class="ne-p"><span class="ne-text">vue 是数据驱动视图更新的框架, 所以对于 vue 来说组件间的数据通信非常重要，那么组件之间如何进行数据通信的呢？ 首先我们需要知道在 vue 中组件之间存在什么样的关系, 才更容易理解他们的通信方式, 就好像过年回家，坐着一屋子的陌生人，相互之间怎么称呼，这时就需要先知道自己和他们之间是什么样的关系。 vue 组件中关系说明:</span></p><p id="7467903a77e4c43e92d4f196903d0bbe_p_5" class="ne-p"><br></p><p id="9b32206ce2e4698409fa9b6e702ab5dc_p_6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1635399234264-ec4a46fa-6e27-4efb-922f-871b5ef8719c.webp" width="462" id="ubbf5437a" class="ne-image"></p><p id="e1b0979b54c1fb29acc1d92ad2159922_p_7" class="ne-p"><br></p><p id="277ac1b9a01a26e550f334d2d650a2af_p_8" class="ne-p"><span class="ne-text">如上图所示, A 与 B、A 与 C、B 与 D、C 与 E 组件之间是父子关系； B 与 C 之间是兄弟关系；A 与 D、A 与 E 之间是隔代关系； D 与 E 是堂兄关系（非直系亲属） 针对以上关系我们归类为：</span></p><p id="eadc4ec477465f1f239730d987d394b1_p_9" class="ne-p"><br></p><ul class="ne-ul"><li id="e921ea6da6315ea6a03b83b1fbdb45ce_li_0"><span class="ne-text">父子组件之间通信</span></li></ul><ul class="ne-ul"><li id="afaa832eef1dad88d3692c9ee7c0cb23_li_1"><span class="ne-text">非父子组件之间通信 (兄弟组件、隔代关系组件等)</span></li></ul><p id="042da541aac17f869693ba89ebd10d8e_p_10" class="ne-p"><br></p><p id="95350d3f636bad4a4fd5424d38f13bf2_p_11" class="ne-p"><span class="ne-text">本文会介绍组件间通信的 8 种方式如下图目录所示: 并介绍在不同的场景下如何选择有效方式实现的组件间通信方式，希望可以帮助小伙伴们更好理解组件间的通信。</span></p><p id="09a2b5671cf447a1a3529d71c89cf9e1_p_12" class="ne-p"><br></p><p id="2845b5316b00b43029a07a2ab35a1d57_p_13" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1635399242725-f019c2ac-ea0b-48d2-81c1-fa4f80211155.webp" width="499" id="u2d5076b9" class="ne-image"></p><p id="7cf79ceeaaf91ef14264b4c55c1c8c1d_p_14" class="ne-p"><br></p><h3 id="2834dd9e"><span class="ne-text">一、</span><code class="ne-code"><span class="ne-text">props</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">$emit</span></code></h3><p id="c53070088aadb43ef468f61fca8ca22a_p_15" class="ne-p"><br></p><p id="aefd39de20827e7fa178830efd84d682_p_16" class="ne-p"><span class="ne-text">父组件通过</span><code class="ne-code"><span class="ne-text">props</span></code><span class="ne-text">的方式向子组件传递数据，而通过</span><code class="ne-code"><span class="ne-text">$emit</span></code><span class="ne-text"> 子组件可以向父组件通信。</span></p><p id="c5eaf555cee01ec836fc749258c6179d_p_17" class="ne-p"><br></p><h4 id="0695b088"><span class="ne-text">1. 父组件向子组件传值</span></h4><p id="3f8949dd5527f0c9624c3fd3faefb76f_p_18" class="ne-p"><br></p><p id="0a6e4fcd704856005fdf95a5090e6575_p_19" class="ne-p"><span class="ne-text">下面通过一个例子说明父组件如何向子组件传递数据：在子组件</span><code class="ne-code"><span class="ne-text">article.vue</span></code><span class="ne-text">中如何获取父组件</span><code class="ne-code"><span class="ne-text">section.vue</span></code><span class="ne-text">中的数据</span><code class="ne-code"><span class="ne-text">articles:['红楼梦', '西游记','三国演义']</span></code></p><p id="db841a6e995b001085603629a3ace379_p_20" class="ne-p"><br></p><pre data-language="vue" id="ebb9fd34" class="ne-codeblock language-vue">// section父组件<template>  <div class="section">    <com-article :articles="articleList"></com-article>  </div></template><script>import comArticle from './test/article.vue'export default {  name: 'HelloWorld',  components: { comArticle },  data() {    return {      articleList: ['红楼梦', '西游记', '三国演义']    }  }}</script></pre><pre data-language="vue" id="yr7NL" class="ne-codeblock language-vue">// 子组件 article.vue<template>  <div>    <span v-for="(item, index) in articles" :key="index"></span>  </div></template><script>export default {  props: ['articles']}</script></pre><p id="u3858a5f2" class="ne-p"><br></p><div class="ne-quote"><p id="85be3e4d88c775ffac9191a0916bdfa5_p_22" class="ne-p"><span class="ne-text">总结: prop 只可以从上一级组件传递到下一级组件（父子组件），即所谓的单向数据流。而且 prop 只读，不可被修改，所有修改都会失效并警告。</span></p></div><p id="4547a4b65fb57fca5301c6973643450c_p_23" class="ne-p"><br></p><h4 id="16b04c6a"><span class="ne-text">2. 子组件向父组件传值</span></h4><p id="1f3b4b4a4867a8b756c196b38558d0c4_p_24" class="ne-p"><br></p><p id="434c1d7d47824a48e59b3b09d32b26c5_p_25" class="ne-p"><span class="ne-text">对于</span><code class="ne-code"><span class="ne-text">$emit</span></code><span class="ne-text"> 我自己的理解是这样的: </span><code class="ne-code"><span class="ne-text">$emit</span></code><span class="ne-text">绑定一个自定义事件, 当这个语句被执行时, 就会将参数 arg 传递给父组件, 父组件通过 v-on 监听并接收参数。 通过一个例子，说明子组件如何向父组件传递数据。 在上个例子的基础上, 点击页面渲染出来的</span><code class="ne-code"><span class="ne-text">ariticle</span></code><span class="ne-text">的</span><code class="ne-code"><span class="ne-text">item</span></code><span class="ne-text">, 父组件中显示在数组中的下标</span></p><p id="b57de0a6a045efefe71d109094be9ddc_p_26" class="ne-p"><br></p><pre data-language="vue" id="3d7164b6" class="ne-codeblock language-vue">// 父组件<template>  <div class="section">    <com-article :articles="articleList" @onEmitIndex="onEmitIndex"></com-article>    <p></p>  </div></template><script>import comArticle from './test/article.vue'export default {  name: 'HelloWorld',  components: { comArticle },  data() {    return {      currentIndex: -1,      articleList: ['红楼梦', '西游记', '三国演义']    }  },  methods: {    onEmitIndex(idx) {      this.currentIndex = idx    }  }}</script></pre><pre data-language="vue" id="fe0aM" class="ne-codeblock language-vue">// 子组件<template>  <div>    <div v-for="(item, index) in articles" :key="index" @click="emitIndex(index)"></div>  </div></template><script>export default {  props: ['articles'],  methods: {    emitIndex(index) {      this.$emit('onEmitIndex', index)    }  }}</script></pre><h3 id="31f6fc27"><span class="ne-text">二、 </span><code class="ne-code"><span class="ne-text">$children</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">$parent</span></code></h3><p id="d17d837b16c49a0e5c21edc18722e410_p_28" class="ne-p"><br></p><p id="cdd59d689a9a129b64c13b91ec6fb344_p_29" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1635399257895-523f1b19-b58a-42bf-9649-abebf7694ef2.webp" width="642" id="u4267112c" class="ne-image"></p><p id="d657ac1e4c3211af4f7dcea889518735_p_30" class="ne-p"><br></p><p id="a53b13677e55fdbc670902cf2d24e401_p_31" class="ne-p"><span class="ne-text">上面这张图片是</span><code class="ne-code"><span class="ne-text">vue</span></code><span class="ne-text">官方的解释，通过</span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">$children</span></code><span class="ne-text">就可以访问组件的实例，拿到实例代表什么？代表可以访问此组件的所有方法和</span><code class="ne-code"><span class="ne-text">data</span></code><span class="ne-text">。接下来就是怎么实现拿到指定组件的实例。</span></p><p id="bb3e20f1faeaf6bf9497bffd7f381295_p_32" class="ne-p"><br></p><h4 id="ec09647d"><span class="ne-text">使用方法</span></h4><p id="73b74e66f7d869f94eb34b57d63eae3f_p_33" class="ne-p"><br></p><pre data-language="vue" id="7a587fd5" class="ne-codeblock language-vue">// 父组件中<template>  <div class="hello_world">    <div></div>    <com-a></com-a>    <button @click="changeA">点击改变子组件值</button>  </div></template><script>import ComA from './test/comA.vue'export default {  name: 'HelloWorld',  components: { ComA },  data() {    return {      msg: 'Welcome'    }  },  methods: {    changeA() {      // 获取到子组件A      this.$children[0].messageA = 'this is new value'    }  }}</script></pre><pre data-language="vue" id="rCHYu" class="ne-codeblock language-vue">// 子组件中<template>  <div class="com_a">    <span></span>    <p>获取父组件的值为:  </p>  </div></template><script>export default {  data() {    return {      messageA: 'this is old'    }  },  computed:{    parentVal(){      return this.$parent.msg;    }  }}</script></pre><div class="ne-quote"><p id="baca8b35b9df69242628141ffca869a0_p_35" class="ne-p"><span class="ne-text">要注意边界情况，如在</span><code class="ne-code"><span class="ne-text">#app</span></code><span class="ne-text">上拿</span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text">得到的是</span><code class="ne-code"><span class="ne-text">new Vue()</span></code><span class="ne-text">的实例，在这实例上再拿</span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text">得到的是</span><code class="ne-code"><span class="ne-text">undefined</span></code><span class="ne-text">，而在最底层的子组件拿</span><code class="ne-code"><span class="ne-text">$children</span></code><span class="ne-text">是个空数组。也要注意得到</span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">$children</span></code><span class="ne-text">的值不一样，</span><code class="ne-code"><span class="ne-text">$children</span></code><span class="ne-text"> 的值是数组，而</span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text">是个对象</span></p></div><p id="6f8f966688575a1f666bafa122494f73_p_36" class="ne-p"><br></p><h4 id="25f9c7fa"><span class="ne-text">总结</span></h4><p id="ab57135091a86c42cc63ec67ac068a45_p_37" class="ne-p"><br></p><p id="c9f98fb68f54448a9f9adec409bc4cbe_p_38" class="ne-p"><span class="ne-text">上面两种方式用于父子组件之间的通信， 而使用 props 进行父子组件通信更加普遍; 二者皆不能用于非父子组件之间的通信。</span></p><p id="faade82d6cfe8ed09f505bc5d9204fda_p_39" class="ne-p"><br></p><h3 id="437dd606"><span class="ne-text">三、</span><code class="ne-code"><span class="ne-text">provide</span></code><span class="ne-text">/ </span><code class="ne-code"><span class="ne-text">inject</span></code></h3><p id="17b412f9fc3ec51ada5f566f0d09108c_p_40" class="ne-p"><br></p><h4 id="6213df69"><span class="ne-text">概念:</span></h4><p id="d9d31f80b21bee6005ee4bb0be1d9a6b_p_41" class="ne-p"><br></p><p id="1a0cc332e9c0eec97da9ef6fd3dc9b58_p_42" class="ne-p"><code class="ne-code"><span class="ne-text">provide</span></code><span class="ne-text">/ </span><code class="ne-code"><span class="ne-text">inject</span></code><span class="ne-text"> 是</span><code class="ne-code"><span class="ne-text">vue2.2.0</span></code><span class="ne-text">新增的 api, 简单来说就是父组件中通过</span><code class="ne-code"><span class="ne-text">provide</span></code><span class="ne-text">来提供变量, 然后再子组件中通过</span><code class="ne-code"><span class="ne-text">inject</span></code><span class="ne-text">来注入变量。</span></p><p id="4930f2b57b08d977b4a7a79433f23490_p_43" class="ne-p"><br></p><div class="ne-quote"><p id="6071f021259eae15a0d98d5f11dbac4b_p_44" class="ne-p"><span class="ne-text">注意: 这里不论子组件嵌套有多深, 只要调用了</span><code class="ne-code"><span class="ne-text">inject</span></code><span class="ne-text"> 那么就可以注入</span><code class="ne-code"><span class="ne-text">provide</span></code><span class="ne-text">中的数据，而不局限于只能从当前父组件的 props 属性中回去数据</span></p></div><p id="0e4b859961c17882302ca1144adad96d_p_45" class="ne-p"><br></p><h4 id="dcf3dc0b"><span class="ne-text">举例验证</span></h4><p id="e81b6efc8e2153cf8aa53e3b04d7f22c_p_46" class="ne-p"><br></p><p id="7c7f50d376751d2fe628d85ee09618ef_p_47" class="ne-p"><span class="ne-text">接下来就用一个例子来验证上面的描述: 假设有三个组件: A.vue、B.vue、C.vue 其中 C 是 B 的子组件，B 是 A 的子组件</span></p><p id="aa95668f5a65b03373d1b0b3f9f8d3a6_p_48" class="ne-p"><br></p><pre data-language="vue" id="62b477b6" class="ne-codeblock language-vue">// A.vue<template>  <div>    <comB></comB>  </div></template><script>  import comB from '../components/test/comB.vue'  export default {    name: "A",    provide: {      for: "demo"    },    components:{      comB    }  }</script></pre><pre data-language="vue" id="aesPO" class="ne-codeblock language-vue">// B.vue<template>  <div>        <comC></comC>  </div></template><script>  import comC from '../components/test/comC.vue'  export default {    name: "B",    inject: ['for'],    data() {      return {        demo: this.for      }    },    components: {      comC    }  }</script></pre><pre data-language="vue" id="KqAZC" class="ne-codeblock language-vue">// C.vue<template>  <div>      </div></template><script>  export default {    name: "C",    inject: ['for'],    data() {      return {        demo: this.for      }    }  }</script></pre><h3 id="ffe7e71c"><span class="ne-text">四、</span><code class="ne-code"><span class="ne-text">ref</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">refs</span></code></h3><h4 id="YzKrJ"><span class="ne-text">基本使用</span></h4><p id="1072ea36c24eecae31028b57db98b711_p_51" class="ne-p"><code class="ne-code"><span class="ne-text">ref</span></code><span class="ne-text">：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据， 我们看一个</span><code class="ne-code"><span class="ne-text">ref</span></code><span class="ne-text"> 来访问组件的例子:</span></p><pre data-language="vue" id="f9KEp" class="ne-codeblock language-vue">// 父组件 app.vue<template>  <component-a ref="comA"></component-a></template><script>  export default {    mounted () {      const comA = this.$refs.comA;      console.log(comA.name);  // Vue.js      comA.sayHello();  // hello    }  }</script></pre><p id="bc2359f7bb1e32241fa27f528e60a125_p_52" class="ne-p"><br></p><pre data-language="vue" id="c49a6949" class="ne-codeblock language-vue">// 子组件 A.vue<p>export default {<br>data () {<br>return {<br>name: ‘Vue.js’<br>}<br>},<br>methods: {<br>sayHello () {<br>console.log(‘hello’)<br>}<br>}<br>}</pre><h4 id="Cz2f0"><span class="ne-text">和 v-for 共使用</span></h4><p id="u22aa1746" class="ne-p"><span class="ne-text">遇到过这个场景，在主组件里面需要多次渲染子组件</span></p><pre data-language="vue" id="MjLX6" class="ne-codeblock language-vue"> <!-- 直播绑定 --></p><div slot="liveBind"><AddLiveBindItemv-for="(data, index) in datas":key="data.id":dataConfig="data.dataConfig":isFirst="index === 0 ? true : false":liveBindId="index === 0? 1: index === 1? 2: index === 2? 3: index === 3? 4: index === 4? 5: 6"@toDeleteLiveBind="toDeleteLiveBind(index)"ref="addLiveBindRef"/></div></pre><p id="uae784a6c" class="ne-p"><span class="ne-text">具体使用：下面第四行代码</span></p><pre data-language="javascript" id="RlGsr" class="ne-codeblock language-javascript"> this.datas.forEach((\_it, index) => {// 当前表单的配置项遍历上传liveRelationList.push(this.$refs.addLiveBindRef[index].liveBindApiParams)// 上传 sort 参数liveRelationList[liveRelationList.length - 1].sort = \_it.id})<p></pre><h4 id="zUA4Q"><span class="ne-text">其他理解</span></h4><ul class="ne-ul"><li id="u54e5a1b7"><span class="ne-text">v-for 用于元素或组件时,引用信息将是</span><strong><span class="ne-text">包含 DOM 节点或组件实例的数组，</span></strong><span class="ne-text">按照这个理解，可以直接利用$refs来获取dom元素</span></li></ul><pre data-language="javascript" id="kpKDX" class="ne-codeblock language-javascript">this.$refs.addAlert.style.display = "block";</pre><p id="u209130bb" class="ne-p"><strong><span class="ne-text">$refs只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问$refs。这是官方说法，提倡props来操作，缺点就是非响应式的</span></strong></p><p id="ub56bb401" class="ne-p"><span class="ne-text"></span></p><p id="u567fd29b" class="ne-p"><strong><span class="ne-text">ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</span></strong></p><h3 id="6d7e6ee5"><span class="ne-text">五、eventBus</span></h3><p id="e10b5c78ee7ba45f407740af88433fc9_p_54" class="ne-p"><br></p><p id="6a46758b0a566ff1d337ce36227f583e_p_55" class="ne-p"><code class="ne-code"><span class="ne-text">eventBus</span></code><span class="ne-text"> 又称为事件总线，在 vue 中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心</span><strong><span class="ne-text">注册发送事件</span></strong><span class="ne-text">或</span><strong><span class="ne-text">接收事件</span></strong><span class="ne-text">， 所以</span><strong><span class="ne-text">组件都可以通知其他组件</span></strong><span class="ne-text">。</span></p><p id="a6e7204180aba568d27cc7b95d0717fd_p_56" class="ne-p"><br></p><div class="ne-quote"><p id="9973944624be5f0aade0adc966299174_p_57" class="ne-p"><span class="ne-text">eventBus 也有不方便之处, 当项目较大, 就容易造成难以维护的灾难</span></p></div><p id="e3c9bad72638009a374744280c63ecc6_p_58" class="ne-p"><br></p><p id="3085c6811d84ca25944e7aab016ae59b_p_59" class="ne-p"><span class="ne-text">在 Vue 的项目中怎么使用</span><code class="ne-code"><span class="ne-text">eventBus</span></code><span class="ne-text">来实现组件之间的数据通信呢? 具体通过下面几个步骤</span></p><p id="daa3e859dfee1b8825cb9c219dcb2526_p_60" class="ne-p"><br></p><h4 id="824f2b2d"><span class="ne-text">1. 初始化</span></h4><p id="d89d8c6a729313c0d25f9b1742c0d590_p_61" class="ne-p"><br></p><p id="ae2699b2afa224478e7e6cc93d0dda54_p_62" class="ne-p"><span class="ne-text">首先需要创建一个事件总线并将其导出, 以便其他模块可以使用或者监听它.</span></p><p id="87e34965e50e2c8e31ce44a85667e8dd_p_63" class="ne-p"><br></p><pre data-language="javascript" id="edaf253e" class="ne-codeblock language-javascript">// event-bus.js</p><p>import Vue from ‘vue’<br>export const EventBus = new Vue()</pre><p id="b3add770127d8c2a5064673aa8a9731f_p_64" class="ne-p"><br></p><p id="2a81d6eed31dfd1dc3c193bbdb75c1a1_p_65" class="ne-p"><br></p><p id="98de67513ec537a79ef3aa695ade51aa_p_66" class="ne-p"><span class="ne-text">假设你有两个组件: </span><code class="ne-code"><span class="ne-text">additionNum</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">showNum</span></code><span class="ne-text">, 这两个组件可以是兄弟组件也可以是父子组件；这里我们以兄弟组件为例:</span></p><p id="152302cc03cd3433e252fd8fbe4bade7_p_67" class="ne-p"><br></p><pre data-language="vue" id="9cb518fd" class="ne-codeblock language-vue"><template></p>  <div>    <show-num-com></show-num-com>    <addition-num-com></addition-num-com>  </div></template><script>import showNumCom from './showNum.vue'import additionNumCom from './additionNum.vue'export default {  components: { showNumCom, additionNumCom }}</script><p></pre><h4 id="gt0jW"><span class="ne-text">2. 发送事件</span></h4><pre data-language="vue" id="ocoY7" class="ne-codeblock language-vue">// addtionNum.vue 中发送事件</p><template>  <div>    <button @click="additionHandle">+加法器</button>      </div></template><script>import {EventBus} from './event-bus.js'console.log(EventBus)export default {  data(){    return{      num:1    }  },  methods:{    additionHandle(){      EventBus.$emit('addition', {        num:this.num++      })    }  }}</script></pre><h4 id="8ef9023b"><span class="ne-text">3. 接收事件</span></h4><p id="956e0d4312e941b77cd57ec35c294aff_p_69" class="ne-p"><br></p><pre data-language="vue" id="6011f243" class="ne-codeblock language-vue">// showNum.vue 中接收事件<template>  <div>计算和: </div></template><script>import { EventBus } from './event-bus.js'export default {  data() {    return {      count: 0    }  },  mounted() {    EventBus.$on('addition', param => {      this.count = this.count + param.num;    })  }}</script></pre><p id="67523e0fa28fe87849ce38cd391e3347_p_70" class="ne-p"><br></p><p id="854f22ccbc720f4f25f3f1e4fbae5cf0_p_71" class="ne-p"><span class="ne-text">这样就实现了在组件</span><code class="ne-code"><span class="ne-text">addtionNum.vue</span></code><span class="ne-text">中点击相加按钮, 在</span><code class="ne-code"><span class="ne-text">showNum.vue</span></code><span class="ne-text">中利用传递来的 </span><code class="ne-code"><span class="ne-text">num</span></code><span class="ne-text"> 展示求和的结果.</span></p><p id="200b796b4b1f5a36aa12caae6b6fa3d8_p_72" class="ne-p"><br></p><h4 id="964c73f0"><span class="ne-text">4. 移除事件监听者</span></h4><p id="7e9db6e1dddd1090f9cbf7742b89f0d6_p_73" class="ne-p"><br></p><p id="017aded1276858df53bbac28c927111b_p_74" class="ne-p"><span class="ne-text">如果想移除事件的监听, 可以像下面这样操作:</span></p><p id="cee026a6997be2fe2ca3b5d6e2ce2bf0_p_75" class="ne-p"><br></p><pre data-language="vue" id="9e0ff39c" class="ne-codeblock language-vue">import { eventBus } from 'event-bus.js'<p>EventBus.$off(‘addition’, {})</pre><p id="391eee0f96cca26f6e7df243706d21bf_p_76" class="ne-p"><br></p><h3 id="7968e5d8"><span class="ne-text">六、Vuex</span></h3><p id="9fc1a1e32cf7c324fef5888bc3009382_p_77" class="ne-p"><br></p><h4 id="0178c857"><span class="ne-text">1. Vuex 介绍</span></h4><p id="f585fed1cef9af7641b65ac1c4919258_p_78" class="ne-p"><br></p><p id="f31764caf4edb6337889991729dab76f_p_79" class="ne-p"><span class="ne-text">Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. Vuex 解决了</span><code class="ne-code"><span class="ne-text">多个视图依赖于同一状态</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">来自不同视图的行为需要变更同一状态</span></code><span class="ne-text">的问题，将开发者的精力聚焦于数据的更新而不是数据在组件之间的传递上</span></p><p id="cacc5e28cdefa24e262c83e0ab2a3ade_p_80" class="ne-p"><br></p><h4 id="6fb77009"><span class="ne-text">2. Vuex 各个模块</span></h4><p id="00780844004a7920ee455d8665291201_p_81" class="ne-p"><br></p><ol class="ne-ol"><li id="086fc566ad1f3e20b5c4075a7729ead3_li_2"><code class="ne-code"><span class="ne-text">state</span></code><span class="ne-text">：用于数据的存储，是 store 中的唯一数据源</span></li></ol><ol start="2" class="ne-ol"><li id="8f90ea99e20515a11d0d1c9f1f7e0553_li_3"><code class="ne-code"><span class="ne-text">getters</span></code><span class="ne-text">：如 vue 中的计算属性一样，基于 state 数据的二次包装，常用于数据的筛选和多个数据的相关性计算</span></li></ol><ol start="3" class="ne-ol"><li id="e6273b5a39a57288e5a1a89f2bc1fcfe_li_4"><code class="ne-code"><span class="ne-text">mutations</span></code><span class="ne-text">：类似函数，改变 state 数据的唯一途径，且不能用于处理异步事件</span></li></ol><ol start="4" class="ne-ol"><li id="a7a27b1b632925547190afbe9ad7fb4b_li_5"><code class="ne-code"><span class="ne-text">actions</span></code><span class="ne-text">：类似于</span><code class="ne-code"><span class="ne-text">mutation</span></code><span class="ne-text">，用于提交</span><code class="ne-code"><span class="ne-text">mutation</span></code><span class="ne-text">来改变状态，而不直接变更状态，可以包含任意异步操作</span></li></ol><ol start="5" class="ne-ol"><li id="d03ef67930c7afc0424138385fa658e8_li_6"><code class="ne-code"><span class="ne-text">modules</span></code><span class="ne-text">：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护</span></li></ol><p id="ede07f6666baf1587414d7171c5dd877_p_82" class="ne-p"><br></p><h4 id="62a341a5"><span class="ne-text">3. Vuex 实例应用</span></h4><p id="187832c794b601f7094c1a9b20086a6b_p_83" class="ne-p"><br></p><pre data-language="vue" id="e46f446f" class="ne-codeblock language-vue">// 父组件</p><template>  <div id="app">    <ChildA/>    <ChildB/>  </div></template><script>  import ChildA from './components/ChildA' // 导入A组件  import ChildB from './components/ChildB' // 导入B组件  export default {    name: 'App',    components: {ChildA, ChildB} // 注册A、B组件  }</script></pre><pre data-language="vue" id="PKLnQ" class="ne-codeblock language-vue">// 子组件childA<template>  <div id="childA">    <h1>我是A组件</h1>    <button @click="transform">点我让B组件接收到数据</button>    <p>因为你点了B，所以我的信息发生了变化：</p>  </div></template><script>  export default {    data() {      return {        AMessage: 'Hello，B组件，我是A组件'      }    },    computed: {      BMessage() {        // 这里存储从store里获取的B组件的数据        return this.$store.state.BMsg      }    },    methods: {      transform() {        // 触发receiveAMsg，将A组件的数据存放到store里去        this.$store.commit('receiveAMsg', {          AMsg: this.AMessage        })      }    }  }</script></pre><pre data-language="vue" id="a9Da8" class="ne-codeblock language-vue">// 子组件 childB<template>  <div id="childB">    <h1>我是B组件</h1>    <button @click="transform">点我让A组件接收到数据</button>    <p>因为你点了A，所以我的信息发生了变化：</p>  </div></template><script>  export default {    data() {      return {        BMessage: 'Hello，A组件，我是B组件'      }    },    computed: {      AMessage() {        // 这里存储从store里获取的A组件的数据        return this.$store.state.AMsg      }    },    methods: {      transform() {        // 触发receiveBMsg，将B组件的数据存放到store里去        this.$store.commit('receiveBMsg', {          BMsg: this.BMessage        })      }    }  }</script></pre><p id="d2ef17a7a18d8c7e67af8d1ea686174e_p_85" class="ne-p"><span class="ne-text">vuex 的</span><code class="ne-code"><span class="ne-text">store,js</span></code></p><p id="c07d4a2054239914d4a014d7d64fcf23_p_86" class="ne-p"><br></p><pre data-language="javascript" id="f958524d" class="ne-codeblock language-javascript">import Vue from 'vue'<p>import Vuex from ‘vuex’<br>Vue.use(Vuex)<br>const state = {<br>// 初始化 A 和 B 组件的数据，等待获取<br>AMsg: ‘’,<br>BMsg: ‘’<br>}</p><p>const mutations = {<br>receiveAMsg(state, payload) {<br>// 将 A 组件的数据存放于 state<br>state.AMsg = payload.AMsg<br>},<br>receiveBMsg(state, payload) {<br>// 将 B 组件的数据存放于 state<br>state.BMsg = payload.BMsg<br>}<br>}</p><p>export default new Vuex.Store({<br>state,<br>mutations<br>})</pre><p id="bd67236b6b40e1ddeba66aa4c905c5af_p_87" class="ne-p"><br></p><h3 id="167c14dd"><span class="ne-text">七、</span><code class="ne-code"><span class="ne-text">localStorage</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">sessionStorage</span></code></h3><p id="ac4c0d2013d04adfac6d2e9459525ac0_p_88" class="ne-p"><br></p><p id="f283288775a2632e08501548c88fd4d5_p_89" class="ne-p"><span class="ne-text">这种通信比较简单, 缺点是数据和状态比较混乱, 不太容易维护。 通过</span><code class="ne-code"><span class="ne-text">window.localStorage.getItem(key)</span></code><span class="ne-text">获取数据 通过</span><code class="ne-code"><span class="ne-text">window.localStorage.setItem(key,value)</span></code><span class="ne-text">存储数据</span></p><p id="700ece5e21ebc17eb29d438c814531fe_p_90" class="ne-p"><br></p><div class="ne-quote"><p id="5f8a28e0e191bf5002124d4728a6494d_p_91" class="ne-p"><span class="ne-text">注意用</span><code class="ne-code"><span class="ne-text">JSON.parse()</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">JSON.stringify()</span></code><span class="ne-text"> 做数据格式转换（localStorage 和 sessionStorage 只能存字符串，会自动调用对象的 toString 方法）</span></p><p id="udd314bb5" class="ne-p"><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">localStorage</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">sessionStorage</span></code><span class="ne-text">可以结合</span><code class="ne-code"><span class="ne-text">vuex</span></code><span class="ne-text">, 实现数据的持久保存, 同时使用 </span><code class="ne-code"><span class="ne-text">vuex</span></code><span class="ne-text">解决数据和状态混乱问题.</span></p></div><p id="f82a35c2fca60d6b3bdc5c1000201985_p_92" class="ne-p"><br></p><pre data-language="javascript" id="juYGQ" class="ne-codeblock language-javascript">// 存取<br>sessionStorage.setItem(<br>'sortColumn',<br>JSON.stringify({ prop: column.prop, order: column.order })<br>)</p><p>// 使用<br>this.sortColumnSession = JSON.parse(<br>sessionStorage.getItem(‘sortColumn’)<br>)</pre><h3 id="42eac076"><span class="ne-text">八 </span><code class="ne-code"><span class="ne-text">$attrs</span></code><span class="ne-text">与 </span><code class="ne-code"><span class="ne-text">$listeners</span></code></h3><p id="92499751fabe053dd037c1574d6f4fb2_p_93" class="ne-p"><br></p><p id="5ee232d8069a64f0310d67c6cba2c264_p_94" class="ne-p"><span class="ne-text">现在我们来讨论一种情况， 我们一开始给出的组件关系图中 A 组件与 D 组件是隔代关系， 那它们之前进行通信有哪些方式呢？</span></p><p id="45f9c401f99c8bc813e223381c98f09b_p_95" class="ne-p"><br></p><ol class="ne-ol"><li id="83215d9ee7c1694d1bc3e76f305d7e9e_li_7"><span class="ne-text">使用</span><code class="ne-code"><span class="ne-text">props</span></code><span class="ne-text">绑定来进行一级一级的信息传递, 如果 D 组件中状态改变需要传递数据给 A, 使用事件系统一级级往上传递</span></li></ol><ol start="2" class="ne-ol"><li id="2c686f3d4e49b6f903a7a060cca635e2_li_8"><span class="ne-text">使用</span><code class="ne-code"><span class="ne-text">eventBus</span></code><span class="ne-text">, 这种情况下还是比较适合使用, 但是碰到多人合作开发时, 代码维护性较低, 可读性也低</span></li></ol><ol start="3" class="ne-ol"><li id="1adc8d2e29da201c9f819b96e079ce85_li_9"><span class="ne-text">使用 Vuex 来进行数据管理, 但是如果仅仅是传递数据, 而不做中间处理, 使用 Vuex 处理感觉有点大材小用了.</span></li></ol><p id="cd1514dfedaab485e5767b166731e116_p_96" class="ne-p"><br></p><p id="1660fc758c7e386ee6c1caa5c0ba61fd_p_97" class="ne-p"><span class="ne-text">在</span><code class="ne-code"><span class="ne-text">vue2.4</span></code><span class="ne-text">中，为了解决该需求，引入了</span><code class="ne-code"><span class="ne-text">$attrs</span></code><span class="ne-text"> 和</span><code class="ne-code"><span class="ne-text">$listeners</span></code><span class="ne-text"> ， 新增了</span><code class="ne-code"><span class="ne-text">inheritAttrs</span></code><span class="ne-text"> 选项。 在版本 2.4 以前，默认情况下, 父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)，将会 “回退” 且作为普通的 HTML 特性应用在子组件的根元素上。接下来看一个跨级通信的例子:</span></p><p id="545db91b827f87cc9afe81c0f08a1a88_p_98" class="ne-p"><br></p><pre data-language="vue" id="e9b0c8ad" class="ne-codeblock language-vue">// app.vue<br>// index.vue</p><template>  <div>    <child-com1      :name="name"      :age="age"      :gender="gender"      :height="height"      title="程序员成长指北"    ></child-com1>  </div></template><script>const childCom1 = () => import("./childCom1.vue");export default {  components: { childCom1 },  data() {    return {      name: "zhang",      age: "18",      gender: "女",      height: "158"    };  }};</script></pre><pre data-language="vue" id="nSfDK" class="ne-codeblock language-vue">// childCom1.vue<template class="border">  <div>    <p>name: </p>    <p>childCom1的$attrs: </p>    <child-com2 v-bind="$attrs"></child-com2>  </div></template><script>const childCom2 = () => import("./childCom2.vue");export default {  components: {    childCom2  },  inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性  props: {    name: String // name作为props属性绑定  },  created() {    console.log(this.$attrs);     // { "age": "18", "gender": "女", "height": "158", "title": "程序员成长指北" }  }};</script></pre><pre data-language="vue" id="Yi0SC" class="ne-codeblock language-vue">// childCom2.vue<template>  <div class="border">    <p>age: </p>    <p>childCom2: </p>  </div></template><script><p>export default {<br>inheritAttrs: false,<br>props: {<br>age: String<br>},<br>created() {<br>console.log(this.$attrs);<br>    // { “gender”: “女”, “height”: “158”, “title”: “程序员成长指北” }<br>  }<br>};<br></script></pre><h3 id="25f9c7fa-1"><span class="ne-text">总结</span></h3><p id="ec69cd8d8f73ee437722723e0adf1fa7_p_100" class="ne-p"><br></p><p id="d1dd1ab4b6c9dd3f0d10d775396b2c46_p_101" class="ne-p"><span class="ne-text">常见使用场景可以分为三类:</span></p><p id="a2c2ab33193f15adcdff2e08f718d7c2_p_102" class="ne-p"><br></p><ul class="ne-ul"><li id="38d84b7f285f00e4e99192b24cdc3891_li_10"><span class="ne-text">父子组件通信: </span><code class="ne-code"><span class="ne-text">props</span></code><span class="ne-text">; </span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">$children</span></code><span class="ne-text">; </span><code class="ne-code"><span class="ne-text">provide</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">inject</span></code><span class="ne-text"> ; </span><code class="ne-code"><span class="ne-text">ref</span></code><span class="ne-text"> ; </span><code class="ne-code"><span class="ne-text">$attrs</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">$listeners</span></code></li></ul><ul class="ne-ul"><li id="3e789b8578fdd7d181db9f576fa76889_li_11"><span class="ne-text">兄弟组件通信: </span><code class="ne-code"><span class="ne-text">eventBus</span></code><span class="ne-text"> ; vuex</span></li></ul><ul class="ne-ul"><li id="e10c2c9737bf8956c62733553c8b2e96_li_12"><span class="ne-text">跨级通信: </span><code class="ne-code"><span class="ne-text">eventBus</span></code><span class="ne-text">；Vuex；</span><code class="ne-code"><span class="ne-text">provide</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">inject</span></code><span class="ne-text"> 、</span><code class="ne-code"><span class="ne-text">$attrs</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">$listeners</span></code></li></ul><p id="1fde78b69ce88c86f4251c4f97a3b4b1_p_104" class="ne-p"><br></p><p id="de46638becbf26f6c7e35f22ece99363_p_108" class="ne-p"><span class="ne-text"><br></span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue3学习笔记</title>
      <link href="/blog/vue_watch_summary/"/>
      <url>/blog/vue_watch_summary/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u35574d72" class="ne-p"><span class="ne-text">前言：以官方文档为蓝本的Vue学习过程中，需要的一些细节以及实际开发中遇到的总结点。</span></p><p id="u13c85002" class="ne-p"><span class="ne-text"></span></p><p id="uae4616b4" class="ne-p"><span class="ne-text">Vue的学习过程中，主要分几个大块：</span></p><ul class="ne-ul"><li id="u4a49a6cf"><span class="ne-text">基础知识：框架自行的一些语法（官网里面的</span><strong><span class="ne-text">基础</span></strong><span class="ne-text">）</span></li><li id="u3fb0af83"><span class="ne-text">组件相关：尤其是组件之间的各类通信方式，在写/抽离组件里面经常用到，单独一篇文章总结。</span></li></ul><p id="u33946860" class="ne-p"><span class="ne-text">官方文档：</span></p><ul class="ne-ul"><li id="ub821cf9f"><span class="ne-text">Vue 2.x：</span><a href="https://cn.vuejs.org/v2/guide/" data-href="https://cn.vuejs.org/v2/guide/" target="_blank" class="ne-link"><span class="ne-text">https://cn.vuejs.org/v2/guide/</span></a></li><li id="uadbfc50c"><span class="ne-text">Vue 3：</span><a href="https://v3.cn.vuejs.org/guide/introduction.html" data-href="https://v3.cn.vuejs.org/guide/introduction.html" target="_blank" class="ne-link"><span class="ne-text">https://v3.cn.vuejs.org/guide/introduction.html</span></a></li></ul><h2 id="m4rPC"><span class="ne-text">计算属性+方法+侦听器</span></h2><h3 id="mjBke"><span class="ne-text">计算属性（computed）和方法（methods）的区别</span></h3><ul class="ne-ul"><li id="u572fc722"><span class="ne-text">计算属性是基于他们的依赖来进行缓存的</span></li></ul><p id="u54f7a988" class="ne-p"><span class="ne-text">“他们的依赖”指的是data数据域中的data数据，如果其变动，计算属性值才会变</span></p><ul class="ne-ul"><li id="uf5df7301"><span class="ne-text">方法不存在缓存</span></li></ul><h3 id="sYAUz"><span class="ne-text">计算属性（computed）和侦听器（watch）的使用</span></h3><ul class="ne-ul"><li id="uba2b8ac8"><span class="ne-text">侦听器更用于异步或是开销较大的操作</span></li></ul><p id="ubde6c341" class="ne-p"><span class="ne-text">文档：</span><a href="https://cn.vuejs.org/v2/api/#watch" data-href="https://cn.vuejs.org/v2/api/#watch" target="_blank" class="ne-link"><span class="ne-text">https://cn.vuejs.org/v2/api/#watch</span></a></p><h3 id="KW8mQ"><span class="ne-text">侦听器（watch）的一些注意事项</span></h3><p id="uf59f37a1" class="ne-p"><span class="ne-text">实际开发过程中：</span></p><ul class="ne-ul"><li id="uacba8ec2"><strong><span class="ne-text">非的确必要，尽量不要使用watch监听，实际过程中，会造成许多问题，比如渲染顺序等，会给后续添加功能带来难以维护的问题</span></strong></li><li id="u4800cbab"><span class="ne-text">当监听的数据不是一个简单的基本类型，比如一个对象，一个数组，此时应该使用深度监听：deep:true；当想让监听器一启动就触发一次watch，应该使用： immediate: true。</span></li></ul><div class="ne-quote"><p id="ub31b8966" class="ne-p"><span class="ne-text">直接</span><code class="ne-code"><span class="ne-text">watch</span></code><span class="ne-text">监听对象内的是检测不到变化的，因为对象的指向并没有发生改变。Vue中的watch监听对象内属性的变动方案</span></p></div><h4 id="U7lp1"><span class="ne-text">使用deep属性</span></h4><p id="ueea09cc3" class="ne-p"><br></p><pre data-language="javascript" id="JlOvU" class="ne-codeblock language-javascript">new Vue({<p>data: {<br>count: 10，<br>blog:{<br>title:’my-blog’,<br>categories:[]<br>}<br>},<br>watch: {<br>blog:{<br>handler(newVal,oldVal){<br>console.log(<code>new: $&#123;newVal&#125;, old: $&#123;oldVal&#125;</code>);<br>},<br>deep:true<br>}<br>}<br>})</pre><p id="u22fd44d5" class="ne-p"></p></p><p id="uc92302d5" class="ne-p"><span class="ne-text">里面的</span><code class="ne-code"><span class="ne-text">deep</span></code><span class="ne-text">设为了</span><code class="ne-code"><span class="ne-text">true</span></code><span class="ne-text">，这样的话，如果修改了这个</span><code class="ne-code"><span class="ne-text">blog</span></code><span class="ne-text">中的任何一个属性，都会执行</span><code class="ne-code"><span class="ne-text">handler</span></code><span class="ne-text">这个方法。不过这样会造成更多的性能开销，尤其是对象里面属性过多，结构嵌套过深的时候。而且有时候我们就只想关心这个对象中的某个特定属性，这个时候可以这样</span></p><p id="u1d8300e8" class="ne-p"></p><h4 id="F2YBm"><span class="ne-text">用字符串来表示对象的属性调用</span></h4><p id="uee6141a0" class="ne-p"></p><pre data-language="javascript" id="ZtlsV" class="ne-codeblock language-javascript">new Vue({  data: {    count: 10，    blog:{        title:'my-blog',        categories:[]    }  },  watch: {    'blog.categories'(newVal, oldVal) {        console.log(`new:${newVal}, old:${oldVal}`);    },   }})</pre><h4 id="aAOEA"><span class="ne-text">使用计算属性(computed)</span></h4><p id="uefb40a42" class="ne-p"></p><pre data-language="javascript" id="ucCyw" class="ne-codeblock language-javascript">new Vue({  data: {    count: 10，    blog:{        title:'my-blog',        categories:[]    }  },  computed: {    categories() {      return this.blog.categories;    }  },  watch: {    categories(newVal, oldVal) {      console.log(`new:${newVal}, old:${oldVal}`);    },   },})</pre><p id="u7e9d13d4" class="ne-p"><span class="ne-text">参考：</span><a href="https://segmentfault.com/a/1190000018080301" data-href="https://segmentfault.com/a/1190000018080301" target="_blank" class="ne-link"><span class="ne-text">https://segmentfault.com/a/1190000018080301</span></a></p><p id="udb758c25" class="ne-p"></p><h2 id="vg9rS"><span class="ne-text">生命周期实践理解</span></h2><p id="u431286ce" class="ne-p"><span class="ne-text">vue2当中：</span></p><ol class="ne-ol"><li id="u03072dc1"><span class="ne-text">beforeCreate：在实例初始化之后，数据观测和事件配置之前被调用</span></li><li id="u7f6830af"><span class="ne-text">created：在实例创建完成后被立即调用</span></li><li id="u363a87ca"><span class="ne-text">beforeMount：在挂载开始之前被调用</span></li><li id="u8c6e7b07"><span class="ne-text">mounted：el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子</span></li><li id="ub431174c"><span class="ne-text">beforeUpdate：数据更新时调用，发生在虚拟DOM打补丁之前</span></li><li id="ud4c52258"><span class="ne-text">updated：由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子</span></li><li id="u5cb6441c"><span class="ne-text">beforeDestroy：实例销毁之前调用</span></li><li id="ue81310ec"><span class="ne-text">destroyed：实例销毁后调用</span></li></ol><p id="u2b15d174" class="ne-p"><span class="ne-text"></span></p><pre data-language="vue" id="GDOuK" class="ne-codeblock language-vue"><script>  setup() {    console.log('----setup第一个执行----')    // vue3.x生命周期写在setup中    onBeforeMount(() => {      console.log('------vue3中onBeforeMount-----')    })    onMounted(() => {      console.log('------vue3中onMounted-----')    })    onRenderTriggered((event) => {      console.log('------vue3中onRenderTriggered-----', event)    })  },  // vue2当中的  beforeCreate() {    console.log('----vue2中beforeCreate第二个执行----')  },  // vue2当中的  created() {    console.log('----vue2中created第三个执行----')  },</script></pre><p id="u20c2d491" class="ne-p"><span class="ne-text">执行结果如下：</span></p><p id="u9c80ce3d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644646841871-0aaeece1-c5dd-493e-bbfc-41f52925931a.png" width="792" id="ue1197c21" class="ne-image"></p><h2 id="czTye"><span class="ne-text">Vue3.x相交Vue2.x的API差异</span></h2><ul class="ne-ul"><li id="udfa929fa"><span class="ne-text">参考教程：</span><a href="https://juejin.cn/post/6940454764421316644" data-href="https://juejin.cn/post/6940454764421316644" target="_blank" class="ne-link"><span class="ne-text">Vue3.0 新特性以及使用经验总结</span></a></li></ul><h3 id="QYCPq"><span class="ne-text">组合式API</span></h3><p id="u61da0c00" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1656489570886-63eb7df3-919e-4746-a848-ef1ddd407c5a.png" width="262" id="uea796c27" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1656489575312-5aa30517-52d0-4b73-be74-1f4bb4ad6a36.png" width="1200" id="u691dd2fb" class="ne-image"></p><h3 id="LQcQP"><span class="ne-text">defineComponent({})</span></h3><p id="u8ccaffb0" class="ne-p"><span class="ne-text">服务于typescript项目，defineComponent 本身的功能很简单，但是最主要的功能是为了 ts 下的类型推导。对于一个 ts 文件，如果我们直接写</span></p><pre data-language="vue" id="tS2xN" class="ne-codeblock language-vue">export default {}</pre><p id="uf5a4f1ff" class="ne-p"><span class="ne-text">对于编辑器而言，{} 只是一个 Object 的类型，无法有针对性的提示我们对于 vue 组件来说 {} 里应该有哪些属性。但是增加一层 defineComponet 的话，</span></p><pre data-language="html" id="yG1ro" class="ne-codeblock language-html">export default defineComponent({})</pre><p id="u0fa05172" class="ne-p"><span class="ne-text">这时，{} 就变成了 defineComponent 的参数，那么对参数类型的提示，就可以实现对 {} 中属性的提示，外还可以进行对参数的一些类型推导等操作。</span></p><h3 id="Snle0"><span class="ne-text">setup()</span></h3><pre data-language="vue" id="SyiLH" class="ne-codeblock language-vue"><script>  setup() {    console.log('----setup第一个执行----')    // vue3.x生命周期写在setup中    onBeforeMount(() => {      console.log('------vue3中onBeforeMount-----')    })    onMounted(() => {      console.log('------vue3中onMounted-----')    })    // 调试哪些数据发生了变化    onRenderTriggered((event) => {      console.log('------vue3中onRenderTriggered-----', event)    })    // ref则处理 js 基础类型的双向绑定，也能处理对象    const year = ref(0)    // reactive用于处理对象的双向绑定    const user = reactive({nickname: 'xiaofan', age: 26, gender: '女'})    const timer = setInterval(() => {      year.value++      user.age++      if (year.value === 2) {        clearInterval(timer)      }    }, 1000)    // 侦听 reactive 定义的数据    watch(      () => user.age,      (curAge, preAge) => {        console.log('reactive新值:', curAge, 'reactive老值:', preAge)      }    )    // 侦听 ref 定义的数据    watch(year, (newVal, oldVal) => {      console.log('ref新值:', newVal, 'ref老值:', oldVal)    })    // 也可以使用 toRefs 实现导出时候进行对象结构    return {      year,      user,      blockContent: `AntV 是蚂蚁。`,    }  },</script></pre><p id="ufb01a703" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644647050857-a30d7d7c-d2e1-49a4-9695-58d1505df9b2.png" width="774" id="u5882a31f" class="ne-image"></p><h3 id="FOUys"><span class="ne-text">watch</span></h3><pre data-language="vue" id="G4aM6" class="ne-codeblock language-vue"><script lang="ts">import {  defineComponent,  onBeforeMount,  onMounted,  onBeforeUpdate,  onUpdated,  onBeforeUnmount,  onUnmounted,  onErrorCaptured,  onRenderTracked,  onRenderTriggered,  reactive,  ref,  watch,} from 'vue'import {  UpCircleTwoTone,  HomeOutlined,  SettingFilled,  SmileOutlined,  SyncOutlined,  LoadingOutlined,  ClockCircleOutlined,} from '@ant-design/icons-vue'<p>export default defineComponent({<br>components: {<br>HomeOutlined,<br>SettingFilled,<br>SmileOutlined,<br>SyncOutlined,<br>LoadingOutlined,<br>UpCircleTwoTone,<br>ClockCircleOutlined,<br>},<br>data() {<br>return {<br>msg: ‘msg in data’,<br>}<br>},<br>setup() {<br>console.log(‘—-setup 第一个执行—-‘)<br>// vue3.x 生命周期写在 setup 中<br>onBeforeMount(() =&gt; {<br>console.log(‘——vue3 中 onBeforeMount—–’)<br>})<br>onMounted(() =&gt; {<br>console.log(‘——vue3 中 onMounted—–’)<br>})<br>// 调试哪些数据发生了变化<br>onRenderTriggered((event) =&gt; {<br>console.log(‘——vue3 中 onRenderTriggered—–’, event)<br>})<br>// ref 则处理 js 基础类型的双向绑定，也能处理对象<br>const year = ref(0)<br>// reactive 用于处理对象的双向绑定<br>const user = reactive({nickname: ‘xiaofan’, age: 26, gender: ‘女’})<br>const timer = setInterval(() =&gt; {<br>year.value++<br>user.age++<br>if (year.value === 2) {<br>clearInterval(timer)<br>}<br>}, 1000)<br>// 侦听 reactive 定义的数据<br>watch(<br>() =&gt; user.age,<br>(curAge, preAge) =&gt; {<br>console.log(‘reactive 新值:’, curAge, ‘reactive 老值:’, preAge)<br>}<br>)<br>// 侦听 ref 定义的数据<br>watch(year, (newVal, oldVal) =&gt; {<br>console.log(‘ref 新值:’, newVal, ‘ref 老值:’, oldVal)<br>})<br>// 也可以使用 toRefs 实现导出时候进行对象结构<br>return {<br>year,<br>user,<br>blockContent: <code>AntV 是蚂蚁金服全新一代数据可视化解决方案，致力于提供一套简单方便、专业可靠、不限可能的数据可视化最佳实践。得益于丰富的业务场景和用户需求挑战，AntV 经历多年积累与不断打磨，已支撑整个阿里集团内外 20000+ 业务系统，通过了日均千万级 UV 产品的严苛考验。 我们正在基础图表，图分析，图编辑，地理空间可视化，智能可视化等各个可视化的领域耕耘，欢迎同路人一起前行。</code>,<br>}<br>},<br>// vue2 当中的<br>beforeCreate() {<br>console.log(‘—-vue2 中 beforeCreate 第二个执行—-‘)<br>},<br>// vue2 当中的<br>created() {<br>console.log(‘—-vue2 中 created 第三个执行—-‘)<br>},<br>})<br></script></pre><h2 id="vTO6p"><span class="ne-text">vue3 路由相关</span></h2><ul class="ne-ul"><li id="uae37aca4"><a href="https://blog.csdn.net/animatecat/article/details/117257037" data-href="https://blog.csdn.net/animatecat/article/details/117257037" target="_blank" class="ne-link"><span class="ne-text">vue3.0 router 路由跳转传参（router.push）</span></a></li><li id="u8666641b"><a href="https://juejin.cn/post/6962528855513006117" data-href="https://juejin.cn/post/6962528855513006117" target="_blank" class="ne-link"><span class="ne-text">【Vue】015. Vue-Router（三）—— 路由传参</span></a></li><li id="u1fbdb709"><span class="ne-text">官网：</span><a href="https://router.vuejs.org/zh/" data-href="https://router.vuejs.org/zh/" target="_blank" class="ne-link"><span class="ne-text">https://router.vuejs.org/zh/</span></a></li></ul><h3 id="AOnGe"><span class="ne-text">得到动态路由信息</span></h3><ul class="ne-tl"><li checked="true" id="u86642b2e"><span class="ne-text">在</span><code class="ne-code"><span class="ne-text">index.ts</span></code><span class="ne-text">中得不到该路由页面的相关信息</span><span class="ne-text" style="text-decoration: line-through">===选一个比较好一点的传值方案，最好在路由 index.ts 设置（props）。</span><span class="ne-text">在路由使用组件中就可以使用。</span></li></ul><p id="u63a3d992" class="ne-p"><span class="ne-text">参考：</span><a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html" data-href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html" target="_blank" class="ne-link"><span class="ne-text">https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html</span></a></p><pre data-language="vue" id="lRvAm" class="ne-codeblock language-vue"><script lang="ts"><br>import {useRouter} from 'vue-router'<br>export default defineComponent({<br>setup() {<br>// 获取当前路由<br>const router = useRouter()<br>// 路由信息<br>const router_info = router.currentRoute.value<br>const lookRouter = () => {<br>console.log(router_info)<br>}</p><pre><code>return &#123;  router_info,  lookRouter,&#125;&#125;,</code></pre><p>})</p><p></script></pre><h2 id="sXl99"><span class="ne-text">定义数据</span></h2><h3 id="opEG9"><span class="ne-text">Vue3 定义普通数据</span></h3><ul class="ne-ul"><li id="u6c4309f4"><span class="ne-text">【不建议】：也还可以使用 Vue2 中的 data，但是不能在 setup()中使用 this 访问</span></li></ul><p id="uf0a14d9c" class="ne-p"><strong><span class="ne-text">不再用 vue2 当中的 data API 了（因为不能进行操作，功能性大大减少）</span></strong></p><ul class="ne-ul"><li id="u59c72cb0"><span class="ne-text">【建议】：使用 ts 的接口类型定义数据</span></li></ul><pre data-language="vue" id="wC2yt" class="ne-codeblock language-vue"><script lang="ts"><br>import {defineComponent} from 'vue'</p><p>// 高效应用场景<br>interface SpecialFunDataItem {<br>title: string<br>description: string<br>}<br>const apply_data: SpecialFunDataItem[] = [<br>{<br>title: ‘知识库/项目文档/产品手册’,<br>description:<br>‘适合团队知识库建设、项目文档，开发手册、技术手册、API Document、在线写作。 适用于大型文档，目录检索式布局，多文档，多级分类排版。’,<br>},<br>{<br>title: ‘帮助中心/FAQ/在线问答’,<br>description:<br>‘适合团队知识库建设、项目文档，开发手册、技术手册、API Document、在线写作。 适用于大型文档，目录检索式布局，多文档，多级分类排版。’,<br>},<br>{<br>title: ‘企业内部/外部知识管理’,<br>description:<br>‘适合团队知识库建设、项目文档，开发手册、技术手册、API Document、在线写作。 适用于大型文档，目录检索式布局，多文档，多级分类排版。’,<br>},<br>{<br>title: ‘第四个标题’,<br>description:<br>‘适合团队知识库建设、项目文档，开发手册、技术手册、API Document、在线写作。 适用于大型文档，目录检索式布局，多文档，多级分类排版。’,<br>},<br>]</p><p>export default defineComponent({<br>name: ‘Home’,<br>components: {},<br>setup() {<br>return {<br>apply_data,<br>}<br>},<br>})<br></script></pre><h3 id="u5iUn"><span class="ne-text">Vue3 定义响应数据</span></h3><h4 id="Mp2Px"><span class="ne-text">ref</span></h4><pre data-language="typescript" id="thSSO" class="ne-codeblock language-typescript"> <a-modal<br>v-model:visible="visible"<br>:title="updateItem === 'delete_user' ? '删除账户' : '修改信息'"<br>@ok="handleOkInfo"<br>@cancel="handleCancelInfo"<br>ok-text="确认"<br>cancel-text="取消" ><br>// -----------------------------------------------------------------------<br>import {ref} from 'vue'</p><p>const visible = ref<boolean>(false)<br>const handleOkInfo = (e: MouseEvent) =&gt; {<br>visible.value = false<br>}</p><pre><code>return &#123;  visible,&#125;&lt;/pre&gt;&lt;h4 id=&quot;Q3CuW&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;reactive&lt;/span&gt;&lt;/h4&gt;&lt;p id=&quot;u6466c8ca&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;这个更过使用在对象和数组类型的响应式定义数据，因为在vue2中，对于数组和对象是不能够响应式的需要监听，而在vue3中，以此作为优化来定义响应式数据。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;u9532c015&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p id=&quot;u8a4b54fd&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p id=&quot;u37aecddc&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;h3 id=&quot;w8Utk&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;Vue2中的data&lt;/span&gt;&lt;/h3&gt;&lt;h4 id=&quot;PtTx4&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;如何在setup中使用data中的数据库？&lt;/span&gt;&lt;/h4&gt;&lt;p id=&quot;ud3222ed5&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;按照以前vue2，直接使用this可以访问到data中定义的数据，但在vue3不行，因为setup()函数的执行要比created，oncrated函数都要早。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;u9da72a0e&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;u34d7ae55&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;具体使用以下小技巧可以访问到：&lt;/span&gt;&lt;/p&gt;&lt;pre data-language=&quot;javascript&quot; id=&quot;rEYAp&quot; class=&quot;ne-codeblock language-javascript&quot;&gt;&lt;div v-on:click=&quot;fun(testdata)&quot;&gt;&lt;/div&gt;</code></pre><p>setup(){<br>const fun=(i)=&gt;{<br>alert(i)<br>}<br>},<br>data(){<br>return{<br>testdata:1,<br>}<br>}</pre><p id="u67e03fdc" class="ne-p"><span class="ne-text">也可以使用 getCurrentInstance 方法获取 data 内的数据</span><strong><span class="ne-text" style="color: #E8323C">（未验证）</span></strong></p><pre data-language="vue" id="iLyVE" class="ne-codeblock language-vue"><script lang="ts"><br>import { getCurrentInstance } from "vue";<br>export default {<br>data() {<br>return {<br>b: "data 数据",<br>};<br>},<br>setup() {<br>const datab = getCurrentInstance();<br>async function getdata(){<br>let dataa=datab.data.b;<br>console.log(dataa)<br>}<br>},<br>};<br></script></pre><p id="uf6f7e0e6" class="ne-p"><br></p><p id="ucd151af5" class="ne-p"><br></p><p id="u7f100b9d" class="ne-p"><br></p><p id="u001ae676" class="ne-p"><br></p><p id="u0d7a7da1" class="ne-p"><br></p><p id="udb42f87e" class="ne-p"><br></p><p id="u0a96b094" class="ne-p"><br></p><p id="u6e7cfd62" class="ne-p"><br></p><p id="udad91284" class="ne-p"><br></p><p id="ubc16170e" class="ne-p"><br></p><h2 id="Rg0rz"><span class="ne-text">其他知识</span></h2><h3 id="lByqY"><span class="ne-text">样式只在当前页面有效</span></h3><p id="u9daaaa0e" class="ne-p"><span class="ne-text">组件中 style 标签后面加上</span><code class="ne-code"><span class="ne-text">scoped</span></code><span class="ne-text">就可以</span></p><pre data-language="vue" id="L5MG7" class="ne-codeblock language-vue"><style lang="less" scoped></style></pre><p id="u3c98593b" class="ne-p"><br></p><p id="u630626b8" class="ne-p"><br></p><p id="u19c17d8e" class="ne-p"><br></p><p id="u3c8838f5" class="ne-p"><br></p><p id="ueed9157c" class="ne-p"><br></p><p id="udb738c5b" class="ne-p"><br></p><p id="uebae97e4" class="ne-p"><br></p><p id="uf883b410" class="ne-p"><br></p><p id="uc3d09de7" class="ne-p"><br></p><p id="u193f20ce" class="ne-p"><br></p><p id="u9db27b6c" class="ne-p"><br></p><p id="u86b1a3f9" class="ne-p"><br></p><p id="u7b30a369" class="ne-p"><br></p><p id="u9b80f4c1" class="ne-p"><br></p><p id="ub54392a9" class="ne-p"><br></p><p id="u8c05a2d8" class="ne-p"><br></p><p id="u16f6ff10" class="ne-p"><br></p><p id="u3c46b065" class="ne-p"><br></p><p id="ua587660d" class="ne-p"><br></p><p id="u0db9ca94" class="ne-p"><span class="ne-text"></span></p><p id="ub7cf7b5e" class="ne-p"><span class="ne-text"></span></p><p id="ufe6b908d" class="ne-p"><span class="ne-text"></span></p><p id="u2f4eac6c" class="ne-p"><span class="ne-text"></span></p><p id="u51e6add6" class="ne-p"><span class="ne-text"></span></p><p id="u71c31694" class="ne-p"><span class="ne-text"></span></p><p id="u3b17b80e" class="ne-p"><span class="ne-text"></span></p><p id="u5a7d2053" class="ne-p"><span class="ne-text"></span></p><p id="ua7c62cbe" class="ne-p"><span class="ne-text"></span></p><p id="ua6237826" class="ne-p"><span class="ne-text"></span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>国庆随笔：向死而生</title>
      <link href="/essay/gqoawl/"/>
      <url>/essay/gqoawl/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ua3dca230" class="ne-p"><span class="ne-text">国庆小随笔</span></p><h2 id="SAZEt"><span class="ne-text">十月五号</span></h2><p id="u5399fbea" class="ne-p"><span class="ne-text">姐姐结婚，爱情是什么样的，我们谁都不得而知，我自认为自己最难懂的就是爱情，从爱情走向婚姻，我觉得是最幸福的事情。</span></p><p id="u49f2a180" class="ne-p"><br></p><h2 id="uJrCV"><span class="ne-text">十月六号</span></h2><p id="ue64801e2" class="ne-p"><br></p><h3 id="rS15r"><span class="ne-text">曾视为空城的那个鄱阳</span></h3><p id="u917356c4" class="ne-p"><span class="ne-text"></span></p><p id="u0d0a9142" class="ne-p"><span class="ne-text">和两个兄弟去了趟鄱阳，那个我曾经视为空城的一个小城，东湖大道那座小桥现已修建名为文正桥，桥是宽阔了许多，不过我还是些许留恋曾经两旁有参天大树的桥道。</span></p><p id="uf89817c9" class="ne-p"><br></p><p id="u268a3f3c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875808473-8c8e729a-95e5-4cc1-9569-75ebeb9ec25e.jpeg" width="3648" id="ua8c982bd" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875807952-96f55875-30da-431c-98dd-76ee3ae331e0.jpeg" width="3648" id="u77239b62" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875809760-4dffcacf-688d-439e-9f71-a2a3245b26dd.jpeg" width="2736" id="ufe07eabd" class="ne-image"></p><p id="u3098a4ec" class="ne-p"><br></p><h3 id="xDvQq"><span class="ne-text">饶州古镇</span></h3><p id="u3a36902f" class="ne-p"><span class="ne-text"></span></p><p id="uc4d62a20" class="ne-p"><span class="ne-text">自家有这么一个古镇景点，还是很不错的</span></p><p id="u6018850f" class="ne-p"><span class="ne-text"></span></p><p id="u3fd40eba" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875997616-e683f592-bb92-4ca9-93d0-67a3712df0b5.jpeg" width="3648" id="u01295dec" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875998381-311af713-f841-4c55-852c-8f92a72749bc.jpeg" width="3648" id="u05d7c963" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875998279-4cdfbe6b-42b1-42bc-81a1-073a7b3830d8.jpeg" width="3840" id="uddde3c37" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875997897-10bf7687-e99e-4f1a-b67d-c6614ece8bca.jpeg" width="3648" id="u7fb6ebc3" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875998399-1534eab0-3711-47d1-886f-4a309f9d9273.jpeg" width="3648" id="ud64bd0a4" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876002155-627bd9d7-39ea-41a4-a82a-4ad9992056c4.jpeg" width="3648" id="ufa00a8a2" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876002241-35379903-c302-4e54-bb58-439786ff4470.jpeg" width="3648" id="u06167c90" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876002731-e1bb0cc3-48c4-45e0-8895-9d435b1e04fe.jpeg" width="3648" id="u625ac0a3" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876002769-34025c83-0fd7-4f24-8ea9-e32f86b94677.jpeg" width="3648" id="u08140798" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876001841-3bfc9710-8031-4cc4-a930-6a60bcb456f7.jpeg" width="3648" id="u582a5e29" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876005039-78bec731-e419-471b-b1d3-5078abd8f32f.jpeg" width="3648" id="uc786dce9" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876005917-cc7d5d1f-8813-41c8-8392-24b446712922.jpeg" width="3648" id="u00e0504d" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876006650-1cf3f393-472d-4af3-910a-454b98599755.jpeg" width="3648" id="u08504088" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876006744-f7a8a89f-a970-4e04-a891-c257f9e67160.jpeg" width="3840" id="u00a090b1" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876009430-86c16483-95dc-4fea-b6ef-5b6429e0a532.jpeg" width="3648" id="ue1f27166" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876009245-da7f7e0a-bfdb-484c-aaac-3b1d666cc25b.jpeg" width="3648" id="u60e30b2c" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876010297-9e5a9f09-53fd-4fe0-8cfd-26fd6a69c87a.jpeg" width="3648" id="u81b81119" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876011269-cf89a74b-13f0-4381-8754-2be7b8cdcf23.jpeg" width="2736" id="u9acd5f62" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876011280-e399e628-809e-4668-a49b-9241c6f3409a.jpeg" width="2736" id="uf29ce6cc" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876013616-b2afe4f8-587b-44d7-871f-f508124584f5.jpeg" width="3648" id="ud0599d64" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876014575-2e2702c5-4cf3-461d-a2b0-c4024a95ac8f.jpeg" width="3648" id="ua104b296" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876014664-975619ee-cd95-44c4-bfd5-a6e32201fc89.jpeg" width="3648" id="u750f8321" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876015648-67768ec5-5d69-40c5-b96a-464e6ba3d913.jpeg" width="2736" id="ud452a52b" class="ne-image"></p><p id="u78b81c6b" class="ne-p"><span class="ne-text"></span></p><p id="uf6357425" class="ne-p"><span class="ne-text"></span></p><h2 id="lHMbd"><span class="ne-text">十月七号</span></h2><p id="u498da28b" class="ne-p"><span class="ne-text">生活节奏太快，想了想，想停下来写写走走看看，于是七号在家中，八号再去公司</span></p><p id="ueebbc9ea" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/gif/1484158/1649041952673-600e4ad8-231b-491a-b1ba-ada6a2c0ee31.gif" width="218" id="nzi5z" class="ne-image"></p><p id="u4cadfe56" class="ne-p"><br></p><h2 id="jrF6C"><span class="ne-text">十月八号</span></h2><p id="ua18e6642" class="ne-p"><br></p><h3 id="iiGzJ"><span class="ne-text">珠海版“人在囧途”</span></h3><p id="u2400248c" class="ne-p"><span class="ne-text"></span></p><p id="u0cf50ffa" class="ne-p"><span class="ne-text">返珠海，上演一段真正的人在囧途，没有遇到</span></p><p id="u51ac14be" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876494701-40bf091b-6af2-41bc-b108-ce3580a8e3b1.jpeg" width="3648" id="uf020ab48" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876495028-16dcd228-d572-4658-9626-6a4a169162a0.jpeg" width="3648" id="uc21583b3" class="ne-image"></p><p id="uafcc1f5e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876843288-1bd256a2-fd14-49a3-b8b2-b21ac3f050af.jpeg" width="1176" id="uf549968e" class="ne-image"></p><p id="u0bcc6009" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876844529-f7c4bd92-d9b2-495c-9309-6a671a860134.jpeg" width="2736" id="QEJAx" class="ne-image"></p><p id="u7d40d1db" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633877452207-23cc8796-b4a5-4675-a283-e520384354b8.jpeg" width="2736" id="u89faf5ba" class="ne-image"></p><p id="ucb84ab3e" class="ne-p"><span class="ne-text"></span></p><h2 id="Eae3s"><span class="ne-text">十月九号</span></h2><p id="ua7267adc" class="ne-p"><span class="ne-text">四点钟被叫醒，说是去赶车，我太难了，假期到现在，每天都在早起，每天都在出行的路上，你要说我现在渴望些什么，我只想吃点粥啥的暖暖胃，然后再好好睡上一觉～</span></p><p id="u527f4d47" class="ne-p"><span class="ne-text"></span></p><p id="uee7179be" class="ne-p"><span class="ne-text">生活或许就是有时该为了活着而活着，而在关键时刻又需要向死而生的一种魄力。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PC端hevc编码的MOV格式视频无法查看</title>
      <link href="/blog/akf33e/"/>
      <url>/blog/akf33e/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u1b5b6b57" class="ne-p"><span class="ne-text">前言：需求中有这么一个问题，部分mov格式的视频在移动端可以播放，但在pc客户端无法显示，对比能播放和不能播放的mov格式视频，发现是hevc编码的mov视频不能播放，对此在做需求过程中，寻求并尝试了一些方法来解决这个问题，在本文做个记录。</span></p><p id="u39e05545" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><ol class="ne-ol"><li id="u6ee0e089"><span class="ne-text">MOV合适视频是苹果手机拍摄的视频格式</span></li><li id="ucb6b1b39"><span class="ne-text">苹果拍照的视频和苹果利用api调用的拍照的视频，这两者拍的视频编码是有差异的</span></li></ol></div><h2 id="aCbsI"><span class="ne-text">一、两者视频元信息比较</span></h2><p id="u6cb5301e" class="ne-p"><span class="ne-text">所用例子：</span></p><ul class="ne-ul"><li id="uc9188c46"><a href="https://image.x7sy.com/oa_medias/65440114717__69E1A426-97B2-4832-95FC-7712D9D7A487-16327083586676.MOV" data-href="https://image.x7sy.com/oa_medias/65440114717__69E1A426-97B2-4832-95FC-7712D9D7A487-16327083586676.MOV" target="_blank" class="ne-link"><span class="ne-text">非hevc编码视频例子</span></a></li><li id="uee54ac6e"><a href="https://image.x7sy.com/oa_medias/IMG_0018-16327078428771.MOV" data-href="https://image.x7sy.com/oa_medias/IMG_0018-16327078428771.MOV" target="_blank" class="ne-link"><span class="ne-text">hevc编码视频例子</span></a></li></ul><p id="u35ea3340" class="ne-p"><br></p><p id="u9a3f6e9b" class="ne-p"><span class="ne-text">利用格式工厂查看两个视频的元信息：</span></p><p id="u26dd80de" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1636168657171-19788f71-f632-44cc-9e62-0e6d9f206379.png" width="825" id="u318798b8" class="ne-image"></p><p id="uefc9da5c" class="ne-p"><span class="ne-text">利用上面的信息以及实际的可播放效果得：</span></p><ul class="ne-ul"><li id="u66d4ca2a"><span class="ne-text">mobile：都能看（安卓和苹果）</span></li><li id="u37f0e1b2"><span class="ne-text">pc：不能看上传的，</span><strong><span class="ne-text">hevc编码的不能解码</span></strong><span class="ne-text">？移动端相较pc能处理hevc编码？</span></li></ul><h2 id="Mg1QX"><span class="ne-text">二、HEVC、H.265兼容性支持情况</span></h2><p id="uaa976dd2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632730222885-c5d08df9-afdf-4b78-85fa-9003cb6b47b2.png" width="568.5" id="u07c0c94a" class="ne-image"></p><p id="u19280f6a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632730253372-9f6e0c9d-03c5-4685-ada6-d68306266653.png" width="570.5" id="u940ac543" class="ne-image"></p><p id="uf59796a1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1636168806126-ed5989be-ca1f-455c-a434-b0fbe89bca94.png" width="888.5" id="ue461184a" class="ne-image"></p><p id="u76eaa99a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632885246692-38ce1a86-66eb-4d5e-8e91-ff2c48a65f4e.png" width="529" id="u48fdcb25" class="ne-image"></p><p id="u351c1cbd" class="ne-p"><span class="ne-text">参考方案：</span></p><ul class="ne-ul"><li id="ue429d104"><a href="https://blog.csdn.net/yanrx76/article/details/116238315" data-href="https://blog.csdn.net/yanrx76/article/details/116238315" target="_blank" class="ne-link"><strong><span class="ne-text">如何在浏览器中支持H265/HEVC</span></strong></a></li><li id="uc784faa2"><a href="https://www.fdbtech.com/webfrontend/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E6%92%AD%E6%94%BEhevch265%E7%BC%96%E7%A0%81%E7%9A%84mp4%E8%A7%86%E9%A2%91" data-href="https://www.fdbtech.com/webfrontend/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E6%92%AD%E6%94%BEhevch265%E7%BC%96%E7%A0%81%E7%9A%84mp4%E8%A7%86%E9%A2%91" target="_blank" class="ne-link"><span class="ne-text">前端web如何播放HEVC(h265)编码的MP4视频</span></a></li></ul><ul class="ne-ul"><li id="u9a15c27a"><a href="https://segmentfault.com/a/1190000017187346" data-href="https://segmentfault.com/a/1190000017187346" target="_blank" class="ne-link"><span class="ne-text">H.265/HEVC在Web视频播放的实践</span></a></li><li id="u464cd360"><a href="https://segmentfault.com/q/1010000020081504" data-href="https://segmentfault.com/q/1010000020081504" target="_blank" class="ne-link"><span class="ne-text">video播放mov文件问题</span></a></li></ul><h2 id="nWppG"><span class="ne-text">三、解决方案</span></h2><p id="u520e30a3" class="ne-p"><span class="ne-text">下面几种方法是解决过程中所尝试的几种方法，前四种都测试未能解决该问题，最后一个方法取之。</span></p><h3 id="Fh8pH"><span class="ne-text">【弃】vue-h265-player插件使用</span></h3><ul class="ne-ul"><li id="ubd7a8f37"><a href="https://www.npmjs.com/package/vue-h265-player" data-href="https://www.npmjs.com/package/vue-h265-player" target="_blank" class="ne-link"><span class="ne-text">https://www.npmjs.com/package/vue-h265-player</span></a></li><li id="u4226c89f"><span class="ne-text"></span><a href="https://blog.csdn.net/Nie2014/article/details/114651376" data-href="https://blog.csdn.net/Nie2014/article/details/114651376" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/Nie2014/article/details/114651376</span></a></li></ul><ul class="ne-ul"><li id="u3bbaae9f"><a href="https://blog.csdn.net/weixin_42274114/article/details/109490633" data-href="https://blog.csdn.net/weixin_42274114/article/details/109490633" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/weixin_42274114/article/details/109490633</span></a></li></ul><p id="uba12ae57" class="ne-p"><span class="ne-text" style="text-decoration: line-through">判断是否为h.265，如果是就将其用新的播放器（插件）播放</span></p><p id="u01016027" class="ne-p"><a href="https://github.com/buzz/mediainfo.js" data-href="https://github.com/buzz/mediainfo.js" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">https://github.com/buzz/mediainfo.js</span></a></p><p id="ufb9ecf27" class="ne-p"><span class="ne-text" style="text-decoration: line-through">项目中添加该api的判断代码</span></p><ul class="ne-ul"><li id="u9cebd4db"><a href="https://blog.csdn.net/weixin_42274114/article/details/109490633" data-href="https://blog.csdn.net/weixin_42274114/article/details/109490633" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">https://blog.csdn.net/weixin_42274114/article/details/109490633</span></a></li><li id="uccca4d9e"><a href="https://segmentfault.com/a/1190000039753551" data-href="https://segmentfault.com/a/1190000039753551" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">https://segmentfault.com/a/1190000039753551</span></a></li></ul><ul class="ne-ul"><li id="u0bcbeeab"><a href="https://blog.csdn.net/Nie2014/article/details/114651376" data-href="https://blog.csdn.net/Nie2014/article/details/114651376" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">https://blog.csdn.net/Nie2014/article/details/114651376</span></a></li></ul><div data-type="danger" class="ne-alert"><p id="u0f44f1f5" class="ne-p"><span class="ne-text">插件源代码本身有问题</span></p></div><h3 id="gtJbk"><span class="ne-text">【弃】EasyPlayer.js插件使用</span></h3><ul class="ne-ul"><li id="u46e2d2e4"><a href="https://my.oschina.net/u/4383286/blog/4496965" data-href="https://my.oschina.net/u/4383286/blog/4496965" target="_blank" class="ne-link"><span class="ne-text">https://my.oschina.net/u/4383286/blog/4496965</span></a></li><li id="uf0143acd"><a href="https://github.com/tsingsee/EasyPlayer.js" data-href="https://github.com/tsingsee/EasyPlayer.js" target="_blank" class="ne-link"><span class="ne-text">https://github.com/tsingsee/EasyPlayer.js</span></a></li></ul><ul class="ne-ul"><li id="u3a8703ea"><a href="https://blog.csdn.net/a843334549/article/details/117323709" data-href="https://blog.csdn.net/a843334549/article/details/117323709" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/a843334549/article/details/117323709</span></a></li><li id="ua7d9beb3"><a href="https://blog.csdn.net/u012848709/article/details/106291133" data-href="https://blog.csdn.net/u012848709/article/details/106291133" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/u012848709/article/details/106291133</span></a></li></ul><ul class="ne-ul"><li id="uee6b716b"><a href="https://www.liveqing.com/docs/manuals/LivePlayer.html#%E5%9C%A8-vue-%E4%B8%AD%E4%BD%BF%E7%94%A8" data-href="https://www.liveqing.com/docs/manuals/LivePlayer.html#%E5%9C%A8-vue-%E4%B8%AD%E4%BD%BF%E7%94%A8" target="_blank" class="ne-link"><span class="ne-text">https://www.liveqing.com/docs/manuals/LivePlayer.html#%E5%9C%A8-vue-%E4%B8%AD%E4%BD%BF%E7%94%A8</span></a></li><li id="uba291925"><a href="https://gitee.com/livegbs/liveplayer-vc" data-href="https://gitee.com/livegbs/liveplayer-vc" target="_blank" class="ne-link"><span class="ne-text">https://gitee.com/livegbs/liveplayer-vc</span></a></li></ul><div data-type="danger" class="ne-alert"><p id="u01bd2388" class="ne-p"><span class="ne-text">未能播放那个苹果上传mov文件</span></p><p id="u7863f7a7" class="ne-p"><span class="ne-text">可能原因是苹果上传的mov文件(hevc)不属于该插件所解码的h.265的范围。</span></p></div><p id="u28130e96" class="ne-p"><br></p><p id="u26393f1a" class="ne-p"><strong><span class="ne-text" style="color: #F5222D">只要是hevc的格式，不管是视频还是声音，都无法播放</span></strong></p><ul class="ne-ul"><li id="u41d3a275"><span class="ne-text">EasyPlayer.js插件：</span><a href="https://github.com/tsingsee/EasyPlayer.js/issues/45" data-href="https://github.com/tsingsee/EasyPlayer.js/issues/45" target="_blank" class="ne-link"><span class="ne-text">https://github.com/tsingsee/EasyPlayer.js/issues/45</span></a></li><li id="uf12732b9"><span class="ne-text">原项目issues（vue-video-player插件）：</span><a href="https://github.com/surmon-china/vue-video-player/issues/232" data-href="https://github.com/surmon-china/vue-video-player/issues/232" target="_blank" class="ne-link"><span class="ne-text">https://github.com/surmon-china/vue-video-player/issues/232</span></a></li></ul><p id="ua4eaf41b" class="ne-p"><br></p><h3 id="ujwBQ"><span class="ne-text">【弃】libde265.JS解决办法</span></h3><ul class="ne-ul"><li id="u73274506"><span class="ne-text"></span><a href="https://github.com/strukturag/libde265" data-href="https://github.com/strukturag/libde265" target="_blank" class="ne-link"><span class="ne-text">https://github.com/strukturag/libde265</span></a></li></ul><ul class="ne-ul"><li id="u8280a4d8"><span class="ne-text"></span><a href="https://www.fdbtech.com/webfrontend/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E6%92%AD%E6%94%BEhevch265%E7%BC%96%E7%A0%81%E7%9A%84mp4%E8%A7%86%E9%A2%91" data-href="https://www.fdbtech.com/webfrontend/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E6%92%AD%E6%94%BEhevch265%E7%BC%96%E7%A0%81%E7%9A%84mp4%E8%A7%86%E9%A2%91" target="_blank" class="ne-link"><span class="ne-text">前端web如何播放HEVC(h265)编码的MP4视频</span></a></li><li id="u211af4cc"><a href="https://segmentfault.com/a/1190000017187346" data-href="https://segmentfault.com/a/1190000017187346" target="_blank" class="ne-link"><span class="ne-text">H.265/HEVC在Web视频播放的实践</span></a></li></ul><div data-type="danger" class="ne-alert"><p id="ud6c4dbc5" class="ne-p"><span class="ne-text">使用该js文件，能播放他自己提供的那个文件（改不改后缀都可以）</span></p><p id="u37c0c0dc" class="ne-p"><span class="ne-text">新上传的hevc编码的文件还是不能播放</span></p></div><h3 id="qhc2n"><span class="ne-text">【弃】easywasmplayer</span></h3><p id="ua907d3d3" class="ne-p"><span class="ne-text">测试地址：</span><a href="http://www.easydarwin.org/easywasmplayer/" data-href="http://www.easydarwin.org/easywasmplayer/" target="_blank" class="ne-link"><span class="ne-text">http://www.easydarwin.org/easywasmplayer/</span></a></p><div data-type="danger" class="ne-alert"><p id="ud3d554a5" class="ne-p"><span class="ne-text">不支持mov播放，mp4可以</span></p></div><h3 id="pDCNT"><span class="ne-text">【取】ffmpeg方法</span></h3><div data-type="success" class="ne-alert"><p id="u98bacc83" class="ne-p"><span class="ne-text">能否在后端利用ffmpeg将mov格式视频转换成mp4，转换之后的mp4格式是h.264编码的（目前只有部分mov格式视频是hevc编码的）</span></p></div><p id="ue3285a88" class="ne-p"><br></p><ul class="ne-ul"><li id="u01a2e3eb"><span class="ne-text"></span><a href="https://learnku.com/articles/50169" data-href="https://learnku.com/articles/50169" target="_blank" class="ne-link"><span class="ne-text">Web 端解码 H.265 视频可行性研究</span></a></li><li id="uda1c876b"><span class="ne-text"></span><a href="https://blog.csdn.net/qq_29931083/article/details/107758997" data-href="https://blog.csdn.net/qq_29931083/article/details/107758997" target="_blank" class="ne-link"><span class="ne-text">ffmpeg将mov格式的视频转换成mp4格式</span></a></li></ul><p id="u54631621" class="ne-p"><span class="ne-text"></span></p><p id="u5708f1f9" class="ne-p"><span class="ne-text">PS：ffmpeg安装方法：</span></p><p id="u6a3cb83b" class="ne-p"><a href="https://ffmpeg.org/download.html" data-href="https://ffmpeg.org/download.html" target="_blank" class="ne-link"><span class="ne-text">https://ffmpeg.org/download.html</span></a></p><p id="u22be7417" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632896302501-77e97ee6-c0fa-444d-a9c2-a34bec0d7493.png" width="491" id="u1938d594" class="ne-image"></p><p id="u7a13ec78" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632896323573-b3da95d2-dba7-42d0-b712-b2cfb5dbf82e.png" width="312.5" id="ud117ee8e" class="ne-image"></p><p id="uf4cb7c84" class="ne-p"><span class="ne-text">添加到环境变量</span></p><p id="uf41cab34" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641181905373-20996222-6e15-43ee-9e2f-4ca7d62da401.png" width="355" id="ud78e85c0" class="ne-image"></p><p id="ue4c9d668" class="ne-p"><span class="ne-text">检测是否安装成功</span></p><p id="ubec3da53" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632896355552-9604ce17-2ff5-44dc-931e-73ebc2efede8.png" width="373.5" id="ubed8d8a3" class="ne-image"></p><p id="u221b2367" class="ne-p"><span class="ne-text">安装成功</span></p><p id="u00bbe596" class="ne-p"><span class="ne-text"></span></p><p id="u4e6bed12" class="ne-p"><strong><span class="ne-text">【ffmpeg转mov为mp4-命令】</span></strong></p><pre data-language="powershell" id="gl0Js" class="ne-codeblock language-powershell">ffmpeg -i test.mov -vcodec libx264 -preset fast -crf 20 -y -acodec libmp3lame -ab 128k test.mp4</pre><p id="u7b747430" class="ne-p"><span class="ne-text"></span></p><p id="u36a66e9e" class="ne-p"><strong><span class="ne-text">【前端实现】</span></strong></p><p id="u4668101b" class="ne-p"><a href="https://download.csdn.net/download/weixin_42120997/19759493" data-href="https://download.csdn.net/download/weixin_42120997/19759493" target="_blank" class="ne-link"><span class="ne-text">https://download.csdn.net/download/weixin_42120997/19759493</span></a><span class="ne-text">【收费】</span></p><p id="u62303f43" class="ne-p"><a href="https://blog.csdn.net/dj513dj/article/details/60961970" data-href="https://blog.csdn.net/dj513dj/article/details/60961970" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/dj513dj/article/details/60961970</span></a></p><p id="u8e862f0f" class="ne-p"><a href="https://juejin.cn/post/6844903961942556685" data-href="https://juejin.cn/post/6844903961942556685" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6844903961942556685</span></a></p><p id="u5100a420" class="ne-p"><a href="https://github.com/damianociarla/node-ffmpeg" data-href="https://github.com/damianociarla/node-ffmpeg" target="_blank" class="ne-link"><span class="ne-text">https://github.com/damianociarla/node-ffmpeg</span></a></p><p id="ubc1e5279" class="ne-p"><a href="https://blog.csdn.net/dj513dj/article/details/60961970" data-href="https://blog.csdn.net/dj513dj/article/details/60961970" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/dj513dj/article/details/60961970</span></a></p><p id="u84fbaae2" class="ne-p"><span class="ne-text">还是需要电脑有ffmpeg环境</span></p><p id="uad061cd9" class="ne-p"><span class="ne-text"></span></p><p id="u70226f72" class="ne-p"><strong><span class="ne-text">【后端实现】</span></strong></p><p id="u34b02720" class="ne-p"><a href="https://blog.csdn.net/fareise/article/details/53188785" data-href="https://blog.csdn.net/fareise/article/details/53188785" target="_blank" class="ne-link"><span class="ne-text">NodeJS实现视频转码</span></a></p><p id="uf09e6507" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632897980832-011bfd61-effc-47f9-a527-17b59644c4ae.png" width="695" id="lFosa" class="ne-image"></p><p id="u77922ea0" class="ne-p"><span class="ne-text">需要服务端有ffmpeg环境</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>师者对技术的态度</title>
      <link href="/essay/dqzalx/"/>
      <url>/essay/dqzalx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u5abe3c3a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1649042341317-573ef9f9-3528-4b7c-b838-21e47448200c.jpeg" width="333.015625" id="u0d8f20dd" class="ne-image"></p><p id="u3b4f5cba" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="2302818483f14cd1baf9ad807e7aef7e"><span class="ne-text">C语言老师：</span><code class="ne-code"><span class="ne-text">像你们这个年龄，在古代那会儿，你们才刚刚进入仕途</span></code></li><li id="2d77dda4d9bf442a081548c366a79f42"><span class="ne-text">数据结构老师：</span><code class="ne-code"><span class="ne-text">将数据结构整本书上的所有算法自己实现一遍，那么代码水平就能够提升到一个不错的高度</span></code></li></ul><ul class="ne-ul"><li id="fbf26996f22e42c27a9397bfab3d4729"><span class="ne-text">JAVA老师：</span><code class="ne-code"><span class="ne-text">Ideas are cheap, show me the code</span></code></li><li id="4c8030857747fc21fdf2cf11f90e735d"><span class="ne-text">计算机网络老师：</span><code class="ne-code"><span class="ne-text">要用工程思维去设计一个系统</span></code></li><li id="3da6ea73090db79b1ffdb17b9ef49e48"><span class="ne-text">计算方法老师：</span><code class="ne-code"><span class="ne-text">计算机没有精确 只有精度</span></code></li></ul><p id="ubc03d941" class="ne-p"><br></p><p id="u6212a8de" class="ne-p"><span class="ne-text">第一个面试的HR：</span></p><p id="u7df30ff8" class="ne-p"><span class="ne-text">感受得到，她是一个资深的面试官，她问的各个问题不是很刁钻，但是很细，伴随着问答的交流，我也逐渐意识到我的不足之处（深度和广度），过程中她说了一句话，让我印象深刻：</span><code class="ne-code"><span class="ne-text">现在技术这条路，不是这么好走的</span></code></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>隐忍——能屈能伸</title>
      <link href="/essay/rng8r9/"/>
      <url>/essay/rng8r9/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人生独行者</title>
      <link href="/essay/fb0yri/"/>
      <url>/essay/fb0yri/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u3bda4409" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1630812970555-a8e776cc-9769-4729-b360-2eaeb8c95afd.jpeg" width="1920" id="u7c5aea52" class="ne-image"></p><p id="u2520bcd0" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="u6a1e5448" class="ne-p"><strong><span class="ne-text">无悔的独行者</span></strong></p><p id="ud15a128d" class="ne-p"><span class="ne-text"></span></p><p id="520f42f3293818f927861ebbd5b15da4_p_0" class="ne-p"><span class="ne-text">人生就是一个行者独自在一条大道上向前行走着，身边有许多美好，有许多遗憾，但是时间是单维度的，时间不会后退，你做过的事情，不会倒退，单一个体要对自己做过的事情无悔</span></p><p id="42b724d5778774d60e8ceb8c6aafe2fd" class="ne-p"><br></p><p id="30dd3a402fcd74138548305a9a1dc171" class="ne-p"><span class="ne-text">路上，你遇到很多人，你又和很多人说再见，你的前方无论什么时候都是那条看不到尽头的道路，</span></p><p id="234a06249234ea5e1e92b1c37696ede9" class="ne-p"><br></p><p id="619083d955cda6ae263322a8ebb6c4ba" class="ne-p"><span class="ne-text">不用去想人生的意义是什么，因为当死了的那一瞬间，了无遗憾，无悔般地笑着</span></p><p id="95cf672e8334071d2fab7f0b4b3d4a07" class="ne-p"><br></p><p id="udd7f0fcb" class="ne-p"><strong><span class="ne-text">造物主的内壁</span></strong></p><p id="u8d5ae5c3" class="ne-p"><br></p><p id="u31d69dda" class="ne-p"><span class="ne-text">人生的阶段就像是一个个内壁，就像是造物主让我们这么一个个生命体聚集在一起，他希望我们是规则的，所以在文明下，我们很多人都是规矩的，一样的……</span></p><p id="u716b142c" class="ne-p"><span class="ne-text"></span></p><p id="ud854a12d" class="ne-p"><span class="ne-text">文明框架下，每个人都是主角，每个人又好像都不是主角。</span></p><p id="ud68a5b91" class="ne-p"><span class="ne-text"></span></p><p id="ubde2b243" class="ne-p"><span class="ne-text"></span></p><p id="u4acf5d48" class="ne-p"><span class="ne-text">循环的单变量</span></p><p id="ua102cb94" class="ne-p"><span class="ne-text">读书===娶老婆===事业===生娃===读书</span></p><p id="b9c17e703a1bbbc593736caa61ef259d" class="ne-p"><br></p><p id="582d9b36ae645f59ac18545d9535ec31" class="ne-p"><span class="ne-text">这个文明带给我们的就像是这样的一段代码，然而，哪有这么容易呢？然而生活还会时不时给你制造bug，比如你学业上的困难，人总是不习惯于框架之外，但又沉溺于这个制度本身，讽刺的是，解决那些bug的人就是我们自己。</span></p><p id="7185a174c6bd5e198c0bcca841ff91fa" class="ne-p"><br></p><p id="4b6819242b47b931d3a1658713b96cfa" class="ne-p"><span class="ne-text">每个人就像是按照既定的规则去做事，不能有程序上的bug，</span></p><p id="d164fa8fc4acdbcc10e3b530cd7e9de0" class="ne-p"><br></p><p id="d8ce710037fe5edd48452a5c16b373d5" class="ne-p"><span class="ne-text">反过来说，要是我们不顺应这个文明制度，这就像是出bug了。</span></p><p id="de0cc843e56199257d01eb46a0eb9e67" class="ne-p"><br></p><p id="a566430fe2233f1d87599342268a3985" class="ne-p"><span class="ne-text">“某人读书期间，不好好读书，不务正业”造物主借由“环境”这么一个事物来影响这一个个体，让其不要破坏这个社会的制度，突然有一天，那个某人终于</span></p><p id="u400aa7ba" class="ne-p"><span class="ne-text"></span></p><p id="u2bbdfaa4" class="ne-p"><span class="ne-text">算法当中的贪心算法，其算法思想就是取局部最优</span></p><p id="u1d735217" class="ne-p"><span class="ne-text"></span></p><p id="u18ca4b97" class="ne-p"><strong><span class="ne-text">假如明天我死了</span></strong></p><p id="uc0e8c7f3" class="ne-p"><span class="ne-text"></span></p><p id="ua2dabb41" class="ne-p"><span class="ne-text">我的人生准则就是，假如我明天就死了，今天的我不会对我所做的任何事情感到后悔。</span></p><p id="b2dc5cb6d52f23fe6487d1760a025384" class="ne-p"><br></p><p id="d1ff7aabe7646884c71ea9990fadcd9b" class="ne-p"><span class="ne-text">我的行为准则很简单，但是并不代表我不懂，许多所谓的道理，我又何尝不懂，只是，我不害怕这个文明，不害怕这个文明所带来的种种。</span></p><p id="e277c3118e88ff9a64a6cb81c9eac6ed" class="ne-p"><br></p><p id="0cddda35c745c8a28a06dd4437db2736" class="ne-p"><span class="ne-text">我总是在坚守那些在其他人看来特别幼稚的事情，但是我却将其看得像珍宝一样珍贵</span></p><p id="d0439f7270971a59e10d3667c218eb94" class="ne-p"><br></p><p id="59473b30286f6680f96bf0d467a3a408" class="ne-p"><span class="ne-text">人如果没有信仰，没有坚守，那活着又有什么意义呢？</span></p><p id="uf2d17c7f" class="ne-p"><span class="ne-text"></span></p><p id="u59058a0c" class="ne-p"><strong><span class="ne-text">大学……</span></strong></p><p id="u7604627b" class="ne-p"><br></p><p id="u4019b73c" class="ne-p"><span class="ne-text">大学，只是我所经历的一站，我的前方依旧在那里，看起来很近，但是却也不近，大学快结束了，我想要的是近了还是远了……</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA算法应用——GPG keys</title>
      <link href="/blog/go85d1/"/>
      <url>/blog/go85d1/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="42bd2d5ebf6401acbcfa2d5d5f734273" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854019765-b6022a63-5214-4d70-98b5-aec146cf1e6b.png" width="524" id="mqoXX" class="ne-image"></p><p id="4f10621b1ac85f0abd467b8356afb2ef" class="ne-p"><br></p><p id="1891e3f1aa952ffff092448715485f0c" class="ne-p"><span class="ne-text">前言：GitHub在提交代码的时候会出现是否验证的情况，如上图所示，出现这个机制的原因就是当利用name和email提交代码时，两个不同的人都可以提交（多人协同一个项目），为了代码更加的严密与可靠，就出现了GPG keys加重验证这一情况。</span></p><p id="0f41f994265f5f78f32a49bb7ba09225" class="ne-p"><br></p><p id="762f0713131a16fd4cd18610c48d5d19" class="ne-p"><span class="ne-text">同时之前学过RSA算法的原理逻辑『</span><a href="https://www.wztlink1013.com/blog/ccd10c/" data-href="https://www.wztlink1013.com/blog/ccd10c/" target="_blank" class="ne-link"><span class="ne-text">RSA公钥密码算法 | 尼采般地抒情</span></a><span class="ne-text">』，本文也算是对该算法的一次应用。</span></p><hr id="krdEH" class="ne-hr"><h2 id="yF4YK"><span class="ne-text">一、创建gpg密钥</span></h2><p id="a05857b69218cdb73ac313e42c0d5441" class="ne-p"><span class="ne-text">在git Bash里面查看gpg版本</span></p><p id="e92b2e3f8a4a513b9a9def618c0df416" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854562240-df76109f-807c-46ec-93cc-eeb634181583.png" width="248" id="FSA2j" class="ne-image"></p><hr id="eSDh4" class="ne-hr"><p id="4814b8f53b0b05e04def958672efc8d3" class="ne-p"><span class="ne-text">生成密钥</span></p><pre data-language="bash" id="wpkdZ" class="ne-codeblock language-bash">gpg --full-generate-key</pre><p id="0c36ae9d901510b238ceab439e01bd73" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854642828-9298534e-2470-4440-a5d3-a0b4eebf9267.png" width="290" id="GLArL" class="ne-image"></p><hr id="MGViU" class="ne-hr"><p id="1ad037c776638cabfd1c45964b01bbbc" class="ne-p"><span class="ne-text">列举已经创建好的密钥id</span></p><pre data-language="bash" id="hNiig" class="ne-codeblock language-bash">gpg --list-secret-keys --keyid-format LONG</pre><p id="eadd38310d47c7777ee21a1d770ab12b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854721166-1a7cf63a-8053-42aa-a365-9f4accc4cb40.png" width="246" id="fBUBe" class="ne-image"></p><p id="0edbc327c4a78841e4deab698907d237" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="8906efe46498590a79f058923b12f7fc" class="ne-p"><span class="ne-text" style="background-color: #FFF6B6">中途会弹出要设置密码，并且是两次弹出。</span></p></div><p id="e8594fac55dab19eaccf0c5a3beca672" class="ne-p"><br></p><hr id="gcMp0" class="ne-hr"><p id="9237aa6bcdf488da490c35bbf9752d7f" class="ne-p"><span class="ne-text">查看密钥内容</span></p><pre data-language="bash" id="kCzhK" class="ne-codeblock language-bash">gpg --armor --export 10A9巴拉巴拉</pre><p id="16cd2775365117160f34038a1dd018ee" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854842847-28c1fb0a-ac3d-446b-b479-4c34a9d89d0d.png" width="235" id="jQgdw" class="ne-image"></p><h2 id="Divf6"><span class="ne-text">二、添加gpg密钥</span></h2><p id="022459be1af9049817901756d7835a0c" class="ne-p"><span class="ne-text">将上述控制台的密钥内容复制到GitHub的一下区域</span></p><p id="bb5883df540881786feeda6353e65ef0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854955321-8c0648b4-2ed8-472a-b9a9-58638bf12b61.png" width="837.5" id="al61T" class="ne-image"></p><hr id="q1wax" class="ne-hr"><p id="40bdd7dea884ce83e2493fc8ad5f35d7" class="ne-p"><span class="ne-text">以下就是公钥和密钥内容</span></p><p id="dbf1ab26d8bb9591d6b1ca7a8562e7c1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628856682736-35e744c2-8f28-425f-8a4c-fe9236cd8616.png" width="586.5" id="naOHh" class="ne-image"></p><h2 id="BVLAu"><span class="ne-text">三、本地设置gpg密钥</span></h2><p id="107d83064cf0663d7f4ef54c584a98d0" class="ne-p"><span class="ne-text">将gpg密钥添加到本地设置中</span></p><pre data-language="bash" id="8Sjvz" class="ne-codeblock language-bash">git config --global user.signingkey 10A9巴拉巴拉</pre><p id="2d87149a54b40e9f642314b53646b674" class="ne-p"><span class="ne-text">在所有项目中设置签名验证</span></p><pre data-language="bash" id="uDPql" class="ne-codeblock language-bash">git config --global commit.gpgsign true</pre><h2 id="DS7c2"><span class="ne-text">四、使用</span></h2><p id="718c79b7e92e6d61c7c03e22b9fdd800" class="ne-p"><span class="ne-text">在提交代码的时候，会弹出该提示框，这就是在设置密码时候的密码（密钥）。</span></p><p id="96527d4a09b6fe6dfd4eb2d3de6846ed" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628855341009-92cccb8c-0007-4361-8d42-778002d554e8.png" width="345.5" id="dLIY1" class="ne-image"></p><p id="50d998aabb61977a0236134dad953c61" class="ne-p"><br></p><p id="e679ea0bb66ecd89a64db2937de9b0b8" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="0284af9faa553fbbd031f2a0067408dc"><a href="https://www.ruanyifeng.com/blog/2013/07/gpg.html" data-href="https://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" class="ne-link"><span class="ne-text">https://www.ruanyifeng.com/blog/2013/07/gpg.html</span></a></li><li id="e2e39f1a038f5d13a6d69d6cabc56c0f"><a href="https://www.jianshu.com/p/195cac3a2b2c" data-href="https://www.jianshu.com/p/195cac3a2b2c" target="_blank" class="ne-link"><span class="ne-text">https://www.jianshu.com/p/195cac3a2b2c</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> RSA算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/helloworld/"/>
      <url>/blog/helloworld/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><hr id="a7SKe" class="ne-hr"><p id="ud33e8116" class="ne-p"><span class="ne-text">date: 2020-01-04 20:32:23</span></p><hr id="S8izF" class="ne-hr"><p id="u0debb705" class="ne-p"><br></p><p id="ue0e148d7" class="ne-p"><span class="ne-text">Welcome to </span><a href="https://hexo.io/" data-href="https://hexo.io/" target="_blank" class="ne-link"><span class="ne-text">Hexo</span></a><span class="ne-text">! This is your very first post. Check </span><a href="https://hexo.io/docs/" data-href="https://hexo.io/docs/" target="_blank" class="ne-link"><span class="ne-text">documentation</span></a><span class="ne-text"> for more info. If you get any problems when using Hexo, you can find the answer in </span><a href="https://hexo.io/docs/troubleshooting.html" data-href="https://hexo.io/docs/troubleshooting.html" target="_blank" class="ne-link"><span class="ne-text">troubleshooting</span></a><span class="ne-text"> or you can ask me on </span><a href="https://github.com/hexojs/hexo/issues" data-href="https://github.com/hexojs/hexo/issues" target="_blank" class="ne-link"><span class="ne-text">GitHub</span></a><span class="ne-text">.</span></p><h2 id="411eaaaa"><span class="ne-text">Quick Start</span></h2><p id="u697744a0" class="ne-p"><br></p><h3 id="ff46be02"><span class="ne-text">Create a new post</span></h3><p id="u505f5ff0" class="ne-p"><br></p><pre data-language="bash" id="a732d21c" class="ne-codeblock">$ hexo new "My New Post"</pre><p id="u0a0c001c" class="ne-p"><br></p><p id="u6f4f908f" class="ne-p"><span class="ne-text">More info: </span><a href="https://hexo.io/docs/writing.html" data-href="https://hexo.io/docs/writing.html" target="_blank" class="ne-link"><span class="ne-text">Writing</span></a></p><p id="u66c42358" class="ne-p"><br></p><h3 id="148bf910"><span class="ne-text">Run server</span></h3><p id="ub6078bd4" class="ne-p"><br></p><pre data-language="bash" id="2b4efa2f" class="ne-codeblock">$ hexo server</pre><p id="u07e4927e" class="ne-p"><br></p><p id="u48f410ea" class="ne-p"><span class="ne-text">More info: </span><a href="https://hexo.io/docs/server.html" data-href="https://hexo.io/docs/server.html" target="_blank" class="ne-link"><span class="ne-text">Server</span></a></p><p id="ubb8d507e" class="ne-p"><br></p><h3 id="25efabb0"><span class="ne-text">Generate static files</span></h3><p id="ueb4659ec" class="ne-p"><br></p><pre data-language="bash" id="8fcbc2e2" class="ne-codeblock">$ hexo generate</pre><p id="ufc85958c" class="ne-p"><br></p><p id="u06260396" class="ne-p"><span class="ne-text">More info: </span><a href="https://hexo.io/docs/generating.html" data-href="https://hexo.io/docs/generating.html" target="_blank" class="ne-link"><span class="ne-text">Generating</span></a></p><p id="u1e01da08" class="ne-p"><br></p><h3 id="fb21a764"><span class="ne-text">Deploy to remote sites</span></h3><p id="uc2c13a6f" class="ne-p"><br></p><pre data-language="bash" id="e4893861" class="ne-codeblock">$ hexo deploy</pre><p id="u54dc7717" class="ne-p"><br></p><p id="ued59f51e" class="ne-p"><span class="ne-text">More info: </span><a href="https://hexo.io/docs/one-command-deployment.html" data-href="https://hexo.io/docs/one-command-deployment.html" target="_blank" class="ne-link"><span class="ne-text">Deployment</span></a></p></div>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『花束般的恋爱』——“我认识了一个和我想法一样的人”</title>
      <link href="/essay/qraopm/"/>
      <url>/essay/qraopm/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u22a66168" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627879984472-b6f94d18-7055-4be5-9cb6-8a550e5342d3.png" width="1911" id="udf56b2ff" class="ne-image"></p><p id="u5f49ad95" class="ne-p"><br></p><p id="ucae40f69" class="ne-p"><span class="ne-text">看完之后的感受：</span><strong><span class="ne-text">始于心动，败于现实</span></strong><span class="ne-text">。</span></p><p id="uda3e74e7" class="ne-p"><br></p><p id="u50e01ea1" class="ne-p"><span class="ne-text">恋爱不是婚姻，因为中间有现实，但现实只是一个因素，在这个因素下，有的人忘却了曾经想要守护的，有的人想守住曾经，有的人幡然悔悟，有的人却早已失望并且走远……</span></p><p id="u6c6292df" class="ne-p"><br></p><p id="u739c65bc" class="ne-p"><span class="ne-text">这可能就是爱情和婚姻的不同吧。我也很幼稚，但是我想试试几年之后的我再看这篇文章会是什么感悟……</span></p><p id="u6e0614c2" class="ne-p"><br></p><hr id="G9wgh" class="ne-hr"><p id="u6dcd1e92" class="ne-p"><br></p><h2 id="v8t7Q"><span class="ne-text">“我认识了一个和我想法一样的人”</span></h2><p id="ud865d1f4" class="ne-p"><span class="ne-text">这就是相同的灵魂的碰撞，我相信巧合，真的相信。交谈有无数种，但是那种契合灵魂的交谈真的只有那个对的人才会有。</span></p><p id="u85bc468b" class="ne-p"><br></p><p id="u58d0633e" class="ne-p"><span class="ne-text">“我们好像，你就像是另一个世界的我一样”，就是那种你不用多言，也能感受到对方将要表达出来的感受。那绝对是亲身经历才能长存心间的事情。</span></p><p id="u0dea7a60" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627880340235-0ee52649-ef7e-4a7b-94b4-81ca645fd24c.png" width="960" id="uc6f2af4b" class="ne-image"></p><p id="u3fc85688" class="ne-p"><br></p><p id="ua9f48cef" class="ne-p"><br></p><h2 id="W5xJs"><span class="ne-text">爱情中的智者？</span></h2><p id="uf0cfa697" class="ne-p"><span class="ne-text">生活中总会有人去告诉你一些道理，像是扮演者一个智者的角色。片中爱情博客博主芽衣就是这么一个角色。</span></p><p id="u46d8b5d9" class="ne-p"><br></p><div class="ne-quote"><p id="u2c01f862" class="ne-p"><span class="ne-text">相遇总是伴随着离别</span></p><p id="ue162fa9a" class="ne-p"><span class="ne-text">恋爱就像派对  总有一天会结束 </span></p><p id="ufee0c56b" class="ne-p"><span class="ne-text">所以恋爱的人</span></p><p id="u75f3644b" class="ne-p"><span class="ne-text">总是喜欢将迷恋的东西夹在书桌里</span></p><p id="u8c6749bb" class="ne-p"><span class="ne-text">再分享他们的爱情</span></p><p id="ud64f8980" class="ne-p"><span class="ne-text">因为他们只能享受这份悲伤</span></p><p id="u09069c2e" class="ne-p"><span class="ne-text">虽然爱情的存存活率极小</span></p><p id="u50fb7f96" class="ne-p"><span class="ne-text">但我的爱情会活下来</span></p></div><p id="uda2fa691" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627881603601-6bb986d5-c12b-4710-8a56-cbefe8667501.png" width="960" id="u4405a4e6" class="ne-image"><span class="ne-text"> </span></p><p id="u40b0dc2e" class="ne-p"><br></p><div class="ne-quote"><p id="uc9f994e3" class="ne-p"><span class="ne-text">芽衣算是看到爱情的死亡吗？</span></p><p id="u3bfdacbd" class="ne-p"><span class="ne-text">她顺应了爱情的结束吗？</span></p><p id="u84a048e0" class="ne-p"><span class="ne-text">我只能去想象</span></p><p id="u2aaf8e51" class="ne-p"><span class="ne-text">而且也不打算  把它套用在自己的爱情上面</span></p><p id="u7a58441e" class="ne-p"><span class="ne-text">只是 我们的派对</span></p><p id="u2445e462" class="ne-p"><span class="ne-text">现在正在高潮部分</span></p></div><p id="uaf99aa6b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627881791016-85d417b3-119a-4c33-8e0f-927071017501.png" width="960" id="u9d16aabc" class="ne-image"></p><p id="u3ac5ff8d" class="ne-p"><br></p><h2 id="mQQbR"><span class="ne-text">现实会让你忘掉恋爱中最初的自己吗？</span></h2><p id="ue5fd01ad" class="ne-p"><span class="ne-text">我不知道，我没能看得见未来那个阶段的自己。</span></p><p id="ue5d791a6" class="ne-p"><br></p><p id="ue88fdd3d" class="ne-p"><span class="ne-text">女主工作初期的失意，以及男主工作中的起势和落魄，这可能就是常人说的现实把。现实让两个人褪去了太多色彩，但是一直坚守的是女主，同样是落魄，男主的陪伴和女主的陪伴换来的结果全然不样，没有好好珍惜把。</span></p><p id="u1a113d65" class="ne-p"><br></p><p id="u9865bfe1" class="ne-p"><span class="ne-text">人会变，也没有谁能够一直陪着谁。</span></p><p id="uedd5c011" class="ne-p"><br></p><p id="ua6f5a461" class="ne-p"><span class="ne-text">人都是个体……</span></p><p id="u613c674f" class="ne-p"><br></p><h2 id="Tq5qu"><span class="ne-text">感性 VS 理性</span></h2><p id="uc2bc6cc8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627883190252-ec419a89-4711-4126-aa45-5bf708930312.png" width="960" id="uca4b5a69" class="ne-image"></p><div data-type="info" class="ne-alert"><p id="uc51ad6c8" class="ne-p"><span class="ne-text">男主和女主最后的那段话，这段对话算是完完全全交代了两个人的终点。</span></p></div><p id="u03a88e41" class="ne-p"><br></p><div class="ne-quote"><p id="uff22c6b7" class="ne-p"><span class="ne-text">谢谢你</span></p></div><p id="ue0d3f9a7" class="ne-p"><br></p><div class="ne-quote"><p id="u37b5740a" class="ne-p"><span class="ne-text">小娟</span></p><p id="u96d4fd08" class="ne-p"><span class="ne-text">我不想分手</span></p><p id="ue0c63850" class="ne-p"><span class="ne-text">我觉得不用分手</span></p><p id="u7ef288cb" class="ne-p"><span class="ne-text">我们结婚吧</span></p><p id="u1f521711" class="ne-p"><span class="ne-text">结婚后</span></p><p id="ue75cc7e1" class="ne-p"><span class="ne-text">和以前一样</span></p><p id="u0efe5ecb" class="ne-p"><span class="ne-text">一起过日子吧</span></p><p id="udab251c8" class="ne-p"><span class="ne-text">没关系的</span></p></div><p id="ucb7d57b9" class="ne-p"><br></p><p id="u227cff08" class="ne-p"><br></p><div class="ne-quote"><p id="u25045beb" class="ne-p"><span class="ne-text">因为今天很开心所以你才会这么想</span></p><p id="u400965e1" class="ne-p"><span class="ne-text">我们又会回到以前那样</span></p></div><p id="u8d714314" class="ne-p"><br></p><div class="ne-quote"><p id="udd3ef590" class="ne-p"><span class="ne-text">我觉得没什么不好</span></p><p id="uc395de1a" class="ne-p"><span class="ne-text">这世上结婚的夫妻</span></p><p id="u1446fb87" class="ne-p"><span class="ne-text">大家不都是如此吗</span></p><p id="uc2a42996" class="ne-p"><span class="ne-text">都会慢慢忘记恋爱的感觉</span></p><p id="ud41c4240" class="ne-p"><span class="ne-text">不是也有结婚之后  继续这样过日子的人吗</span></p><p id="u98618816" class="ne-p"><span class="ne-text">就算感情变了</span></p><p id="u4efa80b2" class="ne-p"><span class="ne-text">不开心的事 就睁一只眼闭一只眼</span></p><p id="u1ea536a5" class="ne-p"><span class="ne-text">继续过日子  有这样的人的</span></p><p id="u81d8d840" class="ne-p"><span class="ne-text">我和你</span></p></div><p id="u52d5bbb4" class="ne-p"><br></p><div class="ne-quote"><p id="u3dff18a7" class="ne-p"><span class="ne-text">又要降低标准吗</span></p><p id="uebfd216d" class="ne-p"><span class="ne-text">降低标准</span></p><p id="u20106d10" class="ne-p"><span class="ne-text">然后想  就这样过吧</span></p><p id="ue58221d7" class="ne-p"><span class="ne-text">这样你就满意吗</span></p></div><p id="u4c953b14" class="ne-p"><br></p><div class="ne-quote"><p id="u11e5a2d5" class="ne-p"><span class="ne-text">满意</span></p><p id="u617feb85" class="ne-p"><span class="ne-text">不可能像以前一样喜欢啊</span></p><p id="u63df5a20" class="ne-p"><span class="ne-text">如果追求这种事就无法幸福了</span></p><p id="u69b1f3db" class="ne-p"><span class="ne-text">会不停地吵架</span></p><p id="uafb61969" class="ne-p"><span class="ne-text">不也是因为恋爱的感觉在捣乱吗</span></p><p id="u45882bbb" class="ne-p"><span class="ne-text">现在成为一家人的话</span></p><p id="u6c4cf163" class="ne-p"><span class="ne-text">我觉得能和你过好</span></p><p id="u1ab9ed12" class="ne-p"><span class="ne-text">生个孩子  孩子管我叫爸爸  管你叫妈妈</span></p><p id="u2e1fae82" class="ne-p"><span class="ne-text">我都能想象到那一幕</span></p><p id="u7a641f41" class="ne-p"><span class="ne-text">三个人或者四个人手牵着手一起去多摩川边散步吧</span></p><p id="u5ad2dbeb" class="ne-p"><span class="ne-text">推着婴儿车一起去逛高岛屋吧</span></p><p id="ubb95e8c0" class="ne-p"><span class="ne-text">买一辆车</span></p><p id="u417b59f8" class="ne-p"><span class="ne-text">去野营  去迪士尼乐园</span></p><p id="u907c89b3" class="ne-p"><span class="ne-text">花时间  一起过完这辈子</span></p><p id="u3d8694f0" class="ne-p"><span class="ne-text">他们俩虽然一起经历了很多事情</span></p><p id="ue334d411" class="ne-p"><span class="ne-text">但现在变成了一堆关系很好的夫妻</span></p><p id="u83c33db1" class="ne-p"><span class="ne-text">你中有我  我中有你</span></p><p id="ue53adf13" class="ne-p"><span class="ne-text">我们变成这样的关系吧</span></p><p id="u42130182" class="ne-p"><span class="ne-text">结婚吧  一起变幸福吧</span></p></div><p id="u15eff770" class="ne-p"><br></p><div class="ne-quote"><p id="u7c54de8f" class="ne-p"><span class="ne-text">你说的可能没错</span></p><p id="uc4b53c4e" class="ne-p"><span class="ne-text">是啊</span></p><p id="ud5023fe5" class="ne-p"><span class="ne-text">如果我们结婚了</span></p><p id="u37c9c63d" class="ne-p"><span class="ne-text">成为了家人</span></p></div><p id="u8b772e27" class="ne-p"><span class="ne-text">没有结局了……</span></p><p id="u091dfd5f" class="ne-p"><br></p><p id="u825d7cda" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627883840887-418d2c4a-2209-4fec-b839-7f85c8bacb17.png" width="960" id="dQsNl" class="ne-image"></p><p id="udde4ec35" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u69f572ed" class="ne-p"><span class="ne-text">始于心动，败于现实，这是我所能想到的，两人的爱情被磨没了，而这之中，对现实的无能为力才是罪魁祸首……</span></p></div><p id="uc119e114" class="ne-p"><br></p><p id="u86cef349" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『士兵突击』</title>
      <link href="/essay/qd0o6r/"/>
      <url>/essay/qd0o6r/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B7%2C0%2C51%5D%2C%5B7%2C0%2C51%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="ua79cadc0" id="ua79cadc0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="udb87ee1e" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1627457976739-9801a315-02f3-4f5f-b590-6b2a532749a7.webp" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="360px" style="visibility: visible; width: 270px;"></span></p><p data-lake-id="uc43a5495" id="uc43a5495" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u30e7b7e4" id="u30e7b7e4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>前言：人生导师级别的一部军旅影视，看完电视剧变买了这本小说一边看完。</span></p><p data-lake-id="0f7a058a54a40e288f29b6dc5d143e5f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span><br></span></p><h2 data-lake-id="a5133cb03312e62e22133bbbb3573172" id="77PfS" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">小说</h2><p data-lake-id="71b218d590149e15a2d338d72f124a87" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">第二章</p><p data-lake-id="d801c1cfdda58c4fcd0f62ed87cfc851" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="45e2571a5a7586e52903f99f47e11eeb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">史今班长的温柔和同情，对他而言，像是看到曾经刚入部队的自己，以至于做出绝不可能而又做出的感性的选择……</p><p data-lake-id="f50e31ddeea8b86e4e841e631511c328" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="8971f4389904dd8a5ded34ddc6b8057a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">以前在初中，是住校的，那时我班上也有一个和许三多一样的同学，我甚至还记得他叫什么，他叫程伊星，他就是看起来傻傻的，也比我们大一两岁，行为举动像是小孩子，也不谙世事，总是成为同学之间玩乐嬉戏的对象。</p><p data-lake-id="f0ecc1c9bdb7b8e86f763edf8f0b68fd" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="6d21a7ade99f2f57aaa4558d4ecc874e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">记得有一次夏季的体育课，我回宿舍，看见他躺在床上整理被子（他是作息及其规律，内务极其规整的一个学生），那时我们聊了会天，我觉得我以前初中和谁都能说得出心里话的那种，当时好像是问他为什么不和我们一起玩，忘了他是怎么回答的，只记得他说了一番话，具体也记不清，但是说出的话就像是滑稽的哲理一般，就像是背诵了书里面的词句一样的人生态度。他收拾完之后，他就习惯性地坐在床上，跟我聊天，多的记不清了，我只知道他是一个读书人，但就像是尚未入世一样……</p><p data-lake-id="1e18f8d95c1e65a9b28fa95b0bb2ddf2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="73e670e02c44652af26e79d1f34f71f8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">如今在键盘上敲字的我苦笑，敲到<strong>入世</strong>两个字，我也看到了自己的些许狼狈，我不知道什么是成长，但我真的也从家乡那个小城走出来，过往的经历就像是坚毅面庞背后的幸酸，<strong>可这个社会制度下，这个文明框架下，不就是充斥着过多的悲哀么，而我们大多数人都是向着死而生</strong>。</p><div data-card-type="block" data-lake-card="hr"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="d5a588b42e08846c8000104fd2869127" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u37a22136" id="u37a22136" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="41aed8a8db4b7d33bbde8fc90b8959c6" id="WhvVJ" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">影视</h2><div data-card-type="block" data-lake-card="hr" id="ErMZ7"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="146985790e8223b739b7528750295713" id="146985790e8223b739b7528750295713" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>10集</span></p><p data-lake-id="50c304a2049362301cf57da667c81b2d" id="50c304a2049362301cf57da667c81b2d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="6e1c87ddcc5263b203a43da6731910ec" id="6e1c87ddcc5263b203a43da6731910ec" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>战友的帮助成就了一个兵，班长的“牺牲”造就了一个兵王。</span></p><p data-lake-id="fdcd11b21ed0576db495d025c8b6680a" id="fdcd11b21ed0576db495d025c8b6680a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这是部队里面才有的。</span></p><p data-lake-id="a31a46b66b5cf0bd692c6bbb96493b3a" id="a31a46b66b5cf0bd692c6bbb96493b3a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c329be5ed7ad045898f47b737e1c93a8" id="c329be5ed7ad045898f47b737e1c93a8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这就像是，重情义的往往是那些曾经成绩不好的后排生，但是会为了彼此扛刀的同学。</span></p><p data-lake-id="2b96f701b3efb2bb2fb3fb9239932ad6" id="2b96f701b3efb2bb2fb3fb9239932ad6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>懂“不抛弃不放弃”远远比成为兵王更重要，真的。</span></p><p data-lake-id="47d7cb7cebab32d2d43decf756a61b64" id="47d7cb7cebab32d2d43decf756a61b64" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="df676c19a2090acc784ebd5f13b05297" id="df676c19a2090acc784ebd5f13b05297" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>成才最后被老A刷下的那般落魄，真的是曾经没有领悟那六个字所造成的结果。</span></p><p data-lake-id="f864a61177d3ec503436cc57c1f95fd0" id="f864a61177d3ec503436cc57c1f95fd0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="e6df67c6365c71a8cedc414130aec622" id="e6df67c6365c71a8cedc414130aec622" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>人做事真的不要太急了，踏实，稳固，远比结果更重要，并且到最后，你还会发现，人如果走的踏实，结果都不会太差的。</span></p><p data-lake-id="e826a531d18d60c3b7c2c9cef5738d30" id="e826a531d18d60c3b7c2c9cef5738d30" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="a6GJX"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="23b445e1c9906f7859bddec7691de2b5" id="23b445e1c9906f7859bddec7691de2b5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>16集</span></p><p data-lake-id="529f488dd86e9d194962594be53d5265" id="529f488dd86e9d194962594be53d5265" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="03a257be0ea28267c0c1980f426d78ed" id="03a257be0ea28267c0c1980f426d78ed" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>早熟的人往往都很晚熟</span></p><p data-lake-id="baaff50bed78e7dad90baa150aec233e" id="baaff50bed78e7dad90baa150aec233e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>骄傲的人又很急性</span></p></blockquote><div data-card-type="block" data-lake-card="hr" id="BDEqt"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="b40ccf37aed85ff9db7ee51fc0554d63" id="b40ccf37aed85ff9db7ee51fc0554d63" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>17集</span></p><p data-lake-id="1a56aa11c4b3887dae8f7f1cc7b2a2cc" id="1a56aa11c4b3887dae8f7f1cc7b2a2cc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="6794a5bb79c3cf74d75d799c54290578" id="6794a5bb79c3cf74d75d799c54290578" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>三多的士官和复员决定与否之路</span></strong></p><p data-lake-id="9e33345b8e01db2a145a02e7891d083d" id="9e33345b8e01db2a145a02e7891d083d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="36bf33bac1ec8cd4961e750768e21995" id="36bf33bac1ec8cd4961e750768e21995" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>高城走了之后，七连只剩下许三多一个兵</span></p><p data-lake-id="20a112a7b3c72e88e62787996e7014c6" id="20a112a7b3c72e88e62787996e7014c6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>一个兵守一个连……</span></p><p data-lake-id="c33dcabbeea89cfad3de368598c3b5d2" id="c33dcabbeea89cfad3de368598c3b5d2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>就是这样，这种历练是何等的孤独，兵王就是兵王，耐得住寂寞。一个人唱战歌，一个人守住仪式，一个人过一整个夜晚，一个人面对整个连的回忆。</span></p><p data-lake-id="7b51e748560e33427fb5d73b84f5f568" id="7b51e748560e33427fb5d73b84f5f568" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ee7af3bfacd13d18381b6f4a140655ff" id="ee7af3bfacd13d18381b6f4a140655ff" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>难，真的难。这种人真的厉害</span></p><p data-lake-id="2e28f429f41afa2f7f56197ceed239b0" id="2e28f429f41afa2f7f56197ceed239b0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="878187c29c141527629bded4a2a7f485" id="878187c29c141527629bded4a2a7f485" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>一个月和别人说话不超过十句话，其他的都是自己和自己说话。</span></p><p data-lake-id="c5923e98320b7904677367a44b2d9282" id="c5923e98320b7904677367a44b2d9282" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="1c41f5b83bb2068da62dd4677e166b80" id="1c41f5b83bb2068da62dd4677e166b80" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>伍六一在这个时候其实是最担心三多的。</span></p><p data-lake-id="0467364aee8d5154a94e3f8f9dbb2d2b" id="0467364aee8d5154a94e3f8f9dbb2d2b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="OZGwh"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u6efa79aa" id="u6efa79aa" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>18集</span></p><p data-lake-id="u35d7c6aa" id="u35d7c6aa" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u161019ec" id="u161019ec" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>袁朗第一次去找许三多对他的评价：</span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="253eff5fd34fac335ceb85813ea17c42" id="253eff5fd34fac335ceb85813ea17c42" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>怎么样  一个人在这守了半年</span></strong></p><p data-lake-id="ud47bc571" id="ud47bc571" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>不好不坏  不高不低的一个兵</span></strong></p><p data-lake-id="u5ebcf310" id="u5ebcf310" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>一个很安分的兵</span></strong></p><p data-lake-id="ue16b3f84" id="ue16b3f84" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>不太焦虑  耐得住寂寞</span></strong></p><p data-lake-id="u122edf3b" id="u122edf3b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>有很多人天天都在焦虑</span></strong></p><p data-lake-id="u37ab8c56" id="u37ab8c56" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>怕没得到  怕寂寞</span></strong></p><p data-lake-id="u6deafebd" id="u6deafebd" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>我喜欢不焦虑的人</span></strong></p></blockquote><p data-lake-id="udd308025" id="udd308025" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="ue85fad82" id="ue85fad82" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>我，其实我骨子里 骨子里可笨了</span></p><p data-lake-id="uc9b2d748" id="uc9b2d748" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>每一次换一次新的环境</span></p><p data-lake-id="u3bfb0767" id="u3bfb0767" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>我就跟死过一次似的</span></p><p data-lake-id="u1ee0f83d" id="u1ee0f83d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>你一个人呆在这是怕鬼把？</span></p><p data-lake-id="u3a27cad8" id="u3a27cad8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这世界上根本就没有鬼</span></p><p data-lake-id="u6afaca77" id="u6afaca77" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>那就奇怪了</span></p><p data-lake-id="ud26d9397" id="ud26d9397" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>鬼和你怕的事情不都是想出来的自己吓唬自己的吗</span></strong></p></blockquote><div data-card-type="block" data-lake-card="hr" id="IVc5Q"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="b79be21dbb5a04b02fb48de4e875900a" id="b79be21dbb5a04b02fb48de4e875900a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>19集</span></p><p data-lake-id="a3cb9fcd1190e8e0580ff08485665074" id="a3cb9fcd1190e8e0580ff08485665074" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="9fa77668b13fd20191ce42c8845fefd7" id="9fa77668b13fd20191ce42c8845fefd7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>参加老A集训，成才，伍六一，许三多，甘小宁……</span></p><p data-lake-id="b234f940a1d01283f36e6f4690914f4b" id="b234f940a1d01283f36e6f4690914f4b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="6b250069e37dade86b19b60f9114d548" id="6b250069e37dade86b19b60f9114d548" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>伍六一里面对</span></p><div data-card-type="block" data-lake-card="hr" id="jAC5r"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="cf61a410b429cb718f20351bbcc318d8" id="cf61a410b429cb718f20351bbcc318d8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>20集</span></p><p data-lake-id="d12002f45cda91a49af194b2679f5b6c" id="d12002f45cda91a49af194b2679f5b6c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="dc1dd61a8715ff3b4f0870215cac83aa" id="dc1dd61a8715ff3b4f0870215cac83aa" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>人不是靠做出来的，而是靠活出来的</span></p><p data-lake-id="13c449eb41bae7b2b68218702028d377" id="13c449eb41bae7b2b68218702028d377" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>就像你，不仅守住了军营，还守住了你自己</span></p><p data-lake-id="732fc389631cd12faa31c84f28d9697e" id="732fc389631cd12faa31c84f28d9697e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="0311ccc2d44f8b49723683e4886932de" id="0311ccc2d44f8b49723683e4886932de" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="i59gR"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="ue155cd1e" id="ue155cd1e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>五班</span></p><p data-lake-id="u044e262f" id="u044e262f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="uf03a40bd" id="uf03a40bd" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>五班是许三多和成才都经历过的一个地方，这部剧里面有太多的亮点，但我印象最深最深的就是五班，一望无际的草原，有人觉得是束缚，又有人觉得是天堂，环境足以磨灭一个人的信仰，经得起磨练的人才真的是人才。</span></p><p data-lake-id="uf02b3188" id="uf02b3188" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u5ab05f30" id="u5ab05f30" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>成才两次去过五班，第一次是部队整编自己去的五班，第二次是被老A打回五班</span></p><p data-lake-id="u48a39f70" id="u48a39f70" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u4b6506d0" id="u4b6506d0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="u4771e254" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628321067461-42092030-1b62-4a01-9ca6-f36195ef3a22.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="381px" style="visibility: visible; width: 736.5px;"></span></p><p data-lake-id="u03c286ff" id="u03c286ff" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>最后的五班，是由成才炼好的！</span></p><p data-lake-id="u8376ce0d" id="u8376ce0d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="AYeDf"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u24166b9c" id="u24166b9c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>七连</span></p><p data-lake-id="uf939680e" id="uf939680e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u533571b7" id="u533571b7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>在这里面真的学会很多，比技术和荣誉更重要的是——“不抛弃，不放弃”的人生信念。</span></p><p data-lake-id="u7c89579c" id="u7c89579c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>其实你会发现在七连不是所有人都是厉害的，但是他们都是最“靠谱”的，最敢拼的，集体荣誉感极强。还没有成长的成才和许三多在这里面就是两个极端，一个能力极强，但功利心极强，一个能力太低，不谙世事。</span></p><p data-lake-id="u9e46a94d" id="u9e46a94d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>就是两个这样的人最后都是兵王，能力强和弱的两个极端，在他们两个人成为一个人才的时间，我个人觉得是对那六个字的理解。</span></p><p data-lake-id="u6b485c98" id="u6b485c98" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>菜鸡重学i++和++i</title>
      <link href="/blog/smpdcq/"/>
      <url>/blog/smpdcq/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="e0e5744708b55a241fcb228636fbcb4d" class="ne-p"><span class="ne-text">前言：for循环里面的i++和++i在平时使用感觉是几乎一样的，但是之前写代码，特别是数据结构课程学链表那会，经常需要做的就是一个节点的next指向什么才结束这样一种情况，当时总是不自觉地将i++调整为++i就能运行成功，这个点比较模糊，查资料才发现存在</span><strong><span class="ne-text">只有++i可以返回左值</span></strong><span class="ne-text">这一情况。</span></p><hr id="OUPno" class="ne-hr"><p id="5485f1bfe8a61ef5dd33e673b9622eaf" class="ne-p"><br></p><p id="44c7f74649c7bf9394e73fb54c8b8883" class="ne-p"><span class="ne-text">先来一段常规使用：</span></p><p id="f8ced571d1f25307cb8758c620911566" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627270650151-857f8953-7e79-4055-a838-2b26b96aaf0a.png" width="522.5" id="sNaU2" class="ne-image"></p><p id="de2db062bf48f2e3a74c66707456022c" class="ne-p"><span class="ne-text">这个没有相关的差别</span></p><p id="015df9c2629edee9a1a1bb482a362ffd" class="ne-p"><br></p><p id="c6e17fcee2b794b85c65b56335443644" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627271346217-4ae80a1d-979b-42cd-b6ff-8fdc271926ab.png" width="544.5" id="kmxHY" class="ne-image"></p><p id="83f75ad28b6011423f8f326d34c1529a" class="ne-p"><span class="ne-text">一个返回+之前的值一个返回+之后的值，也是字面理解。</span></p><p id="ecc2db8646a888e68a78823d1509e587" class="ne-p"><br></p><div class="ne-quote"><p id="a5c77516ff5f7b541316a3f42f4fb677" class="ne-p"><span class="ne-text">左值：在内存存储空间里面有确定的存储地址的值。</span></p><p id="02e5fffdefe3ea4c1c6f973091f7fcd0" class="ne-p"><span class="ne-text">判断是否为左值：看是否允许取地址&运算符获得对应的内存地址。</span></p></div><p id="959f3baabc345c9cc324f27420f5d16f" class="ne-p"><strong><span class="ne-text">++i可以返回左值，i++不可以。</span></strong><span class="ne-text">（下面的截图对i++报错，对++i没有报错）</span></p><p id="21fafa6a5e8632dfc317f4ace858cc73" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627437597153-a59bb261-e406-46f3-8bbb-34af9278b55d.png" width="761" id="Kc6Sg" class="ne-image"></p><p id="9d49f8f0301781a9f1e005e831f42923" class="ne-p"><br></p><p id="8cbc579eae24cf1243b7dc48adb8cbc3" class="ne-p"><span class="ne-text">i++和++i的实现：</span></p><pre data-language="cpp" id="1bDDE" class="ne-codeblock">// 前缀形式：++i<p>int&amp; int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用<br>{//函数本身无参，意味着是在自身空间内增加 1 的<br>*this += 1; // 增加<br>return *this; // 取回值<br>}</p><p>//后缀形式：i++<br>const int int::operator++(int) //函数返回值是一个非左值型的，与前缀形式的差别所在。<br>{//函数带参，说明有另外的空间开辟<br>int oldValue = *this; // 取回值<br>++(*this); // 增加<br>return oldValue; // 返回被取回的值<br>}</pre><p id="0d749fc34ae2871acdb12a30ff18cfe8" class="ne-p"><br></p><p id="7cfeb712bf544e16fb19db3f76dc80b8" class="ne-p"><span class="ne-text">从这个代码也可以看出++i 的效率是优于 i++的，尽管很微弱。</span></p><p id="d0583fbb2c74ca0d23757cf453649629" class="ne-p"><br></p><div data-type="danger" class="ne-alert"><p id="aec6e38a293837eef420c2826726a984" class="ne-p"><span class="ne-text" style="background-color: #FFF3F3">大多数编译器已经对这两种使用方式封装，使其普通使用的效果几乎一致。</span></p></div><p id="72a9faf4dde1f00f9db035b59795ece1" class="ne-p"><br></p><div data-type="success" class="ne-alert"><p id="382e72f803d5cd997a84e8e93a54a152" class="ne-p"><span class="ne-text" style="background-color: #EDF9E8">今后尽量使用++i，特别是 C++写题的时候。</span></p></div><p id="51a283f3fbec44890f013c37c17ad300" class="ne-p"><br></p><p id="2e5387db8d571168339d5e652d55fe73" class="ne-p"><br></p><p id="0567065769cacff436b96bc51ee97736" class="ne-p"><span class="ne-text">参考链接：</span></p><ul class="ne-ul"><li id="d3b4617aca6abc19bca98cfd9a2e763d"><a href="https://www.zhihu.com/question/19811087" data-href="https://www.zhihu.com/question/19811087" target="_blank" class="ne-link"><span class="ne-text">在程序开发中，++i 与 i++的区别在哪里？</span></a></li><li id="da0a72e0b6531880924eacfa377f5e26"><a href="https://blog.csdn.net/zlhy_/article/details/8349300" data-href="https://blog.csdn.net/zlhy_/article/details/8349300" target="_blank" class="ne-link"><span class="ne-text">为什么(i++)不能做左值，而(++i)可以</span></a></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>终端环境配置</title>
      <link href="/blog/pa6aqc/"/>
      <url>/blog/pa6aqc/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u07130102" class="ne-p"><span class="ne-text" style="color: #E8323C">教程：</span><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md" data-href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md" target="_blank" class="ne-link"><span class="ne-text" style="color: #E8323C">命令行的艺术</span></a><span class="ne-text">（the-art-of-command-line）</span></p><h2 id="Z3ER4"><span class="ne-text">scoop下载</span></h2><p id="u3aed86f9" class="ne-p"><a href="https://scoop.sh/" data-href="https://scoop.sh/" target="_blank" class="ne-link"><span class="ne-text">https://scoop.sh/</span></a></p><pre data-language="powershell" id="k99UW" class="ne-codeblock language-powershell"># 在 PowerShell 中输入下面内容，保证允许本地脚本的执行：<p>set-executionpolicy remotesigned -scope currentuser</pre><pre data-language="powershell" id="MU6bQ" class="ne-codeblock language-powershell"># 然后执行下面的命令安装 Scoop：<br>iex (new-object net.webclient).downloadstring('<a href="https://get.scoop.sh&/#39;">https://get.scoop.sh&#39;</a>)</pre><pre data-language="powershell" id="SHBiP" class="ne-codeblock language-powershell"># 静待脚本执行完成就可以了，安装成功后，让我们尝试一下：<br>scoop help</pre><p id="ue576a6d8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639189556041-8c5d7b31-190e-463a-8ded-64ae19bc60d7.png" width="947" id="u42c137bf" class="ne-image"></p><h2 id="EIWO3"><span class="ne-text">lazygit</span></h2><p id="u1a9010b0" class="ne-p"><a href="https://github.com/jesseduffield/lazygit" data-href="https://github.com/jesseduffield/lazygit" target="_blank" class="ne-link"><span class="ne-text">https://github.com/jesseduffield/lazygit</span></a></p><p id="u0f9cf792" class="ne-p"><span class="ne-text"></span></p><p id="ud41786db" class="ne-p"><span class="ne-text">Add the extras bucket</span></p><pre data-language="powershell" id="vMJXN" class="ne-codeblock language-powershell">scoop bucket add extras</pre><p id="u2239e339" class="ne-p"><span class="ne-text">Install lazygit</span></p><pre data-language="powershell" id="rIcNX" class="ne-codeblock language-powershell">scoop install lazygit</pre><p id="udf3d5810" class="ne-p"><span class="ne-text">然后进入一个 git 文件夹用终端打开输入 </span><code class="ne-code"><span class="ne-text">lazygit</span></code><span class="ne-text"> 即可</span></p><h2 id="qlxSq"><span class="ne-text">Windows Terminal</span></h2><ul class="ne-ul"><li id="u7d927532"><span class="ne-text">官方教程：</span><a href="https://docs.microsoft.com/zh-cn/windows/terminal/" data-href="https://docs.microsoft.com/zh-cn/windows/terminal/" target="_blank" class="ne-link"><span class="ne-text">https://docs.microsoft.com/zh-cn/windows/terminal/</span></a></li></ul><p id="ue4d7ad55" class="ne-p"><span class="ne-text">按照此教程可以 DIY 如下：</span></p><p id="ueba0e8ce" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639822798943-6d29922d-cfe5-4101-bac7-3f94650392f3.png" width="249" id="u86db2961" class="ne-image"></p><p id="u679c5799" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639822897499-1230f2d1-791d-4e59-ac32-06c718f71ac6.png" width="352" id="u35f1ca4e" class="ne-image"></p><h2 id="I0Oax"><span class="ne-text">oh-my-posh</span></h2><p id="ua8cde725" class="ne-p"><a href="https://ohmyposh.dev/docs/windows" data-href="https://ohmyposh.dev/docs/windows" target="_blank" class="ne-link"><span class="ne-text">https://ohmyposh.dev/docs/windows</span></a></p><pre data-language="powershell" id="DXuQ0" class="ne-codeblock language-powershell">Install-Module posh-git -Scope CurrentUser<br>Install-Module oh-my-posh -Scope CurrentUser</pre><p id="u7ab1c822" class="ne-p"><a href="https://blog.csdn.net/weixin_44490152/article/details/113854767" data-href="https://blog.csdn.net/weixin_44490152/article/details/113854767" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/weixin_44490152/article/details/113854767</span></a></p><p id="u3afc0be2" class="ne-p"><span class="ne-text">安装字体</span></p><p id="uc6128dd6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639190934169-c1b6e5bc-e0f9-4b34-bdf6-113ba4c3c8f6.png" width="903" id="u81c84ea1" class="ne-image"></p><p id="uca6a246f" class="ne-p"><br></p><p id="uafe7c940" class="ne-p"><span class="ne-text">参考：</span><a href="https://zhuanlan.zhihu.com/p/163007658" data-href="https://zhuanlan.zhihu.com/p/163007658" target="_blank" class="ne-link"><span class="ne-text">https://zhuanlan.zhihu.com/p/163007658</span></a></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『大老师+路哥+师傅+折棒』</title>
      <link href="/essay/mll6d7/"/>
      <url>/essay/mll6d7/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《狼图腾》</title>
      <link href="/essay/gla4ug/"/>
      <url>/essay/gla4ug/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%5D%2C%5B0%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="u543fa103" id="u543fa103" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="uc7dc0cca" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1626253972954-cf013c98-7c95-4e4c-92d0-e58722469a3b.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="381px" style="visibility: visible; width: 260px;"></span></p><p data-lake-id="u9dac54c3" id="u9dac54c3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u6bff1602" id="u6bff1602" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>前言：在那蒙古草原上，有一种被崇敬的事物，那就是狼图腾。</span></p><p data-lake-id="udeff3fda" id="udeff3fda" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="CmmUd"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="ue5a5925c" id="ue5a5925c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>1</span></p><p data-lake-id="u1c60af3d" id="u1c60af3d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="uca6277f6" id="uca6277f6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>狼群是一个有组织的群体，进攻、放哨兵、撤退，都会按照既定的队形实施。</span></p><div data-card-type="block" data-lake-card="hr" id="6Sku3"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="uae7cad4c" id="uae7cad4c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>2</span></p><p data-lake-id="uf31e0f26" id="uf31e0f26" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u5ed098fb" id="u5ed098fb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>黄羊和狼的互相存在就是草原上的生存法则</span></p><p data-lake-id="uda8314ad" id="uda8314ad" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="ua23268b3" id="ua23268b3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>“老人说：我也打狼，可不能多打。要是把狼打绝了，草原就活不成。草原死了，人畜还能活吗？”</span></p></blockquote><p data-lake-id="u280faa97" id="u280faa97" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ub93f42c2" id="ub93f42c2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>“红卫兵”“知青”“学生”……</span></p><p data-lake-id="uf974bf1c" id="uf974bf1c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>在那种蛮荒时代里，步入殷实温暖的蒙古包，其实倒也是不错的经历，简单纯粹。</span></p><p data-lake-id="ua6d05cdb" id="ua6d05cdb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="udadbff77" id="udadbff77" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>“你们汉人胆子太小，像吃草的羊，我们蒙古人是吃肉的狼，你是该有点狼胆了。”</span></p></blockquote><p data-lake-id="u2a0e3bb1" id="u2a0e3bb1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u44901109" id="u44901109" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>狼是草原的守护神，腾格里（信奉的神）护着狼。</span></p><p data-lake-id="u969a5a5d" id="u969a5a5d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>人的内心深处亦或者说人类最原始角色就有一种猎性，只是从一开始作为农耕民族，早已被“便捷”所“进化”地向绵羊一般，不再有猎性，不再是猎人……可能这就是一种我们常说的血性。</span></p><p data-lake-id="ub449121f" id="ub449121f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="u029726ac" id="u029726ac" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>老人说：“光靠狼的狠劲还不行，还得靠狼的耐性”（智慧、耐性、组织性、纪律性）</span></p></blockquote><p data-lake-id="u999089a9" id="u999089a9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u0cc8398e" id="u0cc8398e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>草原上的蒙古人更为精明，作为狼的徒弟，青出于蓝而胜于蓝。</span></p><div data-card-type="block" data-lake-card="hr" id="zPWCX"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u2101a43d" id="u2101a43d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>3</span></p><p data-lake-id="ua92eb9b6" id="ua92eb9b6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u5f16550f" id="u5f16550f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>古老的草原逻辑解释了食肉名族和食草民族几千年来的争斗的根本</span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="uc04ee30e" id="uc04ee30e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>草原名族捍卫的是“大命”——草原和自然的命比人命更宝贵；</span></p><p data-lake-id="u4826bb5a" id="u4826bb5a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>而农耕名族捍卫的是“小命”——天下最宝贵的是人命和活命。</span></p><p data-lake-id="ufd831779" id="ufd831779" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>可是大命没了小命全都没命。</span></p></blockquote><div data-card-type="block" data-lake-card="hr" id="wLRS9"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u4b11bd2d" id="u4b11bd2d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>4</span></p><p data-lake-id="u5431f816" id="u5431f816" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ud53eb6dc" id="ud53eb6dc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>对狼的敬畏</span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="u2f59cd7b" id="u2f59cd7b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>在草原不吃食物，就不能算是真正的草原蒙古人。</span></p></blockquote><p data-lake-id="u9ab7f897" id="u9ab7f897" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>狼死了，狼的灵魂也会飞回腾格里那儿去的。</span></p><p data-lake-id="uf34b5114" id="uf34b5114" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>什么才叫真正的崇敬，对于蒙古民族，崇敬狼图腾，在一个人生命的终点，将躯体当成裸露坦荡的祭祀供品，从而把自己解脱的如此彻底。</span></p><div data-card-type="block" data-lake-card="hr" id="lR2Ih"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u66e4851e" id="u66e4851e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>5</span></p><p data-lake-id="uf0531126" id="uf0531126" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u58887fa8" id="u58887fa8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>巴图带领上等军马出去被狼群袭击。</span></p><p data-lake-id="ubecf5114" id="ubecf5114" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>丧崽哭嚎的母狼加入狼群，会格外地疯狂残忍</span></p><p data-lake-id="ue7ac01c3" id="ue7ac01c3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>疯狼不能打，越打越凶，越杀越疯，疯狼的报复心草原上无人不怕</span></p><p data-lake-id="u813968f1" id="u813968f1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>对狼来说，狼牙就是狼命。狼没了牙，狼就没了天</span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="ucd935f61" id="ucd935f61" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>狼的最凶狠锐利的武器就是它的上下四根狼牙，如果没有狼牙，狼所有的勇敢、强悍、狡猾、凶残、贪婪、狂妄、野心、雄心、耐性、机敏、警觉、体力、耐力、等等一切的品性、个性和物性，统统等于零。</span></p></blockquote><div data-card-type="block" data-lake-card="hr" id="SfpBT"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u83e0eec1" id="u83e0eec1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>6</span></p><p data-lake-id="u97953c5b" id="u97953c5b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="uc94801ed" id="uc94801ed" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>各类查找算法汇总</title>
      <link href="/blog/umxpln/"/>
      <url>/blog/umxpln/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📊查找排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数字电路总结</title>
      <link href="/blog/tn3fhp/"/>
      <url>/blog/tn3fhp/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u1d56c84c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627439456204-1f0fe7c2-b603-476f-93ee-d3705839148c.png" width="354" id="u0286b041" class="ne-image"></p><p id="u4d9aedc3" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="uf894e305" class="ne-p"><span class="ne-text">前言：利用猴博士视频总结的题型对整个数字电路做出复习。</span></p></div><p id="u8876d1ed" class="ne-p"><br></p><h2 id="ApQo3"><span class="ne-text">一、进制及其转换</span></h2><ul class="ne-ul"><li id="u16ac593a"><span class="ne-text">二进制：B</span></li><li id="ub646bb4b"><span class="ne-text">十进制：D</span></li></ul><ul start="3" class="ne-ul"><li id="u4ff7bfc0"><span class="ne-text">八进制：O</span></li><li id="u7751179c"><span class="ne-text">十六进制：H</span></li></ul><p id="u2eb26806" class="ne-p"><br></p><p id="u0dfe7ac0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624499655205-1611e06a-b4bf-49c1-9890-5fe12bbfc2bc.png" width="500.5" id="u30777ccf" class="ne-image"></p><p id="ubf37a27c" class="ne-p"><br></p><h2 id="vhLvf"><span class="ne-text">二、逻辑门电路</span></h2><h3 id="uardA"><span class="ne-text">给出逻辑图、输入，求输出</span></h3><p id="u7b154172" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624458112503-bd20e917-0fbd-4ab0-9ff4-b4ccd9865fc4.png" width="554.5" id="u108d5323" class="ne-image"></p><h3 id="xID8V"><span class="ne-text">给出逻辑图，写表达式</span></h3><p id="uef96a2d9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624458199919-649be4e4-ce94-4902-9c69-5595aff00f9e.png" width="557" id="ude5115ed" class="ne-image"></p><h3 id="StyE1"><span class="ne-text">给出表达式，画逻辑图</span></h3><p id="u9221886b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624458182439-0e80d369-7d17-453d-b7e6-d30e6e046598.png" width="487.5" id="u34ba51a5" class="ne-image"></p><h2 id="xIN31"><span class="ne-text">三、化简逻辑函数表达式</span></h2><h3 id="vBQ14"><span class="ne-text">公式法化简</span></h3><p id="u31c7e7a0" class="ne-p"><span class="ne-text">拍照那个笔记</span></p><h3 id="RzjkG"><span class="ne-text">卡诺图法化简</span></h3><p id="u1980cb57" class="ne-p"><span class="ne-text">要求：</span></p><ol class="ne-ol"><li id="u2a3f7583"><span class="ne-text">卡诺图表示成逻辑函数表达式</span></li><li id="ud0f9b627"><span class="ne-text">逻辑函数表达式表示成卡诺图</span></li></ol><ol start="3" class="ne-ol"><li id="u2d26855b"><span class="ne-text">化简逻辑函数表达式</span></li></ol><ol ne-level="1" class="ne-ol"><li id="u281d3b6e"><span class="ne-text">没有约束</span></li><li id="u661820ea"><span class="ne-text">有约束</span></li></ol><p id="u29f02f24" class="ne-p"><br></p><p id="u2fc80979" class="ne-p"><span class="ne-text">注意以下几点：</span></p><ul class="ne-ul"><li id="u139f5c42"><span class="ne-text">能圈多的就圈多的</span></li><li id="u70fdd96c"><span class="ne-text">约束项*能用就用，用的时候就为1，不用的时候就为0，不需要一定将其应用，*只是服务于1的</span></li></ul><p id="ua5fd92db" class="ne-p"><span class="ne-text"></span></p><h3 id="JkWMO"><span class="ne-text">求反函数</span></h3><p id="u59dd4c77" class="ne-p"><span class="ne-text">根据逻辑函数表达式求反函数</span></p><div class="ne-quote"><ul class="ne-ul"><li id="ue5616d8c"><span class="ne-text">把所有的“与”“或”互换</span></li><li id="u9ecb2432"><span class="ne-text">把所有的0、1互换</span></li></ul><ul start="3" class="ne-ul"><li id="ua54dd42e"><span class="ne-text">原变量和反变量互换</span></li><li id="u037171f1"><span class="ne-text">多个变量的公共非不变</span></li></ul><ul start="5" class="ne-ul"><li id="u9c5a6d39"><span class="ne-text">原始运算的优先顺序不变</span></li></ul></div><p id="u8b98b20d" class="ne-p"><span class="ne-text">根据卡诺图求反函数</span></p><div class="ne-quote"><ul class="ne-ul"><li id="ud37850bd"><span class="ne-text">把图中的0、1互换</span></li><li id="u94d8571b"><span class="ne-text">信徒写出来即可</span></li></ul></div><h2 id="KgpZK"><span class="ne-text">四、组合逻辑电路的分析与设计</span></h2><h3 id="rEHT8"><span class="ne-text">给出逻辑电路图，分析逻辑功能</span></h3><ul class="ne-ul"><li id="uf9001601"><span class="ne-text">逻辑电路图写出函数表达式</span></li><li id="u2d929d38"><span class="ne-text">化简函数表达式（符合要求的）</span></li></ul><ul start="3" class="ne-ul"><li id="uab5cbf33"><span class="ne-text">列出所有情况</span></li><li id="u1d887648"><span class="ne-text">分析出功能</span></li></ul><div class="ne-quote"><p id="u2647044e" class="ne-p"><span class="ne-text">常见的功能有：不一致电路、一致电路、少数服从多数电路</span></p></div><h3 id="gBuKz"><span class="ne-text">给出逻辑功能，画出逻辑电路图</span></h3><p id="u121349e2" class="ne-p"><span class="ne-text">和上面的步骤差不多，</span></p><ul class="ne-ul"><li id="u820d8078"><span class="ne-text">确定输入个数，定义0、1</span></li><li id="u85c18170"><span class="ne-text">列真值表</span></li></ul><ul start="3" class="ne-ul"><li id="ucc3ed547"><span class="ne-text">写出逻辑函数表达式</span></li><li id="u169a605d"><span class="ne-text">化简</span></li></ul><ul start="5" class="ne-ul"><li id="udb6922d4"><span class="ne-text">画出电路图</span></li></ul><h2 id="K5XZx"><span class="ne-text">五、最小项</span></h2><h3 id="qQXKn"><span class="ne-text">卡诺图求最小项</span></h3><ul class="ne-ul"><li id="u048982d0"><span class="ne-text">把逻辑函数表达式转换为卡诺图</span></li><li id="u11706cfe"><span class="ne-text">卡诺图里面为1的就是该位置二进制存在的最小项</span></li></ul><p id="ue4f16148" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624457764328-fc869be5-3d63-4499-9a9a-6e82ca2601fe.png" width="617" id="u2aba1ab9" class="ne-image"></p><h3 id="vkFyT"><span class="ne-text">公式法求最小项</span></h3><p id="uc8350073" class="ne-p"><span class="ne-text">就是通俗的化简，不过结果的每一项都必须包含每个字母，最后用二进制表示</span></p><p id="u56e8eff8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624457888889-57837834-3e20-4a68-93f2-94a5d9cf0482.png" width="374.5" id="u17d70b37" class="ne-image"></p><h3 id="Q1hdE"><span class="ne-text">最小项化成变量形式</span></h3><p id="u74fd1448" class="ne-p"><span class="ne-text">将其下标化成二进制，然后转换</span></p><p id="ufc02732c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624457989908-8eeaae47-38c1-440b-a1b6-aacda1358653.png" width="483" id="u744474eb" class="ne-image"></p><h3 id="PoVZa"><span class="ne-text">卡诺图化简有约束条件的</span></h3><p id="u9dd108d9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624458044603-7393051c-fa08-444d-8890-d510b20f259a.png" width="499.5" id="ud5764522" class="ne-image"></p><h2 id="mvA4U"><span class="ne-text">六、常用的集成器件</span></h2><h3 id="tFSzw"><span class="ne-text">译码器和门电路实现逻辑函数</span></h3><p id="uf2944355" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624495725174-7d84b3db-0535-4e9c-8445-eca05056e43e.png" width="503.5" id="u6d89f5d1" class="ne-image"></p><h3 id="yp7Bb"><span class="ne-text">译码器接线图写出逻辑函数</span></h3><p id="u22797bfd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624495940765-119658e7-e960-4fc3-83a7-634fdc6dc8dd.png" width="491" id="u076f4229" class="ne-image"></p><h3 id="UlDQ9"><span class="ne-text">8选1数据选择器实现3输入逻辑函数</span></h3><p id="ud45570a7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624496141542-776d204b-0332-4dad-acc1-c75ac793c2b7.png" width="504.5" id="u3f7c15b1" class="ne-image"></p><p id="u81d0fd72" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624496797353-52c90305-9a96-4b48-9e94-d4ef979229e1.png" width="500" id="u693c19a9" class="ne-image"></p><h3 id="a7mKV"><span class="ne-text">8选1数据选择器实现多输入逻辑函数</span></h3><p id="u4034e95a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624496656766-4a7aa12f-e321-4db0-a4ad-08b6fa88599e.png" width="507" id="u6828df9f" class="ne-image"></p><p id="u1178e1ca" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624496990732-16fbfeea-0384-4da7-9a20-af26f3a367c3.png" width="507" id="ucd4d8900" class="ne-image"></p><h2 id="HDybP"><span class="ne-text">七、触发器</span></h2><h3 id="SEpD6"><span class="ne-text">同步RS触发器</span></h3><p id="u020023c3" class="ne-p"><br></p><h3 id="iWmbZ"><span class="ne-text">给出D触发器及输入，画出波形图</span></h3><p id="ubbb059eb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624537249474-e313d1d4-e54a-4f11-801a-7cb35477b1ab.png" width="504" id="ua213f1e1" class="ne-image"></p><h3 id="AC2Y7"><span class="ne-text">给出JK触发器及输入，画出波形图</span></h3><p id="uaaa0c047" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624537215870-9c84a3f2-bc32-45fc-ad01-711ccedb1f2f.png" width="500" id="u906a2e93" class="ne-image"></p><p id="uf37039fa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624537294036-58b09d4c-ff3f-463b-a638-40a8d9aceb27.png" width="497" id="u4547f333" class="ne-image"></p><h3 id="wE0EQ"><span class="ne-text">多个触发器相连</span></h3><p id="ue5357d3d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624537373073-41ebf1b0-eefa-4780-bf91-d48419f01d2d.png" width="489" id="ub2a45094" class="ne-image"></p><h2 id="w0KLf"><span class="ne-text">问答题</span></h2><p id="u92521508" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624539793127-eb24945d-a5b8-4b60-ad1b-52764290c914.png" width="427" id="u9205094c" class="ne-image"></p><p id="u57e9de9c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624539824281-1a7c5e6a-774d-41de-96c0-68525d81eb6c.png" width="256.5" id="u71ba7cb4" class="ne-image"></p><p id="u2570e8e3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624539813127-8f316639-a479-4cf2-89b6-7e8d2d6ac7e9.png" width="179" id="u41542c50" class="ne-image"></p><p id="u05bb5331" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624539898752-fe3a106e-2e6d-4296-8ea7-bd2e434481a9.png" width="531" id="uc035f11a" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《洒脱的人才“玩”得起人生》</title>
      <link href="/essay/mzd92z/"/>
      <url>/essay/mzd92z/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u95c01ed3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1624193059628-8f003b19-46ac-47e4-b4af-23593b54b32a.jpeg" width="261.0115966796875" id="u43723471" class="ne-image"></p><p id="u20aa99fc" class="ne-p"><br></p><p id="ufd378d88" class="ne-p"><span class="ne-text">前言：</span><strong><span class="ne-text">我喜欢洒脱的人生态度，洒脱的人，活得简单、快乐</span></strong><span class="ne-text">。</span></p><p id="ub654de52" class="ne-p"><br></p><p id="u1430b4f7" class="ne-p"><span class="ne-text">对蔡澜的认识是源于『舌尖上的中国』，只知道他是一位美食家，最近才知道，蔡先生是一位见识丰富，极具艺术气质的一个人，他不仅是一位美食家，还是作家，电影制片人。</span></p><p id="u2a45e7fb" class="ne-p"><br></p><p id="u99ab65da" class="ne-p"><span class="ne-text">看完蔡澜先生写的这本随笔，会有一种豁达随性之感，有一种“生活本该如此”的感觉。整本书就是作者的随笔合集，作者有记录生活的那些看似不起眼，却也能吐槽，放开心境的一系列事情。书中还记录作者所吃过的许许多多的美食随笔，看这本书有一种吃甜点的那种愉悦感。</span></p><p id="u5f3db708" class="ne-p"><br></p><hr id="RK0bl" class="ne-hr"><p id="u88c00c22" class="ne-p"><span class="ne-text">最喜欢书里面的一段话：</span></p><p id="uc15d2bc4" class="ne-p"><br></p><div class="ne-quote"><p id="ue27f8d2a" class="ne-p"><strong><span class="ne-text">人生的意义太过广泛，这个问题天下多少宗教家、哲学家都解答不了。吃得好一点，睡得好一点，多玩玩，不羡慕别人，不听管束，多储蓄人生经验，死而无憾。这就是最大的意义吧，一点儿也不复杂</span></strong><span class="ne-text">。</span></p></div><h2 id="JUsTC"><span class="ne-text">一、我承认我快乐</span></h2><p id="u0371e027" class="ne-p"><span class="ne-text">快乐</span></p><p id="uba408fb0" class="ne-p"><br></p><p id="u577551e3" class="ne-p"><span class="ne-text">一天过得比一天快乐，是人生欢乐可行之道。可以从不刻薄自己开始。努力之余，想要什么就放手去买、去做。旅行最好，多学一样东西也不错。（蔡澜语录）</span></p><hr id="79LLN" class="ne-hr"><p id="uc9890a3b" class="ne-p"><span class="ne-text">想做的事</span></p><p id="u58dbba98" class="ne-p"><br></p><p id="u3524ee17" class="ne-p"><span class="ne-text">等到我所有的欲望都消失了，像看到好吃的东西也不想吃，好看的女人也不想和她们睡觉时，我就会去雕刻佛像，我好像说过这件事，我在清迈有一块地，可以建筑一间工作室，到时天天刻佛像，刻后涂上五颜六色，佛像的脸，像你、像我，不一定是菩萨观音。（蔡澜语录）</span></p><p id="u4109acb9" class="ne-p"><br></p><p id="ue3c4f8d8" class="ne-p"><span class="ne-text">问：“那么多的兴趣，要等到什么时候才去做？是不是要等到退休？”</span></p><p id="udabdf07b" class="ne-p"><span class="ne-text">答：“我早已退休了，从很年轻开始已经学会退休。我一直觉得时间不够用，只能在某一段时期，做某件事，什么时候开始，什么时候终结，随缘吧。”</span></p><p id="ub75c7b6c" class="ne-p"><br></p><hr id="OuIYr" class="ne-hr"><p id="uc5810815" class="ne-p"><span class="ne-text">好玩之都</span></p><p id="u0c73a96f" class="ne-p"><br></p><p id="ud7390983" class="ne-p"><span class="ne-text">在这个充满丑闻的都市中，我们得到了无限的欢乐，只要一天不死，就有笑话看。是的，还是香港好。（蔡澜语录）</span></p><hr id="hz7EN" class="ne-hr"><p id="uf5edc47f" class="ne-p"><span class="ne-text">玩物丧志</span></p><p id="uecd93098" class="ne-p"><br></p><p id="u476108d2" class="ne-p"><span class="ne-text">谁说玩物丧志？玩物养志才对！（蔡澜语录）</span></p><p id="u5d8c99de" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="ua3a3f445" class="ne-p"><span class="ne-text">玩物丧志吗？</span></p><p id="uf5be0e66" class="ne-p"><span class="ne-text">谁都知道，如果玩的是自己极其感兴趣的，会走出不一样的路，讽刺的是，世上绝大多数人都不敢这么做……</span></p></div><hr id="kAhk0" class="ne-hr"><p id="u20bc0403" class="ne-p"><span class="ne-text">偷笑</span></p><p id="u1ba32475" class="ne-p"><br></p><p id="u8fd3e8d3" class="ne-p"><span class="ne-text">庆幸的是我没有生儿育女的经验。看到别人的失落，我躲起来偷笑。想到自己结交的一些年轻女友都是人家的女儿，笑得更厉害了。（蔡澜语录）</span></p><p id="u9f2d9d40" class="ne-p"><br></p><p id="u7c1df666" class="ne-p"><span class="ne-text">（看这段的时候，笑死）</span></p><p id="ua0655bf9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624348364148-8176d785-505c-4979-873b-8dbdb4341941.png" width="96" id="gGEfk" class="ne-image"></p><hr id="4v0rs" class="ne-hr"><p id="u0b21b0ce" class="ne-p"><br></p><p id="ue2cba551" class="ne-p"><span class="ne-text">后悔</span></p><p id="u5cde919e" class="ne-p"><br></p><p id="u73b9e286" class="ne-p"><span class="ne-text">后悔，我们一定有过。烦恼出自我们的贪婪。两者兼得，就产生后悔和痛苦。a君或b君，要哪一个？烦恼即来。选其中一个，不后悔就是。一切灾殃化为尘，阿弥陀佛！（蔡澜语录）</span></p><hr id="5jhEJ" class="ne-hr"><p id="u278e085e" class="ne-p"><span class="ne-text">惊讶状</span></p><p id="ubb394a0e" class="ne-p"><br></p><p id="u1c7a301e" class="ne-p"><span class="ne-text">换一个新环境，就像交了个新情妇，晚上睡不着觉，一大早起床便往外跑，想发现每一个角落有什么不同的。这种心情是兴奋的、年轻的。这就是我爱旅行、爱住酒店的主要原因。（蔡澜语录）</span></p><p id="u5b398b06" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="uad4b7af9" class="ne-p"><span class="ne-text">这段作者讲述的是在帮一个朋友宣传的时候，某社报的记者来访问的情形，这个记者每句话离不开一个“哟”……</span></p></div><hr id="ENUu5" class="ne-hr"><p id="u8d6d7b79" class="ne-p"><span class="ne-text">水准</span></p><p id="u72d9e938" class="ne-p"><br></p><p id="u3df047cf" class="ne-p"><span class="ne-text">日本有一个很出名的料理人，他教了很多徒弟，其中有一个他最喜欢，但是他不教很多花样，每天一早，就叫这个徒弟煮一碗面豉汤给他喝。徒弟做了三年，师父也喝了三年。每天喝完不称赞，也不批评。后来徒弟才知道，师父教他的是保持一贯的水准，这是最重要的，客人吃了吃了，就吃出瘾来，不光顾不可。</span></p><p id="ueb3a0243" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u02ca7c7c" class="ne-p"><span class="ne-text">很多时候，最本真的或许才是最好的。</span></p><p id="ufe1832c0" class="ne-p"><span class="ne-text">想起了在天津吃的那家网红烤肉店，虽然整个餐厅运营机制不方便，但是吃到原生的服务员做的烤肉那味道，那种感觉还是很美妙的。</span></p></div><hr id="oGcYG" class="ne-hr"><p id="u2e12c8bd" class="ne-p"><span class="ne-text">蓝莓园</span></p><p id="ub91af9f9" class="ne-p"><br></p><p id="ud9862cb0" class="ne-p"><span class="ne-text">从吃一顿饭，便能观察对方是怎样的一种人。拿筷子搬弄一番又不选一块来吃，好不了哪里。大刺刺地先吃最好的部分，而不留给朋友，非常自私。夹了一大堆食物而不去动，是个贪心损人不利己的。畅怀大嚼，属于豁达型，豪放又来得性感，无妨深交。（蔡澜语录）</span></p><p id="u8530c9c1" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u1e23ce95" class="ne-p"><span class="ne-text">哈哈哈，好像还真有道理……</span></p></div><p id="ue14cc5e5" class="ne-p"><br></p><p id="u098d1e17" class="ne-p"><span class="ne-text">对着一望无际的蓝莓，他说：“一粒粒采摘，吃不完做果酱，春天也会开漂亮的花。到了秋天，蓝莓树像枫叶一样满山变红。那边有几棵高大的栗子树，果实熟了掉下，一面看红叶一面烤来吃，我已经不能回到城市去了。”</span></p><p id="u037d7e68" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u67a3e566" class="ne-p"><span class="ne-text">“明知是一场意外，你要不要来”</span></p><p id="udf9a8c0f" class="ne-p"><span class="ne-text">此般愿景，去又何妨</span></p></div><p id="ub9ad0193" class="ne-p"><br></p><hr id="CwGZl" class="ne-hr"><p id="u4b451aa9" class="ne-p"><span class="ne-text">不胖</span></p><p id="ucd64d492" class="ne-p"><br></p><p id="ueb39a037" class="ne-p"><span class="ne-text">一切浅尝，当然肥不了，但还是装腔作势，回答说：“真正会吃的人，是不胖的。”（蔡澜语录）</span></p><p id="u7dca521b" class="ne-p"><br></p><hr id="1aG4i" class="ne-hr"><p id="ua8601943" class="ne-p"><span class="ne-text">演讲与拐杖</span></p><p id="u6450329a" class="ne-p"><br></p><p id="uff5989f5" class="ne-p"><span class="ne-text">能进步的人，都有自己独立的思想，听他们的谈吐，就知与众不同，感想和观点皆独特的，都是努力奋斗的人物。（蔡澜语录）</span></p><hr id="PpRAH" class="ne-hr"><p id="u8d6a8dc9" class="ne-p"><span class="ne-text">世界上的厕所</span></p><p id="u3fa0381c" class="ne-p"><br></p><p id="u07342951" class="ne-p"><span class="ne-text">如果你很想在一生中出一本书的话，也不必有太多的才华，将所闻所见以相机拍下，再加上几行说明文字即行。举个例子，世界上的街灯都不同，乘现在年轻看到了就记录拍下，也是一本好书。（蔡澜语录）</span></p><p id="u2b314737" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u8c52eb5d" class="ne-p"><span class="ne-text">生活是一切美好事物的源泉</span></p></div><hr id="ZCK72" class="ne-hr"><p id="u1f606d10" class="ne-p"><span class="ne-text">整容</span></p><p id="u2bcb442f" class="ne-p"><br></p><p id="u8b985084" class="ne-p"><span class="ne-text">韩国女人愈来愈会打扮，愈来愈会穿衣服，不过这一点儿用处也没有，给外国人的印象，她们的美还是整容的结果。这对她们一点儿也不公平，数十年前经济未起飞时，哪有钱做手术，美女还不是多过其他国家？（蔡澜语录）</span></p><hr id="avytb" class="ne-hr"><p id="u32083649" class="ne-p"><span class="ne-text">商机</span></p><p id="ude152817" class="ne-p"><br></p><p id="u9b018f8f" class="ne-p"><span class="ne-text">如果只为升值及价值而去收藏某物件，这是一种肤浅的行为，我不会刻意去收藏某种物件。买一件你喜欢的，因为可以用上一生一世。（蔡澜语录）</span></p><hr id="uhWkj" class="ne-hr"><p id="u3df64745" class="ne-p"><span class="ne-text">惊喜</span></p><p id="u3564d439" class="ne-p"><br></p><p id="ua1ecca0f" class="ne-p"><span class="ne-text">轮到了乐观派：“蔡先生的团总有惊喜，加了一个采苹果的节目，这次送给我们一次地震的经验。”（蔡澜语录）</span></p><p id="u2c4f6d0a" class="ne-p"><br></p><p id="u03eee7fb" class="ne-p"><span class="ne-text">另一位说：“</span><span class="ne-text" style="color: #F5222D">最大惊喜还是我老婆给我的。结婚十多年，这一次因为地震，她才紧紧抱住我。</span><span class="ne-text">”</span></p><p id="ua3763d25" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u9258cfdc" class="ne-p"><span class="ne-text">悲观者，和乐观者之间的差别，就在此了</span></p></div><p id="u6490f8de" class="ne-p"><br></p><p id="uee991034" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1624195248841-6bc739e9-a3ac-449f-8bd9-6afd3edc9fe5.gif" width="45" id="d9ReS" class="ne-image"></p><hr id="iPTg9" class="ne-hr"><p id="u4679e8be" class="ne-p"><span class="ne-text">白痴</span></p><p id="ubd58feca" class="ne-p"><br></p><p id="u0c553865" class="ne-p"><span class="ne-text">一个人一生中最需要储的，是说实话的本钱。年轻人还没有大本事，你面对同事上司，怎可能随便给人脸色看？明明碰上看不顺眼的人和事，你只有逆来顺受。要一点虚伪也要圆滑，等你建立了相当的自信和说服力后，便储了说实话的本钱。（蔡澜语录）</span></p><hr id="pMetU" class="ne-hr"><p id="ub64435c8" class="ne-p"><span class="ne-text">尊重<p></span><span class="ne-text" style="color: #F5222D">　</span></p><p id="ua5cdc408" class="ne-p"><br></p><p id="u16124879" class="ne-p"><span class="ne-text">不觉得，我心中说，太操劳的事我已不会做。况且，第一团去过的地方第二团重访，店主即当我老爷拜。怪不得那位第一次参加的团友说：“最过瘾的是跟你去到那里，都得到人家的尊重。”（蔡澜语录）</span></p><p id="uf5abb4d0" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u7c8f86df" class="ne-p"><span class="ne-text">感受得到，做生意就是这样，诚恳，尊重他人，待人友善的这种做事风格</span></p></div><div data-type="info" class="ne-alert"><p id="u75963cb5" class="ne-p"><span class="ne-text">所有的快乐都是在自己生活中的点滴累计而成，生活啊，不要太难为自己~身边处处是一些美好的事物啊，难道不是吗？</span></p></div><p id="ue6518e22" class="ne-p"><br></p><h2 id="Yh9if"><span class="ne-text">二、今日的烦恼将成为明日的笑话</span></h2><p id="u6d06dbc1" class="ne-p"><br></p><p id="ud938f18d" class="ne-p"><span class="ne-text">专栏作家</span></p><p id="u9cf30ed4" class="ne-p"><br></p><p id="u28d89714" class="ne-p"><span class="ne-text">既然要写专栏，记得多看专栏，仔细研究其他作者的可读性因素何在。我开始时，先拜十三妹为师，她是专栏作家的老祖宗。本人未见，读遍她的文字，知道她除了谈论国际关系、文学音乐戏剧之外，也多涉及生活点滴，连看医生，向人借钱，也可以娓娓道来，这才能与读者融合在一起。（蔡澜语录）</span></p><p id="u5b344c61" class="ne-p"><br></p><p id="uad7098ac" class="ne-p"><span class="ne-text">作者需要不断地吸收，才能付出。需要不耻下问。旅行、交友、阅读、爱戏剧电影、绘画、音乐等等，是基本的条件。专栏作者和小说家完全是两码子事，后者可以把自己藏起来，编写出动人的故事，但是前者每天赤裸裸地把生活点滴奉献给读者。想过什么、做过什么，都在每天的专栏看得清清楚楚，是假装不出来的。</span></p><p id="ub4a88d73" class="ne-p"><br></p><p id="u7b4e3fee" class="ne-p"><span class="ne-text">我们这些写作人，多多少少都有发表欲，既然有了，不必要扮清高，迎合读者，不是大罪。</span></p><p id="u79358cd8" class="ne-p"><br></p><p id="u55a3832c" class="ne-p"><strong><span class="ne-text">真，是专栏作者的本钱，一假便被看穿，如果我们把真诚的感情放在文字上，读者也许不喜欢，可是一旦爱上，就是终生的了</span></strong><span class="ne-text">。</span></p><p id="ud8d43abc" class="ne-p"><br></p><p id="u5cd19cbc" class="ne-p"><span class="ne-text">既然要写专栏，记得多看专栏，仔细研究其他作者的可读性因素何在。我开始时，先拜十三妹为师，她是专栏作家的老祖宗。本人未见，读遍她的文字，知道她除了谈论国际关系、文学音乐戏剧之外，也多涉及生活点滴，连看医生，向人借钱，也可以娓娓道来，这才能与读者融合在一起。</span></p><p id="u6f5d6a81" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u531382dd" class="ne-p"><span class="ne-text">“真，是专栏作者得本钱！”受益这句话。</span></p></div><p id="ub9a5b83d" class="ne-p"><br></p><hr id="cFgK1" class="ne-hr"><p id="u0e0c8001" class="ne-p"><span class="ne-text">飞行等级</span></p><p id="u8593262e" class="ne-p"><br></p><p id="u3e1a197f" class="ne-p"><br></p><p id="u0ad696d7" class="ne-p"><span class="ne-text">生活质量的提高，商务舱已是抢手货，不管是否公费，大家一坐过之后，已不能退步去坐经济舱了，自掏腰包，也非商务不可，有些航线，已是一半商务一半经济了，更夸张的，是整架飞机，只有商务的趋势。</span></p><p id="uc55ae58d" class="ne-p"><span class="ne-text"><br></span><span class="ne-text">人往高处，乘商务的，心中也一直想要坐头等，头等那么好吗？值得吗？<br></span><span class="ne-text">可以把座椅当床平卧，是最大的特点，但这种服务，多数的商务舱已能做到。<br></span><span class="ne-text">吃得好，喝得佳吗？也不是，所谓的香槟，皆非第一流的，鱼子酱更是咸得要死。坐欧洲的航空公司，头等还有一点头等味道，亚洲的，有钱人通街都是，不当你是贵客。头等，只能遇到一些不肯退休的空中服务员，反正不会被炒鱿鱼，也带狗眼看人低的眼光了。<br></span><span class="ne-text">说什么，也是商务物有所值，但物有所值这句话，是昂贵的，当今的旅行费，绝不便宜。</span></p><p id="uc299d177" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u9836b93d" class="ne-p"><span class="ne-text">或许是不是所有事物都是物有所值把……</span></p></div><p id="u2d592bcb" class="ne-p"><br></p><h2 id="LPqqm"><span class="ne-text">三、只有自爱才心安理得</span></h2><p id="uf2a0221e" class="ne-p"><span class="ne-text">旅行伴侣</span></p><p id="u0b304dc2" class="ne-p"><span class="ne-text"><br></span><span class="ne-text">看了电视剧而找原著来读的不乏其人，相反就寥寥无几。到底，电视剧给我们的是固定的形象，失去了看书的幻想力。（蔡澜语录）</span></p><p id="u395c48c8" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u4fddb723" class="ne-p"><span class="ne-text">还好吧，我觉得『士兵突击』这部电视剧和小说就不错。</span></p></div><p id="u17234d0e" class="ne-p"><br></p><hr id="kP6at" class="ne-hr"><p id="uda4ab8c6" class="ne-p"><span class="ne-text">交友</span></p><p id="ube810227" class="ne-p"><br></p><p id="ue2d8a17c" class="ne-p"><span class="ne-text">最重要的，是把自己最真实的一面表露出来。真面目示众又如何？相貌是父母赐予，不应为讨好别人而改变。如果不够自信，就努力看书，增加自己的内涵，多写精彩的文章，日子久了，就会有人欣赏。</span></p><p id="u8698e1e4" class="ne-p"><br></p><hr id="b4K8C" class="ne-hr"><p id="u7263fd8e" class="ne-p"><span class="ne-text">乐得拍掌</span></p><p id="u2b14386b" class="ne-p"><br></p><p id="ufecede8b" class="ne-p"><span class="ne-text">做人最好的就是醉生梦死。醉生，每天喝醉；梦死，在做梦的时候死去，多幸福！（蔡澜语录）</span></p><h2 id="HnFuJ"><span class="ne-text">四、豁得出去，又是另一片天空</span></h2><p id="u76bd7f0e" class="ne-p"><span class="ne-text">痴人说梦</span></p><p id="u2d495759" class="ne-p"><br></p><p id="u7062ceba" class="ne-p"><span class="ne-text">我一直做梦，梦见给人追杀。醒来，原来是一场梦，怎会不高兴？哈哈哈哈。（蔡澜语录）</span></p><hr id="g3Uxd" class="ne-hr"><p id="u1e463490" class="ne-p"><span class="ne-text">做人</span></p><p id="ucff3b11e" class="ne-p"><br></p><p id="u818cd5cb" class="ne-p"><span class="ne-text">从小，父母亲就要我好好地“做人”。做人就是努力别看他人脸色，做人，也不必要给别人脸色看。生了下来，大家都是平等的。人与人之间要有一份互相的尊敬。所以我不管对方是什么职业，是老是少，我都尊重。（蔡澜语录）</span></p><p id="u63f70902" class="ne-p"><br></p><p id="u90f3d33a" class="ne-p"><span class="ne-text">“你到底是什么身份？电影人？食家？茶商？开餐厅的？开杂货店的？做零食的？卖财柴米油盐酱的？你最想别人怎么看你？”朋友问。“我只想做一个人。”我回答。</span><span class="ne-text">　　从小，父母亲就要我好好地“做人”。做人还不容易吗？不。不容易。“什么叫会做人？”朋友说，“看人脸色不就是？”不，做人就是努力别看他人脸色，做人，也不必要给别人脸色看。</span></p><p id="u58fc3a0c" class="ne-p"><br></p><p id="uce132af8" class="ne-p"><span class="ne-text">生了下来，大家都是平等的。人与人之间要有一份互相的尊敬。所以我不管对方是什么职业，是老是少，我都尊重。</span></p><p id="ud1e2e64c" class="ne-p"><br></p><p id="ubea532f4" class="ne-p"><span class="ne-text">除了尊敬人，也要尊敬我们住的环境，这是一个基本条件。</span></p><p id="uc4807e65" class="ne-p"><br></p><hr id="qJ3m8" class="ne-hr"><h2 id="iOPBS"><span class="ne-text">五、你是为谁生存</span></h2><p id="uefce642b" class="ne-p"><span class="ne-text">最喜欢的</span></p><p id="uc9484557" class="ne-p"><br></p><p id="ue24ae12d" class="ne-p"><span class="ne-text">写文章不求留世，工作当消遣，有什么说什么，东西不好吃就说不好吃，这种讲真话的本钱，是我花了数十年储蓄回来的。从前有点违背良心的话，是看到女人，都叫她们为“靓女”。当今也花不了本钱，说：“聪明。”（蔡澜语录）</span></p><p id="u2863cd09" class="ne-p"><br></p><hr id="3G76q" class="ne-hr"><p id="ufb358f61" class="ne-p"><span class="ne-text">教坏</span></p><p id="u09d444b9" class="ne-p"><br></p><p id="ub76b5b4c" class="ne-p"><span class="ne-text">“现在的孩子，都太乖了。出到社会，不知怎么面对。由我来教坏，遇到什么骗子都不必怕。我有个电影界的泰国朋友秦子彬先生，他把好赌的儿子带到拉斯维加斯去，给他一百万美金去赌，一下子输光，输得那儿子脸都青掉，从此不赌了。这不是以坏易好吗？”</span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对平侠谈个人成长的一些感悟</title>
      <link href="/essay/coeh8m/"/>
      <url>/essay/coeh8m/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="e2f3704cf6670b85e36817769e9f9fcc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624096824333-d7a7a173-78ce-487b-8924-11e04875f913.png" width="1920" id="SJV2T" class="ne-image"></p><p id="1d6668e634401f3fd4f9dfc67554752a" class="ne-p"><br></p><p id="8c8fcf8a5ef50fbf6fe1e0c573b7ada3" class="ne-p"><span class="ne-text">前言：近期看到平侠作者发布的一篇文章『</span><a href="https://www.yuque.com/zenany/up/be_independent" data-href="https://www.yuque.com/zenany/up/be_independent" target="_blank" class="ne-link"><span class="ne-text">从高效能人士的七个习惯谈成长</span></a><span class="ne-text">』，作者对个人成长精炼出来三个要素：心态、格局、魄力，对应《高效能人士的七个习惯》就是积极主动、以终为始、要事第一这三点。这三点算是对个人成长的比较好的概括了，总的来说，这篇文章对近期有些烦躁的自己算是重新点亮了一盏明灯。</span></p><p id="477e38fb7ac7d6641e783be87cf4ebca" class="ne-p"><br></p><hr id="k0k7a" class="ne-hr"><p id="5e9af7d3ec9c6ebae86d4c4582f97905" class="ne-p"><br></p><h2 id="myjBr"><span class="ne-text">积极主动的心态</span></h2><p id="u456d0e22" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624097233676-35f38d3c-7383-430a-9ca3-19551b956320.png" width="618.0208740234375" id="u5b8ae4a2" class="ne-image"></p><p id="d7b59f63f98e752ea3f40804e35336c8" class="ne-p"><br></p><p id="5628a002f07c9ae7759fbafa91e48b1b" class="ne-p"><span class="ne-text">作者说的这句话“</span><strong><span class="ne-text">接受无法改变的，改变有可能改变的</span></strong><span class="ne-text">”，我想应该是和李开复前辈的理念一样——“</span><strong><span class="ne-text">有勇气改变可以改变的，有胸怀接受不可改变的事情</span></strong><span class="ne-text">”，李开复其实后面还说道，“</span><strong><span class="ne-text">用智慧区分两者的不同</span></strong><span class="ne-text">”。其实说白了，就是对所处之境，所遇之事永远抱有一个乐观豁达的心态。</span></p><p id="aa6e9f6c20beab3aea21bbcc7ce596c3" class="ne-p"><br></p><p id="abe8f23a88d6be6ef8c66be72e738764" class="ne-p"><span class="ne-text">近期或然有些许同感，很多所有人都懂的道理，对一些人而言，由于性格的缘故，总要比别人接受的晚，再深点讲其实是内心不想接受罢了，抵触，就像是一个孩子被家长训话，就有些桀骜不驯的孩子，知道是这样的，知道这样是不对的，但就是愿意被性格被情绪所控制，但一旦懂得了并接受了这个所有人都懂的道理，成长加速度就会提升甚至赶超同龄人了，这或许就是成长吧。</span></p><p id="3f43d8ba7488fbf04573aa80db45c44d" class="ne-p"><br></p><div class="ne-quote"><p id="1844216885dfa369244e6831facf1e2d" class="ne-p"><span class="ne-text">天下事，难易相成。在做事的过程中，有顺境，有逆境，难在始终保持积极主动的心态。</span></p><p id="c104e7903380dd4b90271ddc9f84d4b9" class="ne-p"><span class="ne-text">顺境：比较容易做到积极主动，但也容易产生懈怠，需要顺势而为，不可懈怠，快速扩大成果。</span></p><p id="acb2874914169116381f2cd04baea73e" class="ne-p"><span class="ne-text">逆境：往往正是考验积极主动的时候，需要摆正心态，重塑信心，主动寻找改变的契机。</span></p></div><p id="afa0e71d2085b7622d3e7eb7871a70be" class="ne-p"><br></p><p id="d2edaa1299549e71332f332e57380469" class="ne-p"><span class="ne-text">作者这段话我觉得很不错，特别是对逆境的态度——始终坚持积极主动的心态。</span></p><p id="53533a4a221cda7757728bce513e3a53" class="ne-p"><br></p><p id="bd4824fec9840873a1ed87b6bd356c1f" class="ne-p"><span class="ne-text">积极主动的心态其实每个人或多或少都会，但是一直坚持的人，很少，也很难，但也正因是难，才要坚持不是么？（算是把自己好好教育了一番的感觉</span></p><p id="4697c6d6a95c7c2b5f2d2a7582f1a746" class="ne-p"><br></p><p id="b99996f0abb4df529a9c2797d21f5c23" class="ne-p"><span class="ne-text">三分钟不开刀无痛苦的历练，在这个文明制度下，不存在。</span></p><p id="349836253584b571db6174dd736420bb" class="ne-p"><br></p><h2 id="g5Mb0"><span class="ne-text">以终为始的格局</span></h2><p id="8ff8e1818720134b02154d779bd39479" class="ne-p"><span class="ne-text">换一个本人一直贯彻的学习方法中的一句话就是“以结果为导向”，以结果为导向的这种思维，在计算机专业里面特别好使，简单说明就是对于同一个技术，一个大作业比课堂上课一学期好使（我可没说我不好好听课</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624095112125-51056426-2c52-4bbf-9d7f-128cd1fac489.png" width="74" id="aZJCK" class="ne-image"><span class="ne-text">）</span></p><p id="75aa5337178370ae751b7b279d33799a" class="ne-p"><br></p><p id="44a2d3320b7f8fe320e66225e7acf2df" class="ne-p"><span class="ne-text">对于把这种思维转到职业规划与发展里面，亦是如此，划分阶段的话，就如作者的三步，确定终点——推演路径——制定计划。虽然我不太习惯制定这种人生抑或是职业计划，但不得不承认，这种方式是有效果的。</span></p><p id="711d17f71664dc08138c9add98a3828b" class="ne-p"><br></p><p id="51a44226886c03223f1e351388ea3492" class="ne-p"><span class="ne-text">作者所推荐的他的师傅 </span><a href="https://www.zhihu.com/people/wuduoyi" data-href="https://www.zhihu.com/people/wuduoyi" target="_blank" class="ne-link"><span class="ne-text">nwind</span></a><span class="ne-text"> 传授的 </span><a href="https://baike.baidu.com/item/%E9%A9%AC%E9%B9%A4%E5%87%8C/5566647" data-href="https://baike.baidu.com/item/%E9%A9%AC%E9%B9%A4%E5%87%8C/5566647" target="_blank" class="ne-link"><span class="ne-text">马鹤凌老先生</span></a><span class="ne-text"> 的总结：</span><a href="https://github.com/zenany/zenany.github.io/blob/master/_posts/about_time_and_knowledge_management.md" data-href="https://github.com/zenany/zenany.github.io/blob/master/_posts/about_time_and_knowledge_management.md" target="_blank" class="ne-link"><span class="ne-text">此生理想、近期计划、今日功课</span></a><span class="ne-text">。仔细看了看，感觉也在强调计划的操作必要性。此刻，突然想到了兵长内心打算跟随团长的心理独白</span></p><p id="2cb82c13de3211ee0b1451a879120a08" class="ne-p"><br></p><p id="111cd6add3af243a58ba3a8650fb1d58" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624096040600-e72f1c6f-cd5e-4421-a75c-9e5e8ac3edb7.png" width="650.9954223632812" id="bwQJL" class="ne-image"></p><p id="0247bc121ea0177ccd949d754a6717a3" class="ne-p"><span class="ne-text">“</span><strong><span class="ne-text">好吧，我就跟着你好了，埃尔文·史密斯</span></strong><span class="ne-text">”</span></p><p id="615f8bf674c2a0fe183d11aaa3242e6d" class="ne-p"><br></p><h2 id="IUEKs"><span class="ne-text">要事第一的魄力</span></h2><p id="cc37ee7ca89a086292e040c6c27c0de7" class="ne-p"><span class="ne-text">作者想要表达的是“专注当下，取舍果断”。</span></p><p id="13916f0afd1defae5fc51ad9eca3d5ce" class="ne-p"><br></p><p id="9833b0b36c446b504276a5ace21c1e85" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624096754794-70a837ba-bd73-4a01-a20d-712bfe4266fe.png" width="632" id="Di3jA" class="ne-image"></p><p id="86a36e1a9f8e2145291351c318bb8273" class="ne-p"><br></p><p id="d6aee56be157d9a088a4e825d04444de" class="ne-p"><span class="ne-text">舍弃的精神，我觉得我有，作者所描述的今后我可能会遇到的工作方面，也有对职业的持续发展道路方面的，作者的三个问题值得记录：</span></p><p id="c840d6f4a8d55bd4d5bda686adafeffd" class="ne-p"><br></p><div class="ne-quote"><p id="163361efe17827b92a21e09f009ecd5a" class="ne-p"><span class="ne-text">1、我能为团队和公司带来什么？</span></p><p id="202d81b7c74e26af8558c1a16fe762e9" class="ne-p"><span class="ne-text">2、我从身边的人身上可以学到什么？</span></p><p id="13b73d98b2b968a11b365408d0c70217" class="ne-p"><span class="ne-text">3、我真正想做的事是什么？</span></p></div><p id="ac397cfcec4f53a20c4f2d6b00a3032d" class="ne-p"><br></p><p id="142ea0bea3bd4cbeafcfc34e553d1c43" class="ne-p"><span class="ne-text">时时刻刻想着这三个问题，其实结果还是比较显而易见的……</span></p><p id="ufc082983" class="ne-p"><br></p><p id="3a50d5b23e35b3c04c28834eae9cef4a" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>所有的职业终点都是NPC</title>
      <link href="/essay/dpauku/"/>
      <url>/essay/dpauku/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="udee1398d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623929248579-c01331e1-d895-4f58-bf92-026465a16a65.png" width="960" id="u7e92ea60" class="ne-image"></p><p id="u474d71c2" class="ne-p"><br></p><div class="ne-quote"><p id="u7ca8a55d" class="ne-p"><span class="ne-text">非玩家角色或称非操控角色（英语：Non-Player Character，NPC），是指角色扮演游戏中非玩家控制的角色。</span></p><p id="ub60f8b1b" class="ne-p"><span class="ne-text"></span></p><p id="uda30fd66" class="ne-p"><span class="ne-text">NPC是游戏背景中，非主角（狭义上来说还要求非敌人）的陪衬人物。玩家借由他们与游戏互动。在桌上角色扮演游戏里，NPC是由游戏主持者操纵，而在电脑角色扮演游戏里，则是由程序默认的剧本来决定NPC的反应，由游戏的人工智能做出控制。部分NPC有时可变成可操控角色</span></p><p id="uc516030e" class="ne-p"><span class="ne-text"></span></p><p id="ufb570d7c" class="ne-p"><span class="ne-text">——维基百科</span></p></div><p id="u93524499" class="ne-p"><span class="ne-text"></span></p><p id="ua68fe989" class="ne-p"><span class="ne-text">如果将一个人人生的职业经历划分为两段，第一段就像是打怪升级的攻略者，而后一段我想就是NPC吧</span></p><p id="u1894db03" class="ne-p"><span class="ne-text"></span></p><p id="u703679ac" class="ne-p"><span class="ne-text">现在的我就像是一个攻略者，利用对这个文明框架的种种，去攻略眼前的所有困难，但是，我似乎也看到了今后处在NPC角色的我……</span></p><p id="u5cb8c53d" class="ne-p"><span class="ne-text"></span></p><p id="uae26803d" class="ne-p"><span class="ne-text">如果把人生喻成一场游戏，那么我觉得人生的意义则是，</span><strong><span class="ne-text">用一颗勇敢的心，去攻略眼前的一个个困难</span></strong><span class="ne-text">。</span></p><p id="u9523df15" class="ne-p"><span class="ne-text"></span></p><p id="u300a354b" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文明框架下美好的事物是什么样的？</title>
      <link href="/essay/logfxx/"/>
      <url>/essay/logfxx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p id="u193f4654" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623724816738-638c68c5-a58d-4855-a83f-8040d78aba26.jpeg" width="1440" id="AqhVV" class="ne-image"></p><p id="u79885ccd" class="ne-p"><span class="ne-text">图：梁同学</span></p><p id="u96c6a069" class="ne-p"><br></p><hr id="pdIMd" class="ne-hr"><p id="u44d3f512" class="ne-p"><br></p><p id="udb0e38f5" class="ne-p"><br></p><p id="u231dca46" class="ne-p"><span class="ne-text">文明，历史的长久以往，让我们这个文明慢慢趋于一种某一方面而言的制度体系，或许对大多数人而言，这是一种常态，但对我而言，文明是框架。我并没有用束缚这个较为偏激的字眼去形容，而是用的框架。</span></p><p id="u4796a1d5" class="ne-p"><br></p><p id="u938f3c46" class="ne-p"><span class="ne-text">我们所喜欢的事物，至少我喜欢的事物，拆开了讲，许许多多都是都是被框架所限定，生活、思维、情感、甚至是内心，那为什么框架要限定出我们所定义出来的幸福呢？我脑海中浮现的答案是文明，是制度……</span></p><p id="u67bd9d81" class="ne-p"><br></p><p id="u43b784a3" class="ne-p"><span class="ne-text">地球最初的生命，或许只是造物主偷偷在一个水球中放下了能进行光合作用的一些小生物，进而演化成了我们此般文明景象罢了，我们都是进化而来的生物，而生物遵循了生物法则，长久以往的人们制定了无数有益于生存下去的制度、规则，而在这样的大环境下生活着，有一种奇妙的事物叫做快乐抑或是幸福。</span></p><p id="udc021f14" class="ne-p"><br></p><p id="u4b86ec93" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623724819065-43292e39-1cfe-4dd4-b4a9-9cbf05167e4a.jpeg" width="1440" id="jClko" class="ne-image"></p><p id="u1a4a498a" class="ne-p"><br></p><p id="u45b23adb" class="ne-p"><span class="ne-text">人生的终极目标是什么？我又在一直追寻着什么啊？</span></p><p id="ue436ddde" class="ne-p"><br></p><p id="u10af1db1" class="ne-p"><span class="ne-text">我对自己问了一个特别大的问题，甚至有些幼稚的问题，或许我的潜意识里面想过这问题，但是又像是模模糊糊，如果用此刻大脑中的思绪来回答，我应该会回答：文明框架下的快乐和幸福。这个回答看起来是那么的简单易懂，却又有一些伤感与妥协，我站的太低了，我将自己死死地按在一个没有实体的框架下面，多么的悲怆，似乎就像是一台机器去做那些连幸福都定义好了的事情，</span></p><p id="ud45a6ea1" class="ne-p"><br></p><p id="ud771c32e" class="ne-p"><span class="ne-text">突然想到了一些人，无间道里面的刘建明和人间失格里面的叶藏，描述这两个人最好的状态就是无间，无间地狱，真的是艺术，描述的彻彻底底，佛教的思想：轮回、开悟、涅槃，而那两个人，无止境的在无间地狱轮回……想想这个文明制度下的种种，细思极恐</span></p><p id="u0acaf8a2" class="ne-p"><br></p><p id="ue3cfd092" class="ne-p"><br></p><p id="ue03791a5" class="ne-p"><span class="ne-text">人活着就是为了生活更快乐，更幸福，而幸福的生活要自己努力争取来的。</span></p><p id="u2d2d69a9" class="ne-p"><span class="ne-text"></span></p><p id="u26e92b81" class="ne-p"><span class="ne-text">我总是又在想，温柔的人为什么也会被</span></p><p id="u53aa6881" class="ne-p"><br></p><p id="u85586d79" class="ne-p"><br></p><hr id="Qp6B4" class="ne-hr"><p id="ua1d19015" class="ne-p"><br></p><p id="ud2fc7838" class="ne-p"><span class="ne-text">2021.06.16</span></p><p id="u792e40bb" class="ne-p"><span class="ne-text"></span></p><p id="u6b85ac87" class="ne-p"><span class="ne-text">“</span><strong><span class="ne-text">我不喜欢那些正确的人，那些从没堕落过、从没犯过错的人。生活的美未曾在他们面前展开过。</span></strong><span class="ne-text">”一个文学家在所沉浸的文学世界中的独白。</span></p><p id="u7a2eeda1" class="ne-p"><span class="ne-text"></span></p><p id="u39dd6c9a" class="ne-p"><span class="ne-text">真正的文学家总让人感觉是一个怪人，而我却独爱这般不被束缚的精神因子。</span></p><p id="u59b8f4c7" class="ne-p"><br></p><p id="u2fb77813" class="ne-p"><br></p><p id="u276fe678" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1626942905634-3fe3cc98-bedf-46bf-ac8e-20162a512b91.jpeg" width="1176" id="u233ed369" class="ne-image"></p><p id="u0baf1a43" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>各类排序算法汇总</title>
      <link href="/blog/garbxb/"/>
      <url>/blog/garbxb/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="598fe76c79cf4220ab7c32e59463c547" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1625064781047-2f12af3a-ce5c-4280-b387-38a40f307b45.jpeg" width="4961" id="yeGww" class="ne-image"></p><p id="f4799e2e37bd6cff1a774b72530e172e" class="ne-p"><br></p><p id="a4c64971ad367882801c73ec3d3dc979" class="ne-p"><span class="ne-text">前言：排序按照所占用的计算机内部存储设备，可以分为：</span><strong><span class="ne-text">内部排序</span></strong><span class="ne-text">和</span><strong><span class="ne-text">外部排序</span></strong></p><ul class="ne-ul"><li id="4b0aba3fe82521f2629e180cf11c0c74"><strong><span class="ne-text">内部排序：</span></strong><span class="ne-text">占用的是内存，待排序序列全部放在内存加以排序处理</span></li><li id="ce7426ba9e5f35c43ed4f0e90104c7b8"><strong><span class="ne-text">外部排序：</span></strong><span class="ne-text">占用的是外存，数据量比较大，内存空间不足以一次性全部容纳数据的情况</span></li></ul><p id="7f749a6f10609a76ec5fd0b57e19dd42" class="ne-p"><br></p><p id="8a996d904321b45f997b52fd816b00df" class="ne-p"><span class="ne-text">本文章 通过</span><a href="https://leetcode.cn/problems/sort-an-array/" data-href="https://leetcode.cn/problems/sort-an-array/" class="ne-link"><span class="ne-text">912. 排序数组</span></a><span class="ne-text"> 题目，以此来总结内部排序的各种排序算法。</span></p><p id="c9527610c382b4e6629792750a2166da" class="ne-p"><br></p><p id="7da58a290fd9cd6f0c506cf3e1747b3d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623667337022-44c54af8-5961-43d6-8fa4-46ef3f6ec71f.png" width="746" id="zJx4v" class="ne-image"></p><h2 id="qzpnY"><span class="ne-text">一、插入类排序</span></h2><p id="1c913d93d2cc9eff048644211658bd5c" class="ne-p"><span class="ne-text">将无序的子序列插入到有序序列中</span></p><h3 id="etEGl"><span class="ne-text">✅直接插入</span></h3><p id="f1f5744d5e0ed7b62a44cfdc3abd8e30" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625014050650-261f0307-6356-440f-b06a-12e264344572.gif" width="813" id="pZjWF" class="ne-image"></p><p id="d5d5ac06f356ce66f8e428f2f3582506" class="ne-p"><span class="ne-text">将元素序列走一遍，走到某个元素时，将其插入到已走过的已排序序列中，这样可以保证走完所有元素，然后所有的元素都是排序好的。</span></p><p id="94537a784913cd4dce7e158543975878" class="ne-p"><span class="ne-text">数据结构选用的时顺序表</span></p><pre data-language="javascript" id="VLea7" class="ne-codeblock language-javascript">/**<ul><li>@param {number[]} nums</li><li>@return {number[]}<br><em>/<br>var sortArray = function(nums) {<br>for (let i = 0; i&lt;nums.length; i++) {<br>let flag = i<br>for(let j = flag-1;j&gt;=0;j–) {<br>if (nums[flag] &lt; nums[j]) {<br>let temp = nums[j]<br>nums[j] = nums[flag]<br>nums[flag] = temp<br>flag–<br>}<br>}<br>}<br>return nums<br>};</pre><p id="uf9efec9a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653228341393-1bd78b67-0797-4bec-add7-be5d8295ac35.png" width="567.4074474905118" id="uecb8136f" class="ne-image"></p><h3 id="thpnK"><span class="ne-text">优化：折半插入</span></h3><p id="c3ffa5c0de2325e5e10b036617fee982" class="ne-p"><span class="ne-text">在直接插入的过程中，找到一个元素，然后再需要从后往前依次查找“该在”的位置，对其查找进行了折半优化</span></p><pre data-language="cpp" id="pPqb5" class="ne-codeblock language-cpp">/</em> 折半插入排序 <em>/<br>void BinsertSort(SqList &amp;S) {<br>for (int i = 2; i &lt;= S.length;i++) {<br>S.data[0] = S.data[i];<br>int low = 1;<br>int high = i - 1;<br>while (low &lt;= high) {<br>int m = (low + high) / 2;<br>if (S.data[0]&lt;S.data[m]) high = m - 1;<br>else low = m + 1;<br>}<br>int j;<br>for (j = i - 1; j &gt;= high + 1;–j)<br>S.data[j + 1] = S.data[j];<br>S.data[high + 1] = S.data[0];<br>}<br>}</pre><h3 id="gP6SY"><span class="ne-text">优化：希尔排序</span></h3><p id="29eea55fa2a785edf01487c47c16eabc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625015190376-d54ed111-aa4a-41cf-9dde-6593a6aaf4e0.gif" width="665" id="KmYb4" class="ne-image"></p><pre data-language="cpp" id="YKDS3" class="ne-codeblock language-cpp">/</em> 希尔排序 */<br>void ShellInsert (SqList &amp;L, int dk) {<br>for (int i = dk + 1; i &lt;= L.length;++i) {<br>if (L.data[i]&lt;L.data[i-dk]) {<br>L.data[0] = L.data[i];<br>int j;<br>for (j = i - dk; j &gt; 0 &amp;&amp; L.data[0] &lt; L.data[j]; j -= dk)<br>L.data[j + dk] = L.data[j];<br>L.data[j + dk] = L.data[0];<br>}<br>}<br>}<br>void ShellSort (SqList &amp;L, int dt[],int t) {<br>for (int k = 0; k &lt; t;++k) {<br>ShellInsert(L, dt[k]);<br>}<br>}</pre><h2 id="B3KXE"><span class="ne-text">二、交换类排序</span></h2><h3 id="qHXfT"><span class="ne-text">✅ 冒泡排序</span></h3><p id="38bd96910e0a0454a5262c26035fe738" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625013969954-b7310256-1c0a-4b3c-b45b-a7b33eca8e5c.gif" width="813" id="bVJVg" class="ne-image"></p><p id="u33c1f2b6" class="ne-p"><span class="ne-text"></span></p><pre data-language="javascript" id="S5h81" class="ne-codeblock language-javascript">/**</li><li>@param {number[]} nums</li><li>@return {number[]}<br><em>/<br>var sortArray = function(nums) {<br>for (let i = nums.length - 1; i&gt;0; i–) {<br>for (let j = 0; j&lt;i; j++) {<br>if (nums[j] &gt; nums[j+1]) {<br>let temp = nums[j]<br>nums[j] = nums[j+1]<br>nums[j+1] = temp<br>}<br>}<br>}<br>return nums<br>};</pre><p id="u5d20c9a5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653213078608-86011f32-d058-4393-902d-33f97f21578b.png" width="578.5185593865401" id="u8a10d142" class="ne-image"></p><h3 id="tjRbu"><span class="ne-text">快速排序</span></h3><p id="2abcad580b30aa89bbac80e2f52ce1d6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625017709918-661c5cd4-fd2a-49a0-be80-bb59b791ed8f.gif" width="811" id="jCV3S" class="ne-image"></p><pre data-language="cpp" id="v4tMm" class="ne-codeblock language-cpp">/</em> 快速排序 */<br>int Partition (SqList &amp;L, int low, int high) {<br>L.data[0] = L.data[low];<br>int pivotkey = L.data[low];<br>while (low &lt; high) {<br>while (low&lt;high &amp;&amp; L.data[high]&gt;=pivotkey)<br>–high;<br>L.data[low] = L.data[high];<br>while (low&lt;high &amp;&amp; L.data[low]&lt;=pivotkey)<br>++low;<br>L.data[high] = L.data[low];<br>}<br>L.data[low] = L.data[0];<br>return low;<br>}<br>void Qsort(SqList &amp;L, int low, int high) {<br>if (low&lt;high){<br>int pivoloc = Partition(L, low, high);<br>Qsort(L, low, pivoloc - 1);<br>Qsort(L, pivoloc + 1, high);<br>}<br>}<br>void QuickSort(SqList &amp;L) {<br>Qsort(L, 1, L.length);<br>}</pre><h2 id="vqepg"><span class="ne-text">三、选择类排序</span></h2><p id="3aebb659010899dbfd5c16c892662a01" class="ne-p"><a href="http://data.biancheng.net/view/72.html" data-href="http://data.biancheng.net/view/72.html" target="_blank" class="ne-link"><span class="ne-text">参考：ata.biancheng.net/view/72.html</span></a></p><h3 id="Vrp7T"><span class="ne-text">✅ 简单选择排序</span></h3><p id="d5b876da9ea6683382d3772e8c2ad53a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625014017576-1b58bc2d-d46b-48e8-a307-6fc6f4ee8f0a.gif" width="813" id="FeuYg" class="ne-image"></p><pre data-language="javascript" id="UCc3U" class="ne-codeblock language-javascript">/**</li><li>@param {number[]} nums</li><li>@return {number[]}<br>*/<br>var sortArray = function(nums) {<br>for (let i = 0; i&lt;nums.length-1; i++) {<br>for (let j = i+1; j&lt;nums.length; j++) {<br>if (nums[i] &gt; nums[j]) {<br>let temp = nums[i]<br>nums[i] = nums[j]<br>nums[j] = temp<br>}<br>}<br>}<br>return nums<br>};</pre><p id="u43567c96" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653226950636-0e2a6743-01fe-4195-8d7e-a0c59a37891e.png" width="568.1481882835803" id="u6b1a3b2d" class="ne-image"></p><h3 id="8Zesn"><span class="ne-text">树形选择排序</span></h3><p id="96b4ae1229b083e76e8eb148c07e0084" class="ne-p"><br></p><h3 id="Ry3ha"><span class="ne-text">堆排序</span></h3><p id="27bd8e77d511f4282b5bf855ef57d576" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625021691601-c1572503-c54d-4d12-8d3e-97da2ae0aa38.gif" width="547" id="b5jeQ" class="ne-image"></p><h2 id="wYfdM"><span class="ne-text">四、归并排序</span></h2><h3 id="NMBwV"><span class="ne-text">2-路归并排序</span></h3><p id="ea33608f775147ff8f17087962c9765e" class="ne-p"><span class="ne-text">给定一个序列，从左往右两两子序列进行归并</span></p><p id="6c0a75ff9d8bbfc8288fa678954e5fc6" class="ne-p"><br></p><p id="b8819e93c9172046b1309ff544c4fe6f" class="ne-p"><span class="ne-text">子序列归并的算法：加入有两个靠着的 a、b 序列，由上面可知，a、b 各自都是有序序列，现在就是将这两个合并为一个有序序列 k，将 a 和 b 序列的各个元素进行比较，小的依次放入 k 序列，当 a、b 两个中有一个序列为空了，就将那个不为空的序列直接加入到 k 序列即可，最后 k 序列就是目的序列。</span></p><p id="557d9af01136329dd59b2fa7244f3275" class="ne-p"><br></p><p id="461f6d5fc01208d120906ab21346aa22" class="ne-p"><br></p><h2 id="FZipi"><span class="ne-text">五、分配类排序</span></h2><h3 id="Qx2Q5"><span class="ne-text">基数排序</span></h3><p id="353887e2cdc59884fedc11e96e262efc" class="ne-p"><span class="ne-text">TODO: 扑克牌的花色排序</span></p><h2 id="HtSzO"><span class="ne-text">六、外部排序</span></h2><h3 id="CTOql"><span class="ne-text">基本方法</span></h3><h3 id="69w00"><span class="ne-text">多路平衡归并</span></h3><p id="862b47dd7bfc84c631f63adff5eb7698" class="ne-p"><span class="ne-text">基本思想是内部排序中的 2-路归并排序</span></p><h3 id="MbQii"><span class="ne-text">置换-选择排序</span></h3><h3 id="AFobc"><span class="ne-text">最佳归并树</span></h3><h2 id="lRFoT"><span class="ne-text">参考</span></h2><p id="7bb6c59cbacbf8c147d2f3a63ef6f7cb" class="ne-p"><span class="ne-text">文章的动画演示</span></p><ul class="ne-ul"><li id="1e3a39bc9ae64cef928baee74add8602"><a href="https://blog.csdn.net/Hk_john/article/details/79888992" data-href="https://blog.csdn.net/Hk_john/article/details/79888992" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/Hk_john/article/details/79888992</span></a><span class="ne-text">（js）</span></li><li id="daec35f35e8ed9e9f2186b3bd8c5ad29"><a href="https://www.itrhx.com/2020/10/23/A91-sorting-algorithm/" data-href="https://www.itrhx.com/2020/10/23/A91-sorting-algorithm/" target="_blank" class="ne-link"><span class="ne-text">https://www.itrhx.com/2020/10/23/A91-sorting-algorithm/</span></a><span class="ne-text">（python）</span></li></ul></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📊查找排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——梦中姑娘</title>
      <link href="/essay/di14o2/"/>
      <url>/essay/di14o2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="33be681ccc83e4979d2e8754a2873dd2" class="ne-p"><span class="ne-text">空调+风扇睡觉->易着凉->易做梦</span></p><p id="4424c713d130cfb637c4d73b8b7cf267" class="ne-p"><span class="ne-text">因着凉而做的梦大多不是自然醒，此般</span><span class="ne-text">崩坏醒……</span></p></div><p id="5f784f94c5ab374ea88f0635ecabbbf2" class="ne-p"><br></p><p id="446e5edef9cc3c53f6ad238d4f5a2aad" class="ne-p"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623127396847-7144e32c-9f84-4c90-ad75-307f781827a5.png" width="1080" id="IChRS" class="ne-image"></p><p id="f08c18d7c72c51cd6ec1f17f6bd61327" class="ne-p"><br></p><p id="3429bc03398d7bba3a9aed2305d1497f" class="ne-p"><br></p><hr id="KyTjg" class="ne-hr"><p id="918755d555b381178962fd033ea8dff5" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《人间失格》——“纯真无垢的信任算是罪过吗？”</title>
      <link href="/essay/am0q19/"/>
      <url>/essay/am0q19/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue5633382" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622964551715-a700f7e7-b3e8-45c5-9d80-787cbb0c66f3.png" width="400" id="u8cf446b6" class="ne-image"></p><p id="u797500bd" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u224179b9" class="ne-p"><span class="ne-text">“纯真无垢的信任算是罪过吗？”</span></p></div><p id="ue7be8be3" class="ne-p"><br></p><p id="u7bbd9143" class="ne-p"><span class="ne-text">经历了小时候的“看脸色行事”、中学寄读、与家庭隔绝任何关系……</span></p><p id="u2913a434" class="ne-p"><br></p><p id="ua6524f03" class="ne-p"><span class="ne-text">回归抑郁惆怅的那会日常状态，常去的那家酒馆，将自己灌得烂醉，突然有一天，遇见的不懂何为污秽的童贞的由子润湿了生来敏感的叶藏……</span></p><p id="u1ab3498b" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u41d70760" class="ne-p"><span class="ne-text">“即便因为这样日后遭逢再大的悲哀也无所谓，我一定要放纵地享受眼前这极度的欢乐，哪怕这一生仅有这一次。”</span></p></div><p id="ue99521cc" class="ne-p"><br></p><p id="u59bd13fc" class="ne-p"><span class="ne-text">还记得『无间道』里面说的「八大地狱之最，称为无间地狱，为无间断遭受大苦大意，故有此名」</span></p><p id="ucd0f2fd4" class="ne-p"><br></p><p id="u0571b508" class="ne-p"><span class="ne-text">人会变吗？不知道，但我知道敏感的人不易变……</span></p><p id="uc20bcc88" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u1092398f" class="ne-p"><span class="ne-text">四周的气氛蓦地变得异样紧张。两个人从楼顶天台走到二楼,再从二楼往底楼我的屋子走去。在楼梯上堀木停住了脚步,用手指着前面小声说道:“你看!”我家那间屋子上方的小窗户正敞开着,从那儿可以看到里面的光景。</span></p><p id="ue51c3d03" class="ne-p"><br></p><p id="uf3ebdd88" class="ne-p"><span class="ne-text">只见屋子里亮着电灯,有两只动物正在干着什么。我顿时觉得头晕目眩、呼吸急促,但同时心里却在暗自低语—这也算是一出人间粉戏吧,这也算是人类的本性吧,没什么好大惊小怪的—我甚至忘记了出手去解救由子,只是久久地呆立在楼梯中间。</span></p></div><p id="u576d2e7e" class="ne-p"><br></p><p id="u4644d1e8" class="ne-p"><span class="ne-text">“解救”这个一词我不是很理解，我看了两遍，不知道由子是被迫的还是自愿的，但是根据后文的由子对叶藏的眼神躲避的情节，我感觉是自愿的……</span></p><p id="u6f523a3a" class="ne-p"><span class="ne-text"></span></p><div data-type="danger" class="ne-alert"><p id="u0c1cf9c9" class="ne-p"><span class="ne-text">每当我唤她时，她总是身体冷不丁一哆嗦，视线也不知道该投向哪里好。无论我再怎么装痴装疯胡言乱语以逗她一笑，她都一副茫然不知所措、坐立不安、战战兢兢的样子，和我说话时还心不在焉地乱用敬语。</span></p></div><p id="u5a3e9711" class="ne-p"><span class="ne-text"></span></p><hr id="sYclb" class="ne-hr"><p id="ue3f4938f" class="ne-p"><span class="ne-text">原文里面的天台上的叶藏心理……</span></p><p id="u0f9a860f" class="ne-p"><span class="ne-text"></span></p><div data-type="info" class="ne-alert"><p id="ucd4215fb" class="ne-p"><span class="ne-text">我则像逃命似的一个人又冲回到天台，躺在地上，仰望含满雨气的夏日夜空。此时，袭遍我全身的情感不是愤怒，也不是厌恶，更不是悲伤，而是极度的恐惧。那不是面对墓地中诸多幽灵时的恐惧，倒更像是在神社的杉树林间，撞见身着白衣的神明时的那种来自太古的、凶暴恶戾的、令人噤默失语般的恐惧。从那晚起，我开始少年白头，我越发对世间所有的一切失去信心，越发对人产生无止境的怀疑，从此诀别了对人世生活所抱有的全部期待、喜悦、共鸣。事实上，这也是我整个人生中起到决定性作用的一个事件，仿佛被人迎面一刀砍中眉间，日后无论我与任何人接触，那伤口便会隐隐作痛。</span></p></div><p id="u6dd35c42" class="ne-p"><span class="ne-text"></span></p><p id="ue0a7c670" class="ne-p"><span class="ne-text">丧，十分丧……这一段，以前看的极度压抑，现在看的十分同情，敏感的叶藏遇到这种事情，真的是上天的无间地狱的惩罚吗？那现在这个时代的人呢？</span></p><p id="ud66000a9" class="ne-p"><br></p><hr id="j9z3P" class="ne-hr"><p id="ud76c5d75" class="ne-p"><br></p><p id="u276fcea0" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u9d3c5d73" class="ne-p"><span class="ne-text">“纯真无垢的信任算是罪过吗？”</span></p><p id="ufb4eec64" class="ne-p"><span class="ne-text">“纯真无垢的信任之心，难道真是罪恶之源吗？！”</span></p></div><p id="u07af0976" class="ne-p"><br></p><p id="ub16ae777" class="ne-p"><span class="ne-text">作者说着两次，好像文中还有相似强调的话语，对于一个敏感的人的内心最信任人而言，则算是一种无言的崩溃把，堕入人间地狱……</span></p><p id="ua766c76c" class="ne-p"><br></p><p id="ud9d06c63" class="ne-p"><span class="ne-text">作者不解……</span></p><p id="ub9f2e79b" class="ne-p"><br></p><p id="u2b5c6aea" class="ne-p"><span class="ne-text">第一次看这本书对此我是感到抑郁，全程压抑，但是现在看来，感受到的是一个敏感的人对周围的无奈与妥协，到最后那纯真无垢的信任之心也已死……</span></p><p id="u154db264" class="ne-p"><br></p><p id="ubc724026" class="ne-p"><span class="ne-text">这样的人生是何等的失望……</span></p><p id="ue4923726" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《人生》之高加林的爱情我也曾有过……</title>
      <link href="/essay/mh44ds/"/>
      <url>/essay/mh44ds/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ef6e5d9aa1a590615f8473d394d5f526" class="ne-p"><br></p><p id="5c5d199bb38661ac8f23fe4a363d512d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622168235721-f78e67ae-65fa-4208-bdf6-1bbad23a55a8.png" width="291.7477111816406" id="u836e58b6" class="ne-image"></p><p id="c38fbf887b9cc1272fec9e63ebf01020" class="ne-p"><span class="ne-text">以前看的，今天突然有一些很深的感悟</span></p><p id="89427396d2c5d1daa888afbdebb672d3" class="ne-p"><br></p><p id="ae9f2b2b925c6c5b0b5413909a302f3d" class="ne-p"><span class="ne-text">高加林把纯情美丽、聪慧贤淑的刘巧珍这块“金子”丢了，突然想到相似的自己、想到了守恒、想到了辗转反侧却也难忘的心思……</span></p><p id="5c9949954b1ac835a28fec5c7dd7e7d5" class="ne-p"><br></p><p id="b06f185f80c24604db0e907c7e6bf5b3" class="ne-p"><span class="ne-text">守恒律，总觉得这世界上任何东西</span></p><p id="48416172029192e65ab79e808f6bf6a9" class="ne-p"><span class="ne-text">这世界上的事情，总是守恒的，人和人之间的情感，爱情、人情味、亲情</span></p><p id="9010c8e3989fd7b1a3132f85c9688435" class="ne-p"><br></p><p id="039264b44bbe6a4d695c6ce3c31bd2e9" class="ne-p"><span class="ne-text">还记得路遥的《人生》最后说，加林失去了自己人生中最重要的金子，我觉得这也是守恒的，从一开始，高加林就获得了自己的“金子”，然而呢，没珍惜……一开始高加林的教师职位被强拉下来，这的确是人生的不公，但是这也迎来了上天送给他的巧珍这颗金子，而后呢，他又放弃了巧珍这颗金子，追寻另外的一个女人，到最后，这个金子也没了</span></p><p id="92b4ac2768507d2d16d76794d2e49bd0" class="ne-p"><br></p><p id="da45cca86e95857c8894ad872f2ab8d3" class="ne-p"><strong><span class="ne-text">现实是如此的相似，我曾经也失去过金子，她非常漂亮，些许单纯，些许霸道，还喜欢看言情小说……我们和书里面的主人公一摸一样，真就一模一样，原因无他，在当时看来，在当时周围整个世界看来，读书谈啥恋爱……那时的我，很懵懂···后来我就进高中了，她好像是去一个技术学院还是直接工作，我忘了，有一次我上QQ了，那会应该是高一，她真好也在，便和她聊起天，那会她好朋友也在，我们三个是朋友，那会我们一起聊天，突然她朋友来一句“你啥时候和我家XXX表白呢”……</span></strong></p><p id="265828558d5bc033a25f2506ec93a7ae" class="ne-p"><strong><span class="ne-text">是的，那会，又是在读书……我不记得我当时是怎么回应的了，我只知道我当时挺想看看她的……</span></strong></p><p id="36d339b8b1c63384d8c9a9091b4c37d8" class="ne-p"><br></p><p id="0366ac1c457a937be376892979616201" class="ne-p"><strong><span class="ne-text">我大学期间，她生娃了，很漂亮但不帅……</span></strong></p><p id="49c0faf53cf3bfda53a218397a5e2280" class="ne-p"><br></p><p id="ae02a52dc2f537a826f2421d1570c094" class="ne-p"><strong><span class="ne-text">我苦笑、却又辗转反侧……</span></strong></p><p id="bd8f1f817d61e9f33d0b886a53487a1d" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>微信屏蔽的不只有网易云的『性格主导色』</title>
      <link href="/essay/qgtwsr/"/>
      <url>/essay/qgtwsr/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u4d57e041" class="ne-p"><br></p><p id="d2b61f151acbde582282a6b2f646f8ce" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622096165024-de751f5a-0c8f-4d21-8fe9-da41dbf459bf.jpeg" width="541" id="gsk95" class="ne-image"></p><p id="e82f5b43d584b8e8acc2faf69fe90ce4" class="ne-p"><span class="ne-text"></span></p><p id="u0d1d720a" class="ne-p"><span class="ne-text">前言：网易云『性格主导色』活动页面遭微信屏蔽，在微信软件中点击活动页面会出现以下警告内容。我倒是见怪不怪，因为被屏蔽的不只有网易云的『性格主导色』，还有许许多多默不作声的外链，细想之，我个人的看法是与其说这是一种为了维护绿色上网环境，倒不如说是对当下自媒体崛起的一种流量上的恐慌……</span></p><p id="d268c05fe4a227ded7bb1b61b084825d" class="ne-p"><br></p><p id="e934efc031950b4679c0209454f48a45" class="ne-p"><br></p><p id="616a3140048db0ff66dfb99d760786a4" class="ne-p"><span class="ne-text">现如今自媒体的崛起，广告的投放不单单是微信，短视频平台，某站平台等这些更加吸引广大用户的娱乐平台的崛起，说白了，自媒体的崛起给腾讯造成了流量上的恐慌，倘若在B站动漫里面推广一些产品，不比下面这种每天都看的心烦的广告好得多</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622097105798-a36f91ad-5589-4393-8a28-1d152e214c18.jpeg" width="52" id="y9K8r" class="ne-image"><span class="ne-text">……</span></p><p id="367d4467982c910dd749f19c3ba15c70" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622095673079-588276fc-6d38-4886-8d9c-be90b62f0f63.png" width="282" id="C71oi" class="ne-image"></p><p id="a4d23d825e04d4190e7e9fe9b45dccbf" class="ne-p"><span class="ne-text">但是作为腾讯的这种机制是说为了维护用户体验，保留用户的权益……就我个人而言，我所知道的不仅仅是这个事件被屏蔽，还有之前的语雀链接在微信也不能打开，另外近期，在QQ里面我打开自己的网站，也是无效的，会提示非官方网站，许多博客站点都被屏蔽了</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622097255080-95d8e27c-375d-4629-b118-4f74c1273e9c.jpeg" width="62" id="XPRrb" class="ne-image"><span class="ne-text">，总的来说，像上面那种广告是不会被屏蔽的，但是像一些外链现在十有八九是会被屏蔽的，不管这外链是低质量内容还是有不错内容的站点。</span></p><p id="u120f98ee" class="ne-p"><br></p><hr id="MvSBf" class="ne-hr"><hr id="LyYCu" class="ne-hr"><p id="ub4ad397f" class="ne-p"><span class="ne-text">给自己测了下这个主导色，除了蓝色是对的，</span><strong><span class="ne-text">其他的都扯淡</span></strong><span class="ne-text">……</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622098043031-f48fc2c7-e8d9-416f-acd6-925a9528af2e.jpeg" width="48" id="ohPur" class="ne-image"></p><p id="u33cd71f0" class="ne-p"><br></p><p id="ud7df80cd" class="ne-p"><br></p><p id="u3a52bc90" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622097912666-9ca03aa8-58f6-4f2e-a5e0-02145b87cb74.jpeg" width="1176" id="u0e97d042" class="ne-image"></p><p id="423180e1a9062261b09a97f824672c75" class="ne-p"><br></p><p id="e6809a4e992ace86e9ac676452459e73" class="ne-p"><br></p><p id="c8779dfb53d51b04df5d60283ef7b7e3" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《活着》</title>
      <link href="/essay/rcexdl/"/>
      <url>/essay/rcexdl/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B7%2C0%5D%2C%5B7%2C0%5D%5D%2C%22active%22%3Atrue%7D"><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="05795b68a4e1044120001f014cc351bb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">今天突然打开电脑里面的OneNote，发现以前还真写过不少东西……记得当时看这本书的时候，是在一个下午，一个最深的场景主人公他儿子死了，那个清晨黎明两三点，富贵从医院背着儿子往家走的时候，那个场景，针对心酸……有些许微风，夹杂着些许露水……阵阵凉意~</p></blockquote><p data-lake-id="904cf7b39d4a7de52ca0664eae909127" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622032573540-7113b1ee-f2f6-419f-a75b-577f79de0a27.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="366px" style="visibility: visible; width: 671.5px;"></span></p><p data-lake-id="1311f4bca42db95a08151cd53b683752" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="bbb2ca74705fa037f6e4f73396f16d23" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">18年写的</p></blockquote><p data-lake-id="171d6cef71fd7d7c7a9a2a2dacd57b63" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="b4ffda1cada83f72d344cbe02557cfd4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">《活着》有感</p><p data-lake-id="9880b967dd3394db8ac8db6a334286ef" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="936315e433bcc154cf6a1fad055282a3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">每个人的人生都不一样，但是我们都活着。</p><p data-lake-id="dcabc343faf3c64f389ec41ef6b86675" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="f8a32de698dd65c12ce295163b752662" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">——有感</p><p data-lake-id="d2c04cb2afbd09a07bb82778cfc4d416" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="878691c5f4e27bdc24ee4ac599a8ef2c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">“我知道黄昏正在准瞬即逝，黑夜从天而降了。我看到广阔的土地袒露着结实的胸膛，那是召唤的姿态，就像女人召唤者她们的儿女，土地召唤着黑夜来临。”活着是一种姿态，一种哲学，主人公福贵的人生是不幸的，在那个时代生活的艰辛，身边的人都离他而去，他几乎失去了一切，但是他活着，活得无奈，活得平庸，活的平凡，但活出了活着的意义。每个人对于活着都会有不同的人生感悟，我们的人生都不一样，因为我们都活着。</p><p data-lake-id="c7736f8bcbdc3edda2aa593a85016dfc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="0eb1dbe42aea2a8226dac1cea3c8b33c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">一个人的人生会因为一个人的一次行为而改变，而改变正是一个人活着意义所在。赌博让福贵的家庭从家财万贯到穷困潦倒，我一直觉得一个有故事的人一定会是曾经经历了什么。这次赔债过程中，福贵的爹爹也去世了，再混的子女遇见这等事谁不会心里塌了一片天，可能一切对于当时的他来讲很沉重，但是已经发生了。紧接着的又是妻子家珍被她爹带回家。这里我最感触深的是单纯，天真无邪的凤霞。送给龙二钱的时候，被国民党强制性的拉去充炮兵，就这样又和妻子孩子失去联系，在每天的炮火里，唯一的牵挂也只有老婆孩子了，对啊，人只有在最失意的时候才会想起身边的人，才会珍惜所拥有的，曾经对妻子的漠不关心现在会有牵挂，</p><p data-lake-id="bcd9e16522a95621c96c4311e012bc54" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="bd8887e5a69427fbcdbb8d51aac4e659" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">在人民公社之后，百姓的日子日益变得破败不堪，我没有过也没有见过那时代的人，但是我长辈见过。小说有一个片段我觉得挺真实，凤霞用锄头挖到一个地瓜，但是却被村里其他人抢去，可能许多读者看到这不会有太多感触，但我是农村人，我对于此有些许的感触。在决定把凤霞送给别人家的时候，那真的真的是走到尽头了，</p><p data-lake-id="a8f203ad7b6dbb596774ecdf0719b8ed" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">感触最深的就是，凤霞一天晚上偷偷跑回家，当福贵打开家门，凤霞望着自己的爹娘，说不出话，也听不见别人的话，当福贵决定送凤霞到城里人家时，他说了一句话“就是全家都饿死，也不送凤霞回去”，那一刻，我觉得很温暖，我相信，那是真正的父爱。活着为了什么，我觉得就是为了那些生活中的感动，一个人来到这个世界上，一定都是不容易的，有爱自己的父母，这些一切的一切都是会使得情大于现实。</p><p data-lake-id="a4a582f626b93c8a827d0645c6b31254" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="7b2058902899511b2306330250150b5c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">原本已经不错的日子最后还是发生了不幸，儿子有庆离开了人世…那天晚上的福贵抱着有庆在回家的路上走走停停，停停走走，不是得停下坐在田埂看看自己的儿子，摸着儿子的脸庞，那时间我的眼眶真的湿了。不知道为什么，看到那时候我想起了我的父母…</p><p data-lake-id="3f6fbce2dda36f7efe9069d15ac0c8ee" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="34b59079f71c74ffc834901bdd49d0df" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">原本凤霞和二喜的婚姻可以让这个不幸的家庭融入点暖和的血液，只是老天还是无情，凤霞的接生让小的来到这个世上，而大的永远离开了。读到这，我的内心真的很难让我往下看了，因为在父母而言，自己的子女都早于自己离开人世，白发人送黑发人，这是怎样的一种伤感，谁能接受这样的现实呢？只是活着终究要活着。之后的生活家珍走了，走的坦然，走之前的家珍说过一句“下辈子还做你的女人，下辈子还和你过”，让我觉得，这是历经苦难之后真正的爱情。爱情是两情相悦，是无言的天长地久，我敬重他们的真爱。福贵晚年也离不开现实的摧残，二喜、苦根也都离开人世了，苦根还那么小，那么的天真，再往后，就是福贵的和老牛的余生了。</p><p data-lake-id="049dae438737fc21e34b80696466b6fc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ed7d0dde53b7d53e8028786d4b9a034e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">远处的池塘边，有一头老牛在池边喝水，一位老人慢慢的走去。</p><p data-lake-id="fceb970a55838b8744a4f4cff519a96d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="bb1388307b90b3ee0aa3fa86bbf70f80" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">尽管《活着》不是一部老师所要求的自传，但我恰恰觉得这是这个世界里许多平凡的人的自传，是那些这个社会中底层人民的生活真实写照，是那些渺小的生命，却能活出活着的意义。</p><p data-lake-id="c2481fe8be7567940164ce7f5cf5038d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="b7da4d66ffd8383cca955fbb6dfba0ef" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="829298cdfced754b6c6566f9cbac2fc3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">福贵，福贵的牛，福贵的爹，龙二，家丁长根，老全，春生，家珍，凤霞，有庆，二喜，苦根</p><p data-lake-id="7fe1e951d728d6503b99cb7c8b6b0c0b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">和龙二赌博输了家底导致生活破败，爹爹去世了，家珍被她爹带回家</p><p data-lake-id="9f6e2657353a2bec2ee18add05680803" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">被国名党拉去充炮兵，结识老全，春生，战败之际，投降回到家里见到老婆孩子</p><p data-lake-id="7d9acd8b2ddde6e3755d97c9ff5f0ef4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">人民公社的成立以及之后的潦倒生活，文革</p><p data-lake-id="91ef678e8518e3dac8437d7307b82975" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">把凤霞送给别人家，最后还是情大于现实，留下凤霞一家人生活着</p><p data-lake-id="0602788741f7fa9102b3c48a610b6c41" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">有庆献血离去，凤霞接生出血离去，家珍身子体弱离去，二喜工作事故离去，苦根吃豆子死去</p><p data-lake-id="8a8c1dcc710561a2021aebdd665eda6a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="906faa5ee7c65f846679dba0cc041575" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">反过来我们也可以说，<strong>因为我们都活着，从而我们的人生可以选择得不一样</strong>。</p><p data-lake-id="8f06410e555a21cb23ee58c612b9ff45" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c7d31ee818e418b7302309ec9b606c1f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">作者是以第一人称来塑造富贵这个人物形象，最后的最后只有富贵和他的老牛，不幸的人生，却告诉我们一个人生哲学：活着本身的意义就是活着。</p><p data-lake-id="0731a5b59c027f3439682eb1fd845b60" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『境界的彼方』</title>
      <link href="/essay/wvwrcu/"/>
      <url>/essay/wvwrcu/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-traditional" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B1%2C0%5D%2C%5B1%2C0%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="u435b3838" id="u435b3838" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1623940888474-c6aa4c62-7d9d-44df-b0ab-bd198c263434.jpg?x-oss-process=image%2Fresize%2Cw_1500" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="1128px" style="visibility: visible; width: 2003px;"></span></p><p data-lake-id="6246a9bb1cda408c977bad04d75c2888" id="6246a9bb1cda408c977bad04d75c2888" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="uceda34d7" id="uceda34d7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>两个特殊身份的角色在一起发生的战斗纯爱番……栗山未来是有着“被诅咒血脉”的异界士少女，神原秋人是有着寄居在体内强大妖梦的半妖（最大的反派竟是主角自己</span><span data-card-type="inline" data-lake-card="image" id="hqw9a"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623926928373-713cb502-b0c8-43a3-ae20-e45a5b4d6828.jpeg" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="58px" style="visibility: visible; width: 79px;"></span></p><p data-lake-id="u1a52d698" id="u1a52d698" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="8gtz1"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="ud713ec65" id="ud713ec65" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u6a479a0b" id="u6a479a0b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>虚幻之影一战</span></p><p data-lake-id="ue4cd9e2f" id="ue4cd9e2f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这算是秋人解开未来心结的剧情了，男主</span></p><p data-lake-id="u10b370b4" id="u10b370b4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u0ec14f65" id="u0ec14f65" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u95718d68" id="u95718d68" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="jD2t5"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623927006789-0efec99a-7362-4b1f-8118-0f139cb451a3.jpeg" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="481px" style="visibility: visible; width: 1024px;"></span></p><p data-lake-id="udcc70e87" id="udcc70e87" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ud285752b" id="ud285752b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ubbfc4030" id="ubbfc4030" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>当一个纯爱的人突然有一天闯进缺爱的人世界，这个人就不再孤独，他的余生也注定会因此而改变……</span></p><p data-lake-id="ue6f5448e" id="ue6f5448e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u902ad01f" id="u902ad01f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u2e457d3d" id="u2e457d3d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="EBka9"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623927008770-1000842b-b921-4257-9ffe-3698a435f1ef.png?x-oss-process=image%2Fresize%2Cw_1500" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="1080px" style="visibility: visible; width: 1920px;"></span></p><p data-lake-id="u71452075" id="u71452075" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ucfe46fd0" id="ucfe46fd0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>受过爱的缺爱的人做出的抉择往往不会像常人一样……</span></p><p data-lake-id="uef31c1e8" id="uef31c1e8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u07e89aec" id="u07e89aec" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="WSDbg"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623927010160-66e09e34-7c86-4ac5-af4d-0097251e4f26.png?x-oss-process=image%2Fresize%2Cw_1500" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="1080px" style="visibility: visible; width: 1920px;"></span></p><p data-lake-id="uc2681876" id="uc2681876" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u87d127d5" id="u87d127d5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="uf52bea41" id="uf52bea41" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ub6f752f2" id="ub6f752f2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u349cf580" id="u349cf580" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这个是真的呆萌……</span></p><p data-lake-id="uad20e3cf" id="uad20e3cf" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="uf68c7505" id="uf68c7505" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u9bba37de" id="u9bba37de" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="KMadh"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623927004531-2156628e-e34f-415b-9ff1-a2b53d98f167.jpeg" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="481px" style="visibility: visible; width: 1024px;"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最短路径算法（Dijkstra+Floyd）</title>
      <link href="/blog/rxx0ab/"/>
      <url>/blog/rxx0ab/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="zNIHZ"><span class="ne-text">问题描述</span></h2><p id="62dc1f6eeaf4d085770a4b431580e59f" class="ne-p"><strong><span class="ne-text">校园最短路径实验</span></strong></p><p id="a73d6fe9137a449283e7e6174b9a8672" class="ne-p"><span class="ne-text">1、给出校园中常用的几个点，如教室550、文宗楼、三个食堂、大操场、宿舍楼（自定）、校门口、体育场；</span></p><p id="e872dd787b0659b0ba4e065a8d1304e5" class="ne-p"><span class="ne-text">2、画图并给出其邻接矩阵（请合作完成）；</span></p><p id="8dfdd4331fdd61b2225d6ae6be60e67c" class="ne-p"><span class="ne-text">3、用floyd算法求每对顶点间的最短路。</span></p><p id="695d4175097ade1b18ab44f07893e3d0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622701735560-677cf8e1-e3f6-4c6a-9288-500eefaae6d4.png" width="545.5" id="VrPJt" class="ne-image"></p><hr id="RYp3i" class="ne-hr"><p id="f5896a514532e26e9ab4f424db11e700" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">迪杰斯特拉（Dijkstra）算法</span></p></div><p id="f5df7e9bae3edc596f0249ded448a799" class="ne-p"><br></p><p id="c0ace7f4bd10e006e360cc545ad23796" class="ne-p"><span class="ne-text">Dijkstra算法是经典的单源最短路径算法，用于计算源点到其它所有顶点的最短路径。在图 G=(V,E) 中，假设每条边 E[i] 的权值距离为 w[i]，找到由源点 v0 到其余各点的最短路径。</span></p><p id="c4eda4769b9382558e617e1d98192a33" class="ne-p"><span class="ne-text">适用：不含负权重的图</span></p><p id="f8c761d9834b36277f84b1f6b36ba85f" class="ne-p"><br></p><p id="660b2e6d53de278be77090da3cdff5f4" class="ne-p"><span class="ne-text">算法当中，对图的遍历方式为BFS（广度优先遍历）</span></p><h2 id="GgRFy"><span class="ne-text">代码</span></h2><p id="48d84c4d0710621d0f26ff9b37fc918b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622703321484-ea1fa3e2-34db-4827-8048-cd68231125cb.png" width="280.5" id="MRDfH" class="ne-image"></p><pre data-language="cpp" id="EANUw" class="ne-codeblock language-cpp">/**<ul><li>C++: Floyd 算法获取最短路径(邻接矩阵)</li><li>*/</li></ul><p>#include <iomanip><br>#include <iostream><br>#include <vector><br>#include &lt;bits/stdc++.h&gt;<br>using namespace std;</p><p>// 边的结构体<br>class EData<br>{<br>public:<br>char start; // 边的起点<br>char end; // 边的终点<br>int weight; // 边的权重</p><pre><code>public:    EData()&#123;&#125;    EData(char s, char e, int w):start(s),end(e),weight(w)&#123;&#125;</code></pre><p>};</p><p>class MatrixUDG {<br>#define MAX 100<br>#define INF (~(0x1&lt;&lt;31)) // 无穷大(即 0X7FFFFFFF)<br>private:<br>char mVexs[MAX]; // 顶点集合<br>int mVexNum; // 顶点数<br>int mEdgNum; // 边数<br>int mMatrix[MAX][max]; // 邻接矩阵</p><pre><code>public:    // 创建图(自己输入数据)    MatrixUDG();    // 创建图(用已提供的矩阵)    //MatrixUDG(char vexs[], int vlen, char edges[][2], int elen);    MatrixUDG(char vexs[], int vlen, int matrix[][9]);    ~MatrixUDG();    // 深度优先搜索遍历图    void DFS();    // 广度优先搜索（类似于树的层次遍历）    void BFS();    // prim最小生成树(从start开始生成最小生成树)    void prim(int start);    // 克鲁斯卡尔（Kruskal)最小生成树    void kruskal();    // Dijkstra最短路径    void dijkstra(int vs, int vexs[], int dist[]);    // Floyd最短路径    void floyd(int path[][MAX], int dist[][MAX]);    // 打印矩阵队列图    void print();private:    // 读取一个输入字符    char readChar();    // 返回ch在mMatrix矩阵中的位置    int getPosition(char ch);    // 返回顶点v的第一个邻接顶点的索引，失败则返回-1    int firstVertex(int v);    // 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1    int nextVertex(int v, int w);    // 深度优先搜索遍历图的递归实现    void DFS(int i, int *visited);    // 获取图中的边    EData* getEdges();    // 对边按照权值大小进行排序(由小到大)    void sortEdges(EData* edges, int elen);    // 获取i的终点    int getEnd(int vends[], int i);</code></pre><p>};</p><p>/*</p><ul><li><p>创建图(自己输入数据)<br>*/<br>MatrixUDG::MatrixUDG()<br>{<br>char c1, c2;<br>int i, j, weight, p1, p2;</p><pre><code>// 输入&quot;顶点数&quot;和&quot;边数&quot;cout &lt;&lt; &quot;input vertex number: &quot;;cin &gt;&gt; mVexNum;cout &lt;&lt; &quot;input edge number: &quot;;cin &gt;&gt; mEdgNum;if ( mVexNum &lt; 1 || mEdgNum &lt; 1 || (mEdgNum &gt; (mVexNum * (mVexNum-1))))&#123;    cout &lt;&lt; &quot;input error: invalid parameters!&quot; &lt;&lt; endl;    return ;&#125;// 初始化&quot;顶点&quot;for (i = 0; i &lt; mVexNum; i++)&#123;    cout &lt;&lt; &quot;vertex(&quot; &lt;&lt; i &lt;&lt; &quot;): &quot;;    mVexs[i] = readChar();&#125;// 1. 初始化&quot;边&quot;的权值for (i = 0; i &lt; mVexNum; i++)&#123;    for (j = 0; j &lt; mVexNum; j++)    &#123;        if (i==j)            mMatrix[i][j] = 0;        else            mMatrix[i][j] = INF;    &#125;&#125;// 2. 初始化&quot;边&quot;的权值: 根据用户的输入进行初始化for (i = 0; i &lt; mEdgNum; i++)&#123;    // 读取边的起始顶点，结束顶点，权值    cout &lt;&lt; &quot;edge(&quot; &lt;&lt; i &lt;&lt; &quot;): &quot;;    c1 = readChar();    c2 = readChar();    cin &gt;&gt; weight;    p1 = getPosition(c1);    p2 = getPosition(c2);    if (p1==-1 || p2==-1)    &#123;        cout &lt;&lt; &quot;input error: invalid edge!&quot; &lt;&lt; endl;        return ;    &#125;    mMatrix[p1][p2] = weight;    mMatrix[p2][p1] = weight;&#125;</code></pre><p>}</p></li></ul><p>/*</p><ul><li>创建图(用已提供的矩阵)</li><li></li><li>参数说明：</li><li><pre><code>vexs  -- 顶点数组</code></pre></li><li><pre><code>vlen  -- 顶点数组的长度</code></pre></li><li><pre><code>matrix-- 矩阵(数据)</code></pre></li></ul><p>  */<br>  MatrixUDG::MatrixUDG(char vexs[], int vlen, int matrix[][9])<br>  {<br>  int i, j;</p><pre><code>  // 初始化&quot;顶点数&quot;和&quot;边数&quot;  mVexNum = vlen;  // 初始化&quot;顶点&quot;  for (i = 0; i &lt; mVexNum; i++)      mVexs[i] = vexs[i];  // 初始化&quot;边&quot;  for (i = 0; i &lt; mVexNum; i++)      for (j = 0; j &lt; mVexNum; j++)          mMatrix[i][j] = matrix[i][j];  // 统计边的数目  for (i = 0; i &lt; mVexNum; i++)      for (j = 0; j &lt; mVexNum; j++)          if (i!=j &amp;&amp; mMatrix[i][j]!=INF)              mEdgNum++;  mEdgNum /= 2;</code></pre><p>  }</p><p>/*</p><ul><li>析构函数<br>*/<br>MatrixUDG::~MatrixUDG()<br>{<br>}</li></ul><p>/*</p><ul><li>返回 ch 在 mMatrix 矩阵中的位置<br>*/<br>int MatrixUDG::getPosition(char ch)<br>{<br>int i;<br>for(i=0; i&lt;mVexNum; i++)<br>if(mVexs[i]==ch)<br>return i;<br>return -1;<br>}</li></ul><p>/*</p><ul><li><p>读取一个输入字符<br>*/<br>char MatrixUDG::readChar()<br>{<br>char ch;</p><pre><code>do &#123;    cin &gt;&gt; ch;&#125; while(!((ch&gt;=&#39;a&#39;&amp;&amp;ch&lt;=&#39;z&#39;) || (ch&gt;=&#39;A&#39;&amp;&amp;ch&lt;=&#39;Z&#39;)));return ch;</code></pre><p>}</p></li></ul><p>/*</p><ul><li><p>返回顶点 v 的第一个邻接顶点的索引，失败则返回-1<br>*/<br>int MatrixUDG::firstVertex(int v)<br>{<br>int i;</p><pre><code>if (v&lt;0 || v&gt;(mVexNum-1))    return -1;for (i = 0; i &lt; mVexNum; i++)    if (mMatrix[v][i]!=0 &amp;&amp; mMatrix[v][i]!=INF)        return i;return -1;</code></pre><p>}</p></li></ul><p>/*</p><ul><li><p>返回顶点 v 相对于 w 的下一个邻接顶点的索引，失败则返回-1<br>*/<br>int MatrixUDG::nextVertex(int v, int w)<br>{<br>int i;</p><pre><code>if (v&lt;0 || v&gt;(mVexNum-1) || w&lt;0 || w&gt;(mVexNum-1))    return -1;for (i = w + 1; i &lt; mVexNum; i++)    if (mMatrix[v][i]!=0 &amp;&amp; mMatrix[v][i]!=INF)        return i;return -1;</code></pre><p>}</p></li></ul><p>/*</p><ul><li><p>深度优先搜索遍历图的递归实现<br>*/<br>void MatrixUDG::DFS(int i, int *visited)<br>{<br>int w;</p><pre><code>visited[i] = 1;cout &lt;&lt; mVexs[i] &lt;&lt; &quot; &quot;;// 遍历该顶点的所有邻接顶点。若是没有访问过，那么继续往下走for (w = firstVertex(i); w &gt;= 0; w = nextVertex(i, w))&#123;    if (!visited[w])        DFS(w, visited);&#125;</code></pre></li></ul><p>}</p><p>/*</p><ul><li><p>深度优先搜索遍历图<br>*/<br>void MatrixUDG::DFS()<br>{<br>int i;<br>int visited[MAX]; // 顶点访问标记</p><pre><code>// 初始化所有顶点都没有被访问for (i = 0; i &lt; mVexNum; i++)    visited[i] = 0;cout &lt;&lt; &quot;DFS: &quot;;for (i = 0; i &lt; mVexNum; i++)&#123;    //printf(&quot;\n== LOOP(%d)\n&quot;, i);    if (!visited[i])        DFS(i, visited);&#125;cout &lt;&lt; endl;</code></pre><p>}</p></li></ul><p>/*</p><ul><li><p>广度优先搜索（类似于树的层次遍历）<br>*/<br>void MatrixUDG::BFS()<br>{<br>int head = 0;<br>int rear = 0;<br>int queue[MAX]; // 辅组队列<br>int visited[MAX]; // 顶点访问标记<br>int i, j, k;</p><pre><code>for (i = 0; i &lt; mVexNum; i++)    visited[i] = 0;cout &lt;&lt; &quot;BFS: &quot;;for (i = 0; i &lt; mVexNum; i++)&#123;    if (!visited[i])    &#123;        visited[i] = 1;        cout &lt;&lt; mVexs[i] &lt;&lt; &quot; &quot;;        queue[rear++] = i;  // 入队列    &#125;    while (head != rear)    &#123;        j = queue[head++];  // 出队列        for (k = firstVertex(j); k &gt;= 0; k = nextVertex(j, k)) //k是为访问的邻接顶点        &#123;            if (!visited[k])            &#123;                visited[k] = 1;                cout &lt;&lt; mVexs[k] &lt;&lt; &quot; &quot;;                queue[rear++] = k;            &#125;        &#125;    &#125;&#125;cout &lt;&lt; endl;</code></pre><p>}</p></li></ul><p>/*</p><ul><li><p>打印矩阵队列图<br>*/<br>void MatrixUDG::print()<br>{<br>int i,j;</p><pre><code>cout &lt;&lt; &quot;Martix Graph:&quot; &lt;&lt; endl;for (i = 0; i &lt; mVexNum; i++)&#123;    for (j = 0; j &lt; mVexNum; j++)        cout &lt;&lt; setw(10) &lt;&lt; mMatrix[i][j] &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;&#125;</code></pre><p>}</p></li></ul><p>/*</p><ul><li>prim 最小生成树</li><li></li><li>参数说明：</li><li>start – 从图中的第 start 个元素开始，生成最小树<br>*/<br>void MatrixUDG::prim(int start)<br>{<br>int min,i,j,k,m,n,sum;<br>int index=0; // prim 最小树的索引，即 prims 数组的索引<br>char prims[MAX]; // prim 最小树的结果数组<br>int weights[MAX]; // 顶点间边的权值</li></ul><pre><code>// prim最小生成树中第一个数是&quot;图中第start个顶点&quot;，因为是从start开始的。prims[index++] = mVexs[start];// 初始化&quot;顶点的权值数组&quot;，// 将每个顶点的权值初始化为&quot;第start个顶点&quot;到&quot;该顶点&quot;的权值。for (i = 0; i &lt; mVexNum; i++ )    weights[i] = mMatrix[start][i];// 将第start个顶点的权值初始化为0。// 可以理解为&quot;第start个顶点到它自身的距离为0&quot;。weights[start] = 0;for (i = 0; i &lt; mVexNum; i++)&#123;    // 由于从start开始的，因此不需要再对第start个顶点进行处理。    if(start == i)        continue;    j = 0;    k = 0;    min = INF;    // 在未被加入到最小生成树的顶点中，找出权值最小的顶点。    while (j &lt; mVexNum)    &#123;        // 若weights[j]=0，意味着&quot;第j个节点已经被排序过&quot;(或者说已经加入了最小生成树中)。        if (weights[j] != 0 &amp;&amp; weights[j] &lt; min)        &#123;            min = weights[j];            k = j;        &#125;        j++;    &#125;    // 经过上面的处理后，在未被加入到最小生成树的顶点中，权值最小的顶点是第k个顶点。    // 将第k个顶点加入到最小生成树的结果数组中    prims[index++] = mVexs[k];    // 将&quot;第k个顶点的权值&quot;标记为0，意味着第k个顶点已经排序过了(或者说已经加入了最小树结果中)。    weights[k] = 0;    // 当第k个顶点被加入到最小生成树的结果数组中之后，更新其它顶点的权值。    for (j = 0 ; j &lt; mVexNum; j++)    &#123;        // 当第j个节点没有被处理，并且需要更新时才被更新。        if (weights[j] != 0 &amp;&amp; mMatrix[k][j] &lt; weights[j])            weights[j] = mMatrix[k][j];    &#125;&#125;// 计算最小生成树的权值sum = 0;for (i = 1; i &lt; index; i++)&#123;    min = INF;    // 获取prims[i]在mMatrix中的位置    n = getPosition(prims[i]);    // 在vexs[0...i]中，找出到j的权值最小的顶点。    for (j = 0; j &lt; i; j++)    &#123;        m = getPosition(prims[j]);        if (mMatrix[m][n]&lt;min)            min = mMatrix[m][n];    &#125;    sum += min;&#125;// 打印最小生成树cout &lt;&lt; &quot;PRIM(&quot; &lt;&lt; mVexs[start] &lt;&lt; &quot;)=&quot; &lt;&lt; sum &lt;&lt; &quot;: &quot;;for (i = 0; i &lt; index; i++)    cout &lt;&lt; prims[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;</code></pre><p>}</p><p>/*</p><ul><li><p>获取图中的边<br><em>/<br>EData</em> MatrixUDG::getEdges()<br>{<br>int i,j;<br>int index=0;<br>EData *edges;</p><pre><code>edges = new EData[mEdgNum];for (i=0; i &lt; mVexNum; i++)&#123;    for (j=i+1; j &lt; mVexNum; j++)    &#123;        if (mMatrix[i][j]!=INF)        &#123;            edges[index].start  = mVexs[i];            edges[index].end    = mVexs[j];            edges[index].weight = mMatrix[i][j];            index++;        &#125;    &#125;&#125;return edges;</code></pre><p>}</p></li></ul><p>/*</p><ul><li><p>对边按照权值大小进行排序(由小到大)<br><em>/<br>void MatrixUDG::sortEdges(EData</em> edges, int elen)<br>{<br>int i,j;</p><pre><code>for (i=0; i&lt;elen; i++)&#123;    for (j=i+1; j&lt;elen; j++)    &#123;        if (edges[i].weight &gt; edges[j].weight)        &#123;            // 交换&quot;边i&quot;和&quot;边j&quot;            swap(edges[i], edges[j]);        &#125;    &#125;&#125;</code></pre><p>}</p></li></ul><p>/*</p><ul><li>获取 i 的终点<br>*/<br>int MatrixUDG::getEnd(int vends[], int i)<br>{<br>while (vends[i] != 0)<br>i = vends[i];<br>return i;<br>}</li></ul><p>/*</p><ul><li><p>克鲁斯卡尔（Kruskal)最小生成树<br>*/<br>void MatrixUDG::kruskal()<br>{<br>int i,m,n,p1,p2;<br>int length;<br>int index = 0; // rets 数组的索引<br>int vends[MAX]={0}; // 用于保存”已有最小生成树”中每个顶点在该最小树中的终点。<br>EData rets[MAX]; // 结果数组，保存 kruskal 最小生成树的边<br>EData *edges; // 图对应的所有边</p><pre><code>// 获取&quot;图中所有的边&quot;edges = getEdges();// 将边按照&quot;权&quot;的大小进行排序(从小到大)sortEdges(edges, mEdgNum);for (i=0; i&lt;mEdgNum; i++)&#123;    p1 = getPosition(edges[i].start);      // 获取第i条边的&quot;起点&quot;的序号    p2 = getPosition(edges[i].end);        // 获取第i条边的&quot;终点&quot;的序号    m = getEnd(vends, p1);                 // 获取p1在&quot;已有的最小生成树&quot;中的终点    n = getEnd(vends, p2);                 // 获取p2在&quot;已有的最小生成树&quot;中的终点    // 如果m!=n，意味着&quot;边i&quot;与&quot;已经添加到最小生成树中的顶点&quot;没有形成环路    if (m != n)    &#123;        vends[m] = n;                       // 设置m在&quot;已有的最小生成树&quot;中的终点为n        rets[index++] = edges[i];           // 保存结果    &#125;&#125;delete[] edges;// 统计并打印&quot;kruskal最小生成树&quot;的信息length = 0;for (i = 0; i &lt; index; i++)    length += rets[i].weight;cout &lt;&lt; &quot;Kruskal=&quot; &lt;&lt; length &lt;&lt; &quot;: &quot;;for (i = 0; i &lt; index; i++)    cout &lt;&lt; &quot;(&quot; &lt;&lt; rets[i].start &lt;&lt; &quot;,&quot; &lt;&lt; rets[i].end &lt;&lt; &quot;) &quot;;cout &lt;&lt; endl;</code></pre><p>}</p></li></ul><p>/*</p><ul><li>Dijkstra 最短路径。</li><li>即，统计图中”顶点 vs”到其它各个顶点的最短路径。</li><li></li><li>参数说明：</li><li><pre><code>  vs -- 起始顶点(start vertex)。即计算&quot;顶点vs&quot;到其它顶点的最短路径。</code></pre></li><li><pre><code>prev -- 前驱顶点数组。即，prev[i]的值是&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径所经历的全部顶点中，位于&quot;顶点i&quot;之前的那个顶点。</code></pre></li><li><pre><code>dist -- 长度数组。即，dist[i]是&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径的长度。</code></pre></li></ul><p>  */<br>  void MatrixUDG::dijkstra(int vs, int prev[], int dist[])<br>  {<br>  int i,j,k;<br>  int min;<br>  int tmp;<br>  int flag[MAX]; // flag[i]=1 表示”顶点 vs”到”顶点 i”的最短路径已成功获取。</p><pre><code>  // 初始化  for (i = 0; i &lt; mVexNum; i++)  &#123;      flag[i] = 0;              // 顶点i的最短路径还没获取到。      prev[i] = 0;              // 顶点i的前驱顶点为0。      dist[i] = mMatrix[vs][i]; // 顶点i的最短路径为&quot;顶点vs&quot;到&quot;顶点i&quot;的权。  &#125;  // 对&quot;顶点vs&quot;自身进行初始化  flag[vs] = 1;  dist[vs] = 0;  // 遍历mVexNum-1次；每次找出一个顶点的最短路径。  for (i = 1; i &lt; mVexNum; i++)  &#123;      // 寻找当前最小的路径；      // 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。      min = INF;      for (j = 0; j &lt; mVexNum; j++)      &#123;          if (flag[j]==0 &amp;&amp; dist[j]&lt;min)          &#123;              min = dist[j];              k = j;          &#125;      &#125;      // 标记&quot;顶点k&quot;为已经获取到最短路径      flag[k] = 1;      // 修正当前最短路径和前驱顶点      // 即，当已经&quot;顶点k的最短路径&quot;之后，更新&quot;未获取最短路径的顶点的最短路径和前驱顶点&quot;。      for (j = 0; j &lt; mVexNum; j++)      &#123;          tmp = (mMatrix[k][j]==INF ? INF : (min + mMatrix[k][j]));          if (flag[j] == 0 &amp;&amp; (tmp  &lt; dist[j]) )          &#123;              dist[j] = tmp;              prev[j] = k;          &#125;      &#125;  &#125;  // 打印dijkstra最短路径的结果  cout &lt;&lt; &quot;dijkstra(&quot; &lt;&lt; mVexs[vs] &lt;&lt; &quot;): &quot; &lt;&lt; endl;  for (i = 0; i &lt; mVexNum; i++)      cout &lt;&lt; &quot;  shortest(&quot; &lt;&lt; mVexs[vs] &lt;&lt; &quot;, &quot; &lt;&lt; mVexs[i] &lt;&lt; &quot;)=&quot; &lt;&lt; dist[i] &lt;&lt; endl;</code></pre><p>  }</p><p>/*</p><ul><li>floyd 最短路径。</li><li>即，统计图中各个顶点间的最短路径。</li><li></li><li>参数说明：</li><li><pre><code>path -- 路径。path[i][j]=k表示，&quot;顶点i&quot;到&quot;顶点j&quot;的最短路径会经过顶点k。</code></pre></li><li><pre><code>dist -- 长度数组。即，dist[i][j]=sum表示，&quot;顶点i&quot;到&quot;顶点j&quot;的最短路径的长度是sum。</code></pre></li></ul><p>  */<br>  void MatrixUDG::floyd(int path[][max], int dist[][max])<br>  {<br>  int i,j,k;<br>  int tmp;</p><pre><code>  // 初始化  for (i = 0; i &lt; mVexNum; i++)  &#123;      for (j = 0; j &lt; mVexNum; j++)      &#123;          dist[i][j] = mMatrix[i][j];    // &quot;顶点i&quot;到&quot;顶点j&quot;的路径长度为&quot;i到j的权值&quot;。          path[i][j] = j;                // &quot;顶点i&quot;到&quot;顶点j&quot;的最短路径是经过顶点j。      &#125;  &#125;  // 计算最短路径  for (k = 0; k &lt; mVexNum; k++)  &#123;      for (i = 0; i &lt; mVexNum; i++)      &#123;          for (j = 0; j &lt; mVexNum; j++)          &#123;              // 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]和path[i][j]              tmp = (dist[i][k]==INF || dist[k][j]==INF) ? INF : (dist[i][k] + dist[k][j]);              if (dist[i][j] &gt; tmp)              &#123;                  // &quot;i到j最短路径&quot;对应的值设，为更小的一个(即经过k)                  dist[i][j] = tmp;                  // &quot;i到j最短路径&quot;对应的路径，经过k                  path[i][j] = path[i][k];              &#125;          &#125;      &#125;  &#125;  char dot[] = &#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;&#125;;  // 打印floyd最短路径的结果  cout &lt;&lt; &quot;floyd各个地点的最短路径矩阵如下: &quot; &lt;&lt; endl;  cout &lt;&lt; &quot;    &quot;;  for (int k = 0;k&lt;9;k++)&#123;      cout &lt;&lt; dot[k] &lt;&lt; &quot;    &quot;;  &#125;  cout &lt;&lt; &quot;\n&quot;;  for (i = 0; i &lt; mVexNum; i++)&#123;      cout &lt;&lt; dot[i] &lt;&lt; &quot;: &quot;;      for (j = 0; j &lt; mVexNum; j++)          cout &lt;&lt; setw(2) &lt;&lt; dist[i][j] &lt;&lt; &quot;  &quot;;      cout &lt;&lt; endl;  &#125;</code></pre><p>  }</p><p>int main()<br>{<br>int prev[MAX] = {0};<br>int dist[MAX] = {0};<br>int path[MAX][max] = {0}; // 用于保存 floyd 路径<br>int floy[MAX][max] = {0}; // 用于保存 floyd 长度<br>char vexs[] = {‘A’, ‘B’, ‘C’, ‘D’, ‘E’, ‘F’, ‘G’, ‘H’, ‘I’};<br>int matrix[][9] = {<br>/<em>A</em>//<em>B</em>//<em>C</em>//<em>D</em>//<em>E</em>//<em>F</em>//<em>G</em>//<em>H</em>//<em>I</em>/<br>/<em>A 西门</em>/ { 0, 615, 435, 210, 790, INF, INF, INF, INF},<br>/<em>B550 教室</em>/ { 615, 0, 144, 620, 380, 822, INF, INF, INF},<br>/<em>C 文宗楼</em>/ { 435, 144, 0, INF, 265, INF, INF, INF, INF},<br>/<em>D 二餐</em>/ { 210, 620, INF, 0, 480, INF, INF, INF, 170},<br>/<em>E 图书馆</em>/ { 790, 380, 265, 480, 0, 620, 735, 310, 700},<br>/<em>F 北门</em>/ { INF, 822, INF, INF, 620, 0, 500, INF, INF},<br>/<em>G 体育馆</em>/ { INF, INF, INF, INF, 735, 500, 0, 556, INF},<br>/<em>H 一餐</em>/ { INF, INF, INF, INF, 310, INF, 556, 0, 420},<br>/<em>I16 号楼</em>/ { INF, INF, INF, 170, 700, INF, INF, 420, 0}};<br>int vlen = sizeof(vexs)/sizeof(vexs[0]);<br>MatrixUDG* pG;</p><pre><code>// 自定义&quot;图&quot;(输入矩阵队列)//pG = new MatrixUDG();// 采用已有的&quot;图&quot;pG = new MatrixUDG(vexs, vlen, matrix);//pG-&gt;print();   // 打印图//pG-&gt;DFS();     // 深度优先遍历//pG-&gt;BFS();     // 广度优先遍历//pG-&gt;prim(0);   // prim算法生成最小生成树//pG-&gt;kruskal(); // Kruskal算法生成最小生成树// dijkstra算法获取&quot;第4个顶点&quot;到其它各个顶点的最短距离//pG-&gt;dijkstra(3, prev, dist);// floyd算法获取各个顶点之间的最短距离pG-&gt;floyd(path, floy);return 0;</code></pre><p>}</pre><p id="890d57e51a7141565ace3003b56e24c7" class="ne-p"><br></p><h2 id="UcdRQ"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="5086d9c56dadd125ba405e10f6379b06"><a href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-dijkstra" data-href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-dijkstra" target="_blank" class="ne-link"><span class="ne-text">图最短路径算法之迪杰斯特拉算法（Dijkstra）</span></a></li><li id="97fadfb9fac663e518e85ca92e948634"><a href="https://www.cnblogs.com/skywang12345/p/3711526.html" data-href="https://www.cnblogs.com/skywang12345/p/3711526.html" target="_blank" class="ne-link"><span class="ne-text">Floyd 算法(二)之 C++详解</span></a></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图的遍历——DFS（深度优先）、BFS（广度优先）</title>
      <link href="/blog/ztiag3/"/>
      <url>/blog/ztiag3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="c4377b9c5907fc32e4dd3a3ec889224d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621307069176-74d6900b-6edd-4e7a-b761-789df7a17cfe.png" width="563" id="W9sKH" class="ne-image"></p><p id="aeba3ae9fd44225e4bcdfd6b1387df74" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="8602641d8bcd30fd83b83906a84c1786" class="ne-p"><span class="ne-text">前言：用邻接矩阵和邻接表两种图的存储形式实现DFS、BFS算法，并附例子实现。</span></p><p id="a2a30595325972cce3bffd75dcc31f68" class="ne-p"><span class="ne-text">总的来说，邻接矩阵比较好处理，没有邻接表处理那么复杂，但是数组永远不能规避的一个缺点就是内存的占用较邻接表高。</span></p></div><p id="905ea7f782ba98d5a209da0f35f5c203" class="ne-p"><br></p><h2 id="QOJfe"><span class="ne-text">一、深度优先搜索算法（Depth-First-Search）</span></h2><h3 id="MZ0vA"><span class="ne-text">算法说明</span></h3><p id="4e097c10f9608f768b643efb77ddac9f" class="ne-p"><strong><span class="ne-text">访问步骤：</span></strong></p><div class="ne-quote"><ul class="ne-ul"><li id="7a87afee8efc50a1215b2c73dee1007c"><span class="ne-text">访问顶点v；</span></li><li id="75fd425f477a5edfe8e8f42d7362ada1"><span class="ne-text">依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；</span></li><li id="fd5afc9bef88cbee4ece89b7a4b042f5"><span class="ne-text">若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</span></li></ul></div><p id="ba6b093d11719b506938b7131380d8ac" class="ne-p"><br></p><p id="0aab1d1b162418f9bf49863d35a32fda" class="ne-p"><strong><span class="ne-text">核心代码就是利用递归，以及标志数组的设定，每次访问数组元素的那一行，对那行链表进行遍历，每遍历一个链表结点，就将“其”所在的那个数组元素“点亮”。如果标志数组里面的所有元素都被访问了，说明遍历完了</span></strong></p><p id="b12a3d4a70976459fc1d9bcab1a7ff25" class="ne-p" style="text-indent: 2em"><br></p><p id="ccdd034b8bc976b98a833b1b3a4480f7" class="ne-p"><strong><span class="ne-text">深度优先搜索类似于树里面遍历算法当中的先序遍历。</span></strong></p><h3 id="ZU5Ew"><span class="ne-text">邻接矩阵的DFS代码</span></h3><p id="0c7fc91bebbf033661b0d2f0e2755bb3" class="ne-p"><span class="ne-text">以这个无向图为例</span></p><p id="e91496d0133f08a7c583147a966ce5cb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329549870-b2fd8a63-a532-4860-8e46-a79cc52a7e0f.png" width="197" id="Xvwlk" class="ne-image"></p><p id="f5a357efd0ac30dc1a34889c7258c8c8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329584016-32d023fe-dc14-4c0d-90e1-7afe6fcc9cd2.png" width="227.5" id="XY5Cd" class="ne-image"></p><pre data-language="cpp" id="Z8wpM" class="ne-codeblock language-cpp">#include<bits/stdc++.h><p>using namespace std;</p><p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int ArcType;</p><p>/**</p><ul><li>邻接矩阵存储形式<br><em>/<br>typedef struct {<br>/</em> data */<br>VerTexType vexs[MVNum]; //顶点表<br>ArcType arcs[MVNum][mvnum]; //邻接矩阵<br>int vexnum, arcnum; //图的当前顶点和边数<br>}AMGraph;</li></ul><p>/**</p><ul><li>确定 v 在 G 中的位置，即顶点数组的下标<br>*/<br>int LocateVex(AMGraph &amp;G, char v) {<br>for (int i = 0; i &lt; G.vexnum;i++) {<br>if (v == G.vexs[i]){<br>return i;<br>}<br>}<br>}</li></ul><p>/**</p><ul><li>如果创建无向图<br> */<br>void CreateUDN(AMGraph &amp;G) {<br>// 采用邻接矩阵表示法，创建无向图 G<br>cout &lt;&lt; “请输入顶点数和边数：” &lt;&lt; endl;<br>cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和边数<br>// 初始化顶点<br>for (int i = 0; i &lt; G.vexnum;i++){<br>cout &lt;&lt; “请输入第” &lt;&lt; i &lt;&lt; “个顶点值” &lt;&lt; endl;<br>cin &gt;&gt; G.vexs[i];<br>}<br>// 初始化邻接矩阵的边的权值为最大值<br>for (int i = 0; i &lt; G.vexnum;i++) {<br>for (int j = 0; j &lt; G.vexnum;j++) {<br>G.arcs[i][j] = 0;<br>}<br>}<br>// 构造邻接矩阵<br>for (int k = 0; k &lt; G.arcnum;k++) {<br>cout &lt;&lt; “请输入每条边所依附的顶点：” &lt;&lt; endl;<br>char v1, v2;<br>int w = 1; //一条边所依附的顶点和权值<br>cin &gt;&gt; v1 &gt;&gt; v2;<br>int i = LocateVex(G, v1);<br>int j = LocateVex(G, v2);<br>G.arcs[i][j] = w;<br>G.arcs[j][i] = w;<br>}<br>}</li></ul><p>/**</p><ul><li>打印输出图<br>*/<br>void Display(AMGraph &amp;G) {<br>for (int i = 0; i &lt; G.vexnum;i++) {<br>for (int j = 0; j &lt; G.vexnum;j++) {<br>cout &lt;&lt; G.arcs[i][j] &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl;<br>}<br>}</li></ul><p>//—-邻接矩阵的 DFS 遍历—-</p><p>//访问标志数组，其初值为 false<br>bool visited[MVNum];</p><p>/**</p><ul><li>图 G 为邻接矩阵类型，从第 v 个顶点出发深度优先搜索遍历图 G<br>*/<br>void DFS_AM(AMGraph &amp;G, int v) {<br>//访问第 v 个顶点，并置访问标志数组相应分量值为 true<br>cout&lt;&lt;v;<br> visited[v] = true;<br>//依次检查邻接矩阵 v 所在的行<br>for(int w = 0; w &lt; G.vexnum; w++)<br> //G.arcs[v][w] != 0 表示 w 是 v 的邻接点，!visited[w]表示未访问到<br>if((G.arcs[v][w] != 0) &amp;&amp; (!visited[w]))<br> DFS_AM(G, w); //递归调用 DFS_AM<br>}</li></ul><p>/**</p><ul><li>图 G 的储存类型任意，对非连通图 G 做深度优先遍历<br>*/<br>void DFSTraverse(AMGraph &amp;G) {<br>//访问标志数组初始化<br>for(int v = 0; v &lt; G.vexnum; v++)<br> visited[v] = false;<br>//循环调用 DFS<br>for(int v = 0; v &lt; G.vexnum; v++)<br> if(!visited[v])<br>DFS_AM(G, v); //对尚未访问的顶点调用 DFS<br>}</li></ul><p>int main() {<br>AMGraph test;<br>CreateUDN(test);<br>Display(test);<br>DFSTraverse(test);<br>return 0;<br>}</p><p></pre><h3 id="yoSIg"><span class="ne-text">邻接表的DFS代码</span></h3><p id="0185257cc5891b4779bd509a36e4bf08" class="ne-p"><span class="ne-text">举之前上课的一张PPT例子（元素插入为后插法）</span></p><p id="8f0f1b106f7dee1d8b9124d39e708517" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621333199678-46b6841b-415b-46e8-b0f6-0d0407284b15.png" width="554" id="HmOsr" class="ne-image"></p><p id="7d9b1ab0ddea1a0b1cc6919a63753b20" class="ne-p"><span class="ne-text">结果</span></p><p id="87a60371c70d6ef42ae0b5733953742a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621333246481-117ec0ea-ab95-43be-ac13-75712fdf1e2b.png" width="222" id="KjOYY" class="ne-image"></p><pre data-language="cpp" id="5Kw5x" class="ne-codeblock language-cpp">#include <bits/stdc++.h><br>using namespace std;</p><p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int OtherInfo;</p><p>/**</p><ul><li>邻接表存储<br>*/</li></ul><p>/**</p><ul><li>存储结构<br>*/<br>typedef struct ArcNode { //边结点<br> int adjvex; //该边所指向的结点的位置<br>struct ArcNode *nextarc; //指向下一条边的指针<br>OtherInfo info; //和边相关的其他信息<br>}ArcNode;</li></ul><p>typedef struct VNode { //顶点信息<br>VerTexType data; //数据域，存放顶点 vi 的名称或其他有关信息<br>ArcNode *firstarc; //指向第一条依附该顶点的边的指针<br>}VNode, AdjList[MVNum]; //AdjList 表示邻接表的类型</p><p>typedef struct {<br>AdjList vertices;<br>int vexnum, arcnum; //图当前的顶点数和边数<br>}ALGragh; //邻接表（Adjacency List）</p><p>/**</p><ul><li>找到 v 顶点在图的顶点数组中的位置<br>*/<br>int LocateVex(ALGragh &amp;G, char v) {<br>for (int i = 0; i &lt; G.vexnum;i++) {<br>if (v == G.vertices[i].data) {<br>return i;<br>}<br>}<br>}</li></ul><p>/**</p><ul><li>邻接表创建无向图<br>*/<br>void CreateUDG(ALGragh &amp;G) {<br>cout &lt;&lt; “请输入顶点数和边数：” &lt;&lt; endl;<br>cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; // 邻接表的顶点数和边数<br>// 初始化顶点数组<br>for (int i = 0; i &lt; G.vexnum;i++) {<br>cin &gt;&gt; G.vertices[i].data; // 初始化顶点数组里面的结点 data<br>G.vertices[i].firstarc = NULL; // 初始化顶点数组里面的结点 next 域<br>}<br>// 初始化所有的边<br>for (int k = 0; k &lt; G.arcnum;k++) {<br>char v1, v2;<br>cout &lt;&lt; “请输入每条边所依附的顶点：” &lt;&lt; endl;<br>cin &gt;&gt; v1 &gt;&gt; v2;<br>int i = LocateVex(G, v1); // 找到 v1 在顶点数组的下标<br>int j = LocateVex(G, v2); // 找到 v2 在顶点数组的下标<br>// 下面建立 p1 和 p2 是因为无向图，如果是有向图就没必要了只需要 p1<br>// 前插<br>ArcNode *p1 = new ArcNode;<br>p1-&gt;adjvex = j;<br>p1-&gt;nextarc = G.vertices[i].firstarc;<br>G.vertices[i].firstarc = p1;<br>ArcNode *p2 = new ArcNode;<br>p2-&gt;adjvex = i;<br>p2-&gt;nextarc = G.vertices[j].firstarc;<br>G.vertices[j].firstarc = p2;<br>}<br>}</li></ul><p>/**</p><ul><li>打印输出图<br>*/<br>void Display(ALGragh &amp;G) {<br>for (int i = 0; i &lt; G.vexnum;i++) {<br>cout &lt;&lt; “结点” &lt;&lt; i &lt;&lt; “：”;<br>// 复制选中的节点数组中的结点<br>VNode p;<br>p = G.vertices[i];<br>if (p.firstarc != NULL){<br>ArcNode *temp;<br>temp = G.vertices[i].firstarc;<br>while (temp != NULL) {<br>cout &lt;&lt; temp-&gt;adjvex&lt;&lt;” “;<br>temp = temp-&gt;nextarc;<br>}<br>cout &lt;&lt; “\n”;<br>}<br>}<br>}</li></ul><p>//—-邻接表的 DFS 遍历—-<br>bool visited[MVNum]; //访问标志数组，其初值为 false</p><p>void DFS_AL(ALGragh G, int v)<br>{//图 G 为邻接表类型，从从第 v 个顶点出发深度优先搜索遍历图 G<br>cout&lt;&lt;v; //访问第 v 个顶点，并置访问标志数组相应分量值为 true<br>visited[v] = true;<br>ArcNode *p;<br> p = G.vertices[v].firstarc; //p 指向 v 的边链表的第一个边结点<br>while(p != NULL)<br>{<br>int w = p-&gt;adjvex; //w 是 v 的邻接点<br>if(!visited[w]) //如果 w 未访问<br>DFS_AL(G, w); //递归调用 DFS_AL<br>p = p-&gt;nextarc; //p 指向下一个结点<br>}<br>}</p><p>void DFSTraverse(ALGragh G)<br>{//图 G 的储存类型任意，对非连通图 G 做深度优先遍历<br>for(int v = 0; v &lt; G.vexnum; v++) //访问标志数组初始化<br>visited[v] = false;<br>for(int v = 0; v &lt; G.vexnum; v++) //循环调用 DFS<br>if(!visited[v])<br>DFS_AL(G, v); //对尚未访问的顶点调用 DFS<br>}</p><p>int main() {<br>ALGragh test;<br>CreateUDG(test);<br>// Display(test);<br>DFSTraverse(test);<br>}</pre><h2 id="QXnap"><span class="ne-text">二、广度优先搜索算法（Breadth-First-Search）</span></h2><h3 id="G0xbz"><span class="ne-text">算法说明</span></h3><p id="94b96fd18f6299a92edb0bbb0104497e" class="ne-p"><span class="ne-text">从某个顶点 V0 出发，并在访问此顶点之后依次访问 V0 的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和 V0 有路径相通的顶点都被访问到。</span></p><p id="79c6bc4660da95e5eb3a4d3b82f0c95d" class="ne-p"><span class="ne-text"></span></p><p id="7d0dd6f76b33ab2e7809089c7833daa9" class="ne-p"><span class="ne-text">若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</span></p><p id="c994dac6d6ea729bf4c53d5e56f6b638" class="ne-p"><br></p><p id="5603100122d38ec5f9e050b858b65d40" class="ne-p"><strong><span class="ne-text">在树遍历中类似层次遍历。</span></strong></p><p id="cec298b23684b1046e1e7ced82785774" class="ne-p"><strong><span class="ne-text"></span></strong></p><h3 id="tX0WF"><span class="ne-text">邻接矩阵的 BFS 代码</span></h3><p id="2c79fedd6fba3d1dc3fa877ec630c8b4" class="ne-p"><span class="ne-text">还是这个例子</span></p><p id="4182bef26913ccb9daaf8020669dfc2f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329549870-b2fd8a63-a532-4860-8e46-a79cc52a7e0f.png" width="197" id="bbWIn" class="ne-image"></p><p id="aee9ada2779b6772f70229266531e473" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621338913834-3f2453f3-c56d-4401-9e26-2de805587a04.png" width="228.5" id="hRiOt" class="ne-image"></p><pre data-language="cpp" id="yEEtQ" class="ne-codeblock language-cpp">#include<bits/stdc++.h><br>using namespace std;</p><p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int ArcType;</p><p>/**</p><ul><li>邻接矩阵的 bfs 代码<br><em>/<br>typedef struct {<br>/</em> data */<br>VerTexType vexs[MVNum]; //顶点表<br>ArcType arcs[MVNum][mvnum]; //邻接矩阵<br>int vexnum, arcnum; //图的当前顶点和边数<br>}AMGraph;</li></ul><p>/**</p><ul><li>确定 v 在 G 中的位置，即顶点数组的下标<br>*/<br>int LocateVex(AMGraph &amp;G, char v) {<br>for (int i = 0; i &lt; G.vexnum;i++) {<br>if (v == G.vexs[i]){<br>return i;<br>}<br>}<br>}</li></ul><p>/**</p><ul><li>创建无向网</li><li>如果创建无向图<br> */<br>void CreateUDN(AMGraph &amp;G) {<br>// 采用邻接矩阵表示法，创建无向图 G<br>cout &lt;&lt; “请输入顶点数和边数：” &lt;&lt; endl;<br>cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和边数<br>// 初始化顶点<br>for (int i = 0; i &lt; G.vexnum;i++){<br>cout &lt;&lt; “请输入第” &lt;&lt; i &lt;&lt; “个顶点值” &lt;&lt; endl;<br>cin &gt;&gt; G.vexs[i];<br>}<br>// 初始化邻接矩阵的边的权值为最大值<br>for (int i = 0; i &lt; G.vexnum;i++) {<br>for (int j = 0; j &lt; G.vexnum;j++) {<br>G.arcs[i][j] = 0;<br>}<br>}<br>// 构造邻接矩阵<br>for (int k = 0; k &lt; G.arcnum;k++) {<br>cout &lt;&lt; “请输入每条边所依附的顶点：” &lt;&lt; endl;<br>char v1, v2;<br>int w = 1; //一条边所依附的顶点和权值<br>cin &gt;&gt; v1 &gt;&gt; v2;<br>int i = LocateVex(G, v1);<br>int j = LocateVex(G, v2);<br>G.arcs[i][j] = w;<br>G.arcs[j][i] = w;<br>}<br>}</li></ul><p>/**</p><ul><li>打印输出图<br>*/<br>void Display(AMGraph &amp;G) {<br>for (int i = 0; i &lt; G.vexnum;i++) {<br>for (int j = 0; j &lt; G.vexnum;j++) {<br>cout &lt;&lt; G.arcs[i][j] &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl;<br>}<br>}</li></ul><p>//—-邻接矩阵的 BFS 遍历—-</p><p>bool visited[MVNum];</p><p>void BFS_AM(AMGraph G, int v)<br>{//按广度优先非递归遍历连通图 G<br>cout&lt;&lt;v;<br>visited[v] = true; //访问第 v 个顶点，并置访问标志数组相应分量值为 true<br>queue<int> Q;<br>Q.push(v);<br>while(!Q.empty())<br>{<br>int u = Q.front(); //队头元素出队并置为 u<br>Q.pop();<br>for(int w = 0; w &lt; G.vexnum; w++)<br>if((G.arcs[u][w] != 0) &amp;&amp; (!visited[w])) //G.arcs[v][w] != 0 表示 w 是 v 的邻接点，!visited[w]表示未访问到 //w 为 u 的尚未访问的邻接顶点<br>{<br>cout&lt;&lt;w;<br>visited[w] = true; //访问 w，并置访问标志数组相应分量值为 true<br>Q.push(w); //w 进队<br>}<br>}<br>}</p><p>void BFSTraverse(AMGraph &amp;G) {<br>//访问标志数组初始化<br>for(int v = 0; v &lt; G.vexnum; v++)<br> visited[v] = false;<br>//循环调用 BFS<br>for(int v = 0; v &lt; G.vexnum; v++)<br> if(!visited[v])<br>BFS_AM(G, v); //对尚未访问的顶点调用 BFS<br>}</p><p>int main() {<br>AMGraph test;<br>CreateUDN(test);<br>Display(test);<br>// DFSTraverse(test);<br>BFSTraverse(test);<br>return 0;<br>}</p><p></pre><h3 id="1RjxQ"><span class="ne-text">邻接表的BFS代码</span></h3><p id="19d60bf6aae1fc1f2364707c8a4a32c7" class="ne-p"><span class="ne-text">还用和DFS一样的例子</span></p><p id="2f63b2855bb2a7ced47b120060177ab5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621339344717-55530db9-253b-451d-af57-b591ff17353e.png" width="417" id="I73u9" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621390194148-da12a2e4-1f85-491b-9e53-3848ac4e4a4c.png" width="167" id="iul50" class="ne-image"></p><p id="5b8a5022ed1fcec1eef4bd087d6293fa" class="ne-p"><br></p><p id="44e1f9ec1603ae99eb545fd108578a1c" class="ne-p"><br></p><pre data-language="cpp" id="oXGJ9" class="ne-codeblock language-cpp">#include <bits/stdc++.h><br>using namespace std;</p><p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int OtherInfo;</p><p>/**</p><ul><li>邻接表的 bfs 代码<br>*/</li></ul><p>/**</p><ul><li>存储结构<br>*/<br>typedef struct ArcNode { //边结点<br> int adjvex; //该边所指向的结点的位置<br>struct ArcNode *nextarc; //指向下一条边的指针<br>OtherInfo info; //和边相关的其他信息<br>}ArcNode;</li></ul><p>typedef struct VNode { //顶点信息<br>VerTexType data; //数据域，存放顶点 vi 的名称或其他有关信息<br>ArcNode *firstarc; //指向第一条依附该顶点的边的指针<br>}VNode, AdjList[MVNum]; //AdjList 表示邻接表的类型</p><p>typedef struct {<br>AdjList vertices;<br>int vexnum, arcnum; //图当前的顶点数和边数<br>}ALGraph; //邻接表（Adjacency List）</p><p>/**</p><ul><li>找到 v 顶点在图的顶点数组中的位置<br>*/<br>int LocateVex(ALGraph &amp;G, char v) {<br>for (int i = 0; i &lt; G.vexnum;i++) {<br>if (v == G.vertices[i].data) {<br>return i;<br>}<br>}<br>}</li></ul><p>/**</p><ul><li>邻接表创建无向图<br>*/<br>void CreateUDG(ALGraph &amp;G) {<br>cout &lt;&lt; “请输入顶点数和边数：” &lt;&lt; endl;<br>cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; // 邻接表的顶点数和边数<br>// 初始化顶点数组<br>for (int i = 0; i &lt; G.vexnum;i++) {<br>cin &gt;&gt; G.vertices[i].data; // 初始化顶点数组里面的结点 data<br>G.vertices[i].firstarc = NULL; // 初始化顶点数组里面的结点 next 域<br>}<br>// 初始化所有的边<br>for (int k = 0; k &lt; G.arcnum;k++) {<br>char v1, v2;<br>cout &lt;&lt; “请输入每条边所依附的顶点：” &lt;&lt; endl;<br>cin &gt;&gt; v1 &gt;&gt; v2;<br>int i = LocateVex(G, v1); // 找到 v1 在顶点数组的下标<br>int j = LocateVex(G, v2); // 找到 v2 在顶点数组的下标<br>// 下面建立 p1 和 p2 是因为无向图，如果是有向图就没必要了只需要 p1<br>// 前插<br>ArcNode *p1 = new ArcNode;<br>p1-&gt;adjvex = j;<br>p1-&gt;nextarc = G.vertices[i].firstarc;<br>G.vertices[i].firstarc = p1;<br>ArcNode *p2 = new ArcNode;<br>p2-&gt;adjvex = i;<br>p2-&gt;nextarc = G.vertices[j].firstarc;<br>G.vertices[j].firstarc = p2;<br>}<br>}</li></ul><p>/**</p><ul><li>打印输出图<br>*/<br>void Display(ALGraph &amp;G) {<br>for (int i = 0; i &lt; G.vexnum;i++) {<br>cout &lt;&lt; “结点” &lt;&lt; i &lt;&lt; “：”;<br>// 复制选中的节点数组中的结点<br>VNode p;<br>p = G.vertices[i];<br>if (p.firstarc != NULL){<br>ArcNode *temp;<br>temp = G.vertices[i].firstarc;<br>while (temp != NULL) {<br>cout &lt;&lt; temp-&gt;adjvex&lt;&lt;” “;<br>temp = temp-&gt;nextarc;<br>}<br>cout &lt;&lt; “\n”;<br>}<br>}<br>}</li></ul><p>//—-邻接表的 BFS 遍历—-</p><p>bool visited[MVNum];</p><p>int FirstAdjvex(ALGraph&amp; G, int u)<br>{<br>int w = G.vertices[u].firstarc-&gt;adjvex;<br>return w;<br>}<br>int NextAdjVex(ALGraph&amp; G, int u, int w)<br>{<br>ArcNode *temp = G.vertices[u].firstarc;<br>while (temp-&gt;adjvex != w)<br>{<br>temp = temp-&gt;nextarc;<br>}<br>if (temp-&gt;nextarc)<br>return temp-&gt;nextarc-&gt;adjvex;<br>else<br>return -1;<br>delete temp;<br>}<br>void BFS_AL(ALGraph&amp; G, int v){<br>cout &lt;&lt; v;<br>visited[v] = true;<br>queue<int> Q;<br>Q.push(v);<br>int u = v;<br>while (!Q.empty()){<br>u = Q.front();<br>Q.pop();<br>for (int w = FirstAdjvex(G, u); w &gt;= 0; w = NextAdjVex(G, u, w)){<br>if (!visited[w]){<br>cout &lt;&lt;w;<br>visited[w] = true;<br>Q.push(w);<br>}<br>}<br>}<br>}</p><p>void BFSTraverse(ALGraph &amp;G) {<br>//访问标志数组初始化<br>for(int v = 0; v &lt; G.vexnum; v++)<br> visited[v] = false;<br>//循环调用 BFS<br>for(int v = 0; v &lt; G.vexnum; v++)<br> if(!visited[v])<br>BFS_AL(G, v); //对尚未访问的顶点调用 BFS<br>}</p><p>int main() {<br>ALGraph test;<br>CreateUDG(test);<br>Display(test);<br>BFSTraverse(test);<br>}</pre><p id="c606f86cc011bbd8daff4fdf8fde78ee" class="ne-p"><span class="ne-text"></span></p><div data-type="danger" class="ne-alert"><p id="0ef6670727161ceae2b2fd7611579ede" class="ne-p"><span class="ne-text">【插眼】为啥我写的一个函数不需要队列也可以？？？直接将顶点数组的一个元素后面接的链表遍历不就好了，然后再遍历标志数组元素值部位 true 的不就好了。。。为啥要压队列呀？</span></p><p id="40e16d77d4f0ef5fa0dd607f4ef45ee1" class="ne-p"><span class="ne-text">莫不是哪里有隐藏的 bug，插个眼！！！</span></p></div><p id="e6f8995f72a0e332e6921816bb8d07b0" class="ne-p"><span class="ne-text"></span></p><p id="410e780ff2dc9b2b7265d7357bed6936" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1621340205400-d534997e-4b20-4f0e-8db6-4a91e39c68b6.gif" width="218" id="Ivn4n" class="ne-image"></p><p id="87461184d6165e71f83ee3ca2c47cee8" class="ne-p"><span class="ne-text"></span></p><div data-type="success" class="ne-alert"><p id="4555a876fb667c46816df66773c5e6e1" class="ne-p"><span class="ne-text">【拔眼】这样是一种特殊情况，只适合图的各个结点是按照层次标号的，并且放入标志数组也是按照顺序放入的……</span></p></div><p id="1cf117f18c823349567e5d7b36a5ff7b" class="ne-p"><br></p><p id="0f6e52a1f536ea9359c2494c19ca0529" class="ne-p"><span class="ne-text">插眼代码如下：</span></p><pre data-language="cpp" id="8k1hc" class="ne-codeblock language-cpp">void BFS_AL(ALGraph &G, int v)<br>{//按广度优先非递归遍历连通图 G<br>cout<<v;<br>visited[v] = true; //访问第 v 个顶点，并置访问标志数组相应分量值为 true<br>ArcNode *p;<br>p = G.vertices[v].firstarc;<br>if (p != NULL) {<br>while(p != NULL) {<br>if (!visited[p->adjvex]){<br>cout << p->adjvex;<br>}<br>visited[p->adjvex] = true;<br>p = p->nextarc;<br>}<br>}<br>}</pre><p id="ae0f5d621f99ca5480d74bece56a5520" class="ne-p"><span class="ne-text"></span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📉图结构：无向图-有向图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图的术语、存储、应用综述</title>
      <link href="/blog/gqpli5/"/>
      <url>/blog/gqpli5/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">前言：</span><strong><span class="ne-text">数据结构一般就四种关系：集合、线性、树、图</span></strong><span class="ne-text">。这篇文章打算对图这类数据结构做一个概览。先介绍图的一些术语（复制粘贴：））；然后讲解一下图的各种存储形式；最后把图的应用记录一下，具体应用算法放在算法分类里面。</span></p><p id="u15a4556b" class="ne-p"><span class="ne-text"></span></p><h2 id="Xftp7"><span class="ne-text">一、图的一些术语</span></h2><p id="u7b8fcc5d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621256644397-9e2a9a9a-c3f9-4bfe-af9d-d3eec44c16b2.png" width="499" id="ue0b15b96" class="ne-image"></p><p id="u054df83b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621256670453-caccc927-2510-4119-9452-a588b6f590e5.png" width="476" id="u1e1a40e2" class="ne-image"></p><p id="u5c8e2bbc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621256694543-32b41537-3bc7-4515-b8e9-eb56b026d2a7.png" width="470" id="uee62fe0a" class="ne-image"></p><h2 id="YcmB4"><span class="ne-text">二、图存储</span></h2><h3 id="bKChi"><span class="ne-text">邻接矩阵</span></h3><div data-type="info" class="ne-alert"><p id="04fc687e04e1d5533771232c89922a29" class="ne-p"><span class="ne-text">创建无向网</span></p></div><p id="u7562b828" class="ne-p"><br></p><pre data-language="cpp" id="xA3Md" class="ne-codeblock language-cpp">#include<bits/stdc++.h><p>using namespace std;</p><p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int ArcType;</p><p>/**</p><ul><li>邻接矩阵存储形式<br><em>/<br>typedef struct {<br>/</em> data */<br>VerTexType vexs[MVNum]; //顶点表<br>ArcType arcs[MVNum][mvnum]; //邻接矩阵<br>int vexnum, arcnum; //图的当前顶点和边数<br>}AMGraph;</li></ul><p>/**</p><ul><li>确定 v 在 G 中的位置，即顶点数组的下标<br>*/<br>int LocateVex(AMGraph &amp;G, char v) {<br>for (int i = 0; i &lt; G.vexnum;i++) {<br>if (v == G.vexs[i]){<br>return i;<br>}<br>}<br>}</li></ul><p>/**</p><ul><li>创建无向网</li><li>如果创建无向图<br> */<br>void CreateUDN(AMGraph &amp;G) {<br>// 采用邻接矩阵表示法，创建无向图 G<br>cout &lt;&lt; “请输入顶点数和边数：” &lt;&lt; endl;<br>cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和边数<br>// 初始化顶点<br>for (int i = 0; i &lt; G.vexnum;i++){<br>cout &lt;&lt; “请输入第” &lt;&lt; i &lt;&lt; “个顶点值” &lt;&lt; endl;<br>cin &gt;&gt; G.vexs[i];<br>}<br>// 初始化邻接矩阵的边的权值为最大值<br>for (int i = 0; i &lt; G.vexnum;i++) {<br>for (int j = 0; j &lt; G.vexnum;j++) {<br>G.arcs[i][j] = MaxInt;<br>}<br>}<br>// 构造邻接矩阵<br>for (int k = 0; k &lt; G.arcnum;k++) {<br>cout &lt;&lt; “请输入每条边所依附的顶点和权值：” &lt;&lt; endl;<br>char v1, v2;<br>int w; //一条边所依附的顶点和权值<br>cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<br>int i = LocateVex(G, v1);<br>int j = LocateVex(G, v2);<br>G.arcs[i][j] = w;<br>G.arcs[j][i] = w;<br>}<br>}</li></ul><p>void Display(AMGraph &amp;G) {<br>for (int i = 0; i &lt; G.vexnum;i++) {<br>for (int j = 0; j &lt; G.vexnum;j++) {<br>cout &lt;&lt; G.arcs[i][j] &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl;<br>}<br>}</p><p>int main() {<br>AMGraph test;<br>// CreateUDN(test);<br>Display(test);<br>}</pre><p id="u449d1a79" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="ubfd95f3b" class="ne-p"><span class="ne-text">创建无向图</span></p></div><p id="ue2d1f836" class="ne-p"><span class="ne-text">对</span><code class="ne-code"><span class="ne-text">CreateUDN</span></code><span class="ne-text"> 进行处理：</span></p><ul class="ne-ul"><li id="u86393495"><span class="ne-text">G.arcs[i][j] = MaxInt;改为 G.arcs[i][j] = 0;</span></li><li id="uf0d4b0c7"><span class="ne-text">将 w 改为常量 1 即可 </span></li></ul><p id="ubf2f1771" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="ud4631bb3" class="ne-p"><span class="ne-text">创建有向网</span></p></div><p id="u6d3051a6" class="ne-p"><span class="ne-text">对</span><code class="ne-code"><span class="ne-text">CreateUDN</span></code><span class="ne-text"> 进行处理：</span></p><ul class="ne-ul"><li id="ua516c49e"><span class="ne-text">删除 G.arcs[j][i] = w;</span></li></ul><p id="u46ec0f2b" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="ub07dff75" class="ne-p"><span class="ne-text">创建有向图</span></p></div><p id="ua2fdba0d" class="ne-p"><span class="ne-text">对</span><code class="ne-code"><span class="ne-text">CreateUDN</span></code><span class="ne-text"> 进行处理：</span></p><ul class="ne-ul"><li id="u13aeacb4"><span class="ne-text">删除 G.arcs[j][i] = w;</span></li></ul><h3 id="Au8am"><span class="ne-text">邻接表</span></h3><pre data-language="cpp" id="OKNzG" class="ne-codeblock language-cpp">#include <bits/stdc++.h><br>using namespace std;</p><p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int OtherInfo;</p><p>/**</p><ul><li>邻接表存储<br>*/</li></ul><p>/**</p><ul><li>存储结构<br>*/<br>typedef struct ArcNode { //边结点<br> int adjvex; //该边所指向的结点的位置<br>struct ArcNode *nextarc; //指向下一条边的指针<br>OtherInfo info; //和边相关的其他信息<br>}ArcNode;</li></ul><p>typedef struct VNode { //顶点信息<br>VerTexType data; //数据域，存放顶点 vi 的名称或其他有关信息<br>ArcNode *firstarc; //指向第一条依附该顶点的边的指针<br>}VNode, AdjList[MVNum]; //AdjList 表示邻接表的类型</p><p>typedef struct {<br>AdjList vertices;<br>int vexnum, arcnum; //图当前的顶点数和边数<br>}ALGragh; //邻接表（Adjacency List）</p><p>/**</p><ul><li>找到 v 顶点在图中的位置<br>*/<br>int LocateVex(ALGragh &amp;G, char v) {<br>for (int i = 0; i &lt; G.vexnum;i++) {<br>if (v == G.vertices[i].data) {<br>return i;<br>}<br>}<br>}</li></ul><p>/**</p><ul><li>邻接表创建无向图<br>*/<br>void CreateUDG(ALGragh &amp;G) {<br>cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; // 邻接表的顶点数和边数<br>for (int i = 0; i &lt; G.vexnum;i++) {<br>cin &gt;&gt; G.vertices[i].data;<br>G.vertices[i].firstarc = NULL;<br>}<pre><code>for (int k = 0; k &lt; G.arcnum;k++) &#123;    char v1, v2;    cin &gt;&gt; v1 &gt;&gt; v2;    int i = LocateVex(G, v1);    int j = LocateVex(G, v2);    ArcNode *p1 = new ArcNode;    p1-&gt;adjvex = j;    p1-&gt;nextarc = G.vertices[i].firstarc;    G.vertices[i].firstarc = p1;    ArcNode *p2 = new ArcNode;    p2-&gt;adjvex = i;    p2-&gt;nextarc = G.vertices[j].firstarc;    G.vertices[j].firstarc = p1;&#125;</code></pre>}</pre><h3 id="leRQZ"><span class="ne-text">有向图：十字链表存储</span></h3><pre data-language="cpp" id="ElVVW" class="ne-codeblock language-cpp">#include <bits/stdc++.h><br>using namespace std;<br>typedef int Status;<br>#define OK 1;</li></ul><p>//—-有向图的十字链表储存表示—-<br>#define MAX_VERTEX_NUM 20<br>typedef char VerTexType;<br>typedef int InfoType;<br>typedef struct ArcBox<br>{<br>int tailvex, headvex; //该弧的头尾和头顶点的位置<br>struct ArcBox *hlink, *tlink; //分别为弧头相同和弧尾相同的链域<br>InfoType *info; //该弧相关信息的指针<br>}ArcBox;</p><p>typedef struct VexNode<br>{<br>VerTexType data;<br>ArcBox *firstin, *firstout; //分别指向该顶点的第一项入弧和出弧<br>}VexNode;</p><p>typedef struct<br>{<br>VexNode xlist[MAX_VERTEX_NUM]; //表头向量<br>int vexnum, arcnum; //有向图的当前顶点数和弧数<br>}OLGraph; //十字链表（Orthogonal List）</p><p></pre><h3 id="vsryl"><span class="ne-text">无向图：邻接多重表存储</span></h3><pre data-language="cpp" id="jbSnZ" class="ne-codeblock language-cpp">#include <bits/stdc++.h><br>using namespace std;<br>typedef int Status;<br>#define OK 1;</p><p>//—-无向图的邻接多重表储存表示—-<br>#define MAX_VERTEX_NUM 20<br>typedef char VerTexType;<br>typedef int InfoType;</p><p>typedef enum<br>{<br>unvisited, visited //枚举 unvisited 是 0，visited 是 1，注意没有分号<br>}VisitIf;</p><p>typedef struct EBox<br>{<br>VisitIf mark; //访问标记<br>int ivex, jvex; //该边依附的两个顶点的位置<br>struct EBox *ilink, *jlink; //分别指向依附这两个顶点的下一条边<br>InfoType *info; //该边的信息指针<br>}EBox;</p><p>typedef struct VexBox<br>{<br>VerTexType data;<br>EBox *firstedge; //指向第一条依附该顶点的边<br>}VexBox;</p><p>typedef struct<br>{<br>VexBox adjmulist[MAX_VERTEX_NUM];<br>int vexnum, arcnum; //无向图当前的顶点数和边数<br>}AMLGraph; //邻接多重表(Adjacency Multilist)</pre><h3 id="yIN8s"><span class="ne-text">其他：边集数组</span></h3><p id="f7caa591865821073c01be60256a98d5" class="ne-p"><br></p><h3 id="EYiXl"><span class="ne-text">其他：链式前向星</span></h3><p id="37b365ee016545bff4ec27eb3f6afd50" class="ne-p"><br></p><h2 id="GJZzj"><span class="ne-text">三、图的应用</span></h2><ul class="ne-ul"><li id="1853f2f02796d7f84065b7f0802239d1"><span class="ne-text">最小生成树</span></li><li id="3d0e7c3bba57f2e22cb08454d8351cf9"><span class="ne-text">最短路径</span></li><li id="974b0e776d1250a371152cff90420be4"><span class="ne-text">环路</span></li><li id="ebe95ecfd4e0f08b0581a7cfdf5fd876"><span class="ne-text">关键路径</span></li></ul><p id="9d3c089ab3cd581998d3b22fa4c644db" class="ne-p"><br></p><p id="827d80a13d6f97ce4d10e4dcf0ed2b9a" class="ne-p"><span class="ne-text">具体这几类问题都是算法中的贪心算法所属，故将其放到算法分类里面了。</span></p><p id="88bb9f458aac1f0aa89a861c39b131f6" class="ne-p"><br></p><p id="26dd6339706b64d9f617cf5e571ec4bf" class="ne-p"><br></p><p id="4dccc396ba4ee721ad76b490e08c8486" class="ne-p"><br></p><p id="2722e61c51c854135f8ad27e4594a933" class="ne-p"><br></p><p id="a4f7ffd8a89771e03642e1dd3e60709e" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📉图结构：无向图-有向图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『灵笼』——灵魂的牢笼</title>
      <link href="/essay/pnapfw/"/>
      <url>/essay/pnapfw/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B2%2C2%2C0%2C1%5D%2C%5B2%2C2%2C0%2C1%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="87ae0048a72f1bee29ddbcc5e0202b3b" id="87ae0048a72f1bee29ddbcc5e0202b3b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="ijJPU" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621244428291-8f947575-4da5-4938-a3fa-09f21bed0925.png" data-raw-src="" class="image lake-drag-image" alt="Snipaste_2021-05-17_17-38-3d5.png" title="Snipaste_2021-05-17_17-38-3d5.png" data-height="1080px" style="visibility: visible; width: 1920px;"></span></p><p data-lake-id="af9e6b14f89909a2ad76a80c8b99faee" id="af9e6b14f89909a2ad76a80c8b99faee" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>看了五集，觉得剧情设定方面有浓浓的进击的巨人和Darling in the franxx这两部番那味了（去论坛看了看，果然有吐槽的…不过都在说巨人，我更加觉得和国家队的世界观很像）…但不管怎么说，</span><strong><span>剧情设定和画质方面在国漫里面也是可圈可点，并且，我个人认为，这部番是这么多年国漫里面最用心最花成本的一部</span></strong><span>～</span></p><p data-lake-id="936a42ff936d7c1a50bf89c9b89d16da" id="936a42ff936d7c1a50bf89c9b89d16da" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="374184666c63eb0a7c54d62122377acf" id="374184666c63eb0a7c54d62122377acf" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>灵笼，灵魂的牢笼，就像是巨壁</span></p><p data-lake-id="u452a7683" id="u452a7683" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>重立体，立体机动装置（就不能叫个重装甲啥的，害</span><span data-card-type="inline" data-lake-card="image" id="rboSG"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1621243721740-de5b6182-0bb1-4971-95bf-1309c0fdfb1d.jpeg" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="58px" style="visibility: visible; width: 79px;"></span></p><p data-lake-id="udcc19708" id="udcc19708" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>猎荒者，调查兵团</span></p><p data-lake-id="ub245810e" id="ub245810e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>荷光者，宪兵团</span></p><p data-lake-id="c7a73cad76fd1527d918edc112252883" id="c7a73cad76fd1527d918edc112252883" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>……</span></p><p data-lake-id="e78c7f6ff1c79e75b6edd496476b3456" id="e78c7f6ff1c79e75b6edd496476b3456" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="5f41b43f70ab381b3abcf9ff01ffd036" id="5f41b43f70ab381b3abcf9ff01ffd036" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>我之前对darling里面的是『心』这个人物，我当时的感受是整部番的点睛之笔，在世界观的角度上，拉伸高度，在灵笼这里被设定为佩妮这个角色……</span></p><p data-lake-id="728fce5b4089cc37c61f73c1aac677ed" id="728fce5b4089cc37c61f73c1aac677ed" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="VgAwl" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621244183522-a0ab8144-4141-4887-895b-a5b3e6230613.png" data-raw-src="" class="image lake-drag-image" alt="Snipaste_2021-05-17_17-35-00.png" title="Snipaste_2021-05-17_17-35-00.png" data-height="1080px" style="visibility: visible; width: 1920px;"></span></p><p data-lake-id="5fb20c568753e1230fc1d6e5797cc35e" id="5fb20c568753e1230fc1d6e5797cc35e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="b2b0e7e0c4539f2d0197a340b959221c" id="b2b0e7e0c4539f2d0197a340b959221c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这些说实话，感受的挺多了，用这部番里面的一个词就是——躯壳。希望后面的剧情能挖掘出作品的闪光之处～</span></p><p data-lake-id="2eca8e0a0ec8ea3176a08ef390d6d713" id="2eca8e0a0ec8ea3176a08ef390d6d713" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="cUmMX"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="400943748f0c11a5e083e3ec212e589e" id="400943748f0c11a5e083e3ec212e589e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>EP6</span></p><p data-lake-id="48776f2534cdb298e8192f61cd81f10c" id="48776f2534cdb298e8192f61cd81f10c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="OlIMX"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621262671765-0831d8b9-f8eb-4a16-acc0-1b8d622ff5b8.jpg" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="146px" style="visibility: visible; width: 354px;"></span></p><p data-lake-id="8df7dc13a99fcdda8256b823298f09ee" id="8df7dc13a99fcdda8256b823298f09ee" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="fQ07I"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621262686893-e61922ea-e1b5-4fa8-82ac-cabc2ef60391.jpg" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="805px" style="visibility: visible; width: 1349px;"></span></p><p data-lake-id="189f2a7b38aac1e37c3c1a33380ca524" id="189f2a7b38aac1e37c3c1a33380ca524" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>不管这个世界再怎么变，人性永远在那，就像爱情……</span></p><p data-lake-id="befbd46b4767a3843e589d6e1805da04" id="befbd46b4767a3843e589d6e1805da04" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="27fc0931913efab3517f903ee0a636c0" id="27fc0931913efab3517f903ee0a636c0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>或许我在想，即便这个世界颠倒了，文明是一个全新的面貌，人性或许是那诸多不变的点之一。</span></p><p data-lake-id="e0ddfdfcbc11e27cbaddd761616191e4" id="e0ddfdfcbc11e27cbaddd761616191e4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="9yNge"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="43cfb880aec7af6b4d5b99387187dae2" id="43cfb880aec7af6b4d5b99387187dae2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="mKa4W"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621472984542-d6010263-d430-4ab7-ac8d-4f911c4d4bf3.jpg?x-oss-process=image%2Fresize%2Cw_2000" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="834px" style="visibility: visible; width: 2083px;"></span></p><p data-lake-id="55d077335426a9183d75f8137608dde2" id="55d077335426a9183d75f8137608dde2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>万万没想到系列，冉冰居然凉凉～</span></p><div data-card-type="block" data-lake-card="hr" id="JHHXc"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="78b38bbb609e7489da4763bbac776424" id="78b38bbb609e7489da4763bbac776424" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>终章+特别篇</span></p><p data-lake-id="f9676a9ce027e8eb4f0f6f8ac9f534a5" id="f9676a9ce027e8eb4f0f6f8ac9f534a5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="gBT7O"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621473001235-cb79d2e3-6a7e-4556-92b4-33ea9d442010.jpg" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="824px" style="visibility: visible; width: 1996px;"></span></p><p data-lake-id="b4c13366a067784ca2275dc78f63bc2a" id="b4c13366a067784ca2275dc78f63bc2a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="9eb8b13ef41bc89ffb62a78d2d5fca91" id="9eb8b13ef41bc89ffb62a78d2d5fca91" style="text-indent: 2em; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这波用灯塔来反衬地面幸存者的存在的意义，都知道噬极兽会以人类的情感来孕育，灯塔是颁布三大法令来限制灯塔上的人的情感，以此来让灯塔幸存于这乱世，地面幸存者则是相反，情感不但不能舍弃，反而要坚守</span></p><p data-lake-id="7822c0b6e9292530c1203301f4b9559a" id="7822c0b6e9292530c1203301f4b9559a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c8f38feb7a41905e44c624908c3b6642" id="c8f38feb7a41905e44c624908c3b6642" style="text-indent: 2em; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>至于白月魁，直接将这部番提升到修仙境界了</span><span data-card-type="inline" data-lake-card="image" id="MR71l"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622037065067-007f3642-a1e3-4f60-862b-af2e1013c8ec.jpeg" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="77px" style="visibility: visible; width: 77px;"></span><span>，就是人类中靠修炼而成的外挂，和阿克曼一族利威尔兵长是一类人，人类最强。</span></p><p data-lake-id="b5766f96b10e63a8f42dde3c5f7e6e90" id="b5766f96b10e63a8f42dde3c5f7e6e90" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="312a046a99097258c6a8ea393340ac79" id="312a046a99097258c6a8ea393340ac79" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="TxJXz"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621473476256-6440f355-2230-47d7-9a2d-cc3a92afa850.jpg?x-oss-process=image%2Fresize%2Cw_2000" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="1128px" style="visibility: visible; width: 2400px;"></span></p><p data-lake-id="9c1614cb08b3160c581649ba8b86aa00" id="9c1614cb08b3160c581649ba8b86aa00" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="b54a74b17960bed47ccfa51e84751b7b" id="b54a74b17960bed47ccfa51e84751b7b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="2756fb0549ca456400a599e1f6287693" id="2756fb0549ca456400a599e1f6287693" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="f637daffca44c515b3cd4e2e1d12b591" id="f637daffca44c515b3cd4e2e1d12b591" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="52495223c959fec8eafe0d63e412feb8" id="52495223c959fec8eafe0d63e412feb8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="6f4edc684874a8e74dc2fb283776fedd" id="6f4edc684874a8e74dc2fb283776fedd" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="4d9958565eaea1c075296feb05ee05f9" id="4d9958565eaea1c075296feb05ee05f9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="cd0243f05e57869e3766d3b2a6a0b44a" id="cd0243f05e57869e3766d3b2a6a0b44a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="b19d4dde4f88ee6fb0fc5ed772107461" id="b19d4dde4f88ee6fb0fc5ed772107461" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="d6f84594942f8d96354473ed3b7f5450" id="d6f84594942f8d96354473ed3b7f5450" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="5447c9d736c76beff2cf33f6ae3f3956" id="5447c9d736c76beff2cf33f6ae3f3956" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="7e8b0f2d040e7447cc79790df266eccf" id="7e8b0f2d040e7447cc79790df266eccf" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="cfd4f14294417abe856a51737d9fd334" id="cfd4f14294417abe856a51737d9fd334" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]竞赛常用STL容器详解</title>
      <link href="/blog/porzdi/"/>
      <url>/blog/porzdi/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><p id="b174f416224bd7d428d5952653d786f8" class="ne-p"><span class="ne-text">大部分文字内容转载自：</span><a href="https://blog.csdn.net/weixin_43844677/article/details/104902417" data-href="https://blog.csdn.net/weixin_43844677/article/details/104902417" target="_blank" class="ne-link"><span class="ne-text">竞赛常用STL容器详解</span></a></p><p id="u869b6a94" class="ne-p"><span class="ne-text">部分内容个人修改补充。</span></p></div><p id="e5c401f15f8c481887594e6e60a99c11" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1626175209711-5b013be3-5942-4a0a-b9ce-529a73668d94.jpeg" width="360" id="rFa1j" class="ne-image"></p><h2 id="FsIvq"><span class="ne-text">一、 概述</span></h2><p id="9325e5cb1f074bb346e4d4351260b24c" class="ne-p"><span class="ne-text">在算法竞赛中，使用C++语言的占很大比例，而几乎没有人使用C语言，其中核心的原因就是C++包含STL容器库，能够极大地减少选手在赛场上为了一些基础数据结构而浪费的时间。诚然，花一两分钟实现一个stack、queue甚至priority_queue都不是什么大问题，但如果需要实现BBST（Balanced Binary Search Tree）的情况呢？如果可以的话，我们总是希望不要手写红黑树、动态数组的。那么STL容器库的出现就像雪中送炭一样了。它们覆盖了竞赛中最基础的需要（张昆玮树、主席树这种东西肯定不会包含的），让你在面对非数据结构题的时候能够不因数据结构部分的代码而分心。</span></p><p id="46bd6ff3ccf301afd671dccb15832982" class="ne-p"><span class="ne-text"></span></p><p id="97da7fcd9472789cd12c279999442d4a" class="ne-p"><span class="ne-text">关于STL容器的相关问题非常细，经常成为面试中的考题，这里我们仅讨论一些必须的内容，然后只谈论在竞赛中的具体使用。</span></p><p id="551c7c831a7c03907effea19f85d8815" class="ne-p"><span class="ne-text"></span></p><p id="748f546e2cfa7dea162504441128383a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298404-a6bf5daf-fd5b-4504-a4d0-f80b17dc5899.png" width="1778" id="Rv9rY" class="ne-image"></p><p id="bc9da56b08501be44ab80c74871f3bcd" class="ne-p"><span class="ne-text">首先给出一张表格（来自cppreference）：</span></p><p id="b909ffb1c2645000a3fadf53bc7da1d2" class="ne-p"><span class="ne-text"></span></p><p id="89ffba3ee54d7d59bf99a47309fdc95d" class="ne-p"><span class="ne-text">这张表格中给出了各种容器支持的成员函数，在大多数停留在C++14和C++11版本的测试平台中，只有紫色、绿色部分是可用的。</span></p><p id="44ccc4a9adf75f8e0042b43b33fd83de" class="ne-p"><span class="ne-text"></span></p><p id="f29d38316edbbf61104ff268d8cf1503" class="ne-p"><span class="ne-text">在考察具体的容器的时候，出于竞赛中的需要，我们不会涵盖以上的全部，而是着重关注以下几点：</span></p><ol class="ne-ol"><li id="e3a45c83635d297ccda38ddb9d6dd721"><strong><span class="ne-text">随机访问</span></strong></li><li id="69bfa84b70d960e6323b085550f2cea4"><strong><span class="ne-text">插入和删除</span></strong></li><li id="59ba20d870115f04dc50335bc7c94948"><strong><span class="ne-text">端点访问</span></strong></li><li id="336e884d20f34f99decfeadc5641e490"><strong><span class="ne-text">迭代器类型（总结以上几点）</span></strong></li><li id="c498b0f5613aba11c9e457ae6c842ffd"><strong><span class="ne-text">时间复杂度</span></strong></li></ol><p id="99b0d09fab938a21cb2754647d420082" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="a3e5165a16b1bae8fdf91219d525dd61" class="ne-p"><span class="ne-text">事实上，综合以上几点，就可以得出一个容器的作用。容器的作用是由它支持的操作及其时间复杂度决定的，并不是说，容器的名字叫做set我就一定把它当作集合来用。从ADT的角度来说，</span><strong><span class="ne-text">数据结构=接口+接口的复杂度</span></strong><span class="ne-text">。而从另一个角度来看，容器内部支持的逻辑操作决定了它能够使用的迭代器类型，而这决定了外部可能存在哪些接口，因此也可以说</span><strong><span class="ne-text">数据结构=内部存储+迭代器</span></strong><span class="ne-text">。这样两种观点，能够在使用的层面加强我们对于STL容器的理解。</span></p><p id="2991cf1395bfdc1d38f67bdc19b84e7d" class="ne-p"><span class="ne-text"></span></p><p id="cf86b02f332a87d38750352809652a2f" class="ne-p"><span class="ne-text">方便起见，这里先列出一个汇总的表格，包含了竞赛中常用的几种数据结构：</span></p><p id="fc2f072711b55b1880c821933e0952cb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298080-23300f65-22c0-48b6-895a-324e3793fed5.png" width="857" id="PnAJG" class="ne-image"></p><p id="ef4077071ca1b74312af73b195c64fe0" class="ne-p"><span class="ne-text"></span></p><p id="17aab6c9586e8902c6fd2078e0858e61" class="ne-p"><span class="ne-text">这里的表格只给出了很简单的内容，本文末尾会给出两个总结性的表格，给出具体操作的函数名和时间复杂度。</span></p><p id="e40afaabd6286f809dee5c382de4cf66" class="ne-p"><span class="ne-text"></span></p><h2 id="Xuzkh"><span class="ne-text">二、 迭代器</span></h2><h3 id="xshvx"><span class="ne-text">迭代器与遍历</span></h3><p id="074397d1269d9d82ce8b72aee49ddc7b" class="ne-p"><span class="ne-text">操作一个容器，无法脱离它提供的工具——</span><strong><span class="ne-text">迭代器</span></strong><span class="ne-text">。即使没有使用过容器，我们也一定使用过最基本的方式遍历一个数组：</span></p><pre data-language="cpp" id="kBuLl" class="ne-codeblock language-cpp">for (int i = 0; i <n;i++)<pre><code>//......&lt;/pre&gt;&lt;p id=&quot;bef551f9c032825e8f863bf429c15fd2&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;351c9dc6e6e7f8e8f6940e80a257906a&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;不严格地说，这里的”i”就可以视作一个最原始的迭代器。事实上，对于藉由它，我们可以访问一个容器内的全部内容——这就是我们所说的“遍历”，这能够让我们对内部数据进行基于元素的操作。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;e3d177960f3a9710f3f6e20420be6ddc&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;88a1bf253f2267bb88accb386ed229d7&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;事实上，一个真正的迭代器需要符合很多要求。STL容器所配备的迭代器都属于C++迭代器库规定的六种之一，它们是：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;ne-ol&quot;&gt;&lt;li id=&quot;a0a508f956a7f7422c0ead00ef730792&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留输入迭代器&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;&lt;li id=&quot;9f854f20bfdb6d2e1286977be28fe7a4&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留向前迭代器&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;&lt;li id=&quot;0a72a21e2d5642f1eff31bb9d583ba50&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留双向迭代器&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;&lt;li id=&quot;3c95bdede059dce4c441b09a86225a2a&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留随机访问迭代器&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;&lt;li id=&quot;ed66347e7daafc2a005be826efaa4cfe&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留输出迭代器&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;&lt;li id=&quot;c5d7514d16d7b3c2dc4b549670e87ddb&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留连续迭代器&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p id=&quot;e20cdf4f8c8c6e24ed84a0a4f496f6c2&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;这些名字看起来很唬人，让我们来一点一点解释。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;10f96e2fae647322cc53935b4ded4772&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;首先，它们都是“&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留迭代器&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;”，这意味着它们都：（以下假设i是迭代器）&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;b3a4a9484fce4dba2ca346bf763aabb9&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;可&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;解引用&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;（*i得到元素）&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;77ffa0ff535587adbc30033b9e4bfc29&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;可&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;前自增&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;（++i得到下一位置）&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p id=&quot;6287f35ce511723066defafead41e55d&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;这也就是为何我们能藉由迭代器来完成遍历容器内元素的操作。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;bd99dd12ea8e1576f52b59606c2761d1&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;下面给出上文提到的六种迭代器的实际含义，虽然大多数情况下竞赛中用不到这些原理，但偶尔会有基于手动遍历的技巧性操作，这时候也许需要你对迭代器有一定的认知：&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;97f18ee5233fecadc9d2c10b132ade08&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留输入迭代器：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p id=&quot;3ecf3a7b5df6db5f69c312daffa5ce32&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;在&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留迭代器&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;的基础上，&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;04a52d75fbd1399b41b2a89b1046b15e&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;可&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;不等比较&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;（i!=j有定义）&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;003b47a543740051e9a5b4afe8408af3&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;可&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;后自增&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;（i++有定义）&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p id=&quot;ef8ef9ebbdec97b920d878dc57c1fcdc&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;但：**自增后，先前值可能失效。**也就是说，当你访问第1个元素时，可能无法通过这个迭代器的拷贝访问第0个元素。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;2c669df7fb5c7ea71f8d787d0626292c&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留向前迭代器：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p id=&quot;549b249d7366005f6663910166b92d71&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;在&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留输入迭代器&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;的基础上，&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;2148cf7e33ed970a529e0971a7fa763a&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;自增后保证先前值不失效。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p id=&quot;a7efa65b859d944ac6cfb118f9a01a0c&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留双向迭代器：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p id=&quot;27fa68639706c4eef6b49d6cf96de5ef&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;在&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留向前迭代器&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;的基础上，&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;3062dfba061363d314e7404df219a293&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;可&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;前自减&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;（–i有定义）&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;4407856a0ce5d1429e52ef999251e8e2&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;可&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;后自减&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;（i–有定义）&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p id=&quot;f981fa9738a21332add68b7616f568af&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留随机访问迭代器：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p id=&quot;6d11fae78ee405d0e50b53a45c33579e&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;在&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留双向迭代器&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;的基础上，&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;60fd749ae9531b0f615604e6af9edf5b&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;有&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;下标&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;运算符（i[n]有定义）&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;7189f291e63823ee6538353ceaa4d920&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;有&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;比较&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;运算符（&gt;、&lt;、&gt;=、&lt;=有定义）&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;a86c22e9b5a39cbca0f00050bd5d264a&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;可按&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;增量移动&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;（+、-、+=、-=有定义）&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p id=&quot;00031be3672384a249e470a5a5805156&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;且：&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;迭代器移动只耗费常数时间。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p id=&quot;b1c9abdd70ae2a110b1dab135c960e37&quot; class=&quot;ne-p&quot;&gt;&lt;em&gt;&lt;span class=&quot;ne-text&quot;&gt;若以上迭代器满足&lt;/span&gt;&lt;/em&gt;&lt;strong&gt;&lt;em&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留输出迭代器&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&lt;span class=&quot;ne-text&quot;&gt;的标准，那么称它们是“可变迭代器”。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p id=&quot;ad9fae9b279b18048b52b3558422d6ae&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留输出迭代器：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p id=&quot;220355b273fa9687e963738aab9533ca&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;在&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留迭代器&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;的基础上：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;e95b5efedf1430da2c01bcbcc61a83ca&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;可&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;赋值&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;（*i=something有定义）&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;82be7c34f1fafff53248888851e35de9&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;可&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;后自增&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p id=&quot;7b6ba705789cd5611d237dab96a66335&quot; class=&quot;ne-p&quot;&gt;&lt;em&gt;&lt;span class=&quot;ne-text&quot;&gt;若以上迭代器满足&lt;/span&gt;&lt;/em&gt;&lt;strong&gt;&lt;em&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留连续迭代器&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&lt;span class=&quot;ne-text&quot;&gt;的标准，那么称它们是“连续迭代器”。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p id=&quot;f6407a21d18d62bfede55dbdce19796b&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留连续迭代器：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p id=&quot;966927bf45388048f32c753c5dc97e02&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;在&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;遗留迭代器&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;的基础上：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;295aa1c5a2c7abf01d1c8a89fd4a2a34&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;逻辑相邻元素在内存中也相邻，&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;5505a0d35f145ed1be5b9704e1c4021d&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;即：&lt;/span&gt;&lt;code class=&quot;ne-code&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;*(i + n)&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;ne-text&quot;&gt; 等价于 &lt;/span&gt;&lt;code class=&quot;ne-code&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;*(std::addressof(*i) + n)&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p id=&quot;582a156458fbccb1ec63aa622e34b058&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;以上涉及的运算，不仅需要定义，并且需要符合功能要求。同时，部分操作有特例存在。例如，即使迭代器可解引用，也无法对尾后迭代器或孤立迭代器解引用。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;e99c167444924f0b4082b4bb007fd382&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;那么，如果知道某个容器的迭代器类型，对比一下它们支持的操作，你就能知道自己的一些奇思妙想能否实现了。例如：两头向中间访问、一次跳过多个元素、多个迭代器同时访问……&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;7aeb1f2b98528f9ea4648524c956fa92&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;那么，在复杂的环境下，例如访问的同时涉及插入和删除，这些操作还能按照我的意图运行吗？这就是我们要讨论的下一个问题了。如果说以上内容更偏向于实务开发，那么这个问题在竞赛中就更加常见了，它就是“迭代器失效”问题。&lt;/span&gt;&lt;/p&gt;&lt;h3 id=&quot;UeT7t&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;迭代器失效&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;47f4069d0f6796748f6ff291a6db7aa7&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;容器的一些操作会使得先前声明的迭代器失去它应有的作用，这种限制来自于容器底层的实现。例如在vector中，即使在尾部插入一个新元素也可能因为导致空间达到临界值而使得数据全部被移动到新空间，从而使全部迭代器失效。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;495c9d23522fa234f80177a2bacdeeac&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;90bb6dd65a4b4938a8261adeb97d1a18&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;大体来说，删除总会使得迭代器失效，而插入有些情况会使其失效。具体的情形见下表：（同样来自cppreference）&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;e337efacc6b6c67eddb05a168c1b18d4&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;e489e1368915645afa8777bf8467f447&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298154-92c7bf87-74b3-4fd5-9f62-d7ab6e5aa25b.png&quot; width=&quot;982&quot; id=&quot;N6O99&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;p id=&quot;d205f6a916045701debe1e97841744d1&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;6cd9b94d46196c0f14adc7af20025543&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;除此之外，尾后迭代器有一些特殊情形需要考虑，例如vector的尾后迭代器总是会被非法化、除了删除首元素外的修改操作都会非法化deque的尾后迭代器，等等。&lt;/span&gt;&lt;/p&gt;&lt;h3 id=&quot;xSEPM&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;尾后迭代器&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;f647c83d4c6e493b67419f5f8160b665&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;另一个要注意的点是，一般来说一个容器的begin()返回的是指向容器内首个元素的迭代器，而end()指向的却不是尾部元素，而是&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;尾后&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;——一个不存在的元素，我们也常常把这种位置称为“哨兵”。这一点好像恰好和其他参数为一个区间的函数，如sort(), substr()等，对应了起来——似乎编程中所有涉及区间的操作，都是使用左开右闭区间来表示的——也就是说，end()表示尾后。这是为什么呢？&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;3e39e9ba14e44104b73621d2592b67c5&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;考虑对一个具有&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;普通遗留迭代器&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;的容器进行迭代，应当怎么写呢？似乎很简单：&lt;/span&gt;&lt;/p&gt;&lt;pre data-language=&quot;plain&quot; id=&quot;yYKwZ&quot; class=&quot;ne-codeblock language-plain&quot;&gt;for (auto i = x.begin(); i != x.end(); i++)&lt;/pre&gt;&lt;p id=&quot;f50449d8125daae28412eb40bda2df91&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;看到这里，你应当已经明白了：大多数容器不具有遗留连续迭代器的性质，那就不存在像&lt;/span&gt;&lt;code class=&quot;ne-code&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;i &lt; x.end()&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;ne-text&quot;&gt;这种操作，因此无法像迭代一个数组一样以一个偏序比较作为条件，那么就必须有一个哨兵作为实际可以访问到的截止位，这个哨兵就是end()。&lt;/span&gt;&lt;/p&gt;&lt;h3 id=&quot;T5IXM&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;其他补充&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;3e5bcbf022fee73947a9cebc6bbbd284&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;在自写模板的时候，需要加上关键字&lt;/span&gt;&lt;code class=&quot;ne-code&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;typename&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;pre data-language=&quot;cpp&quot; id=&quot;f9Bth&quot; class=&quot;ne-codeblock language-cpp&quot;&gt;typename list&lt;T&gt;::iterator p;&lt;/pre&gt;&lt;h2 id=&quot;5nJdZ&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;三、容器&lt;/span&gt;&lt;/h2&gt;&lt;h3 id=&quot;EIqvD&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;Vector&lt;/span&gt;&lt;/h3&gt;&lt;h4 id=&quot;FLeAQ&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;总览&lt;/span&gt;&lt;/h4&gt;&lt;p id=&quot;8da9b17972578457ab1b8ac68711eab1&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;那么，我们就开始讲每个具体的容器了。在各节中，我们会依次介绍每个容器的用途、迭代器类型、插查删操作及其复杂度，有必要的时候，我们还会介绍一些其他的小trick。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;90864959b211b66ce9b82c10490b466a&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298034-6e429607-ece3-4c15-bd6a-e02efaf4d4f6.png&quot; width=&quot;669&quot; id=&quot;STppH&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;p id=&quot;bd5baafee5b7d487116c4d04df613fe2&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;我们看到，Vector与其他STL容器最大的区别就在于，只要元素不为bool类型（bool类型因内存对齐而不连续），它是唯一使用&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;连续迭代器&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;的，即使对于全部情况，它也符合遗留随机访问迭代器，从而支持以常数复杂度通过下标运算符随机访问。这使得我们可以直接将其作为升级版的数组使用——数组的功能全部被它继承，而它又自带了其他一些便捷的函数——因此vector又被称为 &lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;“动态数组”&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt; 。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;68ba6e696a07e5feb42e1f9197e58ee8&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;它底层的数据结构使用的是静态数组，实现动态扩容的奥秘在于，它在每一次容量占用达到阈值时就进行一次翻倍扩容，从而保证了均摊 O ( 1 ) O(1) &lt;/span&gt;&lt;span class=&quot;ne-text&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;ne-text&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ne-text&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ne-text&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ne-text&quot;&gt;的时间复杂度，而又能节省空间。&lt;/span&gt;&lt;/p&gt;&lt;h4 id=&quot;1nRvr&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;常见用法&lt;/span&gt;&lt;/h4&gt;&lt;p id=&quot;40d49aa8a2ae98495eef68ae7a560d8b&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;在C++11中，在具有begin()和end()的范围上进行迭代，有一种简便写法，那就是&lt;/span&gt;&lt;/p&gt;&lt;pre data-language=&quot;plain&quot; id=&quot;YZ0qw&quot; class=&quot;ne-codeblock language-plain&quot;&gt;for (auto&amp; v : container)&lt;/pre&gt;&lt;p id=&quot;8f3f53ff952f027921f5bd7bc5c5d305&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;它等价于&lt;/span&gt;&lt;/p&gt;&lt;pre data-language=&quot;plain&quot; id=&quot;CQTHT&quot; class=&quot;ne-codeblock language-plain&quot;&gt;for (auto&amp; v = container.begin(); v != container.end(); v++)&lt;/pre&gt;&lt;p id=&quot;f99b96a4b658ddef8216895c2cb93089&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;这里的auto利用了C++11的另一个特性——类型推导，这只是一个语法糖，它使我们不必写上container::iterator这一串复杂的类型，而在程序运行中与完整键入的并无区别。而auto后面加的&amp;代表v是一个左值引用，那么我们就可以通过v来修改容器中的元素。而如果我们想避免这种修改，可以去掉&amp;，这时v就是一个右值拷贝。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;5ea6aa09545d180fe8500bb40dc1e3f8&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;以一个int类型动态数组为例，我们可以这样输出：&lt;/span&gt;&lt;/p&gt;&lt;pre data-language=&quot;plain&quot; id=&quot;7o49C&quot; class=&quot;ne-codeblock language-plain&quot;&gt;vector&lt;int&gt; arr;</code></pre><p>for (auto v : arr)<br>cout&lt;&lt;v;</pre><p id="4e7db535eb1db00d7da248ffd0162de4" class="ne-p"><span class="ne-text">而读入可以这样写：</span></p><pre data-language="plain" id="9HlfB" class="ne-codeblock language-plain">for (int i = 1; i <= n; i++)<br>{</p><pre><code>cin&gt;&gt;temp;arr.push_back(temp);</code></pre><p>}</pre><p id="666266c9dbc2b7a3d18471334ffb3fbf" class="ne-p"><span class="ne-text">当然，同程序员们默认的一样，它的下标是从 0 开始的。</span></p><p id="c8f2191dc38184e07be9cbf4e62fd167" class="ne-p"><span class="ne-text">vector 是否可以写高维数组呢？如果你经常在 Leetcode 上刷题，应当见过二维数组的这种写法：</span><code class="ne-code"><span class="ne-text">vector<vector<int>></span></code><span class="ne-text">。高维数组以此类推即可。在访问上，这种写法与</span><code class="ne-code"><span class="ne-text">int arr[][]</span></code><span class="ne-text">没有任何区别。</span></p><h3 id="DGKQN"><span class="ne-text">List</span></h3><p id="1acbcecc2af052496c684194e713ae79" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298094-bbd53e64-b82a-4b51-aa3a-f354b3bd7023.png" width="669" id="D1lAx" class="ne-image"></p><p id="d63f691f3f345af2bf77c6e3f79f136d" class="ne-p"><span class="ne-text">可以看到，list 实际上就是一个</span><strong><span class="ne-text">双向链表</span></strong><span class="ne-text">，因此对于插入和删除的操作具有优秀的时间表现。当然也很容易想到，list 是无法实现常数时间随机访问的，insert 和 erase 看起来时间复杂度为  O ( 1 ) O(1) </span><span class="ne-text">O</span><span class="ne-text">(</span><span class="ne-text">1</span><span class="ne-text">)</span><span class="ne-text">，但在实际应用中，找到插入位置往往就需要  O ( n ) O(n) </span><span class="ne-text">O</span><span class="ne-text">(</span><span class="ne-text">n</span><span class="ne-text">)</span><span class="ne-text">的时间。</span></p><p id="d32940f3fd463a51dc7ea65729be9260" class="ne-p"><span class="ne-text">与 list 相似的，STL 中还存在一个单向链表 forward_list。由于不需要反向链，它的空间占用有所减小，不过这一点在竞赛中不怎么需要，所以那种结构了解即可。</span></p><h3 id="rolg4"><span class="ne-text">Stack</span></h3><h4 id="kAXMV"><span class="ne-text">总览</span></h4><p id="3ef016234adc4e2ac63f435d07edfb7f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298067-e4b7c1aa-ec7e-4535-a505-59440ac713db.png" width="669" id="Sfmf5" class="ne-image"></p><p id="876d6e559924ae58ddc7a67716f7c38c" class="ne-p"><span class="ne-text">相比于精心构造的数据结构，stack 似乎更应当被称为一种“包装器”，它在底层实现的基础上屏蔽掉了一些功能，从而使自身表现得更像一个物理栈。对于它和 queue，我们不需要多费口舌，也许这是仅有的两种我们可以自己实现而不会使代码冗长的数据结构了。但无论怎么说，有一个构造好的容器使用总是好的，它可以防止我们在底层的操作上犯一些愚蠢的错误。</span></p><h4 id="PHE4D"><span class="ne-text">常见用法</span></h4><p id="2db55f94404cd8b7f985357ba12bf50a" class="ne-p"><span class="ne-text">那么，这里就实际给出使用 stack 完成 DFS 的过程，以下是一段代码片段：</span></p><pre data-language="plain" id="uVATJ" class="ne-codeblock language-plain">vector<int> edges[N];<br>stack<int> dfs;<br>/<em>............</em>/<br>dfs.push(v0);<br>vis[v0] = true;<br>while (!dfs.empty())<br>{</p><pre><code>    bool tag = false;    int now = dfs.top();    prt.push_back(now);    for (auto v : edges[now])        if (!vis[v])        &#123;            dfs.push(v);            vis[v] = true;            tag = true;            break;        &#125;    if (!tag)        dfs.pop();&#125;&lt;/pre&gt;&lt;h3 id=&quot;55tfW&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;Deque及其延伸&lt;/span&gt;&lt;/h3&gt;&lt;h4 id=&quot;nzjq9&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;Deque&lt;/span&gt;&lt;/h4&gt;&lt;p id=&quot;2bbed1a65109b74243d276980a437a1b&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;虽然实际使用时很少见，但deque是很多STL容器的基础，stack和queue都由它封装而来，它也支持相当多的操作，详见下表：&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;7c1538f25f54b9cb6eef0f1277000c7a&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298045-e627f316-cc63-4992-817c-f8025c1474df.png&quot; width=&quot;669&quot; id=&quot;yw0ii&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;p id=&quot;e4c286b966d21b0cde6e4afb055e06d5&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;值得注意的是，该容器的迭代器非法化情形比较有趣，其原理也是面试题常考的内容，建议结合STL源码深入分析。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;50074c6f4b501f0f0b3d31f55a9f4d92&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;结合上表，发现它与List的区别主要在于，它能够实现常数时间随机访问，但内部插入、删除却需要线性时间，这也符合他们底层实现：链表和数组的区别，也正是这一点使得它们的迭代器一个是双向而另一个是随机访问。多进行这种思考，由&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;底层实现——容器——迭代器——操作&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;转为&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;底层实现——迭代器——操作&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;，是一名程序员获得抽象思维的重要方式。&lt;/span&gt;&lt;/p&gt;&lt;h4 id=&quot;6rbAT&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;Queue&lt;/span&gt;&lt;/h4&gt;&lt;p id=&quot;3909376590ae0222a94ca9c7692afde7&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;总览&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;cdee1d85330f92001b29a84a305488fe&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298045-979ccd1c-9d0c-4971-8323-beeb278dfecb.png&quot; width=&quot;669&quot; id=&quot;LTTqa&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;p id=&quot;ec3bf6075f1a314469dd41c85550556d&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;queue就是我们常说的&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;队列&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;了。同stack一样，它是很常见而且简单的数据结构，同样由deque封装得来。当然，由于deque和list都满足它的底层实现的要求，因此你可以指明换用list作为你的queue的底层实现：&lt;/span&gt;&lt;/p&gt;&lt;pre data-language=&quot;plain&quot; id=&quot;7Qp71&quot; class=&quot;ne-codeblock language-plain&quot;&gt;queue&lt;int, list&lt;int&gt;&gt; myQue;&lt;/pre&gt;&lt;p id=&quot;b3e401d6e594a0ed43953b2bf0cee848&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;由于STL容器都使用模板类，因此在实际开发中，你完全可以将所有容器的分配器、底层容器自主实现。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;2b75de0ad67e1676f0db8df3cdadd680&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;6.2.2.常见用法&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;7d2eb183e468080fbbedee2f802bb948&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;queue用来实现BFS应该是最常见的用法了，以下和stack一样给出一个代码片段：&lt;/span&gt;&lt;/p&gt;&lt;pre data-language=&quot;plain&quot; id=&quot;fBJAs&quot; class=&quot;ne-codeblock language-plain&quot;&gt;queue&lt;int&gt; que;while (!que.empty())&#123;    int now = que.front();    que.pop();    if (success(pos[now]))        return true;    for (int i = 0; i &lt; n; i++)        if (!vis[i] &amp;&amp; dis[now][i] &lt;= limit)        &#123;            que.push(i);            vis[i] = true;        &#125;&#125;&lt;/pre&gt;&lt;h4 id=&quot;nq54Y&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;Priority_Queue&lt;/span&gt;&lt;/h4&gt;&lt;p id=&quot;f8bba081079bb648ee52b2800fa424d1&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;6.3.1.总览&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;73c8082ad9bcb477ced5371c8f482918&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298072-4aa3333f-4fe3-4f4e-8f10-212345e22947.png&quot; width=&quot;669&quot; id=&quot;Qei4g&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;p id=&quot;b1a64cf544310cf445ace3e2c776c0b2&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;priority_queue实现了优先队列这一ADT，也就是我们常说的 &lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;“堆”&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt; 。但要明晰的是，优先队列是一种ADT，而堆是它的一种具体实现。在默认状态下，priority_queue实现的是大根堆，但你可以通过模板特化从而实现小根堆，甚至是自己定义的规则。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;18bee2c7c8a3ef343a4a01fb476dc32f&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;2625d01610d99818430568d7dc76a179&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;6.3.2.常见用法&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;fc64dc42e1cfe0f73f54117301683f43&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;实现小根堆的方式很简单:&lt;/span&gt;&lt;/p&gt;&lt;pre data-language=&quot;plain&quot; id=&quot;mHZto&quot; class=&quot;ne-codeblock language-plain&quot;&gt;priority_queue&lt;int, vector&lt;int&gt;, std::greater&lt;int&gt;&gt; myHeap;&lt;/pre&gt;&lt;p id=&quot;b33ef558e9c550cef931703739fb90fd&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;其中第一个参数为元素类型，第二个类型为底层实现，默认为vector，但STL库中的deque也符合要求。第三个参数为你的比较类型。priority_queue会按照这一比较偏序将&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;最末序&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;的元素作为“最大元素”。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;4417a73f75ce3889eaf3285c2868f150&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;在sort函数中自己构造函数对象以指定排序方式的写法非常基础，但其实在优先队列中指定排序方式的写法也并不困难。在sort中，我们传入一个函数指针，sort函数调用这个函数，获得它的返回值，从而得到元素之间的偏序。而在模板类中，由于&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;需要在编译期就特化类&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;，所以我们无法传入一个函数，而必须传入一个&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;类&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;。堆在排序时会&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;调用其构造函数&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;，获得构造函数的返回值，这整体上与我们给sort传参无异。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;165ef316ded3d73eba745a367532c747&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;大多数情况下，我们可以使用STL提供的编译器函数库中的比较运算，例如小于是less，大于等于是greater_equal，等等。上面用于实现小根堆的greater源码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-language=&quot;plain&quot; id=&quot;NrZfO&quot; class=&quot;ne-codeblock language-plain&quot;&gt;template&lt;typename _Tp&gt;struct greater : public binary_function&lt;_Tp, _Tp, bool&gt;&#123;    bool    operator()(const _Tp&amp; __x, const _Tp&amp; __y) const    &#123; return __x &gt; __y; &#125;&#125;;&lt;/pre&gt;&lt;p id=&quot;a78f9ba03c7b071ed994cf16d4234a6d&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;然而观察这一函数，它最终还是要调用具体类型的比较运算。那么如果我们给容器的类不具有偏序，或者我们需要特别指定偏序怎么办呢？下面给出一个实例。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;e8d6aadcbc80e9b16463d5e5cb8f57a8&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;例如，在图的搜索中我们需要存储点和它到源点的距离，那么我们的元素可能是这样的：&lt;/span&gt;&lt;/p&gt;&lt;pre data-language=&quot;plain&quot; id=&quot;l318F&quot; class=&quot;ne-codeblock language-plain&quot;&gt;typename int Vertex;</code></pre><p>typename int Distance;<br>typename pair&lt;Vertex, Distance&gt; Dest;</pre><p id="fdac6754ddac46a7c32775d34f405a56" class="ne-p"><span class="ne-text">在 Dijkstra 算法中，用堆优化时我们需要建立边权的小根堆，那么就可以这样自建比较类型（我们知道自己要使用的类型，就不需要写成模板类了）：</span></p><pre data-language="plain" id="Dpu9d" class="ne-codeblock language-plain">struct myGreater : public binary_function<Dest, Dest, bool><br>{</p><pre><code>bool operator() (const Dest &amp;lhs, const Dest &amp;rhs) const&#123; return lhs.second &gt; rhs.second; &#125;</code></pre><p>}</pre><p id="abcbbae7b6f64f631f2ef577d5b39fea" class="ne-p"><span class="ne-text">于是就可以这样建立基于边权的小根堆：</span></p><pre data-language="plain" id="9s5Ws" class="ne-codeblock language-plain">priority_queue<Dest, vector<Dest>, myGreater> myHeap;</pre><h3 id="UVR8t"><span class="ne-text">Set 及 Multiset</span></h3><h4 id="0ldEU"><span class="ne-text">总览</span></h4><p id="37cd991762e49138a54b07d2185a183a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298126-cd7b73e2-055e-4325-8270-dadc26949011.png" width="669" id="fntg7" class="ne-image"></p><p id="460933e07cace91c2d79850aa732d841" class="ne-p"><span class="ne-text">set 对应的 ADT 是</span><strong><span class="ne-text">集合</span></strong><span class="ne-text">：它支持元素的存储和查找，同时符合抽象意义上的集合要求——</span><strong><span class="ne-text">不允许出现重复元素</span></strong><span class="ne-text">。</span></p><h4 id="eJ0my"><span class="ne-text">常见用法</span></h4><p id="608b3b42ab2d86d2318893fb566ca7a6" class="ne-p"><span class="ne-text">set 的一个重要用途就是</span><strong><span class="ne-text">排序同时去重</span></strong><span class="ne-text">。在 BST 家族中，理论表现最好的是 Fibonacci-heap，但由于常数过大，实际表现最好的数据结构其实是 set 所采用的底层结构红黑树。如果说排序去重可以通过使用一个 sort 函数加手工来完成，那么需要</span><strong><span class="ne-text">支持插入和查找</span></strong><span class="ne-text">的题目呢？莫非我们要手写 RBT 吗？这时候，一个深受考验的 set 无疑是广大竞赛选手的福音。</span></p><p id="67486a4a9e1734a9fe7de395f24fbb50" class="ne-p"><span class="ne-text">当然，在更多的情况下，我们需要</span><strong><span class="ne-text">允许数据中出现重复</span></strong><span class="ne-text">的元素，那么</span><strong><span class="ne-text">可以使用 multiset</span></strong><span class="ne-text">这种数据结构，它在其他地方与 set 无异，唯一的区别在于它允许重复元素的出现。</span></p><p id="6328a682fa5e63b882187edf744a94b1" class="ne-p"><span class="ne-text">在容器中，find 函数在找不到对象的时候一般会返回 end，那么查找可以写作：</span></p><pre data-language="plain" id="oiRk0" class="ne-codeblock language-plain">if (c.find(x) != c.end())<br>//do something...</pre><h3 id="KnVnr"><span class="ne-text">Map</span></h3><h4 id="fGies"><span class="ne-text">总览</span></h4><p id="11714e03628efdbd418962483353ea3c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298068-5d1c0d5a-095f-44a8-92cd-fa4bc119ab01.png" width="669" id="dyk1Y" class="ne-image"></p><h4 id="Brk2P"><span class="ne-text">常见用法</span></h4><p id="6b7f1567e7734cb156957c66f7742e78" class="ne-p"><span class="ne-text">map 和 set 非常类似，只不过它的数据是</span><strong><span class="ne-text">键值对</span></strong><span class="ne-text">而非一个单独的键，而</span><strong><span class="ne-text">键是唯一的</span></strong><span class="ne-text">。如果给它的用途举个例子，可以是存储源点到所有可达点的访问记录。</span></p><p id="8512a19455a672ebcd5cffe914270d06" class="ne-p"><span class="ne-text">当然，同 map 一样，它也有允许键不唯一的版本，那就是</span><strong><span class="ne-text">multimap</span></strong><span class="ne-text">。本质上，</span><code class="ne-code"><span class="ne-text">multimap<Key, T></span></code><span class="ne-text">等价于</span><code class="ne-code"><span class="ne-text">multiset<pair<Key, T>, Comp<pair<Key, T>>, std::allocator<std::pair<Key, T>>></span></code><span class="ne-text">，其中 Comp 是自主实现的依据 Key 的比较类型。</span></p><p id="54a78d612f66c46942d22fae55ef4be8" class="ne-p"><span class="ne-text">也就是说，map 和 set 和 priority_queue 一样，支持特化比较类型，特化的方式也是一样的。只不过实际使用的时候，不要忘记最后一个模板参数，那是用于生成元素空间的分配器。</span></p><h2 id="MeMEn"><span class="ne-text">四、算法</span></h2><p id="6901abc61810e97f08b225965a3331a0" class="ne-p"><span class="ne-text">STL 里面有一些常用的函数模板，可以在平常使用。</span></p><p id="4343e03862a3774dcea7257894b11748" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="24ddbcb123cfa0ba4c14afd8e23a1491" class="ne-p"><span class="ne-text">参考这个链接：</span><a href="https://segmentfault.com/a/1190000021581714" data-href="https://segmentfault.com/a/1190000021581714" target="_blank" class="ne-link"><span class="ne-text">https://segmentfault.com/a/1190000021581714</span></a></p></div><h2 id="Muzfm"><span class="ne-text">五、总结</span></h2><p id="56eba145a4c02cfa4a011954a67d1c6d" class="ne-p"><span class="ne-text">本文最后，给出一个表格以供检索，相比于 cppreference 的总结，这里只列出了竞赛中常用的一些操作及其复杂度。begin()和 end()虽然较为常用，不过由于是全体容器必备的，所以不再列出。</span></p><p id="156aed03e46ea7de2b27acae470d0b92" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298131-b854f40d-40b6-42fb-a901-467032ef3583.png" width="1321" id="Pt0mu" class="ne-image"></p><p id="9e767f6fca48577ae56528e10dd311e8" class="ne-p"><span class="ne-text">这样，这篇文章也就基本结束了。可以看到，为了照顾特定的使用需求，本文对容器具体的实现未做过多探讨，反而对通常不太重视的迭代器部分做了一定的讲解。在竞赛中掌握这些内容，已经能够满足几乎全部的需求了。但在实际应用中，掌握这些内容甚至不足以通过一个大厂的面试。例如，deque 的若是对容器原理有兴趣，可以找市面上评价较好的 STL 源码解读类书籍学习。</span></p><p id="51b6ea6eb3ea297d2531b1a174409218" class="ne-p"><span class="ne-text"></span></p><div data-type="tips" class="ne-alert"><p id="0c4773046d8106f57ad18705b5021e76" class="ne-p"><span class="ne-text">补充：头文件#include&lt;bits/stdc.h&gt;（最常用，特别是 OJ 刷题）的内容如下</span></p></div><p id="83b015f0947ebeaea02152032cc3da8d" class="ne-p"><br></p><pre data-language="cpp" id="S3LLo" class="ne-codeblock language-cpp">// C++ includes used for precompiling -<em>- C++ -</em>-</p><p>// Copyright (C) 2003-2013 Free Software Foundation, Inc.<br>//<br>// This file is part of the GNU ISO C++ Library. This library is free<br>// software; you can redistribute it and/or modify it under the<br>// terms of the GNU General Public License as published by the<br>// Free Software Foundation; either version 3, or (at your option)<br>// any later version.</p><p>// This library is distributed in the hope that it will be useful,<br>// but WITHOUT ANY WARRANTY; without even the implied warranty of<br>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br>// GNU General Public License for more details.</p><p>// Under Section 7 of GPL version 3, you are granted additional<br>// permissions described in the GCC Runtime Library Exception, version<br>// 3.1, as published by the Free Software Foundation.</p><p>// You should have received a copy of the GNU General Public License and<br>// a copy of the GCC Runtime Library Exception along with this program;<br>// see the files COPYING3 and COPYING.RUNTIME respectively. If not, see<br>// &lt;Licenses - GNU Project - Free Software Foundation&gt;.</p><p>/** @file stdc++.h</p><ul><li>This is an implementation file for a precompiled header.<br>*/</li></ul><p>// 17.4.1.2 Headers</p><p>// C<br>#ifndef _GLIBCXX_NO_ASSERT<br>#include <cassert><br>#endif<br>#include <cctype><br>#include <cerrno><br>#include <cfloat><br>#include <ciso646><br>#include <climits><br>#include <clocale><br>#include <cmath><br>#include <csetjmp><br>#include <csignal><br>#include <cstdarg><br>#include <cstddef><br>#include <cstdio><br>#include <cstdlib><br>#include <cstring><br>#include <ctime></p><p>#if __cplusplus &gt;= 201103L<br>#include <ccomplex><br>#include <cfenv><br>#include <cinttypes><br>#include <cstdalign><br>#include <cstdbool><br>#include <cstdint><br>#include <ctgmath><br>#include <cwchar><br>#include <cwctype><br>#endif</p><p>// C++<br>#include <algorithm><br>#include <bitset><br>#include <complex><br>#include <deque><br>#include <exception><br>#include <fstream><br>#include <functional><br>#include <iomanip><br>#include <ios><br>#include <iosfwd><br>#include <iostream><br>#include <istream><br>#include <iterator><br>#include <limits><br>#include <list><br>#include <locale><br>#include <map><br>#include <memory><br>#include <new><br>#include <numeric><br>#include <ostream><br>#include <queue><br>#include <set><br>#include <sstream><br>#include <stack><br>#include <stdexcept><br>#include <streambuf><br>#include <string><br>#include <typeinfo><br>#include <utility><br>#include <valarray><br>#include <vector></p><p>#if __cplusplus &gt;= 201103L<br>#include <array><br>#include <atomic><br>#include <chrono><br>#include <condition_variable><br>#include <forward_list><br>#include <future><br>#include <initializer_list><br>#include <mutex><br>#include <random><br>#include <ratio><br>#include <regex><br>#include <scoped_allocator><br>#include <system_error><br>#include <thread><br>#include <tuple><br>#include <typeindex><br>#include <type_traits><br>#include <unordered_map><br>#include <unordered_set><br>#endif</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>视频的无伤切割</title>
      <link href="/blog/wr3hmo/"/>
      <url>/blog/wr3hmo/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ud132d32d" class="ne-p"><span class="ne-text">前言：对于一个很大的视频，不方便和其他用户使用软件传输，需要将其切割成数个小容量视频，两种方法，一种是利用其他软件来进行切割，比如pr；另一种是利用万能的ffmpeg，这个需求采用后者方法。</span></p><p id="uf011c49d" class="ne-p"><span class="ne-text">需求视频为8G多，总时长01：51：00，QQ在线传输一次最多4G，所以需要将目标视频切成三段，需要的命令如下：</span></p><pre data-language="bash" id="AfrxG" class="ne-codeblock language-bash">ffmpeg -ss 00:00:00 -i target.mp4 -c copy -t 00:45:00 target-part1.mp4 #Start～00:45:00<p>ffmpeg -ss 00:45:00 -i target.mp4 -c copy -t 00:45:00 target-part2.mp4 #00:45:00~01:30:00<br>ffmpeg -ss 01:30:00 -i target.mp4 -c copy -t 00:21:00 target-part3.mp4 #01:30:00 ～ End</pre><p id="u86567bc1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1643942474386-cacbcb25-dd05-48fa-b575-7cf6e13eb635.png" width="675" id="u9fb04278" class="ne-image"></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多一些沉稳，少一点浮躁</title>
      <link href="/essay/wrlggf/"/>
      <url>/essay/wrlggf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u426878f6" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="ue7f3a63c" class="ne-p"><span class="ne-text">在自己、同学、父母身上学到的一些关于沉稳和浮躁的相关感悟。</span></p></div><p id="u76cc7f70" class="ne-p"><span class="ne-text"></span></p><p id="u334205ae" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621129502175-8304c744-6269-4ca9-a89f-7180dbd6911c.png" width="1920" id="ue9157375"></p><p id="ua4bfe073" class="ne-p"><br></p><p id="uea4e4ec2" class="ne-p"><strong><span class="ne-text">多一些沉稳，少一些浮躁</span></strong></p><p id="u163a699d" class="ne-p"><span class="ne-text"></span></p><p id="ufa440c5c" class="ne-p" style="text-indent: 2em"><span class="ne-text">真正的技术人是不断去学习技术的，抑或是精进自己已有的技术，而不是像一个井底之蛙，不踏踏实实做技术，只想着一步登云，对技术而言，哪来的精进可言</span></p><p id="u3e091225" class="ne-p"><span class="ne-text"></span></p><p id="uaa7e917f" class="ne-p" style="text-indent: 2em"><span class="ne-text">这个节奏下面，很多人很多时候被生活牵着走，不再是我们过生活，而是生活过着我们，少了一些风情雅致，多了一些功利与欲望，就像是越肤浅的人，越浮躁，一新急于求成，功利心太重。越是有实力，能将生活活出自我的人越是沉稳安静，不急不躁，踏实努力，以梦为马，执笔为声！</span></p><p id="u6053d842" class="ne-p"><br></p><p id="u82921bff" class="ne-p" style="text-indent: 2em"><span class="ne-text">上面说到功利了，于是乎想到了我父母做生意的那路历程，做生意不可能一直起势，有起就有落，可在一些人眼中，他们所看到的，永远只有起势和高光……大学三年之下，A同学想着年薪百万，B同学想着开公司，我觉得这都是可以的，我相信年轻的资本在人生历程中是占比很足的，但是现在细想，那些话的字体行间透露着些许的浮躁，我暂且用野心来代替那些话，我相信野心这个词，但这三年在学校的生活与对社会的前驱认知告诉我，野心是基于沉稳之上的，野心是基于踏实之上，野心更是对理想而拆解成一系列目标并予以实施的基础上的，多一些沉稳，少一些浮躁……</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树</title>
      <link href="/blog/fyhtb2/"/>
      <url>/blog/fyhtb2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="6aTqg"><span class="ne-text">实验内容</span></h2><p id="7d4494118179e44e0f3ed8839f84ffb0" class="ne-p"><span class="ne-text">已知某系统在通信联络中只可能出现n种字符，其概率从键盘输入。试创建哈夫曼树。</span></p><p id="u14631b82" class="ne-p"><span class="ne-text"></span></p><h2 id="cozPM"><span class="ne-text">实验要求</span></h2><p id="2e4df6f34b851d957d20a58176fee7ae" class="ne-p"><span class="ne-text"> 1、从键盘输入n, 以及n个字符的概率。</span></p><p id="53159717888700928d3025e77865f9a9" class="ne-p"><span class="ne-text">例如：已知某系统在通信联络中只可能出现n种字符，其概率分别为   0.05, 0.29, 0.07, 0.08, 0.14, 0.23, 0.03, 0.11，试设计哈夫曼编码创建哈夫曼树。</span></p><p id="3f08e9ba77eae8c4d6729c3d06a2c7de" class="ne-p"><span class="ne-text">2、用顺序存储。</span></p><p id="8fa3ffb8da8d9047bbe0fcf4b26a8146" class="ne-p"><span class="ne-text">3、输出结果如下</span></p><p id="8ca76d9eebc14783ea80967a6eede7f6" class="ne-p"><span class="ne-text"> </span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620964210279-ee3848d0-d031-4dc0-a850-3ae179b7a317.png" width="312" id="lteAK" class="ne-image"></p><p id="0c54abe86060ef65be0dc82c893a755c" class="ne-p"><span class="ne-text">交作业时间：下次上机前</span></p><h2 id="z4tNS"><span class="ne-text">实验代码</span></h2><pre data-language="cpp" id="Cdxk7" class="ne-codeblock language-cpp">#include <bits/stdc++.h><p>using namespace std;</p><p>int n, m, s1, s2;<br>typedef struct HTNode<br>{<br>int weight, parent, lchild, rchild, pos;<br>bool operator&lt;(const HTNode &amp;a)const<br>{<br>return a.weight &lt; weight;<br>}<br>}HTNode, *HuffmanTree;</p><p>priority_queue<HTNode>P;</p><p>void Select(HuffmanTree &amp;HT, int ii, int &amp;s1, int &amp;s2)<br>{<br>HTNode t = P.top();<br>s1 = t.pos;<br>P.pop();<br>t = P.top();<br>s2 = t.pos;<br>P.pop();<br>}</p><p>void CreateHuffmantree(HuffmanTree &amp;HT, int n)<br>{<br>if(n &lt;= 1)<br>return;<br>m = 2 * n - 1;<br>HT = new HTNode[m + 1];<br>for(int i = 1; i &lt;= m; i++)<br>{<br>HT[i].parent = 0;<br>HT[i].lchild = 0;<br>HT[i].rchild = 0;<br>}<br>for(int i = 1; i &lt;= n; ++i)<br>{<br>cin &gt;&gt; HT[i].weight;<br>HT[i].pos = i;<br>P.push(HT[i]);<br>}<br>for(int i = n + 1; i &lt;= m; i++)<br>{<br>Select(HT, i - 1, s1, s2);<br>HT[s1].parent = i;<br>HT[s2].parent = i;<br>HT[i].lchild = s1;<br>HT[i].rchild = s2;<br>HT[i].weight = HT[s1].weight + HT[s2].weight;<br>HT[i].pos = i ;<br>P.push(HT[i]);<br>}<br>}</p><p>int main()<br>{<br>HuffmanTree HT;<br>cout &lt;&lt; “请输入哈夫曼树的叶子结点个数：”;<br>cin &gt;&gt; n;<br>cout &lt;&lt; “请输入每个叶子结点的权值：” &lt;&lt; ‘\n’;<br>CreateHuffmantree(HT, n);<br>for(int i = 1; i &lt;= 2 * n - 1; ++i)<br>{<br>cout &lt;&lt; “结点序号 “ &lt;&lt; i &lt;&lt; “ 权重 “ &lt;&lt; HT[i].weight<br>&lt;&lt; “ parent “ &lt;&lt; HT[i].parent &lt;&lt; “ lchild “ &lt;&lt; HT[i].lchild<br>&lt;&lt; “ rchild “ &lt;&lt; HT[i].rchild &lt;&lt; ‘\n’;<br>}<br>}</p><p></pre><h2 id="Oq4eC"><span class="ne-text">实验结果</span></h2><p id="a17e3b9f9fa59ed14ab816423bd5d336" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621215937466-2f1ef720-c7ae-4103-bf0b-0f75855059ff.png" width="369" id="mQROC" class="ne-image"></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树的基本知识</title>
      <link href="/blog/tyyaq0/"/>
      <url>/blog/tyyaq0/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>blob格式视频链接的下载</title>
      <link href="/blog/bhnvxw/"/>
      <url>/blog/bhnvxw/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="my40N"><span class="ne-text">场景</span></h3><p id="ub57bf056" class="ne-p"><span class="ne-text">有些网页的视频链接（html中）如下格式会下载不了，也没有视频的url可供访问</span></p><ul class="ne-ul"><li id="ua5adde30"><span class="ne-text">具体网页：</span><code class="ne-code"><a href="https://5kb.co/vodplay/33666-2-1.html" data-href="https://5kb.co/vodplay/33666-2-1.html" target="_blank" class="ne-link"><span class="ne-text">https://5kb.co/vodplay/33666-2-1.html</span></a></code></li><li id="ub002c8b1"><span class="ne-text">网页中的blob视频格式</span></li></ul><pre data-language="html" id="F6CkE" class="ne-codeblock language-html"><img src: "blob:https://5kb.co/a504161c-cf27-4979-a1c3-86a0ce4f6556"></pre><ul class="ne-ul"><li id="ud27b560d"><span class="ne-text">控制台查看后缀为m3u8的接口访问网络请求</span></li></ul><p id="ud04248ff" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641182194610-2c7ff9b7-6445-45b3-b2d9-fcbe164705b4.png" width="820" id="u616d033a" class="ne-image"></p><h3 id="cC4PX"><span class="ne-text">解决思路</span></h3><p id="u03a76a85" class="ne-p"><span class="ne-text">思路：安装ffmpeg环境，利用转换命令将其转换为MP4资源</span></p><ul class="ne-ul"><li id="uce246083"><span class="ne-text">ffmpeg环境的安装：</span><a href="https://www.yuque.com/wztlink1013/blog/akf33e#pDCNT" data-href="https://www.yuque.com/wztlink1013/blog/akf33e#pDCNT" target="_blank" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/blog/akf33e#pDCNT</span></a></li><li id="u02d12fdd"><span class="ne-text">转换命令：</span></li></ul><pre data-language="plain" id="uyN3Y" class="ne-codeblock language-plain">ffmpeg -i https://v3.dious.cc/20210520/8sKShH2U/index.m3u8 target.mp4</pre><h3 id="BtAhT"><span class="ne-text">关于blob视频加密相关知识</span></h3><p id="u4cafee64" class="ne-p"><span class="ne-text">blob视频加密就相当于将原视频url进行隐藏，然后切片访问播放。</span></p><p id="uc4c9fa2e" class="ne-p"><span class="ne-text">那么网页如何成功加载该视频呢？服务器会返回一个m3u8的响应文件，这个文件的作用就是正确找到所有的切片，然后拼接播放。</span></p><p id="u873a2172" class="ne-p"><span class="ne-text"></span></p><p id="ub09557a7" class="ne-p"><span class="ne-text">在使用ffmpeg将其拼接ts文件称mp4文件过程中，如下：</span></p><p id="u06afdfb4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641183335922-952b5616-e47f-44fa-89b6-4f6abaf78157.png" width="1402" id="u8b056dae" class="ne-image"></p><p id="u4f49849a" class="ne-p"><span class="ne-text">那么ts文件又是什么用的呢？</span></p><p id="u6093b0a7" class="ne-p"><span class="ne-text">百度百科的定义：</span></p><div class="ne-quote"><p id="u9945b40f" class="ne-p"><span class="ne-text">ts是日本高清摄像机拍摄下进行的封装格式，全称为MPEG2-TS。ts即"Transport Stream"的缩写。MPEG2-TS格式的特点就是要求从视频流的任一片段开始都是可以独立解码的。</span></p></div><p id="u7ab401c8" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的创建与遍历🔖DFS🔖先序🔖中序🔖后序</title>
      <link href="/blog/ggimdr/"/>
      <url>/blog/ggimdr/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="4Epl1"><span class="ne-text">实验报告</span></h2><div data-type="color1" class="ne-alert"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">编写一个程序，实现二叉树的各种运算，并在此基础上设计一个程序完成如下功能：</span></p></div><p id="4d03c6b09b984aef043ed5b518c363c7" class="ne-p"><br></p><div class="ne-quote"><p id="38598db323ff50acdf71c84be93d56d2" class="ne-p"><span class="ne-text">（1）创建一棵二叉树（用键盘按照</span><strong><span class="ne-text">先序遍历</span></strong><span class="ne-text">序列输入一个字符串生成二叉树）；</span></p><p id="6d6611128e131f3a0d3a0f0d853687c8" class="ne-p"><span class="ne-text">（2）输出前序、中序、后序遍历的遍历序列；  </span></p><p id="d3bc67e9954efda55a647c26d988e214" class="ne-p"><span class="ne-text">（3）统计并输出二叉树的的结点个数；</span></p><p id="2b559b492f686815878cb75ac83b3b42" class="ne-p"><span class="ne-text">（4）输出二叉树的叶子结点的个数；(选做)</span></p></div><p id="c05a274226f7be751442f3c2688a5e1f" class="ne-p"><br></p><div data-type="color1" class="ne-alert"><p id="3d301d5e79f0b9519c224c1db62d626b" class="ne-p"><span class="ne-text">实验要求：  </span></p></div><p id="9a21f7d2dbdf87c8a1d6951d6090b939" class="ne-p"><br></p><div class="ne-quote"><p id="29367bb74625a503f401e74a67a84591" class="ne-p"><span class="ne-text">用键盘输入一个字符串，按照</span><strong><span class="ne-text">满二叉树的特点</span></strong><span class="ne-text">生成一棵二叉树。</span></p></div><p id="663a7b36b101c7fddf398dd7f4151ef9" class="ne-p"><br></p><div data-type="color1" class="ne-alert"><p id="31e43c4890b63675efb128313a69f5e6" class="ne-p"><span class="ne-text">测试用例要求：</span></p></div><p id="8508e775c2dd3f3338c305eec70bcfd5" class="ne-p"><br></p><div class="ne-quote"><p id="5b4622339600d057a077198d9246b236" class="ne-p"><span class="ne-text">如下二叉树的输入字符串为：ABD###C#E##</span></p><p id="70373932282643f63ec142623dc8c357" class="ne-p"><span class="ne-text">书写方法：碰到#说明该二叉树是一棵空树，注意分配（下面缺两个左右补两个#，缺一个左/右子树，补一个#）</span></p></div><p id="1e4fa4b6d686ada91a2726874baf4778" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620295747111-4774a4a6-b617-4f26-a0c3-f9f1bdb386cc.png" width="235" id="Fl1gC" class="ne-image"></p><div data-type="color1" class="ne-alert"><p id="33e9672dfd9a5ed7c83baa6580c2cfdb" class="ne-p"><span class="ne-text">二叉链表的结点类型（C++）：</span></p></div><p id="203045dd2c8c14b360c1d2de82cbf109" class="ne-p"><br></p><pre data-language="cpp" id="UYEHy" class="ne-codeblock language-cpp">Typedef structure  tnode{<pre><code>int   data;structure  tnode   *lchild, *rchild;</code></pre><p>}bitree,*bitlink ;</pre><h2 id="iDiJK"><span class="ne-text">实验代码</span></h2><p id="4e4255e3159bf6d3a0d0ac2d29c6a6aa" class="ne-p"><span class="ne-text">用上面的二叉树作为例子：</span></p><pre data-language="cpp" id="bGw0S" class="ne-codeblock language-cpp">#include<bits/stdc++.h><br>using namespace std;<br>typedef int Status;<br>typedef char TElemType;<br>#define OVERFLOW -1<br>#define ERROR 0<br>#define OK 1<br>char ch;</p><p>/**</p><ul><li>采用二叉链表的存储形式<br>*/<br>typedef struct BiTNode<br>{<br>TElemType data;<br>struct BiTNode *lchild, *rchild;<br>}BiTNode, *BiTree;</li></ul><p>/**</p><ul><li>创建一棵二叉树<br>*/<br>void CreateBiTree(BiTree &amp;T) {<br>//按先序次序输入二叉树中结点的值，创建二叉链表表示的二叉树 T<br>TElemType ch;<br>cin&gt;&gt;ch;<br>if(ch == ‘#’){//递归结束，建空树<br>T = NULL;<br>} else {<br>T = new BiTNode;<br>T-&gt;data = ch;<br>CreateBiTree(T-&gt;lchild);<br>CreateBiTree(T-&gt;rchild);<br>}  </li></ul><p>}</p><p>/**</p><ul><li>先序遍历<br>*/<br>void PreOrderTraverse(BiTree &amp;T)<br>{//先序遍历二叉树 T 的递归算法<br>if(T) //若二叉树非空<br>{<br>cout &lt;&lt; T-&gt;data &lt;&lt; “ “; //访问根结点<br>PreOrderTraverse(T-&gt;lchild); //中序遍历左子树<br>PreOrderTraverse(T-&gt;rchild); //中序遍历右子树<br>}<br>}</li></ul><p>/**</p><ul><li>中序遍历<br>*/<br>void InOrderTraverse(BiTree &amp;T) {<br>if (T) {<br>InOrderTraverse(T-&gt;lchild);<br>cout &lt;&lt; T-&gt;data &lt;&lt; “ “;<br>InOrderTraverse(T-&gt;rchild);<br>}<br>}</li></ul><p>/**</p><ul><li>后序遍历<br>*/<br>void PostOrderTraverse(BiTree &amp;T)<br>{//后序遍历二叉树 T 的递归算法<br>if(T) //若二叉树非空<br>{<br>PostOrderTraverse(T-&gt;lchild); //中序遍历左子树<br>PostOrderTraverse(T-&gt;rchild); //中序遍历右子树<br>cout &lt;&lt; T-&gt;data &lt;&lt; “ “; //访问根结点<br>}<br>}</li></ul><p>/**</p><ul><li>统计二叉树中节点个数<br>*/<br>int NodeCount (BiTree &amp;T) {<br>if (T == NULL) {<br>return 0;<br>} else {<br>return NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + 1;<br>}<br>}</li></ul><p>/**</p><ul><li>二叉树中叶结点个数<br>*/<br>int LeavesCount (BiTree &amp;T) {<br>if (T == NULL) {<br>return 0;<br>} else if (T-&gt;lchild == NULL &amp;&amp; T-&gt;rchild == NULL) {<br>return LeavesCount(T-&gt;lchild) + LeavesCount(T-&gt;rchild) + 1;<br>}<br>else {<br>return LeavesCount(T-&gt;lchild) + LeavesCount(T-&gt;rchild);<br>}<br>}</li></ul><p>int main() {<br>BiTree test = new BiTNode;<br>cout &lt;&lt; “请输入一个字符串以生成二叉树：”;<br>CreateBiTree(test);<br>cout &lt;&lt;”\n”&lt;&lt; “先序遍历结果：”;<br>PreOrderTraverse(test);<br>cout &lt;&lt;”\n”&lt;&lt; “中序遍历结果：”;<br>InOrderTraverse(test);<br>cout &lt;&lt;”\n”&lt;&lt; “后序遍历结果：”;<br>PostOrderTraverse(test);<br>cout &lt;&lt;”\n”&lt;&lt; “二叉树结点个数：”&lt;&lt;NodeCount(test);<br>cout &lt;&lt;”\n”&lt;&lt; “二叉树叶结点个数：”&lt;&lt;LeavesCount(test);<br>}</pre><p id="f7b064b46c7f5e5145d73cd94574a05e" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620302765118-f27235d1-7167-40ae-ab80-dc23494d55cc.png" width="512.5" id="fbgNz" class="ne-image"></p><h2 id="sowJA"><span class="ne-text">DFS 遍历算法</span></h2><p id="u4362d8eb" class="ne-p" style="text-align: center"><strong><span class="ne-text" style="color: #E8323C">DFS 遍历分三种情况：先序、中序、后序</span></strong></p><div data-type="info" class="ne-alert"><p id="u95df2ce2" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">把一颗树遍历完，有下面三种方法：</span></p><ul class="ne-ul"><li id="uc9ff0cc0"><strong><span class="ne-text" style="background-color: #E8F7FF">波兰</span></strong><span class="ne-text" style="background-color: #E8F7FF">表达式 -&gt; </span><strong><span class="ne-text" style="background-color: #E8F7FF"> 先序</span></strong><span class="ne-text" style="background-color: #E8F7FF">遍历二叉树</span></li><li id="uc43055cb"><strong><span class="ne-text" style="background-color: #E8F7FF">中缀</span></strong><span class="ne-text" style="background-color: #E8F7FF">表达式 -&gt; </span><strong><span class="ne-text" style="background-color: #E8F7FF">中序</span></strong><span class="ne-text" style="background-color: #E8F7FF">遍历二叉树</span></li><li id="udba25db2"><strong><span class="ne-text" style="background-color: #E8F7FF">逆波兰</span></strong><span class="ne-text" style="background-color: #E8F7FF">表达式 -&gt;</span><strong><span class="ne-text" style="background-color: #E8F7FF"> 后序</span></strong><span class="ne-text" style="background-color: #E8F7FF">遍历二叉树</span></li></ul></div><p id="u92cfd7ea" class="ne-p"><br></p><p id="u22ea8840" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620298049502-63346474-7a61-45cf-88a8-56c66954d894.png" width="385.5" id="WLPKa" class="ne-image"></p><h3 id="Huygi"><span class="ne-text">手写例子</span></h3><p id="u4849dcc2" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620298098593-6760a592-4907-4662-a4be-404dde35d246.png" width="295" id="zsvnG" class="ne-image"></p><p id="ueab83a04" class="ne-p" style="text-align: left"><br></p><p id="ue7256163" class="ne-p" style="text-align: left"><span class="ne-text">各种遍历结果</span></p><ul class="ne-ul"><li id="ua1c0307d" style="text-align: left"><span class="ne-text">先序：-+a<em>b-cd/ef</span></li><li id="uf0007730" style="text-align: left"><span class="ne-text">中序：a+b</em>c-d-e/f</span></li><li id="u16808acb" style="text-align: left"><span class="ne-text">后序：abcd-*+ef/-</span></li></ul><p id="6a565f3d23b6283c08540b7cf1afa97e" class="ne-p" style="text-align: left"><br></p><h3 id="ZLoiv"><span class="ne-text">前序遍历</span></h3><ul class="ne-ul"><li id="u945a3d19"><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" data-href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" class="ne-link"><span class="ne-text">144. 二叉树的前序遍历</span></a></li></ul><pre data-language="javascript" id="nrZMj" class="ne-codeblock language-javascript">/**</p><ul><li>Definition for a binary tree node.</li><li>function TreeNode(val, left, right) {</li><li><pre><code>this.val = (val===undefined ? 0 : val)</code></pre></li><li><pre><code>this.left = (left===undefined ? null : left)</code></pre></li><li><pre><code>this.right = (right===undefined ? null : right)</code></pre></li><li>}<br>*/<br>/**</li><li>@param {TreeNode} root</li><li>@return {number[]}<br>*/<br>var preorderTraversal = function(root) {<br>let result = []<br>let preorder = data =&gt; {<br>if (data) {<br>result.push(data.val)<br>preorder(data.left)<br>preorder(data.right)<br>}<br>}<br>preorder(root)<br>return result<br>};</pre><h3 id="v6dYp"><span class="ne-text">中序遍历</span></h3><ul class="ne-ul"><li id="ua597b26d"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" data-href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" class="ne-link"><span class="ne-text">94. 二叉树的中序遍历</span></a></li></ul><pre data-language="javascript" id="LG67V" class="ne-codeblock language-javascript">/**</li><li>Definition for a binary tree node.</li><li>function TreeNode(val, left, right) {</li><li><pre><code>this.val = (val===undefined ? 0 : val)</code></pre></li><li><pre><code>this.left = (left===undefined ? null : left)</code></pre></li><li><pre><code>this.right = (right===undefined ? null : right)</code></pre></li><li>}<br>*/<br>/**</li><li>@param {TreeNode} root</li><li>@return {number[]}<br>*/<br>var inorderTraversal = function(root) {<br>let result = []<br>let inorder = data =&gt; {<br>if (data) {<br>inorder(data.left)<br>result.push(data.val)<br>inorder(data.right)<br>}<br>}<br>inorder(root)<br>return result<br>};</pre><h3 id="o6HJu"><span class="ne-text">后序遍历</span></h3><ul class="ne-ul"><li id="u9bf35e9b"><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" data-href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" class="ne-link"><span class="ne-text">145. 二叉树的后序遍历</span></a></li></ul><pre data-language="javascript" id="Wz4cL" class="ne-codeblock language-javascript">/**</li><li>Definition for a binary tree node.</li><li>function TreeNode(val, left, right) {</li><li><pre><code>this.val = (val===undefined ? 0 : val)</code></pre></li><li><pre><code>this.left = (left===undefined ? null : left)</code></pre></li><li><pre><code>this.right = (right===undefined ? null : right)</code></pre></li><li>}<br>*/<br>/**</li><li>@param {TreeNode} root</li><li>@return {number[]}<br>*/<br>var postorderTraversal = function(root) {<br>let result = []<br>let postorder = data =&gt; {<br>if (data) {<br>postorder(data.left)<br>postorder(data.right)<br>result.push(data.val)<br>}<br>}<br>postorder(root)<br>return result<br>};</pre></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验5——波兰/逆波兰表达式求值🔖栈</title>
      <link href="/blog/iyb7wi/"/>
      <url>/blog/iyb7wi/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="9e860144325b87da71afc87eefe2d77a" class="ne-p"><br></p><h2 id="9vFrj"><span class="ne-text">实验报告</span></h2><p id="f79ae7dddc05f05b1fe9f31553cdf695" class="ne-p"><span class="ne-text">实验五：实现用波兰表达式（先序）和逆波兰表达式（后序）求算术表达式的值</span></p><p id="4a9b70f09095db07a51166c993864aa5" class="ne-p"><span class="ne-text">要求：仅用一个栈实现（并且用原生单链表实现）</span></p><p id="0073cffd2d82424ee08e442fde183209" class="ne-p"><span class="ne-text">测试用例：4+2*3-10/5</span></p><p id="1015932deb14ce9808f762815a09e7c9" class="ne-p"><span class="ne-text">交作业时间：5月14日</span></p><h2 id="95f63ce98656d59fcee6f1cad6c4ae42"><span class="ne-text">思路</span></h2><p id="03a71edb0ce041bb880fac7483d51a8d" class="ne-p"><span class="ne-text">两个步骤：</span></p><ol class="ne-ol"><li id="127832819ea0b8b0383119803531e321"><strong><span class="ne-text">将给定的表达式转换为波兰表达式/逆波兰表达式</span></strong></li><li id="bbeddc496c9bbaa01590501e70c3593d"><strong><span class="ne-text">对转换后的式子进行计算</span></strong></li></ol><p id="75aa0ca11c1c45c1e80b31c018656ccc" class="ne-p"><br></p><p id="544e05aece3b557af8c08d44fe4340cf" class="ne-p"><span class="ne-text">学习遍历二叉树，利用前序/中序/后序表达式的时候，经常有一个问题就是：</span></p><p id="9fda6508e74029858e9a77d75c366090" class="ne-p"><br></p><ul class="ne-tl"><li checked="true" id="dff42916b2274e13af7620f3be09f8f4"><span class="ne-text">给出中缀表达式，【写出&&编程出】</span><span class="ne-text">后序（逆波兰）表达式</span></li></ul><p id="1cc028e11883abbffc825eedbee0a6d1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620306330357-a83abeff-56a3-44f1-b837-82051f46e3b5.png" width="237" id="ZAX5A" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620306352380-f6eef790-b72d-4e1d-9da1-6597ec5ae11d.png" width="294" id="zESCQ" class="ne-image"></p><p id="4ac0025b3ca7f49b653537cf8d999dca" class="ne-p"><span class="ne-text">上面的是课堂上在纸上的书写，那么如何将其用编程语言实现呢？思路应该是这样的：</span></p><ul class="ne-ul"><li id="f3e9b0538142d63fb0dddee70782998a"><span class="ne-text">遍历表达式：对遍历的元素进行判断</span></li><li id="16cdfca79195b1e48ee8fb8da2f93a3f"><span class="ne-text">是运算符？操作数？还是括号呢？对其相应的判断</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="536967d5477dce93aae2af4844744c6a"><span class="ne-text">操作数</span></li><li id="f742c335bbfeceb701f45f6da5359fda"><span class="ne-text">运算符：+-*/</span></li><li id="37bf504cf25ab5a1e31c553ebfe1f88e"><span class="ne-text">括号</span></li></ul></ul><ul class="ne-tl"><li checked="true" id="5a8cbdcf9cfe9df1a63ee1b6026b78d7"><span class="ne-text">个位数/双位数……的字符处理</span></li></ul><p id="59a438bb0fbcce4204dcef4b54e34c97" class="ne-p"><br></p><ul class="ne-tl"><li checked="true" id="03c0087d691f6334d867ef61684852de"><span class="ne-text">给出中缀表达式，【</span><span class="ne-text">写出&&编程出】</span><span class="ne-text">前序（波兰）表达式</span></li></ul><p id="0f94194b7fb7b6193beba54f8228ffa2" class="ne-p"><span class="ne-text">如果写出了逆波兰表达式，转换为波兰表达式只需要将</span><code class="ne-code"><span class="ne-text">（</span></code><span class="ne-text">变为</span><code class="ne-code"><span class="ne-text">）</span></code><span class="ne-text">，同时遍历从后往前遍历即可</span></p><p id="fb58b92c1fc00f9bcd46cc62d1ec7c6e" class="ne-p"><br></p><p id="7eb7f2863604df250b519a0432fe9e65" class="ne-p"><span class="ne-text">最后的结果逆置</span></p><ul class="ne-tl"><li checked="true" id="cb3454de2df57954ef838a0995e12ebc"><span class="ne-text">最后的计算，波兰和逆波兰不能写成一个函数，因为减数和被减数，除数和被除数的缘故</span></li></ul><h2 id="IjDi9"><span class="ne-text">实验代码</span></h2><p id="394b25ed4cb75f5498127a399da3cfeb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620979662957-690a9050-8a82-4170-816b-ffcff99f38d7.png" width="500" id="Kzxk3" class="ne-image"></p><p id="0e973006837549c019ba002da970c410" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620979669021-d90e4ff6-feb6-4df9-9f6a-d7176b25d258.png" width="446" id="XDVSW" class="ne-image"></p><pre data-language="cpp" id="RQfNT" class="ne-codeblock language-cpp">#include<bits/stdc++.h><p>using namespace std;</p><p>/**</p><ul><li>波兰表达式/逆波兰表达式求解运算表达式</li><li>*/</li></ul><p>/**</p><ul><li>单链表的存储结构<br>*/<br>typedef struct LNode {<br>string data; //数据域<br>struct LNode *next; //指针域<br>}Lnode, *LinkList; //LinkList 为指向结构体 LNode 的指针类型</li></ul><p>/_ 初始化链表 _/<br>void InitList(LinkList &amp;L) {<br>L = new LNode;<br>L-&gt;next = NULL;<br>}</p><p>/_ 打印 _/<br>void TraverseList(LinkList &amp; L){<br>LNode *p = new LNode;<br>p = L-&gt;next;<br>// cout &lt;&lt; “此中缀表达式链表打印的结果为：”;<br>while (p != NULL)<br>{<br>cout &lt;&lt; p-&gt;data;<br>p = p-&gt;next;<br>}<br>cout &lt;&lt; “\n”;<br>}</p><p>/_ 逆置 _/<br>void ReverseList(LinkList &amp;L) {<br>LNode *p = L-&gt;next;<br> L-&gt;next = NULL;<br> while(p)<br> {<br>LNode *q = p-&gt;next;<br> p-&gt;next = L-&gt;next;<br> L-&gt;next = p;<br> p = q;<br> }<br>}</p><p>/**</p><ul><li>初始化用户输入的链表<br>*/<br>void Center(LinkList &amp;L,string s) {<br>InitList(L);<br>LinkList p = L;<br>string temp = “”;<br>for (int i = 0; i &lt; s.length();i++){<br>// 处理双位数字情况<br>if (isdigit(s[i])) {<br>// 该字符为数字<br>temp = temp + s[i];<br>if (!isdigit(s[i+1])) {<br>// 下一个不是数字，而是字符，将 temp 后插<br>LinkList node = new LNode;<br>node-&gt;data = temp;<br>node-&gt;next = NULL;<br>p-&gt;next = node;<br>p = node;<br>// 将 temp 重置<br>temp = “”;<br>continue;<br>}<br>continue;<br>}<br>// 后插到 L 尾巴上<br>LinkList node = new LNode;<br>node-&gt;data = s[i];<br>node-&gt;next = NULL;<br>p-&gt;next = node;<br>p = node;<br>}<br>}</li></ul><p>/**</p><ul><li><p>将表达式转换为波兰表达式/逆波兰表达式</p></li><li><p>第二个参数对逆波兰而言是左括号，第三个参数对逆波兰而言是右括号</p></li><li><p>对波兰而言反过来<br>*/<br>void Transition(LinkList &amp;L, string l, string r){<br>// 定义一个栈用来处理<br>stack<string> stack;<br>LinkList p = L-&gt;next;<br>LinkList result = new LNode;<br>InitList(result);<br>LinkList result_a = result;</p><pre><code>while(p != NULL) &#123;    if (p-&gt;data == l) &#123;        stack.push(p-&gt;data);    &#125; else if(p-&gt;data == r) &#123;        while(stack.top() != l)&#123;            LinkList temp = new LNode;            temp-&gt;data = stack.top();            temp-&gt;next = NULL;            result_a-&gt;next = temp;            result_a = temp;            stack.pop();        &#125;        if (stack.top() == l)&#123;            stack.pop();        &#125;    &#125; else if(p-&gt;data == &quot;+&quot; || p-&gt;data == &quot;-&quot;) &#123;        if (stack.size() != 0) &#123;            if (stack.top() == &quot;*&quot; || stack.top() == &quot;/&quot;)&#123;                for (int i = 0; i &lt; stack.size();i++) &#123;                    if (stack.top() == l) &#123;                        break;                    &#125;                    LinkList temp = new LNode;                    temp-&gt;data = stack.top();                    temp-&gt;next = NULL;                    result_a-&gt;next = temp;                    result_a = temp;                    stack.pop();                &#125;            &#125;        &#125;        stack.push(p-&gt;data);    &#125; else if(p-&gt;data == &quot;*&quot; || p-&gt;data == &quot;/&quot;) &#123;        stack.push(p-&gt;data);    &#125; else &#123;        LinkList temp = new LNode;        temp-&gt;data = p-&gt;data;        temp-&gt;next = NULL;        result_a-&gt;next = temp;        result_a = temp;    &#125;    p = p-&gt;next;&#125;// TraverseList(result);for (int i = 0; i &lt; stack.size();i++) &#123;    LinkList temp = new LNode;    temp-&gt;data = stack.top();    temp-&gt;next = NULL;    result_a-&gt;next = temp;    result_a = temp;    stack.pop();&#125;// 上一个操作总是不能清空栈的最后一个元素LinkList temp = new LNode;temp-&gt;data = stack.top();temp-&gt;next = NULL;result_a-&gt;next = temp;result_a = temp;stack.pop();L = result;</code></pre><p>}</p></li></ul><p>/**</p><ul><li>计算<br>*/</li></ul><p>void EvaulTree(LinkList &amp;L) {<br>// 定义一个栈用来处理<br>stack<string> stack;<br>LinkList p = L-&gt;next;<br>while(p != NULL) {<br>if (p-&gt;data == “+”){<br>int x = stoi(stack.top());<br>stack.pop();<br>int y = stoi(stack.top());<br>stack.pop();<br>stack.push(to_string(y + x));<br>} else if(p-&gt;data == “-“) {<br>int x = stoi(stack.top());<br>stack.pop();<br>int y = stoi(stack.top());<br>stack.pop();<br>stack.push(to_string(y - x));<br>} else if(p-&gt;data == “_”) {<br>int x = stoi(stack.top());<br>stack.pop();<br>int y = stoi(stack.top());<br>stack.pop();<br>stack.push(to_string(y _ x));<br>} else if(p-&gt;data == “/“) {<br>int x = stoi(stack.top());<br>stack.pop();<br>int y = stoi(stack.top());<br>stack.pop();<br>stack.push(to_string(y / x));<br>} else {<br>stack.push(p-&gt;data);<br>}<br>p = p-&gt;next;<br>}<br>while (!stack.empty()){<br>cout &lt;&lt; stoi(stack.top());<br>stack.pop();<br>}<br>}</p><p>void EvaulTree_polish(LinkList &amp;L) {<br>// 定义一个栈用来处理<br>stack<string> stack;<br>LinkList p = L-&gt;next;<br>while(p != NULL) {<br>if (p-&gt;data == “+”){<br>int x = stoi(stack.top());<br>stack.pop();<br>int y = stoi(stack.top());<br>stack.pop();<br>stack.push(to_string(x + y));<br>} else if(p-&gt;data == “-“) {<br>int x = stoi(stack.top());<br>stack.pop();<br>int y = stoi(stack.top());<br>stack.pop();<br>stack.push(to_string(x - y));<br>} else if(p-&gt;data == “_”) {<br>int x = stoi(stack.top());<br>stack.pop();<br>int y = stoi(stack.top());<br>stack.pop();<br>stack.push(to_string(x _ y));<br>} else if(p-&gt;data == “/“) {<br>int x = stoi(stack.top());<br>stack.pop();<br>int y = stoi(stack.top());<br>stack.pop();<br>stack.push(to_string(x / y));<br>} else {<br>stack.push(p-&gt;data);<br>}<br>p = p-&gt;next;<br>}<br>while (!stack.empty()){<br>cout &lt;&lt; stoi(stack.top());<br>stack.pop();<br>}<br>}</p><p>int main () {<br>cout &lt;&lt; “————————————“&lt;&lt;”\n”;<br>string s;<br>cout &lt;&lt; “请输入运算表达式：”&lt;&lt;”\n”;<br>cin &gt;&gt; s;<br>LinkList test_reversepolish = new LNode;<br>InitList(test_reversepolish);<br>LinkList test_polish = new LNode;<br>InitList(test_polish);</p><pre><code>Center(test_reversepolish, s);Center(test_polish, s);cout &lt;&lt; &quot;------------------------------------&quot;&lt;&lt;&quot;\n&quot;;// 波兰表达式ReverseList(test_polish);Transition(test_polish, &quot;)&quot;, &quot;(&quot;);cout &lt;&lt; &quot;波兰表达式为：&quot;;ReverseList(test_polish);TraverseList(test_polish);cout &lt;&lt; &quot;波兰表达式计算结果为：&quot;;ReverseList(test_polish);EvaulTree_polish(test_polish);cout &lt;&lt; &quot;\n&quot;&lt;&lt;&quot;------------------------------------&quot;&lt;&lt;&quot;\n&quot;;// 逆波兰表达式Transition(test_reversepolish, &quot;(&quot;, &quot;)&quot;);cout &lt;&lt; &quot;逆波兰表达式为：&quot;;TraverseList(test_reversepolish);cout &lt;&lt; &quot;逆波兰表达式计算结果为：&quot;;EvaulTree(test_reversepolish);cout &lt;&lt; &quot;\n&quot;&lt;&lt;&quot;------------------------------------&quot;&lt;&lt;&quot;\n&quot;;</code></pre><p>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BF和KMP模式匹配算法</title>
      <link href="/blog/ah7arw/"/>
      <url>/blog/ah7arw/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="bbef41e6cf359255bbde71a85dc43898" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620290726560-b77d1aa1-b7ed-4561-95b4-0e8f7e643ca9.png" width="361.5" id="Q9tj2" class="ne-image"></p><p id="c907579b64684dfce48f3205154333a3" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="2d18b8a0f458f4ecf10e7bd1f860780f" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">在进行字符串匹配的相关程序中，看一个子串是否在一个主串里面，有著名的Brute-Force和基于此改进的KMP算法，具体学习记录如下：</span></p></div><h2 id="Ffqh8"><span class="ne-text">Brute-Force</span></h2><div class="ne-quote"><p id="8ad2578b424968bc6bd4f2ed0e0f65af" class="ne-p"><span class="ne-text">给出一个主串和一个子串</span></p><p id="8a36746aaf9610184b750791b5965c6b" class="ne-p"><span class="ne-text">主串：s = ababc</span><strong><span class="ne-text">abcac</span></strong><span class="ne-text">bab</span></p><p id="9d4d068fe6d44771c021c63e175b098e" class="ne-p"><span class="ne-text" style="background-color: transparent">子串：t = abcac</span></p></div><p id="b2dd074081afd9c9b47ccd7b9143e880" class="ne-p"><span class="ne-text">①BF算法算是一种暴力算法，首先是查看t的第一字母a和上面s的第一个字母比较相同，所以接着比较比到各自的第三个字符也就是，aba、abc发现不同，</span></p><p id="e35adca9e0bc3093c9d5f32e26b61bed" class="ne-p"><br></p><p id="131d9605c2eda9766ec9f323ff2dc55c" class="ne-p"><span class="ne-text">②再递推比较，t回到第一个字母a，这时s回到第二个字符（因为第一个字符已经比过了）相当于</span><span class="ne-text">babcabcacbab和abcac两个字符串进行比较，很明显第一个字符就不一样，</span></p><p id="edbbad2ce92acabab926dfe05a89c053" class="ne-p"><br></p><p id="d9d2e440fb580c81dfee4ebb1d516d52" class="ne-p"><span class="ne-text">③再递推比较……</span></p><p id="70fa395bcedb3156c06b512ee7064afb" class="ne-p"><br></p><p id="c94c3d9622e6711a795a02dd95dfbed1" class="ne-p"><span class="ne-text">按常理来思考，这样总能得出结果，但是在此基础上，可以有进一步的优化操作，怎么说？</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617677082076-945e1a85-4b75-40ad-a413-46f7e514b7f4.jpeg" width="55" id="xbp9q" class="ne-image"></p><p id="0f257d56637c7793a108f18b7ed01bc8" class="ne-p"><span class="ne-text">在上面的第②步里面，我们总是一步一步递推，那我们能不能一次性推好几步呢？就根据已经匹配了的那串字母。</span></p><p id="ed3b2f764966d419e64c220dd62e5cc9" class="ne-p"><br></p><p id="d90f5843ceba354fcb6794586b242373" class="ne-p"><span class="ne-text">具体表现为：①已经发现是第三个字符不同，那我们就根据前面两个相同的字符（ab）推出第②步推两步，为什么根据相同的ab，第②个步骤就可以一次性走两步？</span></p><h2 id="oEgiu"><span class="ne-text">KMP算法</span></h2><h3 id="wGOpN"><span class="ne-text">算法详述</span></h3><p id="bbd5d8a2fc71893bd94dc1ffb47a3523" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617677082076-945e1a85-4b75-40ad-a413-46f7e514b7f4.jpeg" width="55" id="tAJ2v" class="ne-image"><span class="ne-text">先学会用，理论日后再补…… 🕊</span></p><p id="8b014eafa0ce22db1682a80cc7459e40" class="ne-p"><span class="ne-text"></span></p><p id="05966fbe8ad009c95ad9f1520ce6f98c" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620286656388-6b7c4ae0-8c01-4ae5-9451-9d17c63a23bb.png" width="362.5" id="t1z49" class="ne-image"></p><h3 id="3gIJ6"><span class="ne-text">计算next函数值</span></h3><div class="ne-quote"><p id="c45f9f063f5d4748f12a7b453abb0aa1" class="ne-p"><span class="ne-text">（3）串“ababaaababaa”的next数组为（  ）。</span></p><p id="e026a63024d856bb636b5dc3e91145c8" class="ne-p"><span class="ne-text">A．012345678999   B．012121111212   C．011234223456    D．0123012322345</span></p><p id="05cb2f2e114ba30bf170a09d1f5ab3d6" class="ne-p"><span class="ne-text">答案：C</span></p></div><p id="28778f634e9aa96ca56b29417b3a5d2a" class="ne-p"><br></p><table id="WQyby" class="ne-table" style="width: 623px"><tbody><tr style="height: 33px"><td width="75"><p id="9be41bd898970beaef453015a11fc209_p_0" class="ne-p"><span class="ne-text">j</span></p></td><td width="41"><p id="f5288918051daac58a0cdf74b1d666a8_p_0" class="ne-p"><span class="ne-text">1</span></p></td><td width="47"><p id="2437cac6ad8f03448ae403be9a3af9ed_p_0" class="ne-p"><span class="ne-text">2</span></p></td><td width="41"><p id="51d6cd746c79a513e0ce3a75ec25e3f9_p_0" class="ne-p"><span class="ne-text">3</span></p></td><td width="47"><p id="c5dca1e0e58592b0de68a15917b9aac6_p_0" class="ne-p"><span class="ne-text">4</span></p></td><td width="48"><p id="e93c6396b478003add85a5ab1354e564_p_0" class="ne-p"><span class="ne-text">5</span></p></td><td width="44"><p id="4e0a00f0fff2d08f625bcf3627cf94db_p_0" class="ne-p"><span class="ne-text">6</span></p></td><td width="50"><p id="ae427e384184b1214e0bf3f7df0a833e_p_0" class="ne-p"><span class="ne-text">7</span></p></td><td width="50"><p id="2a7b14533ca92e6ddd576c36969708ce_p_0" class="ne-p"><span class="ne-text">8</span></p></td><td width="45"><p id="af98e36da6caf2103235814d586bea93_p_0" class="ne-p"><span class="ne-text">9</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">10</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="u19987c0e" class="ne-p"><span class="ne-text">11</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="ube4b3363" class="ne-p"><span class="ne-text">12</span></p></td></tr><tr style="height: 33px"><td width="75"><p id="a542bd2757409de9dfb7727ebcaf31c5_p_0" class="ne-p"><span class="ne-text">t</span></p></td><td width="41"><p id="08ca20eb36284487001463292f6550f4_p_0" class="ne-p"><span class="ne-text">a</span></p></td><td width="47"><p id="8d5efedb4fdbe061cc194fc98f15df26_p_0" class="ne-p"><span class="ne-text">b</span></p></td><td width="41"><p id="u4ba171c0" class="ne-p"><span class="ne-text">a</span></p></td><td width="47"><p id="uad8517ea" class="ne-p"><span class="ne-text">b</span></p></td><td width="48"><p id="u4fc6d17a" class="ne-p"><span class="ne-text">a</span></p></td><td width="44"><p id="u3a396665" class="ne-p"><span class="ne-text">a</span></p></td><td width="50"><p id="uea5ab139" class="ne-p"><span class="ne-text">a</span></p></td><td width="50"><p id="uf43da0d5" class="ne-p"><span class="ne-text">b</span></p></td><td width="45"><p id="u15a07baf" class="ne-p"><span class="ne-text">a</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="ue0fede51" class="ne-p"><span class="ne-text">b</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="u925438c3" class="ne-p"><span class="ne-text">a</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="u3bc3bb00" class="ne-p"><span class="ne-text">a</span></p></td></tr><tr style="height: 33px"><td width="75"><p id="fc06ea377ed3bb2f227b8d21f4771bce_p_0" class="ne-p"><span class="ne-text">next(j)</span></p></td><td width="41"><p id="515141c761d1a2676477bcc490f86bc4_p_0" class="ne-p"><span class="ne-text">0</span></p></td><td width="47"><p id="uf33c1bad" class="ne-p"><span class="ne-text">1</span></p></td><td width="41"><p id="u6cc7fec3" class="ne-p"><span class="ne-text">1</span></p></td><td width="47"><p id="u906cf0a9" class="ne-p"><span class="ne-text">2</span></p></td><td width="48"><p id="ud7d51835" class="ne-p"><span class="ne-text">3</span></p></td><td width="44"><p id="u1ac6d524" class="ne-p"><span class="ne-text">4</span></p></td><td width="50"><p id="uf064b958" class="ne-p"><span class="ne-text">2</span></p></td><td width="50"><p id="u20960527" class="ne-p"><span class="ne-text">2</span></p></td><td width="45"><p id="u82b4e795" class="ne-p"><span class="ne-text">3</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="udb52cb3c" class="ne-p"><span class="ne-text">4</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="u5ec269a0" class="ne-p"><span class="ne-text">5</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="u85d1d3ab" class="ne-p"><span class="ne-text">6</span></p></td></tr></tbody></table><p id="ede4828120a719212ee5f1d7947d6c20" class="ne-p"><br></p><p id="4de55acebb3d510651128eca5999d7f1" class="ne-p"><span class="ne-text">方法：</span></p><p id="ab27975aadd906abf25ea1dbd2125eb0" class="ne-p"><span class="ne-text">①next数组第一位永远是0，1；</span></p><p id="cfb93f39fdd200be46ebfeada7a0a690" class="ne-p"><span class="ne-text">②next(j) = 前序列相同元素个数 + 1；</span></p><p id="6df74f3284fc578a55db44c9c9f9d254" class="ne-p"><br></p><p id="fa5ee3ccca7aac454647436aa6cf105d" class="ne-p"><span class="ne-text">eg：当t = 6：</span></p><p id="9864edcb5890059cbb029dbc654018de" class="ne-p"><span class="ne-text">前面的序列为ababa，可以看出相同的子序列为aba，相同元素个数为3，所以next(6) = 3 + 1 = 4</span></p><p id="cf8a5f56ac58875441ad5b78ef1d2b3b" class="ne-p"><br></p><p id="c47cb9d84cbe7f19c89783788434f82b" class="ne-p"><span class="ne-text">注意：不能“全覆盖”，比如当j = 2时候，前面的a不能看成a = a序列，这样就变成next(2) = 2了；</span></p><h3 id="Lal6X"><span class="ne-text">计算next函数修正值</span></h3><div class="ne-quote"><p id="82c60e34e8efe5d73792a25711b26d07" class="ne-p"><span class="ne-text">（4）串“ababaabab”的nextval为（  ）。</span></p><p id="0d1e20f00ec873da884183137c074223" class="ne-p"><span class="ne-text">A．010104101      B．010102101      C．010100011       D．010101011  </span></p><p id="86fd109cdad34ea14d6272183b3be0c5" class="ne-p"><span class="ne-text">答案：A</span></p></div><p id="32422b3ed1271a846e5e6fb91bfc5c8c" class="ne-p"><br></p><table id="iFRJu" class="ne-table" style="width: 685px"><tbody><tr style="height: 33px"><td width="91"><p id="u0503555c" class="ne-p"><span class="ne-text">j</span></p></td><td width="58"><p id="uaffdd452" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="u948458ea" class="ne-p"><span class="ne-text">2</span></p></td><td width="67"><p id="ua15993c3" class="ne-p"><span class="ne-text">3</span></p></td><td width="67"><p id="u6fe61ea3" class="ne-p"><span class="ne-text">4</span></p></td><td width="67"><p id="ubb150015" class="ne-p"><span class="ne-text">5</span></p></td><td width="67"><p id="u4fe2041a" class="ne-p"><span class="ne-text">6</span></p></td><td width="67"><p id="u22de8214" class="ne-p"><span class="ne-text">7</span></p></td><td width="67"><p id="ue55b58a5" class="ne-p"><span class="ne-text">8</span></p></td><td width="67"><p id="ua381e01f" class="ne-p"><span class="ne-text">9</span></p></td></tr><tr style="height: 33px"><td width="91"><p id="ue40b085e" class="ne-p"><span class="ne-text">t</span></p></td><td width="58"><p id="ub14b7f38" class="ne-p"><span class="ne-text">a</span></p></td><td width="67"><p id="uf8d77d0a" class="ne-p"><span class="ne-text">b</span></p></td><td width="67"><p id="u5d6d9d21" class="ne-p"><span class="ne-text">a</span></p></td><td width="67"><p id="u8f3c9d6c" class="ne-p"><span class="ne-text">b</span></p></td><td width="67"><p id="ub23d82fe" class="ne-p"><span class="ne-text">a</span></p></td><td width="67"><p id="u84ef0982" class="ne-p"><span class="ne-text">a</span></p></td><td width="67"><p id="u71711152" class="ne-p"><span class="ne-text">b</span></p></td><td width="67"><p id="uabbd99d3" class="ne-p"><span class="ne-text">a</span></p></td><td width="67"><p id="ufdaa6f7c" class="ne-p"><span class="ne-text">b</span></p></td></tr><tr style="height: 33px"><td width="91"><p id="ue4f46a92" class="ne-p"><span class="ne-text">next(j)</span></p></td><td width="58"><p id="u0d72915c" class="ne-p"><span class="ne-text">0</span></p></td><td width="67"><p id="ua6e5fb83" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="ub71e39c2" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="u18bd8601" class="ne-p"><span class="ne-text">2</span></p></td><td width="67"><p id="uf56335fe" class="ne-p"><span class="ne-text">3</span></p></td><td width="67"><p id="u6c9e9845" class="ne-p"><span class="ne-text">4</span></p></td><td width="67"><p id="u84ac07b9" class="ne-p"><span class="ne-text">2</span></p></td><td width="67"><p id="u197bad17" class="ne-p"><span class="ne-text">3</span></p></td><td width="67"><p id="u3050e6c5" class="ne-p"><span class="ne-text">4</span></p></td></tr><tr style="height: 33px"><td width="91"><p id="ud1bcfa0a" class="ne-p"><span class="ne-text">nextval(j)</span></p></td><td width="58"><p id="u2935a6d0" class="ne-p"><span class="ne-text">0</span></p></td><td width="67"><p id="uca5f7fff" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="u8033274d" class="ne-p"><span class="ne-text">0</span></p></td><td width="67"><p id="u4018b298" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="ufda5b86c" class="ne-p"><span class="ne-text">0</span></p></td><td width="67"><p id="u623694a6" class="ne-p"><span class="ne-text">4</span></p></td><td width="67"><p id="u07718737" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="u24391151" class="ne-p"><span class="ne-text">0</span></p></td><td width="67"><p id="u320bd3a3" class="ne-p"><span class="ne-text">1</span></p></td></tr></tbody></table><p id="43418445725a8b1c9da02be97acc6eb0" class="ne-p"><br></p><p id="3e55a0781e7099dd7009a0f7d481b0c6" class="ne-p"><span class="ne-text">方法：</span></p><p id="2faf3d9586a9b0d8c5486e592d62e0f1" class="ne-p"><span class="ne-text">①先列举出next(j)，求nextval(j)是基于</span><span class="ne-text">next(j)的；</span></p><p id="ab7e86d247d92acbbf32773beaab474e" class="ne-p"><span class="ne-text">②</span><span class="ne-text">求nextval(j)，先看</span><span class="ne-text">求next(j)的值，记这个值为x；</span></p><p id="165ea6e5343f9d430222164c5bcf2f5f" class="ne-p"><span class="ne-text">③在表格中找出j = x的那一列，如果这一列的t值和②步骤中的t值相同，则结果为j = x这一列的</span><span class="ne-text">nextval(j)值，如果不相同，则结果为所要求的那一列的</span><span class="ne-text">next(j)值；</span></p><p id="3a0744062e0dcb3e16e2d6e3ca799b61" class="ne-p"><br></p><p id="7b1836d799fc31c6d255b45fcd52987d" class="ne-p"><span class="ne-text">eg：当j = 5时：</span></p><p id="5454822d50705ef65ed7c54c9e0d0234" class="ne-p"><span class="ne-text">此时next(j) = 3，就去j = 3那一列看到t = a，和j = 5一列的t值a相同，所以结果为j = 3一列的</span><span class="ne-text">nextval值0</span></p><p id="f88b11c1f0df00493a4fef31c0d174ab" class="ne-p"><br></p><p id="2e9d752cb16fedaf515563cf05ee8149" class="ne-p"><span class="ne-text">eg：当j = 6时：</span></p><p id="18e8aa25864872faa5c446d1bf786d16" class="ne-p"><span class="ne-text">此时next(j) = 4，就去j = 4那一列看到t = b，和j = 6一列的t值不相同，所以结果为j = 6一列的</span><span class="ne-text">next值4</span></p><h3 id="Vn5VN"><span class="ne-text">具体匹配情况</span></h3><div class="ne-quote"><p id="2bb2aa0c380cb029f331136f0bf95666" class="ne-p"><span class="ne-text">（2）设目标为t=“abcaabbabcabaacbacba”,模式为p=“abcabaa”</span></p><p id="93f6259891d767ae845e04e48379f217" class="ne-p"><span class="ne-text">① 计算模式p的naxtval函数值；</span></p><p id="52096b14ec8bfa95f285bd5cb9477dc3" class="ne-p"><span class="ne-text">② 不写出算法,只画出利用KMP算法进行模式匹配时每一趟的匹配过程。</span></p></div><p id="3e8c22d46292fd2da5b00fbae2e47a63" class="ne-p"><span class="ne-text">答案：</span></p><p id="004848556f2fb83956150623bee8d144" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620290726560-b77d1aa1-b7ed-4561-95b4-0e8f7e643ca9.png" width="361.5" id="cwWr7" class="ne-image"></p><h3 id="LGp3i"><span class="ne-text">代码</span></h3><pre data-language="cpp" id="pftag" class="ne-codeblock language-cpp">#include<bits/stdc++.h><p>using namespace std;<br>typedef int Status;<br>typedef int ElemType;<br>#define OVERFLOW -1<br>#define ERROR 0<br>#define OK 1</p><p>//——串的顺序存储结构—–<br>#define MAXLEN 225<br>typedef struct<br>{<br>char ch[MAXLEN + 1]; //存储串的一维数组，从下标为 1 的数组分量开始存储的，下标为 0 的分量闲置不用<br>int length; //串的当前长度<br>}SString;</p><p>//——串的堆式顺序存储结构—–<br>typedef struct<br>{<br>char *ch; //若是非空串，则按串长分配存储区，否则 ch 为 NULL<br>int length; //串的当前长度<br>}HString;</p><p>HString S, T;</p><p>//—–串的链式存储结构—–<br>#define CHUNKSIZE 80<br>typedef struct Chunk<br>{<br>char ch[CHUNKSIZE];<br>struct Chunk *next;<br>}Chunk;<br>typedef struct<br>{<br>Chunk *head, *tail; //串的头指针和尾指针<br>int length; //串的当前长度<br>}LString;</p><p>// //1、生成串<br>// StrAssign(&amp;T, chars)</p><p>// //2、复制<br>// StrCopy(&amp;T, S)</p><p>// //3、判空<br>// StrEmpty(S)</p><p>// //4、比较<br>// StrCompare(S, T)</p><p>// //5、长度<br>// StrLength(S)</p><p>// //6、清空<br>// ClearString(&amp;S)</p><p>// //7、联接<br>// Concat(&amp;T, S1, S2)</p><p>// //8、子串<br>// SubString(&amp;Sub, S, pos, len)</p><p>//9、串的模式匹配_BF 算法 O(n * m)<br>int Index_BF(HString S, HString T, int pos)<br>{//返回模式 T 在主串 s 中第 pos 个字符开始第一次出现的位置。若不存在，则返回值为 0<br>//其中，T 非空，1&lt;=pos&lt;=S.length<br>int i = pos, j = 1; //初始化<br>while(i &lt;= S.length &amp;&amp; j &lt;= T.length) //两串均未比较到串尾<br>{<br>if(S.ch[i] == T.ch[j]) //继续比较后继字符<br>{<br>i++;<br>j++;<br>}<br>else //指针后退重新开始匹配<br>{<br>i = i - j + 2; //i=i-j+1 回到 i 的起点，+2 到下一个字符<br>j = 1;<br>}<br>}<br>if(j &gt; T.length)<br>return i - T.length; //匹配成功，返回 T 在 S 中第一次出现的位置<br>else<br>return 0;<br>}</p><p>//9、串的模式匹配_KMP 算法求 next 数组<br>void get_next(HString, int next[])<br>{//求模式串 T 的 next 函数值并存入数组 next<br>int j = 1, t = 0;<br>next[1] = 0;<br>while(j &lt; T.length)<br>{<br>if(t == 0 || T.ch[j] == T.ch[t])<br>{<br>t++;<br>j++;<br>next[j] = t;<br>}<br>else<br>t = next[t];<br>}<br>}</p><p>//9、串的模式匹配_KMP 算法求 nextval 数组<br>void get_nextval(HString T, int nextval[])<br>{//求模式串 T 的 next 函数修正值并存入数组 nextval<br>int j = 1, t = 0;<br>nextval[1] = 0;<br>while(j &lt; T.length)<br>{<br>if(t == 0 || T.ch[j] == T.ch[t])<br>{<br>t++;<br>j++;<br>if(T.ch[j] != T.ch[t])<br>nextval[j] = t;<br>else<br>nextval[j] = nextval[t];<br>}<br>else<br>t = nextval[t];<br>}<br>}</p><p>//9、串的模式匹配_KMP 算法 O(n + m)<br>int Index_KMP(HString S, HString T, int pos, int next[])<br>{//利用模式串 T 的 next 函数求 T 在主串 S 中第 pos 个字符之后的位置<br>//其中，T 非空，1&lt;=pos&lt;=S.length<br>int i = pos, j = 1;<br>while(i &lt;= S.length &amp;&amp; j &lt;= S.length) //两个串均未比较到串尾<br>{<br>if(j == 0 || S.ch[i] == T.ch[i]) //继续比较后继字符<br>{<br>i++;<br>j++;<br>}<br>else<br>j = next[j]; //模式串向右移动<br>if(j &gt; T.length) //匹配成功<br>return i - T.length;<br>else<br>return 0;<br>}<br>}</p><p>// //10、插入<br>// Strlnsert(&amp;S, pos, T)</p><p>// //11、删除<br>// StrDelete(&amp;S, pos, len)</p><p>// //12、销毁<br>// DestroyString(&amp;S)</p><p></pre><p id="da6d9a983e14a866be04369afc52bbe6" class="ne-p"><br></p><p id="4e65f666b11f7a7d080ef5f05ae814ff" class="ne-p"><br></p><p id="5bba2de59a85e9d920e75a24bd65b86e" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🥢KMP类算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《文城》——我也曾是林详福</title>
      <link href="/essay/ll4lrz/"/>
      <url>/essay/ll4lrz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><div class="ne-quote"><p id="efd2f302b81a26e601cfbd82b34ad478" class="ne-p" style="text-align: left"><span class="ne-text">文城（《活着》作者余华时隔8年，全新长篇重磅归来。关于一个人和他一生的寻找，以及一群人和一个汹涌的年代。他原本不属于这里，但许多人的牵挂和眼泪都留在了他身上） (余华)</span></p></div><p id="a4685e7df874bb285abef683fb9c9c66" class="ne-p" style="text-align: left"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1620263368423-1137b0d5-338f-4b67-8710-05113a05e2cf.webp" width="245" id="q1Cav" class="ne-image"></p><p id="u05a7e443" class="ne-p" style="text-align: center"><br></p><div class="ne-quote"><p id="ud1c9376b" class="ne-p"><span class="ne-text">七月三号阅读小记</span></p></div><p id="bd63ffd0b27f153328c726f955c75da8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1625267396039-fd9ba6e0-3e18-4d2d-abf1-ac129db4ec64.png" width="1128" id="wN6zS" class="ne-image"></p><p id="da68bafe473eff9e0ca481a9669ed16e" class="ne-p"><br></p><p id="1d75b4248ebc31ca1eea816b9feb0063" class="ne-p"><br></p><p id="ua9b8fb9e" class="ne-p"><span class="ne-text"></span></p><p id="u4fea5143" class="ne-p"><span class="ne-text">- 您在位置 #275-277的标注 | 添加于 2021年4月28日星期三 下午2:27:12</span></p><p id="u5cc60fd1" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u53d58b19" class="ne-p"><span class="ne-text">她一边说一边笑，她的眼睛闪闪发亮，这是林祥福第一次见到小美这样的神态。一个在屋子里走动时只有木屐声响的女子，一个不会笑出声音而是将笑意含在嘴角的女子，此刻容光焕发了。</span></p></div><p id="u6596fcd9" class="ne-p"><span class="ne-text"></span></p><p id="u1ae7424c" class="ne-p"><span class="ne-text">- 您在位置 #289-289的标注 | 添加于 2021年4月28日星期三 下午2:29:19</span></p><p id="uf23a8556" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u74e7c20f" class="ne-p"><span class="ne-text">刚才屋顶被砸出的洞口纷纷落下来碗大的雨雹，砸到地上后犹如花开花谢。</span></p></div><p id="u31225aa6" class="ne-p"><span class="ne-text"></span></p><p id="u9ec716d1" class="ne-p"><span class="ne-text">- 您在位置 #330-330的标注 | 添加于 2021年4月28日星期三 下午2:33:05</span></p><p id="uaf1384c9" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u8d6dc744" class="ne-p"><span class="ne-text">“天下棺材七尺三。”</span></p></div><p id="ub564b13f" class="ne-p"><span class="ne-text"></span></p><p id="u0be77ed2" class="ne-p"><span class="ne-text">- 您在位置 #474-476的标注 | 添加于 2021年4月28日星期三 下午2:46:24</span></p><p id="uc419e439" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u636878f8" class="ne-p"><span class="ne-text">人生在世祸福难测，有一门技艺在身能够逢凶化吉，技艺是怎么也不会败落的。林祥福觉得自己的木工技艺应该更上一层楼，应该继续去拜师学艺。</span></p></div><p id="u6b786f38" class="ne-p"><span class="ne-text"></span></p><p id="ude3dae47" class="ne-p"><span class="ne-text">- 您在位置 #818-819的标注 | 添加于 2021年4月28日星期三 下午3:09:19</span></p><p id="u156cb9c7" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="ucafa1f0a" class="ne-p"><span class="ne-text">晚霞在明净的天空里燃烧般通红，岸上的田地里传来耕牛回家的哞哞叫声，炊烟正在袅袅升起。</span></p></div><p id="u91bbd27f" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『无间道』有感</title>
      <link href="/essay/ebd5c2/"/>
      <url>/essay/ebd5c2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-traditional" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B6%2C0%2C0%2C0%2C0%5D%2C%5B6%2C0%2C0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="d4cd9e0b7643b178590e5bd43190a698" id="d4cd9e0b7643b178590e5bd43190a698" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="p3dbG" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620262818767-a8f3dd82-2eb8-49c4-a240-42f1618ae335.png?x-oss-process=image%2Fresize%2Cw_1500" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="540px" style="visibility: visible; width: 960px;"></span></p><p data-lake-id="bca677546c40af316ec70d00c4f1f9aa" id="bca677546c40af316ec70d00c4f1f9aa" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="zT0rR" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620262714711-9a4e8bf0-56f2-4db0-9c48-9f05243e19e7.png?x-oss-process=image%2Fresize%2Cw_1500" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="540px" style="visibility: visible; width: 960px;"></span></p><p data-lake-id="c79d5e3f0a39dd702d986bafe1be8a08" id="c79d5e3f0a39dd702d986bafe1be8a08" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>上个礼拜看的，我觉得这无间道三部曲算是港片的鼻祖地位的，因为传神……</span></p><p data-lake-id="8d300c677e4a9086d7e65ebf9d38463f" id="8d300c677e4a9086d7e65ebf9d38463f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="9ecc208c16440d622ef7f65e4f3526b4" id="9ecc208c16440d622ef7f65e4f3526b4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>对刘建明和阿仁，我只想说，</span><strong><span>有的人死去，人已经解脱了，有的人，看似风生水起，实则，已堕入无间地狱</span></strong><span>。</span></p><p data-lake-id="16c080f51d5704ddb6a9b798aba0c519" id="9b8f43669e12798d79692411f0d6bccb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span><br></span></p><p data-lake-id="9b8f43669e12798d79692411f0d6bccb" id="9b8f43669e12798d79692411f0d6bccb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>还有一句“我只想做个好人”，初听之下就像是步入正途之下的光明大道，实则细想实在是</span><strong><span>鬼魅</span></strong><span>。</span></p><p data-lake-id="d52ffb5a5b0c766efccd5acbc29d2768" id="d52ffb5a5b0c766efccd5acbc29d2768" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c4f8147964b709abdb4fd363215884b1" id="c4f8147964b709abdb4fd363215884b1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="d52ca9bbaa3f79d34d3480ea1173d8ce" id="d52ca9bbaa3f79d34d3480ea1173d8ce" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这里面还有很多关于佛教的一些摘录，感觉很值得揣摩，在此摘录一番</span></p><p data-lake-id="3608c9450d75ee1469f27cdb481746ca" id="3608c9450d75ee1469f27cdb481746ca" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote class="lake-alert lake-alert-tips" style="margin: 0px; padding: 10px; border: 1px solid rgb(195, 195, 195); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(255, 246, 182);"><p data-lake-id="079ef868ca01f016b633a9ece7c10a0f" id="079ef868ca01f016b633a9ece7c10a0f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>《涅槃经》第十九卷</span></p><p data-lake-id="be0431b93590460a95a42c30827e15ca" id="be0431b93590460a95a42c30827e15ca" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>「八大地狱之最，称为无间地狱，为无间断遭受大苦大意，故有此名。」</span></p></blockquote><p data-lake-id="701037c1e65ccdb7be47ca7bb8536938" id="701037c1e65ccdb7be47ca7bb8536938" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote class="lake-alert lake-alert-tips" style="margin: 0px; padding: 10px; border: 1px solid rgb(195, 195, 195); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(255, 246, 182);"><p data-lake-id="a6b2b87526764897fbe9410ec967ac06" id="a6b2b87526764897fbe9410ec967ac06" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>「无间有三，时无间，空无间，受业无间。犯忤逆罪这永堕此界，尽受终极之无间。」</span></p></blockquote><p data-lake-id="72803a2d8e43b08ce33939c809250346" id="72803a2d8e43b08ce33939c809250346" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote class="lake-alert lake-alert-tips" style="margin: 0px; padding: 10px; border: 1px solid rgb(195, 195, 195); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(255, 246, 182);"><p data-lake-id="5d43979d9efd07864562fad132f591fc" id="5d43979d9efd07864562fad132f591fc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>地藏菩萨本愿经卷上：</span></p><p data-lake-id="3db11f1ff4abe3f5955ba94113b85e13" id="3db11f1ff4abe3f5955ba94113b85e13" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>「如是本辈，当堕无间地狱，千万亿劫，以此连绵，求出无期。」</span></p></blockquote><p data-lake-id="924afdb50df8e8613eb2e3d4133903fa" id="924afdb50df8e8613eb2e3d4133903fa" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="f54e3ce4ddf35bc041c2c155126a2caf" id="f54e3ce4ddf35bc041c2c155126a2caf" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="80e985baec561216ea9f5d5da324cf8c" id="80e985baec561216ea9f5d5da324cf8c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="jfQ8C" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620262755423-85be1e40-abd1-4879-abc5-94e82b6a913a.png?x-oss-process=image%2Fresize%2Cw_1500" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="540px" style="visibility: visible; width: 960px;"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『DARLING in the FRANXX』</title>
      <link href="/essay/lwgmc6/"/>
      <url>/essay/lwgmc6/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5D%2C%22active%22%3Atrue%7D"><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="eb20118c0862988d4b58e2f199067c2c" id="eb20118c0862988d4b58e2f199067c2c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>Darling in the FranXX （比翼之吻）</span></p></blockquote><p data-lake-id="5eff8955e6a6de7fb185315726afb2ce" id="5eff8955e6a6de7fb185315726afb2ce" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u1a39d7f3" id="u1a39d7f3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u7ed4fe23" id="u7ed4fe23" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这部番我觉得从世界观的角度来说构思很新奇，贯穿全篇则为——人性。</span></p><p data-lake-id="uaf01d3d1" id="uaf01d3d1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u1ee6b533" id="u1ee6b533" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>世界观颠覆了以往的人类美的一面，将人类的人格寄存于“爸爸”的手掌之下，欲望促使人类的人形暴露，但同时人性的一些闪光点，也在悄然萌发。</span></p><p data-lake-id="u12f8e672" id="u12f8e672" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u5969b72c" id="u5969b72c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>zero two和广的爱情，就像是我之前写的『缺爱』一篇，zero two的缺爱的极端时刻，被广的光辉所拯救了，成年之际，广的失意落魄被zero two口中的darling所拯救；</span></p><p data-lake-id="ue7fba2c8" id="ue7fba2c8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ufb130638" id="ufb130638" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>还有心的圣母形象，忘了对满的感情和生育的知识，这是我觉得这部番里面特别重要的一个点睛之笔。</span></p><p data-lake-id="uf464e2e7" id="uf464e2e7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ud4dbf13a" id="ud4dbf13a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>我们很难去理性的分析这些人物角色，但是贯穿这些的我想就是人性最为光辉的各个闪光点吧……</span></p><p data-lake-id="uc768b23e" id="uc768b23e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u109f29d8" id="u109f29d8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>转载一篇文章，片中几个机体的命名——对应的都是植物</span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="u3cf346f2" id="u3cf346f2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><a href="https://movie.douban.com/review/9225938/" target="_blank"><span>片中几个机体的命名——对应的都是植物</span></a></p></blockquote><p data-lake-id="ue098f2ad" id="ue098f2ad" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ub2673e7b" id="ub2673e7b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="u4f75054a" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619577542480-78f1ab01-405e-411c-ae14-537958ecf49e.jpeg" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="540px" style="visibility: visible; width: 960px;"></span></p><p data-lake-id="u417634c2" id="u417634c2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="e2c837ea6885adf42094dfcc56db1347" id="e2c837ea6885adf42094dfcc56db1347" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="QP1th" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619485267464-dd9642d5-df67-4a97-8419-8e5fc3a709a9.png" data-raw-src="" class="image lake-drag-image" alt="85308871_p0.png" title="85308871_p0.png" data-height="1200px" style="visibility: visible; width: 1600px;"></span></p><p data-lake-id="2afb306203f11e865bca119dc4559b91" id="2afb306203f11e865bca119dc4559b91" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="U6MD4" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619485230506-60d08215-4e79-42cb-9ba0-d3b5681edec4.png" data-raw-src="" class="image lake-drag-image" alt="87980648_p0.png" title="87980648_p0.png" data-height="1261px" style="visibility: visible; width: 2000px;"></span></p><p data-lake-id="8cf5c9ef0277f37b37cd611a58909e65" id="8cf5c9ef0277f37b37cd611a58909e65" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="LdgD5" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619485170602-d19ab096-b1e2-4001-a419-4e1cc1c5a8ba.jpeg" data-raw-src="" class="image lake-drag-image" alt="87883532_p0.jpg" title="87883532_p0.jpg" data-height="1040px" style="visibility: visible; width: 700px;"></span></p><p data-lake-id="f30b58723d2340e5ff523deac5fc5904" id="f30b58723d2340e5ff523deac5fc5904" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="Y2Du1" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619485191278-d20ca434-1141-41f5-a73e-db7b54f34d4e.png?x-oss-process=image%2Fresize%2Cw_2000" data-raw-src="" class="image lake-drag-image" alt="87324495_p0.png" title="87324495_p0.png" data-height="5000px" style="visibility: visible; width: 3000px;"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《平凡的世界》有感</title>
      <link href="/essay/hhd57l/"/>
      <url>/essay/hhd57l/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="863f517155e0cf66b43d8d543437e9a1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622032253532-9007acd3-e5c9-4e15-9839-7412bf52d680.jpeg" width="350" id="gdmS8" class="ne-image"></p><p id="u9ec3384d" class="ne-p" style="text-align: left"><span class="ne-text">平凡的世界（路遥著长篇小说）</span></p><hr id="jWCqK" class="ne-hr"><p id="ueda912e9" class="ne-p"><span class="ne-text">21.06.12</span></p><p id="ua1a33424" class="ne-p"><span class="ne-text"></span></p><p id="uc053d937" class="ne-p"><span class="ne-text">经历了一件事，心碎。</span></p><p id="udcaa575c" class="ne-p"><span class="ne-text">今天的我懂得到什么叫成长，就像最后的少平那样，笔直地走向那条铁路，坚毅，成长……</span></p><p id="u98966ebf" class="ne-p"><span class="ne-text"></span></p><p id="u91c377bd" class="ne-p"><span class="ne-text">“少平，你要记得，你与其他人不一样，你是一个有另外世界的人，你的心不应该只在这，而是在远方，那个充满光的地方”</span></p><p id="u0fd6aeb5" class="ne-p"><span class="ne-text"></span></p><p id="u3204451d" class="ne-p"><span class="ne-text">这话湿了眼眶……</span></p><p id="u4f212593" class="ne-p" style="text-align: left"><br></p><hr id="nqvgI" class="ne-hr"><p id="ue48eb825" class="ne-p" style="text-align: left"><span class="ne-text">21.02.21号整理家里书架时候写的</span></p><p id="593a8a6d23a9a70a8856487c01c855c3" class="ne-p"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619483066100-b7e6b34c-9232-4dda-859f-02f28ceec07c.jpeg" width="1125" id="fX4yb" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我变了吗？</title>
      <link href="/essay/ogyb5h/"/>
      <url>/essay/ogyb5h/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>应用层及网络应用万维网的HTTP协议</title>
      <link href="/blog/re05fo/"/>
      <url>/blog/re05fo/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="eglYS"><span class="ne-text">为什么需要应用层呢？</span></h2><p id="d5104f7caada438423b3717ef9b93288" class="ne-p"><span class="ne-text">应用层的上一层，也就是传输层其实就已经搭建好了传输信息的框架，但是为什么还需要应用层这一层，因为</span><strong><span class="ne-text">传输层传的太简单，只实现我给你传过去，不全面有不足之处，用课上老师的话说，各层的宗旨就是尽力而为，举一些传输层心有余而力不足的地方：</span></strong></p><ul class="ne-ul"><li id="0acc0f7570b3c0e5417a75fdeb9e6983"><span class="ne-text">客户端发送的是什么数据类型的文件</span></li><li id="581acc4506fb6a8a75f799fbb1dcd879"><span class="ne-text">数据的长度，传输一次的数据长度为多长，一次是否传得完？什么时候传完？（TCP的流量控制）</span></li><li id="3129068ecf6d9fd8d743db5437703910"><span class="ne-text">数据的压缩方式，服务端如何知道客户端对数据是否压缩抑或是压缩算法是什么？</span></li></ul><p id="a3ae40530a1423eca58fa2142460cd8c" class="ne-p"><br></p><p id="303a98500a5374d068fe268e5fa1a103" class="ne-p"><span class="ne-text">而对于上述三个问题，在应用层给出相应的解决方案：</span></p><p id="a085c8e41d589ed87ec5c51ef626824e" class="ne-p"><br></p><ul class="ne-ul"><li id="8d28769a5e009a3b99805b3c8b1a2ffa"><span class="ne-text">数据的类型，HTTP Header： Content-Type</span></li><li id="5dd888b6b68aaa859ca36dc9b7f38b0a"><span class="ne-text">数据的长度，HTTP Header： Content-Length</span></li><li id="f463ad19d58db7e42f4d3e370230935e"><span class="ne-text">数据的压缩方式，HTTP Header： Accept-Encoding</span></li></ul><h2 id="0LSKV"><span class="ne-text">搞清互联网和万维网主次</span></h2><p id="848f8e181e1e1eae9e4e449f6653ce70" class="ne-p"><span class="ne-text">之前上课的时候，这里一直被忽视了，有一个主次概念需要搞清楚，</span><strong><span class="ne-text">万维网（WWW）是一个网络应用，万维网应用是一种基于客户/服务器体系结构的网络应用</span></strong><span class="ne-text">『应用层的协议都是基于客户服务器方式的，即便是P2P对等通信方式，实质上也是一种特殊的客户服务器方式』</span><strong><span class="ne-text">，它是一个网络应用</span></strong><span class="ne-text">，相应地，在互联网里面，还有</span><span class="ne-text">文件传输（FTP)、电子邮件E-mail、远程登录（Telnet）等这些应用。</span><span class="ne-text">所以引用对互联网还可以说成：</span><strong><span class="ne-text">是线路、协议以及通过TCP/IP协议实现数据电子传输的硬件和软件的集合体</span></strong><span class="ne-text">。</span></p><p id="3531571023b1a92a57dce45c234d1255" class="ne-p"><br></p><p id="476b67a110c81401bc82687c6403de7c" class="ne-p"><span class="ne-text">万维网这个应用还包括一些部件：万维网浏览器，万维网服务器，玩万维网文档的格式标准，以及一个应用层协议等等，这样就将HTTP的来源就串起来了。</span></p><p id="ee7d7d54ab30969e56b58a92dba75cd4" class="ne-p"><br></p><p id="dbf21727037776ed88af3faca6d22fa1" class="ne-p"><span class="ne-text">理解了主次，再从“主”依次理解“次”</span></p><ul class="ne-ul"><li id="95736441e5fb2ac7a2376f56c0fd96c8"><span class="ne-text">先理解许多应用协议都要使用的</span><strong><span class="ne-text">域名系统（DNS）</span></strong><span class="ne-text">，这是基础中的基础</span></li><li id="29c5e23d4350feeebdbf9855ddb1fc82"><span class="ne-text">文件传送协议：具体应用就是云主机的使用吧</span></li></ul><p id="38be84c954a2fc5689252b2c4789bac5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618625750527-7aa85753-4d61-4400-8e86-f8f2c6ae0c41.png" width="109.5" id="YCaOz" class="ne-image"></p><ul class="ne-ul"><li id="46d301d7daca1ec195ae686bc312aebf"><span class="ne-text">远程登录协议：书上只讲了TELNET，具体应用XSHELL的SSH也是</span></li></ul><p id="e842d4a8b93c9e9a6d104ddab2d12ed8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618625847438-b61068f8-a3d5-43b0-8cd3-eefb3aeac42d.png" width="100" id="koiBy" class="ne-image"></p><ul class="ne-ul"><li id="0b6e902c07b0f45cfb86072d27c2b6c9"><strong><span class="ne-text">万维网及其主要协议</span></strong></li><li id="cd7e73deb034be478e6f4cfe0e1b93aa"><span class="ne-text">电子邮件</span></li></ul><p id="325eec7049007d74b9561c42a059b958" class="ne-p"><br></p><h2 id="w9vSY"><span class="ne-text">万维网是什么？有什么用？</span></h2><div class="ne-quote"><p id="12b962bab78cc1e96e78ac77f5f8e1c8" class="ne-p"><span class="ne-text">用课本的概念：万维网用链接的方式能非常方便地从互联网上的一个站点访问另一个站点（也就是所谓的“链接到另一个站点”），从而主动地按需获取丰富的信息。</span></p></div><p id="7c40e2993f984315240eabd2e49c851f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618626263044-e610396b-b7b5-4f11-a8f5-1499f0f7f5d8.png" width="477.5" id="BPTJ3" class="ne-image"></p><p id="c08afff16b15c0cce9ba8d6d667dddb0" class="ne-p"><span class="ne-text">要达到这样的构想，架构这样的系统需要解决哪些问题呢？</span></p><p id="06bc65dea7d96591f5d96b2b8c2805e2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618626404243-cf649c67-a499-46a3-a163-aad61a17c9b7.png" width="566" id="Gmaxj" class="ne-image"></p><ol class="ne-ol"><li id="13007b271ad66e84aed1f7a3b4236cc4"><span class="ne-text">利用URL</span></li><li id="46cfaf4c592f52c7ad765c16131ed883"><span class="ne-text">HTTP协议（基于TCP）</span></li><li id="6fb27a72523914ff0a353ce10907758a"><span class="ne-text">HTML：就是超文本标记语言，这里不再赘述</span></li><li id="252dfb874897ae120ce37fd620e81382"><span class="ne-text">搜索工具：搜索引擎工具，谷歌、百度……</span></li></ol><h2 id="to7JS"><span class="ne-text">HTTP协议</span></h2><h3 id="8aJXI"><span class="ne-text">HTTP的报文结构</span></h3><p id="2fb36cdb73dc4719227c4f15a619568b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618626839900-2a58c82a-1c27-427e-a902-6b21e3458b12.png" width="429" id="V2nrj" class="ne-image"></p><h3 id="L5msE"><span class="ne-text">请求报文实例</span></h3><p id="0c0b60cf6a71a91b10300cbbe9fe07ac" class="ne-p"><span class="ne-text">请求行中的方法，就是对所请求对象进行的操作，具体有以下一些方法：</span></p><p id="5a338f15ca4935a54a9d36cdc6df0fe7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627091156-cd978f06-4e39-41ea-9652-0ceddab98bb7.png" width="341" id="zSrHY" class="ne-image"></p><p id="1543b18fe99a0e5f4f64804fcdcd28b3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627123440-4ed5d351-96a7-4228-a9fe-aaff7e5bb9e2.png" width="474.5" id="crkmI" class="ne-image"></p><p id="e14d60dd756dc70e202c5479b323a164" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627710005-1577f282-ff85-4fd2-a6ae-51187928044e.png" width="442.5" id="sW7Mj" class="ne-image"></p><p id="123d8d70ed726a26db301addb5a6c6af" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627722921-07c819d7-b873-4644-8cb0-844ff27450d0.png" width="414" id="w3y6P" class="ne-image"></p><p id="12b86c7270c3e6472753afa85275a373" class="ne-p"><span class="ne-text">具体在浏览器的显示为：</span></p><p id="e054b5c596e564117ba8aedd01f6ed3e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627622010-49ba1876-a555-41a6-85b6-f23bc458ac82.png" width="624" id="mlIDO" class="ne-image"></p><p id="6f64df2c40ae71196368903404adfb29" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627640727-1204203a-4f3e-4fff-a388-fa47224fd7a0.png" width="618.5" id="DJDi5" class="ne-image"></p><h3 id="4nTpJ"><span class="ne-text">本地存储和Cookie</span></h3><p id="95a70d5098ff005a5099ad0291933f6b" class="ne-p"><span class="ne-text">自己搭建个人网站的时候，有这么一个功能，</span></p><p id="842ad0d38510d250834aed05aab39b3e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627885598-f7d86695-ab4b-47b1-84de-1f7131daf095.png" width="960" id="LcLA1" class="ne-image"></p><p id="9a8e21d715e2818bbe49ce1861e221d1" class="ne-p"><span class="ne-text">对用户在本地浏览器里面点击这个伸缩布局按钮，下一次再打开网站，浏览器会记住这个布局，我是使用的localSession这个对象方法，因为是静态网站，这样实现还是比较友好的</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618628002219-e1725906-d456-4930-bba7-cc800938c02f.png" width="960" id="sVhQJ" class="ne-image"></p><p id="370b9b001740e9c98903fa9bfb647684" class="ne-p"><span class="ne-text">这是静态站点使用的友好方式，比较灵活的还有Cookie方式，特别是在动态网站的搭建过程中。</span></p><p id="00cabe344e8430db30acf5ec4a56db79" class="ne-p"><span class="ne-text">在Node.js框架Express里面利用“</span><span class="ne-text">express-session</span><span class="ne-text">”插件来使用Cookie。</span></p><p id="95cf757c966b97a1bb048ed21b7ca9c9" class="ne-p"><br></p><ul class="ne-ul"><li id="61cf0bad5bbc5b0da962c4418ac4e03b"><span class="ne-text">Cookie会记录客户端和服务端之间的信息</span></li><li id="d01cdf4dafe2204a182ecc1eed464ff5"><span class="ne-text">每次请求都会默认携带Cookie</span></li><li id="a6254f43bc5f5055478aea9d23a90bfc"><span class="ne-text">会被加密，安全</span></li></ul><p id="dd068003f7ac215177018bb30fd03783" class="ne-p"><span class="ne-text">关于安全问题，课本上的表述是这样的：</span></p><p id="4a2c4cec13e5c675a3beac303246bb7b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618628510004-3df5120d-f238-4a6c-9dc8-e9c803283163.png" width="465.5" id="hPBY6" class="ne-image"></p><p id="491b384fb9c7fc0225367cde0910181a" class="ne-p"><br></p><h2 id="59BBL"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="fb3d200ff22f63429e8f4ddfe04cddff"><span class="ne-text">《计算机网络》第7版——谢希仁</span></li><li id="6679e4b30fd24962320d3ace093d7526"><a href="https://www.html.cn/qa/other/21226.html" data-href="https://www.html.cn/qa/other/21226.html" target="_blank" class="ne-link"><span class="ne-text">万维网和互联网的区别是什么？</span></a></li><li id="c5f068bcea7d8b66f2fd8474f1248623"><a href="https://www.zhihu.com/question/368324676/answer/988997873" data-href="https://www.zhihu.com/question/368324676/answer/988997873" target="_blank" class="ne-link"><span class="ne-text">为什么需要，以及如何设计应用层协议？</span></a></li><li id="fd5da6f3aeb1a5557fc24e6d3c75a7a4"><a href="https://blog.csdn.net/u010076558/article/details/17620719" data-href="https://blog.csdn.net/u010076558/article/details/17620719" target="_blank" class="ne-link"><span class="ne-text">几种远程控制协议</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验4——超市排队机🔖队列</title>
      <link href="/blog/zgiaxv/"/>
      <url>/blog/zgiaxv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="20T4y"><span class="ne-text">实验任务</span></h2><p id="9f9b98eac38d19e538b42d7746c04a9f" class="ne-p"><span class="ne-text">    实验4：队列的链式表示和实现</span></p><p id="7f5ef7b6fb7c14232a9d0715d945ae8e" class="ne-p"><span class="ne-text">    要求：某小超市有两个排队机，构建2个用带头结点的单链表队列QA和QB, 实现下列操作</span></p><p id="61513287fe3e2922bdd79107f0ef3355" class="ne-p"><span class="ne-text">        1、初始化队列(清空)；</span></p><p id="e318417a78d41bdc35b2fb51fea54408" class="ne-p"><span class="ne-text">        2、入队；</span></p><p id="66ab82335f33a8cb72f8a7d37f44777b" class="ne-p"><span class="ne-text">        3、出队;</span></p><p id="c16c943dd4288a72dd6b295bfa0377bf" class="ne-p"><span class="ne-text">        4、求队列长度；</span></p><p id="10fe96031b21a32c13c6097ae020e25f" class="ne-p"><span class="ne-text">        5、判断队列是否为空；</span></p><p id="ae0a391b09cffe7a9126f70818e56eda" class="ne-p"><span class="ne-text">        6、判断队列是否为满；</span></p><p id="9e5d1dae28859a8abeca1d0471446006" class="ne-p"><span class="ne-text">        7、对于队列QA和QB，如果其中一个队列的售货员下班，则自动甩到另一个队列后面。</span></p><p id="5e9cc15a80111b6a597cc9e255190af3" class="ne-p"><span class="ne-text">截止日期：4月22日</span></p><p id="u7db2feae" class="ne-p"><span class="ne-text"></span></p><h2 id="14MhD"><span class="ne-text">实验讨论</span></h2><p id="2e010ce1f965a4edb43b07e76023f987" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="87dfb2648de3a04b1bf58824421fe863" class="ne-p"><span class="ne-text">觉得问题里面有bug</span></p></div><p id="06843150f7061a5692c3cab91b34abaf" class="ne-p"><br></p><p id="d94608e0b1b127fba7a074eb3c24a11b" class="ne-p"><span class="ne-text">对问题判满的疑惑与解决，第六个问题对链对判满是否有意义，如果是链式存储，数据结构本身判断满没有意义，但是考虑到是小型超市，超市空间不大，所以对其进行一开始的用户自己输入两个队列的最大长度。</span></p><p id="b46ce36306c0795c661082ae93333276" class="ne-p"><br></p><p id="d1dc74f717ac959b4fe6f310f217fb61" class="ne-p"><span class="ne-text">但是这样又有一个问题，在问题7中，如果一个队列的售货员下班了，这个队列的所有人排到另一个队列中，那如果新队列的长度超出用户输入的队列最大长度呢？考虑到实际问题，这个问题不打算解决了，让他们挤挤……</span></p><h2 id="yLU1H"><span class="ne-text">代码代码</span></h2><pre data-language="cpp" id="wFMVW" class="ne-codeblock language-cpp">#include<bits/stdc++.h><p>using namespace std;</p><p>typedef int Status;<br>typedef int QElemType;</p><p>#define OVERFLOW -1<br>#define ERROR 0<br>#define OK 1</p><p>/**<br>实验 4：队列的链式表示和实现<br>要求：某小超市有两个排队机，构建 2 个用带头结点的单链表队列 QA 和 QB, 实现下列操作<br>1、初始化队列(清空)；<br>2、入队；<br>3、出队;<br>4、求队列长度；<br>5、判断队列是否为空；<br>6、判断队列是否为满；<br>7、对于队列 QA 和 QB，如果其中一个队列的售货员下班，则自动甩到另一个队列后面。</p><p>*/</p><p>/_ 存储形式 _/<br>typedef struct QNode{ //链队用的结点<br>QElemType data;<br>struct QNode *next;<br>}QNode,*QueuePtr;</p><p>typedef struct {<br>QueuePtr front;<br>QueuePtr rear;<br>}LinkQueue;</p><p>/_ 初始化 _/<br>Status InitQueue(LinkQueue &amp;queue) {<br>queue.front = queue.rear = new QNode;<br>queue.front-&gt;next = NULL;<br>return OK;<br>}</p><p>/_ 求队列长度 _/<br>Status QueueLength(LinkQueue &amp;queue) {<br>int count = 0;<br>if (queue.rear == queue.front) {<br>return count;<br>}<br>QueuePtr temp = queue.front;<br>while (temp != queue.rear) {<br>count++;<br>temp = temp-&gt;next;<br>}<br>return count;<br>}</p><p>/_ 入队 _/<br>Status EnQueue(LinkQueue &amp;queue, QElemType e, int length) {<br>if (QueueLength(queue) &lt;length) {<br>QueuePtr temp = new QNode;<br>temp-&gt;data = e;<br>temp-&gt;next = NULL;<br>queue.rear-&gt;next = temp;<br>queue.rear = temp;<br>return OK;<br>} else {<br>cout &lt;&lt; “队已经满了，不能再入元素了”&lt;&lt; “\n”;<br>return ERROR;<br>}<br>}</p><p>/_ 出队 _/<br>Status DeQueue(LinkQueue &amp;queue) {<br>if (queue.front == queue.rear) {<br>return OVERFLOW;<br>}<br>// 有必要定义一个 p，不然头结点会掉<br>QueuePtr p = queue.front-&gt;next;<br>QElemType e = p-&gt;data;<br>queue.front-&gt;next = p-&gt;next;<br>// 考虑最后一个元素被删，队尾指针指向头结点<br>if (queue.rear == p) {<br>queue.rear = queue.front;<br>}<br>return e;<br>}</p><p>/_ 取队头元素 _/<br>// Status GetHead(LinkQueue &amp;queue) {<br>// if (queue.front != queue.rear){<br>// return queue.front-&gt;next-&gt;data;<br>// }<br>// }</p><p>/_ 判断队列是否为空 _/<br>bool QueueIsEmpty(LinkQueue &amp;queue) {<br>if (queue.rear == queue.front) {<br>return true;<br>} else {<br>return false;<br>}<br>}</p><p>/**</p><ul><li>判断队列是否为满</li><li>不是很理解为什么链队需要判断是否为满呢？</li><li>采用输入链队长度，利用链队函数来判断</li><li>那么入队的代码需要输入 length 参数来判断是否还能让元素入队<br>*/<br>bool QueueIsFull(LinkQueue &amp;queue, int length) {<br>if (QueueLength(queue) == length) {<br>return true;<br>} else {<br>return false;<br>}<br>}</li></ul><p>/_ 一个队列甩到另一个队列 _/<br>Status QueueMove(LinkQueue &amp;queue_delete,LinkQueue &amp;queue_add) {<br>queue_add.rear-&gt;next = queue_delete.front-&gt;next;<br>queue_add.rear = queue_delete.rear;<br>return OK;<br>}</p><p>/_ 遍历查看队列元素 _/<br>Status DisplayQueue(LinkQueue &amp;queue) {<br>LinkQueue L = queue;<br>while (L.front-&gt;next != NULL) {<br>cout &lt;&lt; L.front-&gt;next-&gt;data &lt;&lt; “ “;<br>L.front = L.front-&gt;next;<br>}<br>cout &lt;&lt; “\n”;<br>return OK;<br>}</p><p>int main() {</p><pre><code>cout&lt;&lt;&quot;------------------------链队菜单----------------------&quot;&lt;&lt;&#39;\n&#39;;cout&lt;&lt;&quot;操作0：退出程序&quot;&lt;&lt;&#39;\n&#39;;cout&lt;&lt;&quot;操作1：初始化两队列&quot;&lt;&lt;&#39;\n&#39;;cout&lt;&lt;&quot;操作2：入队操作&quot;&lt;&lt;&#39;\n&#39;;cout&lt;&lt;&quot;操作3：出队操作&quot;&lt;&lt;&#39;\n&#39;;cout&lt;&lt;&quot;操作4：判断判断链队是否为空&quot;&lt;&lt;&#39;\n&#39;;cout&lt;&lt;&quot;操作5：判断判断链队是否为满&quot;&lt;&lt;&#39;\n&#39;;cout&lt;&lt;&quot;操作6：售货员偷懒选项&quot;&lt;&lt;&#39;\n&#39;;cout&lt;&lt;&quot;操作7：查看队列&quot;&lt;&lt;&#39;\n&#39;;cout&lt;&lt;&quot;操作8：求队列长度&quot;&lt;&lt;&#39;\n&#39;;cout&lt;&lt;&quot;--------------------------------------------------------&quot;&lt;&lt;&#39;\n&#39;;int a, length,flag = 1;cout &lt;&lt; &quot;请输入你希望排队机最多能排的人数：&quot;&lt;&lt;&quot;\n&quot;&lt;&lt;&quot;\n&quot;;cin &gt;&gt; length;LinkQueue QA,QB;while(flag)&#123;    cout&lt;&lt;&#39;\n&#39;&lt;&lt;&quot;请选择要执行的操作：&quot;;    while(cin&gt;&gt;a)    &#123;        if(a &lt; 0 || a &gt; 8)            cout&lt;&lt;&quot;请选择正确操作编号：&quot;;        else            break;    &#125;    switch(a)    &#123;        case 0:        &#123;            cout&lt;&lt;&quot;正在退出程序中……&quot;&lt;&lt;&#39;\n&#39;;            flag = 0;            break;        &#125;        case 1:        &#123;            cout&lt;&lt;&quot;初始化QA、QB队列中……&quot;&lt;&lt;&#39;\n&#39;;            InitQueue(QA);            InitQueue(QB);            break;        &#125;        case 2:        &#123;            cout&lt;&lt;&quot;请输入入队的队列（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;            int select_queue;            cin &gt;&gt; select_queue;            if (select_queue == 1) &#123;                cout&lt;&lt;&quot;请输入入QA队的队列的元素&quot;&lt;&lt;&#39;\n&#39;;                int select_queue_A;                cin &gt;&gt; select_queue_A;                EnQueue(QA, select_queue_A, length);            &#125; else if (select_queue == 2) &#123;                cout&lt;&lt;&quot;请输入入QB队的队列的元素&quot;&lt;&lt;&#39;\n&#39;;                int select_queue_B;                cin &gt;&gt; select_queue_B;                EnQueue(QB, select_queue_B, length);            &#125; else &#123;                cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;            &#125;            break;        &#125;        case 3:        &#123;            cout&lt;&lt;&quot;请输入需要出队的队列（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;            int select_queue;            cin &gt;&gt; select_queue;            if (select_queue == 1) &#123;                DeQueue(QA);            &#125; else if (select_queue == 2) &#123;                DeQueue(QB);            &#125; else &#123;                cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;            &#125;            break;        &#125;        case 4:        &#123;            cout&lt;&lt;&quot;请输入需要判空的队列（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;            int select_queue;            cin &gt;&gt; select_queue;            if (select_queue == 1) &#123;                cout &lt;&lt; &quot;QA队列为空吗？&quot;&lt;&lt; boolalpha &lt;&lt; QueueIsEmpty(QA) &lt;&lt; &quot;\n&quot;;            &#125; else if (select_queue == 2) &#123;                cout &lt;&lt; &quot;QB队列为空吗？&quot;&lt;&lt; boolalpha &lt;&lt; QueueIsEmpty(QB) &lt;&lt; &quot;\n&quot;;            &#125; else &#123;                cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;            &#125;            break;        &#125;        case 5:        &#123;            cout&lt;&lt;&quot;请输入需要判满的队列（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;            int select_queue;            cin &gt;&gt; select_queue;            if (select_queue == 1) &#123;                cout &lt;&lt; &quot;QA队列为满吗？&quot;&lt;&lt; boolalpha &lt;&lt; QueueIsFull(QA,length) &lt;&lt; &quot;\n&quot;;            &#125; else if (select_queue == 2) &#123;                cout &lt;&lt; &quot;QB队列为满吗？&quot;&lt;&lt; boolalpha &lt;&lt; QueueIsFull(QB,length) &lt;&lt; &quot;\n&quot;;            &#125; else &#123;                cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;            &#125;            break;        &#125;        case 6:        &#123;            cout&lt;&lt;&quot;请输入下班的售货员（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;            int select_queue;            cin &gt;&gt; select_queue;            if (select_queue == 1) &#123;                QueueMove(QA, QB);            &#125; else if (select_queue == 2) &#123;                QueueMove(QB, QA);            &#125; else &#123;                cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;            &#125;            break;        &#125;        case 7:        &#123;            cout&lt;&lt;&quot;请输入要查看的队列（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;            int select_queue;            cin &gt;&gt; select_queue;            if (select_queue == 1) &#123;                DisplayQueue(QA);            &#125; else if (select_queue == 2) &#123;                DisplayQueue(QB);            &#125; else &#123;                cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;            &#125;            break;        &#125;        case 8:        &#123;            cout&lt;&lt;&quot;请输入要查看的队列的长度（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;            int select_queue;            cin &gt;&gt; select_queue;            if (select_queue == 1) &#123;                cout&lt;&lt;QueueLength(QA)&lt;&lt; &quot;\n&quot;;            &#125; else if (select_queue == 2) &#123;                cout&lt;&lt;QueueLength(QB)&lt;&lt; &quot;\n&quot;;            &#125; else &#123;                cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;            &#125;            break;        &#125;    &#125;&#125;</code></pre><p>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++队列顺序和链式实现及操作</title>
      <link href="/blog/fbfgft/"/>
      <url>/blog/fbfgft/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="noBws"><span class="ne-text">顺序循环队列</span></h2><p id="u38c4a437" class="ne-p"><br></p><pre data-language="cpp" id="YuxfO" class="ne-codeblock language-cpp">#include<bits/stdc++.h><p>using namespace std;</p><p>typedef int Status;<br>typedef int QElemType;</p><p>#define OVERFLOW -1<br>#define ERROR 0<br>#define OK 1<br>#define MAXSIZE 100</p><p>/**</p><ul><li>循环队列——队列的顺序表示和实现</li><li></li><li>操作：初始化、队列长度、入队、出队、取队头元素<br>*/</li></ul><p>/_ 存储形式 _/<br>typedef struct {<br>QElemType *base;<br>int front;<br>int rear;<br>} SqQueue;</p><p>/_ 初始化 _/<br>Status InitQueue(SqQueue &amp;queue) {<br>// 初始化这个 base 地址为一个有最大容量的数组初地址<br>queue.base = new int[MAXSIZE];<br>if (!queue.base) {<br>return OVERFLOW;<br>}<br>queue.front = queue.rear = 0;<br>return OK;<br>}</p><p>/_ 求队列长度 _/<br>Status QueueLength(SqQueue &amp;queue) {<br>return (queue.rear - queue.front + MAXSIZE) % MAXSIZE;<br>}</p><p>/_ 入队 _/<br>Status EnQueue(SqQueue &amp;queue, QElemType e) {<br>if ((queue.rear+1)%MAXSIZE == queue.front) {<br>return OVERFLOW;<br>}<br>queue.base[queue.rear] = e;<br>queue.rear = (queue.rear + 1) % MAXSIZE;<br>return OK;<br>}</p><p>/_ 出队 _/<br>Status DeQueue(SqQueue &amp;queue) {<br>if ((queue.rear+1)%MAXSIZE == queue.front) {<br>return OVERFLOW;<br>}<br>QElemType e = queue.base[queue.front];<br>queue.front = (queue.front + 1) % MAXSIZE; //队头指针+1<br>return e;<br>}</p><p>/_ 取队头元素 _/<br>Status GetHead(SqQueue &amp;queue) {<br>if (queue.front != queue.rear) {<br>return queue.base[queue.front];<br>}<br>}</p><p>int main() {<br>SqQueue test;<br>InitQueue(test);<br>EnQueue(test, 10);<br>EnQueue(test, 15);<br>EnQueue(test, 20);<br>cout &lt;&lt; “队列长度为：” &lt;&lt; QueueLength(test) &lt;&lt; “\n”;<br>cout &lt;&lt; GetHead(test)&lt;&lt;” “&lt;&lt; GetHead(test)&lt;&lt;” “&lt;&lt; GetHead(test)&lt;&lt;” “&lt;&lt;”\n”;<br>cout &lt;&lt; DeQueue(test)&lt;&lt;” “&lt;&lt; DeQueue(test)&lt;&lt;” “&lt;&lt; DeQueue(test)&lt;&lt;” “&lt;&lt;”\n”;<br>}</pre><h2 id="ntYcn"><span class="ne-text">链队</span></h2><pre data-language="cpp" id="K9aYb" class="ne-codeblock language-cpp">#include<bits/stdc++.h><br>using namespace std;</p><p>typedef int Status;<br>typedef int QElemType;</p><p>#define OVERFLOW -1<br>#define ERROR 0<br>#define OK 1<br>#define MAXSIZE 100</p><p>/**</p><ul><li>链队——队列的链式表示和实现</li><li></li><li>操作：初始化、入队、出队、取队头元素<br>*/</li></ul><p>/_ 存储形式 _/<br>typedef struct QNode{ //链队用的结点<br>QElemType data;<br>struct QNode *next;<br>}QNode,*QueuePtr;</p><p>typedef struct {<br>QueuePtr front;<br>QueuePtr rear;<br>}LinkQueue;</p><p>/_ 初始化 _/<br>Status InitQueue(LinkQueue &amp;queue) {<br>queue.front = queue.rear = new QNode;<br>queue.front-&gt;next = NULL;<br>return OK;<br>}</p><p>/_ 入队 _/<br>Status EnQueue(LinkQueue &amp;queue, QElemType e) {<br>QueuePtr temp = new QNode;<br>temp-&gt;data = e;<br>temp-&gt;next = NULL;<br>queue.rear-&gt;next = temp;<br>queue.rear = temp;<br>return OK;<br>}</p><p>/_ 出队 _/<br>Status DeQueue(LinkQueue &amp;queue) {<br>if (queue.front == queue.rear) {<br>return OVERFLOW;<br>}<br>QElemType e = queue.front-&gt;next-&gt;data;<br>queue.front-&gt;next = queue.front-&gt;next-&gt;next;<br>// 考虑最后一个元素被删，队尾指针指向头结点<br>if (queue.rear == queue.front) {<br>queue.front = queue.rear;<br>}<br>return e;<br>}</p><p>/_ 取队头元素 _/<br>Status GetHead(LinkQueue &amp;queue) {<br>if (queue.front != queue.rear){<br>return queue.front-&gt;next-&gt;data;<br>}<br>}</p><p>int main() {<br>LinkQueue test;<br>InitQueue(test);<br>EnQueue(test, 10);<br>EnQueue(test, 15);<br>EnQueue(test, 20);<br>// cout &lt;&lt; “队列长度为：” &lt;&lt; QueueLength(test) &lt;&lt; “\n”;<br>cout &lt;&lt; GetHead(test)&lt;&lt;” “&lt;&lt; GetHead(test)&lt;&lt;” “&lt;&lt; GetHead(test)&lt;&lt;” “&lt;&lt;”\n”;<br>cout &lt;&lt; DeQueue(test)&lt;&lt;” “&lt;&lt; DeQueue(test)&lt;&lt;” “&lt;&lt; DeQueue(test)&lt;&lt;” “&lt;&lt;”\n”;<br>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++栈顺序和链式实现及操作</title>
      <link href="/blog/tlzqah/"/>
      <url>/blog/tlzqah/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="179d6501b149bd3789fe38d726e29887" class="ne-p"><span class="ne-text">存储形式以及操作和顺序表和链表差不多，需要的操作也少，学栈和队列，感觉只是抽离出来这两种便于在应用层面使用</span></p></div><h2 id="GFKJm"><span class="ne-text">顺序栈</span></h2><pre data-language="cpp" id="HEWE3" class="ne-codeblock language-cpp">#include<bits/stdc++.h><p>typedef int Status;<br>typedef int SElemType;<br>#define OVERFLOW -1<br>#define ERROR 0<br>#define OK 1<br>#define MAXSIZE 100</p><p>using namespace std;<br>/**</p><ul><li>顺序栈</li><li></li><li>顺序栈的基本操作：初始化、入栈、出栈、取栈顶元素<br>*/</li></ul><p>/_ 顺序栈的存储形式 _/<br>typedef struct {<br>SElemType *base;<br>SElemType *top;<br>int stacksize;<br>} SqStack;</p><p>/_ 初始化 _/<br>Status InitSqStack(SqStack &amp;stack) {<br>// 为栈分配容量<br>stack.base = new int[MAXSIZE];<br>// 分配失败返回失败值<br>if (!stack.base) {<br>return OVERFLOW;<br>}<br>// 让栈顶地址初始为栈底地址<br>stack.top = stack.base;<br>// 初始化容量<br>stack.stacksize = MAXSIZE;<br>return OK;<br>}</p><p>/_ 入栈 _/<br>Status Push(SqStack &amp;stack, SElemType e) {<br>if (stack.top - stack.base == stack.stacksize) {<br>return OVERFLOW;<br>}<br>*stack.top = e; // 先在 top 位置赋值<br>stack.top++; // 将 top 地址++<br>return OK;<br>}</p><p>/_ 出栈 _/<br>Status Pop(SqStack &amp;stack) {<br>// 空栈返回异常<br>if (stack.top == stack.base) {<br>return OVERFLOW;<br>}<br>stack.top–; // 栈顶地址减 1<br>return *stack.top; // 返回此时“栈顶”元素<br>}</p><p>/_ 取栈顶元素 _/<br>Status GetTop (SqStack &amp;stack) {<br>// 空栈返回异常<br>if (stack.top == stack.base) {<br>return OVERFLOW;<br>}<br>// stack.top–; // 栈顶地址减 1，这是和出栈的区别<br>return *(stack.top-1); // 返回此时“栈顶”元素<br>}</p><p>int main() {<br>SqStack test;<br>InitSqStack(test);<br>Push(test, 10);<br>Push(test, 15);<br>Push(test, 20);<br>cout &lt;&lt; GetTop(test)&lt;&lt;” “&lt;&lt; GetTop(test)&lt;&lt;” “&lt;&lt; GetTop(test)&lt;&lt;” “&lt;&lt;”\n”;<br>cout &lt;&lt; Pop(test)&lt;&lt;” “&lt;&lt; Pop(test)&lt;&lt;” “&lt;&lt; Pop(test)&lt;&lt;” “&lt;&lt;”\n”;<br>}</pre><h2 id="aheiA"><span class="ne-text">链栈</span></h2><pre data-language="cpp" id="fZUr6" class="ne-codeblock language-cpp">#include<bits/stdc++.h><br>typedef int Status;<br>typedef int SElemType;<br>#define OVERFLOW -1<br>#define ERROR 0<br>#define OK 1<br>#define MAXSIZE 100</p><p>using namespace std;<br>/**</p><ul><li>链栈</li><li></li><li>链栈的基本操作：初始化、入栈、出栈、取栈顶元素<br>*/</li></ul><p>/_ 链栈的存储形式 _/<br>typedef struct StackNode{<br>SElemType data;<br>struct StackNode *next;<br>} StackNode, *LinkStack;</p><p>/**</p><ul><li>初始化</li><li>不设头结点<br>*/<br>Status InitLinkStack(LinkStack &amp;stack) {<br>stack = NULL; // 栈顶元素置空<br>return OK;<br>}</li></ul><p>/_ 入栈 _/<br>Status Push(LinkStack &amp;stack, SElemType e) {<br>// 不能用 LinkStack 这样声明结点变量，需要 new 一个内存空间<br>LinkStack temp = new StackNode;<br>temp-&gt;data = e;<br>temp-&gt;next = stack;<br>stack = temp;<br>return OK;<br>}</p><p>/_ 出栈 _/<br>Status Pop (LinkStack &amp;stack) {<br>SElemType i = stack-&gt;data;<br>stack = stack-&gt;next;<br>return i;<br>}</p><p>/_ 取栈顶元素 _/<br>Status GetTop (LinkStack &amp;stack) {<br>return stack-&gt;data;<br>}</p><p>int main() {<br>LinkStack test;<br>InitLinkStack(test);<br>Push(test, 10);<br>Push(test, 15);<br>Push(test, 20);<br>cout &lt;&lt; GetTop(test)&lt;&lt;” “&lt;&lt; GetTop(test)&lt;&lt;” “&lt;&lt; GetTop(test)&lt;&lt;” “&lt;&lt;”\n”;<br>cout &lt;&lt; Pop(test)&lt;&lt;” “&lt;&lt; Pop(test)&lt;&lt;” “&lt;&lt; Pop(test)&lt;&lt;” “&lt;&lt;”\n”;<br>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>缺爱</title>
      <link href="/essay/xikynq/"/>
      <url>/essay/xikynq/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue38d18f1" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1620269016472-0205bffa-da28-4411-9950-1b94025de0f7.jpeg" width="550" id="THQSB" class="ne-image"></p><p id="u78948a78" class="ne-p" style="text-align: left"><br></p><p id="ub66f1859" class="ne-p" style="text-align: left"><span class="ne-text">前言：观《刀剑神域》《东京食尸鬼》《进击的巨人》等一些番，对“缺爱”这个词的一些感悟……</span></p><p id="u9c68e113" class="ne-p" style="text-align: left"><br></p><hr id="srTUH" class="ne-hr"><p id="u6563aa42" class="ne-p"><br></p><p id="uf2eaf996" class="ne-p" style="text-align: center"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">缺爱的人，内心总有一些渴望，渴望被关爱，渴望被呵护，渴望对方是自己心里想要的模样……这种渴望是一种游走在刀尖上的隐式力量，甚至，会让一个人人格变化，变成一个我们都不在认识的人……</span></p><p id="c4117653d51cd868e6dc22310070e8fa" class="ne-p"><br></p><p id="4a6b24cfa2b15d79fe14e63a02c3f76a" class="ne-p"><span class="ne-text">尤吉欧缺的是从小的青梅竹马爱丽丝的爱，在面对最高祭司的亲昵……当然，尤吉欧的强大就强大在，他无条件相信挚友桐人，即便是那般情形，他也从刀尖上走向了正确的道路。金木研缺少的是母爱，的佣人，缺少的是家主的关爱</span></p><p id="a478fc563129e4f079b6953e4d61345a" class="ne-p"><br></p><p id="3270eb285d36ab65041306778a361ad5" class="ne-p"><span class="ne-text">兵长利威尔，就更不用说了，人类中外挂，绝对的强者，他缺少的不仅是亲人的爱，更是这个世界的压抑与社会的动荡，地下生活，从小就仰头看不见天空，低头被人唾弃，这缺的简直是一个世界啊，他心里也是多么珍视自己的爱和他人的爱，最初的两个小伙伴，再到利威尔整个班，还有……佩特拉……</span></p><p id="dd1259eb009d4739a1200ca7aa563b64" class="ne-p"><br></p><p id="43a38f1ccb147a4287059cf525aad5d3" class="ne-p"><span class="ne-text">如果说这个世界真有一种至暗力量，缺爱或许也是其一呢~这个世界谁都没错，错的是这个世界，那么    我又为何一直低头呢？这就是缺爱的至暗力量……</span></p><p id="d4e2f3b848139d4c6309dc4c86de9199" class="ne-p"><br></p><p id="aec01b16fedb1f190c42998dd0bfc12c" class="ne-p"><span class="ne-text">生活中，也有很多啊，跟班，小时候的孩子，经常有跟班一说，如果你是和别人相爱的人，那么你可以给对方更多一点的爱，如果你是为人父母，你可以更加爱自己的子女，爱，从来都不嫌多，两个人之间的爱情也是一样</span></p><p id="b1748f97ad8674bc38ef2a38857c60fe" class="ne-p"><br></p><p id="1613204624cab5463d85d87e2a4ab215" class="ne-p"><span class="ne-text">人与人之间，不要让对方、让彼此缺爱……</span></p><p id="1cbf858f5b06b20c52478e7f5a6b349a" class="ne-p"><br></p><p id="e691ca557d793a55550ea296fc706439" class="ne-p"><span class="ne-text">你仔细看看，缺爱的人好多，小什造，又何尝不是，</span></p><p id="578e731111732a7970a40d89ac702f6c" class="ne-p"><br></p><p id="90606eeec48d383f2365da3b94729cbb" class="ne-p"><br></p><p id="217aafd31c5bb15e59f0194e07211d32" class="ne-p"><span class="ne-text">这部剧好就好在，没有没有对错，没有哪一方是绝对的正确，贯穿全剧的就是一句话——“错的不是我，而是这个世界”</span></p><p id="6db1b2b17b72e9d4157a23637f2b828f" class="ne-p"><br></p><p id="uff60666a" class="ne-p"><br></p><p id="9add66c2f6176132dfe12b6382c5f6b5" class="ne-p"><span class="ne-text">写着写着，简直我就要黑化一般</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1618565453724-89af8f91-a000-4be3-bddd-cb1708cc5065.jpeg" width="52" id="fQUdE" class="ne-image"></p><p id="8ad1a4088531ca01eb309d6471ed829b" class="ne-p"><br></p><p id="ba3a0f736f53b26b9b6438df3ed2196e" class="ne-p"><code class="ne-code"><span class="ne-text">2021.05.06</span></code></p><p id="854af4395650d0eaf1e60c9604aa723e" class="ne-p"><br></p><p id="309036480d8044a52008b70a3f57daf7" class="ne-p"><span class="ne-text">上网搜了一下，缺爱还是有相应的词条的：</span><a href="https://baike.baidu.com/item/%E7%BC%BA%E7%88%B1/4544029" data-href="https://baike.baidu.com/item/%E7%BC%BA%E7%88%B1/4544029" target="_blank" class="ne-link"><span class="ne-text">缺爱·百度百科</span></a></p><p id="be6c6541496ec8a5c8f7af6c39009eb4" class="ne-p"><br></p><div class="ne-quote"><p id="6126e973de9910dd6b637453ae721b5c" class="ne-p"><span class="ne-text">缺爱：一般指缺少关爱的孩子的一种心情表现形式，着调于凄凉寂寞的非乐观主义。缺爱的孩子性格往往和普通孩子不一样，思想也成熟的早一点，但是较容易走极端。</span></p><p id="539c7177e3d4a0b69efe564377e2b866" class="ne-p"><span class="ne-text">——百度百科</span></p></div><p id="848ed0e6c1e965a5de024aa5242f0881" class="ne-p"><br></p><div class="ne-quote"><p id="d779548761360bf116198c8257ec7729" class="ne-p"><span class="ne-text">表现：缺爱的孩子性格往往和普通孩子不一样，思想也成熟的早一点，但是容易走极端，比较叛逆，一般能力较强，事业心强，但在内心里缺乏安全感，不论拥有再多，始终担忧如果有一天失去了怎么办。</span></p><p id="2945629b7787335af10a6fdcc5e8cde7" class="ne-p"><span class="ne-text">缺爱的孩子比较喜欢自己一个人不声不响的做事，性格比较孤僻，一般让人看上去会形容他“感觉这个人有很多心事”。</span></p></div><div class="ne-quote"><p id="bd3304777067eacab18ed6a98a3c989c" class="ne-p"><span class="ne-text">对于爱情，缺爱的孩子比较“慢热”，心里有恐惧感，害怕如果我投入了结果会怎样…… 但是一旦投入了，就会比较偏激的把自己认为好的全部给对方。不管这爱是亲情，友情，爱情，他都是全方位的去考虑去付出。因为他缺少爱，他全身心的付出内心里也是希望对方能像他一样全身心付出的对他好。如果没有得到期望中的回报或者被人所不屑，心中必然是由爱生恨，他们的爱恨往往比较极端。</span></p></div><div class="ne-quote"><p id="814a4210db2d23ca47878a7b60457bbc" class="ne-p"><span class="ne-text">单亲家庭的孩子、孤儿、重男轻女家庭的女儿、重小轻大家庭的大孩一般都会存在缺爱的现象，这是一个比较普遍的现象。</span></p></div><div class="ne-quote"><p id="e4c825fa0ab7b1e7c1360c4454dcf174" class="ne-p"><span class="ne-text">缺爱的孩子需要社会的关心，不然容易变坏，社会上这样的例子很多。</span></p><p id="8c622d0019853599e7fe8675b11dd46c" class="ne-p"><span class="ne-text">——百度百科</span></p></div></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验3——求LA和LB(用单链表表示)的并和交集🔖链表</title>
      <link href="/blog/tw2cvt/"/>
      <url>/blog/tw2cvt/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="kfwKY"><span class="ne-text">实验要求</span></h2><p id="fc77a305509589eb8e57f5dfb40b0283" class="ne-p"><span class="ne-text" style="font-size: 16px">求两个集合</span><span class="ne-text" style="font-size: 16px">LA</span><span class="ne-text" style="font-size: 16px">和</span><span class="ne-text" style="font-size: 16px">LB(</span><span class="ne-text" style="font-size: 16px">用单链表表示</span><span class="ne-text" style="font-size: 16px">)</span><span class="ne-text" style="font-size: 16px">的并和交集</span></p><p id="97cde14d07d55927cbe8c267732498e8" class="ne-p"><span class="ne-text" style="font-size: 16px">要求：在实验二的基础上，使用单链表表示集合。编写两个算法（求交算法和求并算法），并输出最终的结果。</span></p><p id="ead1e8e70488c4fe4831812a1ca80cd6" class="ne-p"><span class="ne-text" style="font-size: 16px">测试用例：集合</span><span class="ne-text" style="font-size: 16px">A</span><span class="ne-text" style="font-size: 16px">为</span><span class="ne-text" style="font-size: 16px">{3</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">4</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">1</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">6}</span><span class="ne-text" style="font-size: 16px">，集合</span><span class="ne-text" style="font-size: 16px">A</span><span class="ne-text" style="font-size: 16px">为</span><span class="ne-text" style="font-size: 16px">{2</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">3</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">6</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">7}</span><span class="ne-text" style="font-size: 16px">，</span></p><p id="bb2a51a2d8dae453e9cee5530fc5cf09" class="ne-p"><span class="ne-text" style="font-size: 16px">           </span><span class="ne-text" style="font-size: 16px">交集为</span><span class="ne-text" style="font-size: 16px">{3</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">6}</span></p><p id="16107b01f015db18e9dad1c123c47f6f" class="ne-p"><span class="ne-text" style="font-size: 16px">           </span><span class="ne-text" style="font-size: 16px">并集为</span><span class="ne-text" style="font-size: 16px">{1</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">2</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">3</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">4</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">6</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">7}</span></p><p id="a985b06473d654b3af94e60d4faaecb5" class="ne-p"><span class="ne-text" style="font-size: 16px">交作业时间：4月16日</span></p><h2 id="bRCZx"><span class="ne-text">实验代码</span></h2><pre data-language="cpp" id="UZjFM" class="ne-codeblock language-cpp">#include<bits/stdc++.h><p>using namespace std;</p><p>/**</p><ul><li>求两个集合 LA 和 LB(用单链表表示)的并和交集<br>*/</li></ul><p>/_ 单链表的存储结构 _/<br>typedef struct LNode {<br>int data; //数据域<br>struct LNode *next; //指针域<br>}Lnode, *LinkList; //LinkList 为指向结构体 LNode 的指针类型</p><p>/_ 初始化链表 _/<br>void InitList(LinkList &amp;L) {<br>L = new LNode;<br>L-&gt;next = NULL;<br>}</p><p>/_ 创建：后插 _/<br>void CreateList_R(LinkList &amp;L, int n) {<br>cout &lt;&lt; “请输入” &lt;&lt; n &lt;&lt; “个数字”&lt;&lt; “\n”;<br>InitList(L);<br>// 定义一个在下面循环用来一直操作所加元素的结点 p 来指向头结点 L<br>LinkList p = L;<br>for (int i = 0; i &lt; n;i++) {<br>LinkList q = new Lnode;<br>q-&gt;next = NULL;<br>cin &gt;&gt; q-&gt;data;<br>p-&gt;next = q;<br>p = q; //为了下一次<br>}<br>}</p><p>/_ 打印 _/<br>void TraverseList(LinkList &amp; L){<br>LinkList p = new LNode;<br>p = L-&gt;next;<br>cout &lt;&lt; “此链表打印的结果为：”&lt;&lt; “\n”;<br>while (p != NULL)<br>{<br>cout &lt;&lt; p-&gt;data &lt;&lt; “ “;<br>p = p-&gt;next;<br>}<br>cout &lt;&lt; “\n”;<br>}</p><p>/_ 排序单链表 _/<br>void sort(LinkList &amp;L) {</p><p>}</p><p>/_ jiao 算法 _/<br>void jiao(LinkList &amp;A,LinkList &amp;B) {<br>// 用双循环得出共有的元素并输出<br>LinkList p;<br>InitList(p);<br>A = A-&gt;next;<br>B = B-&gt;next;<br>while (A != NULL ) {<br>LinkList copy_b = B;<br>while(copy_b != NULL) {<br>if (A-&gt;data == copy_b-&gt;data) {<br>LinkList temp = new Lnode;<br>temp-&gt;data = copy_b-&gt;data;<br>temp-&gt;next = p-&gt;next;<br>p-&gt;next = temp;<br>break;<br>} else {<br>copy_b = copy_b-&gt;next;<br>}<br>}<br>A = A-&gt;next;<br>}</p><pre><code>while(p-&gt;next != NULL) &#123;    cout &lt;&lt; p-&gt;next-&gt;data &lt;&lt; &quot; &quot;;    p = p-&gt;next;&#125;</code></pre><p>}</p><p>/_ bing 算法 _/<br>void bing(LinkList &amp;A,LinkList &amp;B) {<br>LinkList p = A;<br>LinkList s = B;</p><pre><code>A = A-&gt;next;B = B-&gt;next;while (A != NULL ) &#123;    LinkList copy_b = B;    while(copy_b != NULL) &#123;        if (A-&gt;data == copy_b-&gt;data) &#123;            // cout &lt;&lt; A-&gt;data &lt;&lt; &quot;\n&quot;;            // 在p链里面删除A-&gt;data值            LinkList q = p;            while(q-&gt;next != NULL) &#123;                if (q-&gt;next-&gt;data == A-&gt;data) &#123;                    q-&gt;next = q-&gt;next-&gt;next;                    break;                &#125; else &#123;                    q = q-&gt;next;                &#125;            &#125;            break;        &#125; else &#123;            copy_b = copy_b-&gt;next;        &#125;    &#125;    A = A-&gt;next;&#125;// 将p链表连接到s链表上LinkList result = p;while (p != NULL) &#123;    if (p-&gt;next == NULL) &#123;        p-&gt;next = s-&gt;next;        break;    &#125;    p = p-&gt;next;&#125;while(result-&gt;next != NULL) &#123;    cout &lt;&lt; result-&gt;next-&gt;data &lt;&lt; &quot; &quot;;    result = result-&gt;next;&#125;</code></pre><p>}</p><p>int main() {<br>LinkList list_A;<br>LinkList list_B;<br>InitList(list_A);<br>InitList(list_B);<br>CreateList_R(list_A, 6);<br>CreateList_R(list_B, 6);<br>LinkList list_C = list_A;<br>LinkList list_D = list_B;<br>cout &lt;&lt;”A、B 交集的值为：”;<br>jiao(list_A, list_B);<br>cout &lt;&lt;”\n”&lt;&lt;”A、B 并集的值为：”;<br>bing(list_C, list_D);<br>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>“错的不是我，是这个世界”</title>
      <link href="/essay/lu9dks/"/>
      <url>/essay/lu9dks/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="9d6d26b32c5407fa409e22cc09422383" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619799998545-a5718c40-08b7-4571-84a2-c79b4396d498.jpeg" width="2154" id="WX9p5" class="ne-image"></p><p id="u96b61946" class="ne-p"><br></p><p id="u3e997bfe" class="ne-p"><span class="ne-text">既不是喰种也不是人类，与既是喰种又是人类，怎么选呢？</span></p><p id="u2e8b020d" class="ne-p"><span class="ne-text">不谙世事所带来的就是单纯与洁白</span></p><p id="u6768765b" class="ne-p"><span class="ne-text"></span></p><p id="u6027b438" class="ne-p"><span class="ne-text">英对好友金木敏锐的反应真的是关心与从小而来的感情之深。</span></p><p id="uf33262fa" class="ne-p"><br></p><div class="ne-quote"><p id="uc691bd7b" class="ne-p"><span class="ne-text">咖啡的味道会随着人们花费于其中的精力而变</span></p><p id="uaf790a20" class="ne-p"><span class="ne-text">人做事也是如此，你不用太着急</span></p></div><p id="u67365225" class="ne-p"><span class="ne-text">所有人都认为是对的事情，不一定是对的，而有些错误的事情，的确掌握在少数人手上</span></p><p id="ubc53c7bf" class="ne-p"><span class="ne-text"></span></p><p id="u27fb74dd" class="ne-p"><span class="ne-text">呗先生说的一句话：“金木没有恋人吗  比起同龄的女性  更喜欢被年长的姐姐疼爱把”，这也的确点明金木从小缺爱的身世。</span></p><p id="u7df1d4ec" class="ne-p"><br></p><p id="ub0375c15" class="ne-p"><span class="ne-text">稚实和董香应该都是内心非常可爱的女孩子把，从小经历生死颠簸坎坷的生活与环境，能保持这么一点可爱的童心真的很不容易。</span></p><p id="ucf45e830" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642409420043-064162ee-0226-4957-bb9e-2d0b8050ec57.png" width="1920" id="ub936c96a" class="ne-image"></p><p id="u27a23963" class="ne-p"><br></p><h3 id="kdQTp"><span class="ne-text">致终章</span></h3><div class="ne-quote"><p id="u1208d7d3" class="ne-p"><span class="ne-text">不……不是我的错</span></p><p id="ueb12282f" class="ne-p"><span class="ne-text">不对  都是我  都是我的错</span></p></div><p id="u1a9e88c4" class="ne-p"><br></p><div class="ne-quote"><p id="u9b3ef655" class="ne-p"><span class="ne-text">事到如今  你还在说这么显而易见的事实</span></p><p id="u08514cc6" class="ne-p"><span class="ne-text">你就像这样责备自己  不断地责备自己</span></p></div><p id="u246dd462" class="ne-p"><br></p><div class="ne-quote"><p id="uf0a4fa9b" class="ne-p"><span class="ne-text">只是一味地责备自己  结果一点也没有改变</span></p><p id="u204c6fa1" class="ne-p"><span class="ne-text">变成这样到底是谁的错</span></p><p id="u3e87d74f" class="ne-p"><span class="ne-text">偶然  事故  运气</span></p><p id="uaa0b7fc8" class="ne-p"><strong><span class="ne-text">运气是不存在的  那只是情况和情况的不同组合</span></strong></p><p id="u19d69df4" class="ne-p"><span class="ne-text">那又是谁制造了这种情况  是谁呢？</span></p><p id="u7c5af00f" class="ne-p"><span class="ne-text">就是你啊</span></p><p id="u990aab69" class="ne-p"><strong><span class="ne-text">世界上所有的不利因素都是因为当事人的能力不足</span></strong></p></div><p id="ua98c32e0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618470547319-c45591d3-8c94-4a78-8e1d-83174784522b.png" width="960" id="u3e621b1a" class="ne-image"></p><p id="uf2bd473c" class="ne-p"><br></p><div class="ne-quote"><p id="ud1eb8702" class="ne-p"><span class="ne-text">事实如此</span></p><p id="ud1bfe9b8" class="ne-p"><span class="ne-text">话说回来  一切的开端</span></p><p id="uc7feaa6c" class="ne-p"><strong><span class="ne-text">也就是因为你是一个不谙世事的笨蛋啊</span></strong></p><p id="u700a4ca5" class="ne-p"><span class="ne-text">因为你是笨蛋  然后被我欺骗</span></p><p id="u28786c7d" class="ne-p"><span class="ne-text">还被医生动了手脚</span></p><p id="u8193f59a" class="ne-p"><span class="ne-text">所以变成了怪物</span></p></div><p id="u41d38080" class="ne-p"><br></p><div class="ne-quote"><p id="u14d42fe1" class="ne-p"><span class="ne-text">全部都是你的错</span></p><p id="u73565b64" class="ne-p"><span class="ne-text">于其伤害他人  不如成为被伤害的那一方</span></p><p id="uef9eba06" class="ne-p"><span class="ne-text">所以你遇到这种事</span></p><p id="udd24419e" class="ne-p"><span class="ne-text">如果你足够强到能够杀死壁虎的话</span></p><p id="uc3b27f60" class="ne-p"><span class="ne-text">那两人就能得救了哦</span></p><p id="ub5b0621e" class="ne-p"><span class="ne-text">或者如果你选择了男人的话  那个女人就可能得救了</span></p><p id="u7ad4f9f7" class="ne-p"><span class="ne-text">那个时候也是如此</span></p><p id="u7e162a96" class="ne-p"><strong><span class="ne-text">如果你有足够实力的话</span></strong></p></div><p id="u1f9eb97c" class="ne-p"><br></p><p id="u4e68e398" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618470834142-4bea4e83-48a2-41fd-9246-e1f0b27c04e5.png" width="960" id="u8e685db7" class="ne-image"></p><p id="u0ae4fd4a" class="ne-p"><br></p><div class="ne-quote"><p id="u12ce4896" class="ne-p"><span class="ne-text">从今往后也一样</span></p><p id="u7b3fb88b" class="ne-p"><span class="ne-text">董香  雏实  英  </span></p><p id="uf2880180" class="ne-p"><span class="ne-text">你所珍视的人</span></p></div><p id="u902d8b8b" class="ne-p"><br></p><div class="ne-quote"><p id="u31cf0e26" class="ne-p"><span class="ne-text">明白了吗</span></p><p id="u424f8eed" class="ne-p"><span class="ne-text">这就是你所选择的生活方式</span></p><p id="u2791fd54" class="ne-p"><span class="ne-text">你所选择的未来啊</span></p><p id="u405d9cc8" class="ne-p"><span class="ne-text">为什么要哭泣呢  为什么要呐喊呢</span></p><p id="u34e8514d" class="ne-p"><span class="ne-text">与其伤害他人  你选择成为被伤害的那一方不是吗</span></p><p id="ue2a9d257" class="ne-p"><span class="ne-text">既温柔又美好</span></p><p id="uac21108b" class="ne-p"><span class="ne-text">看似你两者都选择了</span></p><p id="udbc70cee" class="ne-p"><span class="ne-text">但实际上你两者都失去了</span></p><p id="u36f705f0" class="ne-p"><span class="ne-text">你的母亲也是如此</span></p></div><p id="u2fe0846b" class="ne-p"><br></p><div class="ne-quote"><p id="u436173b3" class="ne-p"><span class="ne-text">你其实也希望她这么做吧</span></p><p id="u28728406" class="ne-p"><span class="ne-text">请你……不要再说了</span></p></div><p id="u0ef17453" class="ne-p"><br></p><div class="ne-quote"><p id="ua534ce78" class="ne-p"><span class="ne-text">为什么</span></p><p id="u66a48a5a" class="ne-p"><span class="ne-text">为什么留下我一个人</span></p><p id="ub3cc6355" class="ne-p"><span class="ne-text">我不要孤单一人</span></p><p id="ub51c3e6c" class="ne-p"><span class="ne-text">我好希望你能够选择我啊</span></p></div><p id="u05930376" class="ne-p"><br></p><div class="ne-quote"><p id="uf49eacd3" class="ne-p"><span class="ne-text">没错  金木</span></p><p id="u6dfde17f" class="ne-p"><strong><span class="ne-text">『每个人都有必须舍弃某一边才能保护重要事物的时刻』</span></strong></p></div><p id="u70555b21" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618471315132-4f0b9cc2-ba10-4c59-8c6f-73475002e472.png" width="960" id="u5f1533bb" class="ne-image"></p><p id="u33115feb" class="ne-p"><br></p><div class="ne-quote"><p id="u41c7c5a0" class="ne-p"><strong><span class="ne-text">没做到这一点  只是软弱罢了</span></strong></p><p id="u75ef3085" class="ne-p"><strong><span class="ne-text">没有舍弃的坚强  缺乏深刻的觉悟</span></strong></p><p id="u9857e086" class="ne-p"><span class="ne-text">你还能继续做被伤害的那一方吗</span></p><p id="u102bc79c" class="ne-p"><span class="ne-text">你还能原谅壁虎这种人吗</span></p></div><p id="u27678e24" class="ne-p"><br></p><div class="ne-quote"><p id="ud726279d" class="ne-p"><span class="ne-text">无法……无法原谅</span></p></div><p id="u2a11cbc4" class="ne-p"><br></p><div class="ne-quote"><p id="u97512d74" class="ne-p"><span class="ne-text">你最重要的英  还有安定区的同伴们</span></p><p id="u079c5634" class="ne-p"><span class="ne-text">都有可能遇到那种事</span></p></div><p id="u3907bb53" class="ne-p"><br></p><p id="ub5752ca7" class="ne-p"><br></p><div class="ne-quote"><p id="ufd611f74" class="ne-p"><strong><span class="ne-text">你拥有做到这些的力量吗</span></strong></p><p id="u23c23957" class="ne-p"><strong><span class="ne-text">我有…</span></strong></p><p id="u3680cb80" class="ne-p"><strong><span class="ne-text">那也就是你要接受我的意思吗</span></strong></p><p id="u8796a7ba" class="ne-p"><strong><span class="ne-text">不对</span></strong></p><p id="ud18a180c" class="ne-p"><strong><span class="ne-text">并不是这样</span></strong></p><p id="u9bce2c3b" class="ne-p"><strong><span class="ne-text">我只要超越你就好了</span></strong></p><p id="u3c07236f" class="ne-p"><strong><span class="ne-text">即使这是错误的选择也没关系吗</span></strong></p><p id="u8eca6478" class="ne-p"><strong><span class="ne-text" style="color: #F5222D">『错的人不是我   错误的是…这个世界』</span></strong></p></div><p id="u78887dd7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618471631139-459ab7b1-8de4-439a-ba90-47ec64a973db.png" width="960" id="u359998a2" class="ne-image"></p><p id="ud33c5f4e" class="ne-p"><br></p><p id="u52478afc" class="ne-p"><br></p><p id="ud1a2ce0b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618471714779-46f493f2-f76d-4ae8-8016-82a8acc51e66.png" width="960" id="u0b809119" class="ne-image"></p><p id="u786832fe" class="ne-p"><br></p><p id="u98d514cc" class="ne-p"><br></p><p id="uf4dec34a" class="ne-p"><br></p><div id="iBfRz" class="ne-thirdparty"><a href="https://music.163.com/outchain/player?type=2&id=29017078&auto=0&height=66">https://music.163.com/outchain/player?type=2&id=29017078&auto=0&height=66</a></div><p id="ub2437acf" class="ne-p"><br></p><p id="uf1d37ecd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618472037932-fcffb7e6-0ca2-4f68-9c3d-52d865fd05ca.png" width="960" id="u82016ac2" class="ne-image"></p><p id="u45031f57" class="ne-p"><br></p><pre data-language="plain" id="gvJc8" class="ne-codeblock language-plain">教えて 教えてよ<p>その仕組みを<br>僕の中に誰がいるの？<br>壊れた 壊れたよ<br>この世界で<br>君が笑う<br>何も見えずに<br>壊れた僕なんてさ<br>息を止めて<br>ほどけない もう ほどけないよ<br>真実さえ freeze<br>壊せる 壊せない<br>狂える 狂えない<br>あなたを見つけて 揺れた<br>歪んだ世界にだんだん僕は<br>透き通って見えなくなって<br>見つけないで 僕のことを<br>見つめないで<br>誰かが描いた世界の中で<br>あなたを傷つけたくはないよ<br>覚えていて 僕のことを<br>鮮やかなまま<br>無限に広がる孤独が絡まる<br>無邪気に笑った記憶が刺さって<br>動けない 動けない<br>動けない 動けない<br>動けない 動けないよ<br>Unravelling the world<br>変わってしまった 変えられなかった<br>2 つが絡まる 2 人が滅びる<br>壊せる 壊せない<br>狂える 狂えない<br>あなたを汚せないよ 揺れた<br>歪んだ世界にだんだん僕は<br>透き通って見えなくなって<br>見つけないで 僕のことを<br>見つめないで<br>誰かが仕組んだ孤独な罠に<br>未来がほどけてしまう前に<br>思い出して 僕のことを<br>鮮やかなまま<br>忘れないで 忘れないで<br>忘れないで 忘れないで<br>変わってしまったことに paralyze<br>変えられないことだらけの paradise<br>覚えていて 僕のことを<br>教えて<br>教えて<br>僕の中に誰がいるの？</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>art-template模板</title>
      <link href="/blog/qhgult/"/>
      <url>/blog/qhgult/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B2%2C0%2C1%2C0%2C17%5D%2C%5B2%2C0%2C1%2C0%2C17%5D%5D%2C%22active%22%3Atrue%7D"><h2 data-lake-id="61b71090e71a42cd9513389859fdaf25" id="b2N2J" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">art-template和express-art-template</h2><blockquote class="lake-alert lake-alert-info" style="background-color: rgb(232, 247, 255); margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38);"><p data-lake-id="e81fb9afc377a89ff77e62472fe6888f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">为了是art-template模板引擎能够更好地和Express框架配合，模板引擎官方在源art-template模板引擎的基础上封装了express-art-template，所以在使用Espress框架时候，这两个模块都要下载。</p></blockquote><ul data-lake-id="d11b77d0fb802a8689d4d183e4a0866d" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="3adfd7ff7ffa142abbd0994e6cd1fdc2">art-template官网：<a href="https://aui.github.io/art-template/zh-cn/docs/" target="_blank">https://aui.github.io/art-template/zh-cn/docs/</a></li><li data-lake-id="f3aa99eabfbe9ef89236ea72110834cc">关于模板引擎：<a href="https://segmentfault.com/a/1190000020478061" target="_blank">6个常见JS模板引擎</a></li></ul><h3 data-lake-id="5337312138fc9083ee298b8ca1b92d85" id="F4gaD" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">使用模板渲染情况下声明</h3><div data-card-type="block" data-lake-card="codeblock" id="bmkAD" class="lake-card-margin" data-language="javascript"><div class="lake-codeblock-content" style="border: 1px solid rgb(232, 232, 232); max-width: 750px; color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: rgb(249, 249, 249);"><div class="CodeMirror-sizer" style="color: rgb(89, 89, 89); margin: 0px; padding: 16px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><pre class="cm-s-default" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 渲染后缀为art的模板时，所使用的模板引擎是什么</span><p></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">app</span>.<span class="cm-property" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">engine</span>(<span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">‘art’</span>, <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">require</span>(<span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">‘express-art-template’</span>));<br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 告诉 express 框架模板的位置</span><br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">app</span>.<span class="cm-property" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">set</span>(<span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">‘views’</span>, <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">path</span>.<span class="cm-property" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">join</span>(<span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">__dirname</span>, <span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">‘views’</span>))<br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 告诉 express 框架模板的默认后缀是什么</span><br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">app</span>.<span class="cm-property" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">set</span>(<span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">‘view engine’</span>, <span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">‘art’</span>);</span></span></pre></div></div></div><h3 data-lake-id="c0f2b06f951eab51f4b60847af75cc8b" id="eTsmx" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">关于绝对/相对路径的引用</h3><p data-lake-id="ee887858624d1b0690c72bd8607b9490" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>模板资源里面引用静态资源的路径要用绝对路径</span></strong><span>。怎么使用绝对路径呢，类似 hexo 静态博客一样，前面加一个“/”即可是根目录路径下，再进行根目录路径下路径写法</span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>应用层下的域名系统DNS</title>
      <link href="/blog/lz0ywx/"/>
      <url>/blog/lz0ywx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="e851aae42d65745b0d683eb5c9f38726" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">域名系统DNS的作用就是域名解析为IP地址，因为在网络中传输的是字节，从之前学过的报文结构就可以得知，但是为何不直接在报文中直接传输域名呢？因为IP地址长度是固定的32位（如果是IPV6就是固定的128位），而域名长度不是固定长度的，及其处理比较困难。所以将域名解析成IP地址这个任务就交给了域名服务器了。</p><p data-lake-id="6be2ebd7d69e4dda7aab539619d76c3b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="2b20760eff31b899c1219d589dfaeb38" id="4WKcd" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">理解什么是域名服务器？</h2><p data-lake-id="1cc5df2045c13e41c651fe6812d3b2b4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">域名服务器构成了DNS中的分布式网络系统，其功能主要是为内外主机提供域名与IP地址的互相解析映射服务。域名服务器分布在互联网的各子网中，每个域名服务器负责管理连接到本子网的所有主机，并为其提供服务。</p><p data-lake-id="93b03fc108af5fac7292ba6ab353e54c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="b89c451d28c2ebb7a55f664cf8147253" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="a9fca39e81541c5c9665eecfa5e909ee" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618645215420-4ee27962-12d4-467b-81e6-f932e4c82a2a.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="226px" style="visibility: visible; width: 545px;"></span></p><p data-lake-id="f9d06677dbad14dff6fdf4e0744cfd33" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">域名服务器分为上面所表示的根域名服务器、顶级域名服务器、权限域名服务器、还有本地域名服务器（在本地电脑里面）</p><h3 data-lake-id="7e0a561a8c3968a46230625423fff0c1" id="a1FJu" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">关于本地域名服务器</h3><p data-lake-id="83ac8606dda70819aa90179b895d0785" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">本地电脑就有</p><p data-lake-id="5d071c8c1f140fd228aa2dcbfd45eae5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618647707183-7e8f7af0-a3ab-455b-b702-18f82644471b.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="398px" style="visibility: visible; width: 331px;"></span></p><h3 data-lake-id="cc532d2ef47892e3d60a6128246a56c8" id="UGxo5" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">关于根域名服务器</h3><blockquote style="padding-left: 1em; margin-top: 5px; margin-bottom: 5px; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="64679f4246c6f2c8f8f18602cb31f390" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">关于根域名服务器，这里面有个有趣的话题，参考这篇文章：</p><p data-lake-id="66ff46e7fac8c1d721a2f1026281a27b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><a href="https://segmentfault.com/a/1190000023696737" target="_blank">美国如果把根域名服务器封了，中国会从网络上消失？</a></p></blockquote><h2 data-lake-id="dc9f03115bf131a979cc8f96aa024b51" id="4B7Ww" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">理解什么是域名注册商？</h2><blockquote style="padding-left: 1em; margin-top: 5px; margin-bottom: 5px; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="adfedbee81dfb532339a7cf2ce133800" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">域名服务器之所以能知道域名与 IP 地址的映射信息，是因为我们在域名服务商那里提交了域名记录。购买了一个域名之后，我们需要在域名服务商那里设置域名解析的记录，域名服务商把这些记录推送到权威域名服务器，这样我们的域名才能正式生效。</p><p data-lake-id="f5c2d8e7621afe29f08a554fc85b5eb1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">常见的域名服务商有阿里云、腾讯云等等……</p></blockquote><p data-lake-id="ed2d627e039df479e28204f746a09736" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h3 data-lake-id="0b6a493bd3b95a64eee229ed099d4e48" id="SSnav" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">注册域名注册商</h3><p data-lake-id="76f57c7e99c0dc75a6e571d973945d3c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">要成为域名注册商需要提权，具体参考：<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86" target="_blank">https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86</a></p><p data-lake-id="06be4f72f91ac2dde73f73b3bbf46051" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618646601711-fca612d8-b2cd-4c22-8417-5938c415c7ce.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="85px" style="visibility: visible; width: 532px;"></span></p><h3 data-lake-id="004bc62474ceb180c59870df62f03064" id="KiHSB" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">ICANN</h3><p data-lake-id="4c9ca4772d8e63100012dc5fb1a91a45" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">『互联网名称与数字地址分配机构』</p><p data-lake-id="24609c832d6f348497c178acd6cf2dab" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">可以看看发展历程</p><p data-lake-id="97b91b88d06c1a605a293875fbecabf3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618646847974-89e834aa-7e05-4788-aebb-ac3a084362e4.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="382px" style="visibility: visible; width: 553.5px;"></span></p><p data-lake-id="e4f1cda3459a5b5b0c247267f85eac42" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">不仅如此，包含全球的域名相关信息的ICANN的数据库管控方式也是极为严格，</p><p data-lake-id="9e7f3f82f476a2f40719f5e0af18eef8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618646929122-b3d35ad5-9a28-4fd2-a56f-1b7164cd51ff.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="242px" style="visibility: visible; width: 555.5px;"></span></p><p data-lake-id="9056b8917ea83736ad7c0873a0fc9b8e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">像极了电影里面的情节<span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1618646983840-652fc715-3b53-427d-9722-86890ccbe07a.jpeg" data-raw-src="" class="image lake-drag-image" alt="huaji1558a846ddf2e12b.jpeg" title="huaji1558a846ddf2e12b.jpeg" data-height="59px" style="visibility: visible; width: 55px;"></span></p><p data-lake-id="98c8450eeafbd5e497108e18580d79b8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">具体参考：<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&fromid=6807198" target="_blank">https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&fromid=6807198</a></p><p data-lake-id="3634e4e1e97dbc2d2c0264d33ab6e04d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="4abf672446cb6fe5eaf462baa4f8bcc3" id="59xby" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">域名解析过程</h2><p data-lake-id="71a80dbdbfd5889f40353a3a80b66a3c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote class="lake-alert lake-alert-info" style="background-color: rgb(232, 247, 255); margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38);"><p data-lake-id="f19f6e4e3c9b012ea32ed4cc472712d7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">了解了上面一些DNS宏观的设计方式，再来到域名解析就比较好理解了，域名解析就是将域名解析为IP地址，它怎么解析呢？利用在域名服务器里面查找有没有相关的解析记录。</p></blockquote><p data-lake-id="3a46bb7b8be5f903df7b243a4f66381f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="10fc7258fdc590421f837ccdd5f460e9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618647354829-7da7d070-ba2e-404d-937d-45dcfb2faf25.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="329px" style="visibility: visible; width: 646.5px;"></span></p><p data-lake-id="f0d402c626b6a0792e62b7d6ea8d8f7a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618647396384-6ec5030a-0fdf-46c5-9ebb-1d257d92f2c9.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="333px" style="visibility: visible; width: 471.5px;"></span></p><h2 data-lake-id="66a563b6690fbe174ae4beb11e40739d" id="7Elhd" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">使用工具查看DNS查询过程</h2><h3 data-lake-id="d25b2b925de1038ee94bcc037a16cf1d" id="fuhq6" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">Linux下的dig命令</h3><p data-lake-id="3a937ee6b6bc4b2c91ddb33518ce531b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618649698238-46345e66-fccd-4ad5-b99c-76db7072c62f.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="360px" style="visibility: visible; width: 720px;"></span></p><h3 data-lake-id="ef503ad3f8edfe300c6f97d22ab47f3a" id="VGQRU" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">Windows下的trance命令</h3><p data-lake-id="984c3f3cbc5a4292ba60871d988d97e8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618649719833-b58925d7-4a25-4bdc-897b-e7bb281efed5.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="360px" style="visibility: visible; width: 720px;"></span></p><p data-lake-id="5e639c59243b33bb22120546f13a53c4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="2ccbd3230b7ec01b60999276b4935e05" id="zlv4P" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">参考</h2><ul data-lake-id="9506c2ac3a1f5e61b993e4a5211b1929" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="88c500237bd998872be26826ce7e62c7"><a href="https://github.com/ruanyf/articles/blob/master/2016/2016-06-15-dns.md" target="_blank">DNS 原理入门 - 阮一峰的网络日志</a></li><li data-lake-id="1473e4390fa9183575fc62148041d58b"><a href="https://segmentfault.com/a/1190000023696737" target="_blank">https://segmentfault.com/a/1190000023696737</a></li><li data-lake-id="fbafc64d00d65323ec9d045a47070dd8"><a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86" target="_blank">https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86</a></li><li data-lake-id="146e25f3e8343119b2922eb9d154a4c9"><a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&fromid=6807198" target="_blank">https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&fromid=6807198</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>客户端存储</title>
      <link href="/blog/bzdwkx/"/>
      <url>/blog/bzdwkx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="bt5VO"><span class="ne-text">本地存储特性</span></h3><ul class="ne-ul"><li id="fe1e67d146dcba84053c3ed73416e503"><span class="ne-text">数据存储在用户浏览器中</span></li><li id="694d4c336287d21891a48c1585df9167"><span class="ne-text">设置、读取方便、甚至页面刷新不丢失数据</span></li><li id="9e0c681e5ab26d20e35a98ee55ab923e"><span class="ne-text">容量较大，</span><code class="ne-code"><span class="ne-text">sessionStorage</span></code><span class="ne-text">约</span><code class="ne-code"><span class="ne-text">5M</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">localStorage</span></code><span class="ne-text">约</span><code class="ne-code"><span class="ne-text">20M</span></code></li><li id="b4c20b4d476feaa8701afb77bc733fd2"><span class="ne-text">只能存储字符串，可以将对象</span><code class="ne-code"><span class="ne-text">JSON.stringify()</span></code><span class="ne-text">编码后存储，然后使用的使用</span><code class="ne-code"><span class="ne-text">JSON.parse()</span></code><span class="ne-text">转换回对象</span></li></ul><h3 id="0VYws"><span class="ne-text">window.sessionStorage</span></h3><p id="4fbc447b4ea9f2038b2724db70d01ac3" class="ne-p"><span class="ne-text">1、生命周期为关闭浏览器窗口</span></p><p id="ccbbbcff305024a4dcdaaba7a6fafb46" class="ne-p"><span class="ne-text">2、在同一个窗口(页面)下数据可以共享</span></p><p id="a89a782ba947bdd860fc28e00b0ec836" class="ne-p"><span class="ne-text">3、以键值对的形式存储使用</span></p><p id="0d5a24edd5013b2b523b7556c60b3a03" class="ne-p"><span class="ne-text">存储数据：</span></p><pre data-language="javascript" id="lDSnz" class="ne-codeblock language-javascript">sessionStorage.setItem(key, value)</pre><p id="378124830a6c00a1292d88c4290e2e3a" class="ne-p"><span class="ne-text">获取数据：</span></p><pre data-language="javascript" id="jHDBc" class="ne-codeblock language-javascript">sessionStorage.getItem(key)</pre><p id="de29b3a1eac52596c4d6ad3477a15da7" class="ne-p"><span class="ne-text">删除数据：</span></p><pre data-language="javascript" id="20hGL" class="ne-codeblock language-javascript">sessionStorage.removeItem(key)</pre><p id="1e38450b9673a6b54d83ef06310d138d" class="ne-p"><span class="ne-text">清空数据：(所有都清除掉)</span></p><pre data-language="javascript" id="ZBIwo" class="ne-codeblock language-javascript">sessionStorage.clear()</pre><h3 id="W0req"><span class="ne-text">window.localStorage</span></h3><p id="a007e6a71e5ca794e958969ddef8bdba" class="ne-p"><span class="ne-text">1、声明周期永久生效，除非手动删除 否则关闭页面也会存在</span></p><p id="6a425f93f4e0f02acb3258b01229e6ab" class="ne-p"><span class="ne-text">2、可以多窗口（页面）共享（同一浏览器可以共享）</span></p><p id="a518a54105653ec1d50b49829412919b" class="ne-p"><span class="ne-text">3.  以键值对的形式存储使用</span></p><p id="1484f30a6a428ec7aa94550ad64b0dfe" class="ne-p"><span class="ne-text">存储数据：</span></p><pre data-language="javascript" id="cfcdR" class="ne-codeblock language-javascript">localStorage.setItem(key, value)</pre><p id="ca6e3b4987fe148e2ca3e237353b2b91" class="ne-p"><span class="ne-text">获取数据：</span></p><pre data-language="javascript" id="DMTGe" class="ne-codeblock language-javascript">localStorage.getItem(key)</pre><p id="e9492b2f395dc29922c93f6fa0ecb2bb" class="ne-p"><span class="ne-text">删除数据：</span></p><pre data-language="javascript" id="XGHCz" class="ne-codeblock language-javascript">localStorage.removeItem(key)</pre><p id="81471323871e63783885b77b2ca4387e" class="ne-p"><span class="ne-text">清空数据：(所有都清除掉)</span></p><pre data-language="javascript" id="ueB31" class="ne-codeblock language-javascript">localStorage.clear()</pre><h3 id="swXya"><span class="ne-text">工具函数的封装</span></h3><pre data-language="javascript" id="xPhc2" class="ne-codeblock language-javascript">class StorageFn {<pre><code>constructor () &#123;    this.ls = window.localStorage;    this.ss = window.sessionStorage;&#125;/*-----------------cookie---------------------*//*设置cookie*/setCookie (name, value, day) &#123;    var setting = arguments[0];    if (Object.prototype.toString.call(setting).slice(8, -1) === &#39;Object&#39;)&#123;        for (var i in setting) &#123;            var oDate = new Date();            oDate.setDate(oDate.getDate() + day);            document.cookie = i + &#39;=&#39; + setting[i] + &#39;;expires=&#39; + oDate;        &#125;    &#125;else&#123;        var oDate = new Date();        oDate.setDate(oDate.getDate() + day);        document.cookie = name + &#39;=&#39; + value + &#39;;expires=&#39; + oDate;    &#125;&#125;/*获取cookie*/getCookie (name) &#123;    var arr = document.cookie.split(&#39;; &#39;);    for (var i = 0; i &lt; arr.length; i++) &#123;        var arr2 = arr[i].split(&#39;=&#39;);        if (arr2[0] == name) &#123;            return arr2[1];        &#125;    &#125;    return &#39;&#39;;&#125;/*删除cookie*/removeCookie (name) &#123;    this.setCookie(name, 1, -1);&#125;/*-----------------localStorage---------------------*//*设置localStorage*/setLocal(key, val) &#123;    var setting = arguments[0];    if (Object.prototype.toString.call(setting).slice(8, -1) === &#39;Object&#39;)&#123;        for(var i in setting)&#123;            this.ls.setItem(i, JSON.stringify(setting[i]))        &#125;    &#125;else&#123;        this.ls.setItem(key, JSON.stringify(val))    &#125;&#125;/*获取localStorage*/getLocal(key) &#123;    if (key) return JSON.parse(this.ls.getItem(key))    return null;&#125;/*移除localStorage*/removeLocal(key) &#123;    this.ls.removeItem(key)&#125;/*移除所有localStorage*/clearLocal() &#123;    this.ls.clear()&#125;/*-----------------sessionStorage---------------------*//*设置sessionStorage*/setSession(key, val) &#123;    var setting = arguments[0];    if (Object.prototype.toString.call(setting).slice(8, -1) === &#39;Object&#39;)&#123;        for(var i in setting)&#123;            this.ss.setItem(i, JSON.stringify(setting[i]))        &#125;    &#125;else&#123;        this.ss.setItem(key, JSON.stringify(val))    &#125;&#125;/*获取sessionStorage*/getSession(key) &#123;    if (key) return JSON.parse(this.ss.getItem(key))    return null;&#125;/*移除sessionStorage*/removeSession(key) &#123;    this.ss.removeItem(key)&#125;/*移除所有sessionStorage*/clearSession() &#123;    this.ss.clear()&#125;</code></pre><p>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>综合实验2——约瑟夫环🔖链表</title>
      <link href="/blog/itu2g5/"/>
      <url>/blog/itu2g5/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="FMVQA"><span class="ne-text">问题描述</span></h2><p id="76743e7f4199f7efee4a22b25121b5e5" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px">设有</span><span class="ne-text" style="font-size: 16px">n</span><span class="ne-text" style="font-size: 16px">个人围坐在圆桌周围，现从某个位置</span><span class="ne-text" style="font-size: 16px">m(1</span><span class="ne-text" style="font-size: 16px">≤</span><span class="ne-text" style="font-size: 16px">m</span><span class="ne-text" style="font-size: 16px">≤</span><span class="ne-text" style="font-size: 16px">n)</span><span class="ne-text" style="font-size: 16px">上的人开始报数，报数到</span><span class="ne-text" style="font-size: 16px">k</span><span class="ne-text" style="font-size: 16px">的人就站出来。下一个人，即原来的第</span><span class="ne-text" style="font-size: 16px">k+1</span><span class="ne-text" style="font-size: 16px">个位置上的人，又从</span><span class="ne-text" style="font-size: 16px">1</span><span class="ne-text" style="font-size: 16px">开始报数，再报数到</span><span class="ne-text" style="font-size: 16px">k</span><span class="ne-text" style="font-size: 16px">的人站出来。依次重复下去，直到全部的人都站出来为止。试设计一个程序求出这</span><span class="ne-text" style="font-size: 16px">n</span><span class="ne-text" style="font-size: 16px">个人的</span><strong><span class="ne-text" style="font-size: 16px">出列顺序</span></strong><span class="ne-text" style="font-size: 16px">。</span></p><h2 id="TthUA"><span class="ne-text">问题要求</span></h2><ol class="ne-ol"><li id="f7ffa65606c3c5ce4f0945ee28b9389d"><span class="ne-text" style="font-size: 16px">构造一个具有</span><span class="ne-text" style="font-size: 16px">n</span><span class="ne-text" style="font-size: 16px">个结点的循环单链表，用于存储圆桌周围的人的编号，链表结点的</span><span class="ne-text" style="font-size: 16px">data</span><span class="ne-text" style="font-size: 16px">域存放桌子周围的人的编号。</span></li><li id="7474e399364ccbe7fb2f5a2a999027b9"><span class="ne-text" style="font-size: 16px">为保持程序的通用性</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">问题中的</span><span class="ne-text" style="font-size: 16px">n</span><span class="ne-text" style="font-size: 16px">、</span><span class="ne-text" style="font-size: 16px">m</span><span class="ne-text" style="font-size: 16px">、</span><span class="ne-text" style="font-size: 16px">k</span><span class="ne-text" style="font-size: 16px">可由用户从键盘输入</span><span class="ne-text" style="font-size: 16px">.</span></li><li id="234247c54de30c2b78b470b84bd03335"><span class="ne-text" style="font-size: 16px">要求编写函数模拟约瑟夫问题的实现过程</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">并输出</span><span class="ne-text" style="font-size: 16px">n</span><span class="ne-text" style="font-size: 16px">个人的出列顺序。</span></li></ol><h2 id="4I3Ah"><span class="ne-text">问题分析</span></h2><p id="5a6ecfa618166afd045d0a0791b14f3b" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px">这个问题和综合实验一的思路一样，都是利用循环单链表（所以理论上之前的狐狸逮兔子应该用顺序表，而我用了链表</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617761762269-2745323d-e497-4442-984b-fe31e817f25a.jpeg" width="62" id="stiqD" class="ne-image" style="font-size: 16px"><span class="ne-text" style="font-size: 16px">）。</span></p><h2 id="E798Q"><span class="ne-text">代码</span></h2><p id="3dccd7bfd415ad54cdb2e26974c2bf5b" class="ne-p"><span class="ne-text">写代码过程中，题目没看清楚，一开始以为是被选中的人还呆在环里面，就导致我的指针指了一下午的寂寞……</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617799608465-1b5ed521-81ea-4434-a2bb-3d104e6ea038.jpeg" width="52" id="gg81l" class="ne-image"><span class="ne-text">，不说了，交实验报告去了……</span></p><pre data-language="cpp" id="gDAHs" class="ne-codeblock language-cpp">#include<bits/stdc++.h><p>using namespace std;</p><p>/**</p><ul><li>定义一个单链表<br>*/<br>typedef struct LNode {<br>int data;<br>struct LNode *next;<br>}Lnode, *LinkList;</li></ul><p>/**</p><ul><li>初始化单链表<br>*/<br>void InitList(LinkList &amp;L) {<br>L = new LNode;<br>L-&gt;next = NULL;<br>L-&gt;data = 1;<br>}</li></ul><p>/_ 初始化循环链表的初始值 _/<br>void init_add(LinkList &amp;L, int n) {<br>InitList(L);<br>LinkList p = L;<br>for (int i = 2; i &lt;= n;i++) {<br>LinkList p_temp = new Lnode;<br>p_temp-&gt;data = i;<br>if (i == n) {<br>p_temp-&gt;next = L;<br>p-&gt;next = p_temp;<br>} else {<br>p_temp-&gt;next = p-&gt;next;<br>p-&gt;next = p_temp;<br>p = p-&gt;next;<br>}<br>}<br>}</p><p>void joseph_ring(LinkList &amp;L, int n, int m, int k) {<br>init_add(L, n);<br>LinkList p = L;<br>for (int i = 0; i&lt; m; i++) {<br>p = p-&gt;next;<br>}<br>while(p-&gt;next != p) {<br>for (int j = 1; j&lt; k; j++) {<br>if (j == k-1) {<br>cout&lt;<p->next-&gt;data&lt;&lt;”号出来”&lt;&lt;”\n”;<br>p-&gt;next = p-&gt;next-&gt;next;<br>p = p-&gt;next;<br>} else {<br>p = p-&gt;next;<br>}<br>}<br>}<br>cout&lt;&lt; p-&gt;data&lt;&lt;”号出来”&lt;&lt;”\n”;</p><p>}</p><p>int main()<br>{<br>cout &lt;&lt; “请依次输入人数 n、报数位置 m、报到指定值就站起来的 k 值” &lt;&lt; “\n”;<br>int n, m, k;<br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>LinkList p;<br>joseph_ring(p, n, m, k);<br>}</pre><p id="77d3f4a34fbc0db46b044a8d3113eb4f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618305848004-50b702f4-e85f-410e-8310-bbd0c16ecac2.png" width="466.5" id="Mzbfg" class="ne-image"></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>综合实验1——狐狸逮兔子🔖链表</title>
      <link href="/blog/bexxoi/"/>
      <url>/blog/bexxoi/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="PyYRh"><span class="ne-text">问题描述</span></h2><p id="68664ae3a87302ca7bffb18e27450a37" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px">围绕着山顶有</span><span class="ne-text" style="font-size: 16px">10</span><span class="ne-text" style="font-size: 16px">个圆形排列的洞</span><span class="ne-text" style="font-size: 16px">,狐狸</span><span class="ne-text" style="font-size: 16px">要吃兔子</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">兔子说</span><span class="ne-text" style="font-size: 16px">:”</span><span class="ne-text" style="font-size: 16px">可以</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">但必须找到我</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">我就藏于这</span><span class="ne-text" style="font-size: 16px">10</span><span class="ne-text" style="font-size: 16px">个洞中</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">你先到</span><span class="ne-text" style="font-size: 16px">1</span><span class="ne-text" style="font-size: 16px">号洞找</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">第二次隔</span><span class="ne-text" style="font-size: 16px">1</span><span class="ne-text" style="font-size: 16px">个洞</span><span class="ne-text" style="font-size: 16px">(</span><span class="ne-text" style="font-size: 16px">即</span><span class="ne-text" style="font-size: 16px">3</span><span class="ne-text" style="font-size: 16px">号洞</span><span class="ne-text" style="font-size: 16px">)</span><span class="ne-text" style="font-size: 16px">找</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">第二次隔</span><span class="ne-text" style="font-size: 16px">2</span><span class="ne-text" style="font-size: 16px">个洞</span><span class="ne-text" style="font-size: 16px">(</span><span class="ne-text" style="font-size: 16px">即</span><span class="ne-text" style="font-size: 16px">6</span><span class="ne-text" style="font-size: 16px">号洞</span><span class="ne-text" style="font-size: 16px">)</span><span class="ne-text" style="font-size: 16px">找</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">以后如此类推</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">次数不限</span><span class="ne-text" style="font-size: 16px">.”</span><span class="ne-text" style="font-size: 16px">但狐狸从早到晚进进出出了</span><span class="ne-text" style="font-size: 16px">1000</span><span class="ne-text" style="font-size: 16px">次</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">仍没有找到兔子</span><span class="ne-text" style="font-size: 16px">.</span><span class="ne-text" style="font-size: 16px">问</span><span class="ne-text" style="font-size: 16px">:</span><span class="ne-text" style="font-size: 16px">兔子究竟藏在那个洞里</span><span class="ne-text" style="font-size: 16px">?</span></p><p id="u97a0e4c8" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px"></span></p><h2 id="5AMn1"><span class="ne-text">问题要求</span></h2><ol class="ne-ol"><li id="5faf33621f969d6114ccd33d665e60dd"><span class="ne-text" style="font-size: 16px">设计一种存储方式用于存储山洞</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">元素的下标表示山洞的编号</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">元素的值为</span><span class="ne-text" style="font-size: 16px">1</span><span class="ne-text" style="font-size: 16px">表示狐狸没有进过山洞</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">为</span><span class="ne-text" style="font-size: 16px">0</span><span class="ne-text" style="font-size: 16px">表示狐狸进过该山洞</span><span class="ne-text" style="font-size: 16px">.</span></li><li id="f878e49a39c71c179a009fc33c471445"><span class="ne-text" style="font-size: 16px">为保持程序的通用性</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">山洞的数目和狐狸进出山洞的次数不一定为题设的</span><span class="ne-text" style="font-size: 16px">10</span><span class="ne-text" style="font-size: 16px">和</span><span class="ne-text" style="font-size: 16px">1000,</span><span class="ne-text" style="font-size: 16px">可由用户从键盘输入</span><span class="ne-text" style="font-size: 16px">.</span></li><li id="80dac89e32893d84daf589e4340ebd9b"><span class="ne-text" style="font-size: 16px">要求编写函数模拟狐狸逮兔子的过程</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">并输出兔子可能的藏身之处</span><span class="ne-text" style="font-size: 16px">.</span></li></ol><p id="8b49c149e23f9100f3206f3d7eb62b55" class="ne-p"><span class="ne-text" style="font-size: 16px">注：实验报告中要求说明采用了什么存储结构。</span></p><h2 id="RU5tb"><span class="ne-text">问题分析</span></h2><p id="85384a1ced148c62d966da4e772571c1" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px">这实际上是一个反复查找线性表的过程</span><span class="ne-text" style="font-size: 16px">.</span></p><p id="94ce9c55919fd04eb253ed8b75d78535" class="ne-p" style="text-align: left"><span class="ne-text" style="text-decoration: line-through; font-size: 16px">定义一个顺序表</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">用具有</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">10</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">个元素的顺序表来表示这</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">10</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">个洞</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">.</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">每个元素表示围绕山顶的一个洞</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">下标为洞的编号</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">.</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">对所有洞设置初始标志为</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">1,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">然后通过</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">1000</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">次循环</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">对每次所进之洞修改标志为</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">0,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">最后输出标志为</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">1</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">的洞</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">即兔子藏身的洞</span><span class="ne-text" style="font-size: 16px">.</span></p><p id="19a5619b15d3f1fec17d3e9d6ebc376b" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px">定义了一个单链表，将其转换为循环链表，利用循环链表来解决了这个问题。</span></p><h2 id="EbCn3"><span class="ne-text">代码</span></h2><pre data-language="cpp" id="QnoZa" class="ne-codeblock language-cpp">#include<bits/stdc++.h><p>using namespace std;</p><p>typedef struct LNode {<br>int data;<br>int flag;<br>struct LNode *next;<br>}Lnode, *LinkList;</p><p>int main() {<br>LinkList L;<br>L = new LNode;<br>L-&gt;data = 1;<br>L-&gt;flag = 1;<br>L-&gt;next = NULL;<br>for (int i = 1; i &lt; 10;i++) {<br>LinkList p;<br>p = new LNode;<br>p-&gt;data = 11-i;<br>p-&gt;flag = 1;<br>p-&gt;next = L-&gt;next;<br>L-&gt;next = p;<br>if (i == 1){<br>p-&gt;next = L;<br>}<br>}</p><pre><code>LinkList s;s = new LNode;s = L;for (int i = 0; i &lt; 1000;i++) &#123;    s-&gt;flag = 0;    for (int j = 0; j &lt; i+2;j++) &#123;        s = s-&gt;next;    &#125;&#125;cout &lt;&lt; &quot;最终结果：&quot;&lt;&lt; &quot;\n&quot;;for (int i = 0; i &lt; 10;i++)&#123;    cout &lt;&lt; L-&gt;data &lt;&lt;&quot;洞&quot;&lt;&lt; &quot; &quot; &lt;&lt; L-&gt;flag &lt;&lt; &quot;\n&quot;;    L = L-&gt;next;&#125;</code></pre><p>}</pre><p id="08bfc357d12d7c800475ed13e89e31fb" class="ne-p"><span class="ne-text" style="font-size: 16px"></span></p><p id="308c8b412ea8db17fbec5f4d9585c80d" class="ne-p"><span class="ne-text" style="font-size: 16px"> </span></p><p id="1cd3c1d9b37ab8d19bc96a09ccc7e035" class="ne-p"><span class="ne-text" style="font-size: 16px"> </span></p><p id="75d6038d714c56f1524323be1470baf8" class="ne-p"><span class="ne-text" style="font-size: 16px"></span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[加密文章]Write Code Summary</title>
      <link href="/blog/fit037/"/>
      <url>/blog/fit037/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++串</title>
      <link href="/blog/hcwio0/"/>
      <url>/blog/hcwio0/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B12%2C0%2C14%5D%2C%5B12%2C0%2C14%5D%5D%2C%22active%22%3Atrue%7D"><h2 data-lake-id="f265812fd0ea136fc0cb08637c13c905" id="v6aeX" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">课后一些问题</h2><p data-lake-id="31dcf9c599f0a38ce7dfec130ed9a175" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">（1）串是一种特殊的线性表，其特殊性体现在（  ）。</p><p data-lake-id="b696679a3f8e3e7ff083b2b85ece3497" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">  A．可以顺序存储             <strong>  B．数据元素是一个字符   </strong>   </p><p data-lake-id="d6c3841d7e341e214200b07f4fd282d4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">C．可以链式存储               D．数据元素可以是多个字符若  </p><p data-lake-id="a3939fa8d1e2259268cc78b5ee563022" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">答案：B</p><p data-lake-id="d6d0eddef652ccc89742e2efd7da81a2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="b3c9440a7cdecd4ce0dd0bdfdc03fcde" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">（2）串下面关于串的的叙述中，（  ）是不正确的？  </p><p data-lake-id="ed64bcc84722f575ba3518bd135bc206" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">A．串是字符的有限序列          <strong>B．空串是由空格构成的串</strong></p><p data-lake-id="6bf941378f090c901f73f1246d2f8732" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">C．模式匹配是串的一种重要运算  D．串既可以采用顺序存储，也可以采用链式存储</p><p data-lake-id="6f341985e3ea3d674cdd927cae6796a2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">答案：B</p><p data-lake-id="d878bd0a038c640896dd8f04a309a8bf" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">解释：空格常常是串的字符集合中的一个元素，有一个或多个空格组成的串成为空格串，零个字符的串成为空串，其长度为零。  </p><p data-lake-id="8673313376125a3b137f76bd69946003" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c6a8a28c382e562ac2d4da16640d1068" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">（5）串的长度是指（  ）。</p><p data-lake-id="25636c2447e4fa8a95d61194f1a57570" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">A．串中所含不同字母的个数    <strong>   B．串中所含字符的个数</strong></p><p data-lake-id="3821edffbc48826fa70d1af55d056424" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">C．串中所含不同字符的个数       D．串中所含非空格字符的个数</p><p data-lake-id="145dc10f528d8704b69109679379ddc7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">答案：B</p><p data-lake-id="00bb229b2b0660bdbd3bb980d0e2a44d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">解释：串中字符的数目称为串的长度。</p></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今年的清明有点不一样</title>
      <link href="/essay/nyh946/"/>
      <url>/essay/nyh946/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p class="ne-p"><span class="ne-text">还是在昨天，济南这边下了一场不小的雨，图书馆外的风甚是喧嚣，今天却又是格外晴朗…</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">和三月份回学校那天一样，南昌下着大雨，在去昌北机场大巴的车上，鹏鹏打电话和我说华哥死了的时候，那会儿我是很突然的，还没反应过来，人就懵了…车窗外的雨下的愈来愈大</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">以前，亲戚长辈们总和我们后辈说，不要学华哥，说是没出息，那会我不懂，我不懂的是什么叫出息，更不懂人们眼中的出息叫什么，我只知道他是我哥，我很喜欢和他玩。</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">小时候某年过节那会，亲戚朋友们都聚在一起，大人们都在那谈论电动摩特车，我在一旁听着，想跃跃欲试，我和身旁的华哥说，借他车去路上试试，华哥二话不说把我带到路上把车子开动，我凭着刚才他们大人们的三言两句，三下五除二车子就被我骑的老远，然后手不由自主地加速，车子越来越快，那一瞬间我突然想起来我忘了问刹车在哪…那一瞬间我实实在在感受到了相对速度的感念，车子走了，我屁股着地了～事后华哥笑着和我爸妈说，没多大事…</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">这个世界上，我一直相信人不止一面，在人们面前展示的一面，或许是普通的一面，可能一个人的表面是不被人所喜爱的，有几分不羁放纵，也可以是洒脱，当然也有那种特别讨别人喜的那种性格，但我也说了，人是复杂的，有的人在别人看来很没出息，没有大作为，可是，人心很好，当亲朋好友有困难，他会第一时间帮忙，和长辈说话，他会很认真倾听…当人类文明被创建那会，就注定会有框架来定义某些事情的标准。</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">我一直对自己说，平生这辈不做一个庸俗之人，尽管身处这个文明有很多的框架…</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">已故之人，定当缅怀之，下飞机已经是傍晚六点那会，夕阳洒在那诺大的跑道上，那般场景太容易调动情感，</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">在飞机上的一个半小时，我应该是离华哥最近的吧…</span></p><p class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617606456340-0908688d-ae97-4581-9cdd-53c767da919d.jpeg" width="354"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617606104878-d295f451-12db-4207-b53a-9bfa1b250017.jpeg" width="354"></p><p class="ne-p"><br></p><p class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>轮子哥……</title>
      <link href="/essay/las4ft/"/>
      <url>/essay/las4ft/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C20%5D%2C%5B0%2C0%2C20%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">一时造轮子一时爽，一直造轮子，一直爽……</p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery使用笔记</title>
      <link href="/blog/aa9fsh/"/>
      <url>/blog/aa9fsh/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><code class="ne-code"><span class="ne-text">jQuery</span></code><span class="ne-text">只是对原生的</span><code class="ne-code"><span class="ne-text">JavaScript</span></code><span class="ne-text">进行封装，说白了就是封装成伪数组，所以记住它的一些调用方法就可以了</span></p><p id="de43568ce566d742cc4dc43bfcbceb53" class="ne-p"><br></p><h2 id="12cNO"><span class="ne-text">参考资料</span></h2><ul class="ne-ul"><li id="e01bddf6d0184ec895f76c099bc08a32"><a href="https://jquery.cuishifeng.cn/" data-href="https://jquery.cuishifeng.cn/" target="_blank" class="ne-link"><span class="ne-text">jQuery API 速查表  --作者：Shifone</span></a></li><li id="b6410930dad07c76852da1de0d43b439"><a href="https://www.processon.com/view/link/5b7d6458e4b0534c9bb76ad9#map" data-href="https://www.processon.com/view/link/5b7d6458e4b0534c9bb76ad9#map" target="_blank" class="ne-link"><span class="ne-text">jQuery思维导图</span></a></li></ul><h2 id="Yy6G8"><span class="ne-text">一些特性</span></h2><ul class="ne-ul"><li id="9ab2320fab604f7cb9f2ff9bc93f2eb5"><code class="ne-code"><span class="ne-text">$</span></code><span class="ne-text">符号：jq里面的顶级对象</span></li><li id="1b1742fcc89d53c4a71949d43b13db7e"><span class="ne-text">入口函数：在DOM里面的</span><span class="ne-text">DOMContentLoaded，在$里面直接赋予入口函数即可</span></li></ul><ul start="3" class="ne-ul"><li id="58420a26243878b1c5e6d82615ed8d58"><span class="ne-text">jq对象和DOM对象：</span></li></ul><p id="c9ac62a6c03b2a1d9e5cdc1f4373bb0f" class="ne-p"><span class="ne-text">两者之间的函数调用不能互换（因为是被封装成了伪数组）</span></p><p id="225f10b8aabd791d71f18ae75ab43ceb" class="ne-p"><span class="ne-text">jq转换为DOM：加数组下标即可</span><span class="ne-text">（因为是被封装成了伪数组，利用索引即可）</span></p><p id="1c8e7ce06b6018fd90c9f08141073c26" class="ne-p"><span class="ne-text">DOM转换为jq：使用$符号即可（括号不加引号），或者是get(索引值)</span></p><h2 id="KS0GD"><span class="ne-text">常用API</span></h2><h3 id="UPgrG"><span class="ne-text">选择器操作</span></h3><ul class="ne-ul"><li id="2a41e99fc1b06afd4748a517f675fc1d"><span class="ne-text">元素获取：之前的CSS选择器（基础选择器、复合选择器）怎么写，这里直接就放到$里面即可</span></li></ul><p id="7650925720f490de73ba59e8322a9e01" class="ne-p"><span class="ne-text">筛选选择器</span></p><p id="4e27c9c09861b54c98d5eb1f8cdd285a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617359781992-e02802ae-f357-4987-a8a0-46cc0c5be69a.png" width="524" id="yL3dG" class="ne-image"></p><ul class="ne-ul"><li id="1a27dd3a03c64a9534739d7c6c8eed3c"><span class="ne-text">隐式迭代：如果获取的元素是一个数组，那么对其赋予的新操作，会隐式遍历</span></li><li id="2bee8e4ae71361c3d944e799fec950de"><span class="ne-text">元素属性操作：css("属性","值")函数</span></li></ul><ul start="3" class="ne-ul"><li id="0cb05668563d2d2ffd3493767266c90e"><span class="ne-text">元素节点操作</span></li></ul><p id="a3c41e2d8826c81dfb91873977ed1e8a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617359820567-38b9fad2-deb7-429f-9d21-8f9676563426.png" width="541" id="G7Yck" class="ne-image"></p><p id="672e6e51a8475d895774bfb5d481d768" class="ne-p"><br></p><ul class="ne-ul"><li id="dc7922e3952089ef17dde809f5e8358b"><span class="ne-text">事件：.mouseover()、.click()</span></li><li id="aa872635f671ab45ac240ab897e92ba7"><span class="ne-text">.show()、.hide()：元素显示和隐藏</span></li></ul><ul start="3" class="ne-ul"><li id="6082de1ba1336d659e31b3059aaeb319"><span class="ne-text">$(this)当前这个对象</span></li></ul><h3 id="aSnP5"><span class="ne-text">样式操作</span></h3><p id="3e8f10016e271373aa72a4bd04f84379" class="ne-p"><span class="ne-text">样式的操作还是和之前的DOM一样，有两种，一种是逐个设置该元素的属性和值，另一种就是改变其类，jq里面也是这个大题思路，不过有不同</span></p><p id="7514a4dc78af37e41d943b07a4abad78" class="ne-p"><br></p><ul class="ne-ul"><li id="86e64d0eebee88b5b095f6d8adb70e46"><span class="ne-text">单一设置：.css()函数，一个参数的时候，返回该参数的值，两个参数的时候，即赋予该属性及值</span></li><li id="5866e3069dc9461ede811a32ce07fd0a"><span class="ne-text">clsss设置</span></li></ul><p id="fb354fca6afe944be652058c065de7ae" class="ne-p"><span class="ne-text">.addClass("类名")：如果该元素没有该类，则加上</span></p><p id="64fcddc76d48e8ff6dc608c8f2e52961" class="ne-p"><span class="ne-text">.removeClass()：移除指定类名</span></p><p id="cf1d33cf1d1b4b3a1048701bce77140b" class="ne-p"><span class="ne-text">.toggle()：如果该元素有该类则删除，如果没有该类则加上</span></p><p id="65aa808d270c7ca0376eead229fa3896" class="ne-p"><br></p><ul class="ne-ul"><li id="a95103df535ead96a7e6a61b3f1a86b9"><span class="ne-text">class设置和DOM里面className区别是前者不会删除原本的类，后者会</span></li></ul><h3 id="dgpQs"><span class="ne-text">效果操作</span></h3><p id="557caec8d8090bdde7526a69d5e81253" class="ne-p"><span class="ne-text">jq封装了很多的效果，具体可以详查相关文档    </span></p><p id="2c91295911a02a1636db646b11a14181" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617361907950-d1d89194-401d-46aa-9471-34139e3e00df.png" width="351.5" id="SD9oO" class="ne-image"></p><h3 id="DzFX6"><span class="ne-text">属性操作</span></h3><ul class="ne-ul"><li id="b0312590ad1d416a46c7047cad1eb51b"><span class="ne-text">prop()：得到/设置元素固有的属性及值</span></li><li id="75381246b6dd4f80808426d191caaed3"><span class="ne-text">attr()：得到/设置元素自定义的属性及值</span></li></ul><ul start="3" class="ne-ul"><li id="08ec800bbbd7ebb550101047a6132655"><span class="ne-text">data()：数据缓存</span></li></ul><h3 id="NlpzM"><span class="ne-text">内容文本值操作</span></h3><ul class="ne-ul"><li id="c00ce586c548052b1357d7c2694caa2b"><span class="ne-text">html()：相当于innerHTML</span></li><li id="5fbfcc177fc81d3d1525e69bdd7a8a7e"><span class="ne-text">text()：相当于innerText</span></li></ul><ul start="3" class="ne-ul"><li id="660d54b547338a92c6432042fc1ba3f5"><span class="ne-text">val()：操作表单的值（没有参数是获取值，有一个参数是设置）</span></li></ul><h3 id="u4L4A"><span class="ne-text">元素操作</span></h3><div data-type="info" class="ne-alert"><p id="11ee78e97c938aa98b1789a93790ae7d" class="ne-p"><span class="ne-text">遍历</span></p></div><p id="b38098c59a399b93fbd23ce5cfd3dafe" class="ne-p"><br></p><div class="ne-quote"><p id="ebf89f25145d952c93719ecf6617b416" class="ne-p"><span class="ne-text">第一种表达：</span></p></div><ul class="ne-ul"><li id="7d6908137833a84be94dd8d3cfd9e7d5"><span class="ne-text">$("div").each(function(index,ele){XXXX})</span></li><li id="fbe71cf944eb5882519c695fa0dd7fda"><span class="ne-text">其中index是索引号，ele得到的是DOM对象</span></li></ul><div class="ne-quote"><p id="913f07908bcd64c5b98d83210315403e" class="ne-p"><span class="ne-text">第二种表达</span></p></div><ul class="ne-ul"><li id="e3a19e3266a3e2865533169928321c51"><span class="ne-text">$.each(Object,function(index,ele){XXXXX})</span></li><li id="0b81bcf5981aed6fb50411f4efaadb69"><span class="ne-text">主要用于数据处理</span></li></ul><p id="a2d0d6a9ac0f09ebbecede19eaad70c4" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="c9f786a0f9ceeaebe548220fcb9d3b5c" class="ne-p"><span class="ne-text">创建</span></p></div><p id="6b1de1e66547f3f16c00e328bd4b2c64" class="ne-p"><br></p><p id="879ad0498c5d00cd026bb5274af07224" class="ne-p"><span class="ne-text">直接在$里面双引号加上需要创建的标签</span></p><p id="767d6cc22830a26393b135d2b498fa5f" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="07059a0b2eb61dece09fa91041fdfaa1" class="ne-p"><span class="ne-text">添加</span></p></div><p id="74c01037713daae461bc3a957cb243df" class="ne-p"><br></p><div class="ne-quote"><p id="6621fe80cdd7269d49fe030309384dbc" class="ne-p"><span class="ne-text">第一种关系：添加生成父子关系</span></p></div><ul class="ne-ul"><li id="f26a63599bf94c55db5a88177d751562"><span class="ne-text">append("")</span></li><li id="9f981d6a7e1147114329ddb689987e73"><span class="ne-text">prepend("")</span></li></ul><div class="ne-quote"><p id="b25d1ded663bd9079177df2b138ff027" class="ne-p"><span class="ne-text">第二种关系：添加生成兄弟关系</span></p></div><ul class="ne-ul"><li id="249a0d56e52df01b48ae3bc34803d308"><span class="ne-text">after("")</span></li><li id="726de4b46f61bc29d99d49a834d71915"><span class="ne-text">before("")</span></li></ul><p id="8301a769f76c2e93d6a36819800b8c27" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="fa6120f2c42f9084290d26a8ede55362" class="ne-p"><span class="ne-text">删除</span></p></div><p id="0959176024c4622f309e59c6b05f725e" class="ne-p"><br></p><ul class="ne-ul"><li id="fb13b9f3c00152f3324b5267d5b0ba09"><span class="ne-text">remove()：移除选定节点</span></li><li id="dde65bd8b804b2d36f327e1e69c3aaa8"><span class="ne-text">empty()：清空所选节点的左右子节点</span></li></ul><ul start="3" class="ne-ul"><li id="cddf9dd16267a7e1c4ea57b238b1c47a"><span class="ne-text">html("")：将所选节点的html内容制空（相当于删除节点了）</span></li></ul><h3 id="L7wkW"><span class="ne-text">尺寸、位置操作</span></h3><p id="1d0b003757b8a2f0553a50faafbafbc0" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="0979ce8391a1cfe51e177c149311b3aa" class="ne-p"><span class="ne-text">尺寸操作</span></p></div><p id="52250d8638cb68a364d9e07b0365361a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364626783-b5a50ec5-eeb2-4447-bc15-c7c209ae1d08.png" width="583" id="AIKMv" class="ne-image"></p><p id="9e29cca939c5b3efe1921d23336187ad" class="ne-p"><span class="ne-text">参数为空：返回值</span></p><p id="51f292fb19da19a6d477efaa569c14b5" class="ne-p"><span class="ne-text">参数为一个值：设置</span></p><p id="a71f7e5719b083e1f628ba7db4d96b7e" class="ne-p"><br></p><p id="7dd7dfadb8ba312a97ed97496c00accc" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="72d806ea8edd33836b4e32011f80d4c4" class="ne-p"><span class="ne-text">位置操作</span></p></div><p id="2c59051aaaf55f39c36349f349594db0" class="ne-p"><br></p><p id="00bd1e37a2b8faa0c0b8200e083310ac" class="ne-p"><br></p><p id="c02db588425c095fc03a80a0c06b42a1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364679986-4ff0b4c0-8622-4111-9c4b-c6571bd278db.png" width="623" id="SdHbS" class="ne-image"></p><p id="3a60bc8a5c64f4ac264dd4f8d0f2e22f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364688980-2d85f32d-a51c-48ae-85a9-fc9f613536e5.png" width="589.5" id="AO6QL" class="ne-image"></p><p id="3c40b3114fa2320a1bec36ed192b4677" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364699038-74aa84bc-20ec-4427-9485-311ebaf9d066.png" width="523.5" id="jllHI" class="ne-image"></p><p id="e74be622e43f0843137ec567dbb4ec59" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS预处理器</title>
      <link href="/blog/zsiw5e/"/>
      <url>/blog/zsiw5e/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><h2 id="u2Coo"><span class="ne-text">stylus</span></h2><p id="452a67e8416e5886cf217588873f2947" class="ne-p"><span class="ne-text">CSS预处理器优化CSS的开发</span></p><p id="ccdcf278ecc82a6e13e74521cdb4a20d" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="3225668e3c05a454496713f58c85b9cd" class="ne-p"><span class="ne-text">CSS 的预处理器，给 CSS 添加了可编程的特性，也就是说，在 stylus 中可以使用变量、函数、判断、循环一系列 CSS 没有的东西来编写样式文件，这个文件可编译成 CSS 文件</span></p></div><p id="d98fa72ca4a4d2c7bf4de368a59b5a4e" class="ne-p"><br></p><h3 id="UxRVE"><span class="ne-text">note</span></h3><ul class="ne-ul"><li id="378c5b362d5f14d4ca2667b8e5ae15f5"><span class="ne-text">“[]”：中括号内容，是定义属性的方式</span></li></ul><p id="ebd134e9428d26b9f70409563356beff" class="ne-p"><br></p><h3 id="B9Svy"><span class="ne-text">参考</span></h3><ul class="ne-ul"><li id="cdb195997112ae2a308d8333150363d7"><a href="https://www.zhangxinxu.com/jq/stylus/" data-href="https://www.zhangxinxu.com/jq/stylus/" target="_blank" class="ne-link"><span class="ne-text">stylus中文版参考文档之综述——张鑫旭</span></a></li><li id="67056520763e5b1fe08cb786414c73dc"><a href="https://stylus.bootcss.com/" data-href="https://stylus.bootcss.com/" target="_blank" class="ne-link"><span class="ne-text">富于表现力、动态的、健壮的 CSS</span></a></li></ul><p id="ua8003f55" class="ne-p"><span class="ne-text"></span></p><h2 id="lmd5c"><span class="ne-text">less</span></h2><p id="u9b2914bf" class="ne-p"><span class="ne-text">参考：</span><a href="https://less.bootcss.com/" data-href="https://less.bootcss.com/" target="_blank" class="ne-link"><span class="ne-text">https://less.bootcss.com/</span></a></p></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS的媒体查询</title>
      <link href="/blog/mio9h2/"/>
      <url>/blog/mio9h2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><h3 id="23ZNi"><span class="ne-text">媒体查询（CSS3）</span></h3><div data-type="info" class="ne-alert"><p id="5ac086b799bc33aa7a9cd2e7ece989b3" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">@media：注意@符号</span></p></div><pre data-language="css" id="f9zKo" class="ne-codeblock language-css">@media mediatype and|not|only (media feature) {<pre><code>CSS-Code;</code></pre><p>}</pre><h3 id="Jdwqy"><span class="ne-text">mediatype 查询类型</span></h3><div data-type="info" class="ne-alert"><p id="d6f925662956c9dbc2e4c88433bc166c" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">将不同的终端设备划分成不同的类型，称为媒体类型</span></p></div><p id="27435027d74589dafd7000d4c2de0b1f" class="ne-p"><br></p><p id="070a16a857a6e87adc3e6f53ff2127fd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325196-c449a080-4612-4814-b5da-5a61b1da1c0b.jpg" width="915" id="jLd4P" class="ne-image"></p><h3 id="91mxe"><span class="ne-text">关键字</span></h3><div data-type="info" class="ne-alert"><p id="7918a9dbda126ecad8bab3207f970fef" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">关键字将媒体类型或多个媒体特性连接到一起做为媒体查询的条件。</span></p></div><p id="3498795937d447cc9cc04d33c3aebe52" class="ne-p"><br></p><ul class="ne-ul"><li id="e089796360e0009d3b14ec2aff4a6242"><span class="ne-text">and：可以将多个媒体特性连接到一起，相当于“且”的意思。</span></li><li id="9eb946d76e571bb6dd5f8ce52754a1f4"><span class="ne-text">not：排除某个媒体类型，相当于“非”的意思，可以省略。</span></li><li id="5d3fd7da92fe2ac73f1d56c81c8e424f"><span class="ne-text">only：指定某个特定的媒体类型，可以省略。</span></li></ul><h3 id="LOgiW"><span class="ne-text">媒体特性</span></h3><div data-type="info" class="ne-alert"><p id="9015da3e9feb95758fe3dbe563cab402" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。</span></p></div><p id="89e55b400cd384cf5d5c5494d812f35a" class="ne-p"><br></p><p id="ad00b8c6f4e31428409176ace3ccc883" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325364-d6cd0d1a-1ec7-4bd1-a67e-3fadde7c4381.jpg" width="918" id="yj8Yz" class="ne-image"></p><h3 id="8eYMp"><span class="ne-text">媒体查询书写规则</span></h3><div data-type="danger" class="ne-alert"><p id="49409e3a9b274523127921a2233d650d" class="ne-p"><span class="ne-text" style="background-color: #FFF3F3">为了防止混乱，媒体查询我们要按照从小到大或者从大到小的顺序来写,但是我们最喜欢的还是从小到大来写，这样代码更简洁</span></p></div><p id="0cf8bb4f1f7175bd98658821fcbd9a40" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 布局 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub基于Issue的软件项目管理</title>
      <link href="/blog/hgbehz/"/>
      <url>/blog/hgbehz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u22cd1647" class="ne-p"><br></p><div data-type="color1" class="ne-alert"><p id="011a5357f7205dddf9b1506eaad76bb4" class="ne-p"><span class="ne-text">在进行GitHub项目开发过程中，途中会有一些新想法，遇见的新bug等问题，提出的一些新灵感等等都可以利用GitHub每个项目自带的issues（议题）来进行管理、跟踪并且加以解决。</span></p><p id="ec94d49f4ca5d591db0708d31278dec0" class="ne-p"><span class="ne-text">传统的软件项目管理还有Milestones（里程碑）、Projects（画板）来一并进行项目的开发，GitHub在2020年还新增加了Discussion（讨论区）模块，进一步提高软件项目的管理工作。</span></p></div><p id="42d01dbfc9c0385189d6ccd13dd47397" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616655875686-d8387a58-3c42-4442-b6b5-1cd2b0c68a5f.png" width="946.5" id="vUGI2" class="ne-image"></p><p id="3710271f5e1a3824aa072f559ead2b3b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616656006240-dd9c58bd-6675-487e-aab0-58878e9fcb29.png" width="947.5" id="PmAcn" class="ne-image"></p><h2 id="uwbhj"><span class="ne-text">Issue标签类型总结</span></h2><h3 id="URZo7"><span class="ne-text">GitHub默认标签</span></h3><table id="NznVX" class="ne-table" style="width: 893px"><tbody><tr style="height: 33px"><td width="150"><p id="u12a869c5" class="ne-p" style="text-align: center"><strong><span class="ne-text">Label</span></strong></p></td><td width="212"><p id="u896c770b" class="ne-p" style="text-align: center"><strong><span class="ne-text">explanation</span></strong></p></td><td width="531"><p id="udd4e1716" class="ne-p" style="text-align: center"><strong><span class="ne-text">Description</span></strong></p></td></tr><tr style="height: 33px"><td width="150"><p id="u0619f6a9" class="ne-p" style="text-align: center"><span class="ne-text">bug</span></p></td><td width="212"><p id="u38e16eb8" class="ne-p" style="text-align: center"><span class="ne-text">提出一个bug</span></p></td><td width="531"><p id="u48ef1bcc" class="ne-p" style="text-align: center"><span class="ne-text">Indicates an unexpected problem or unintended behavior</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ua98df8d6" class="ne-p" style="text-align: center"><span class="ne-text">documentation</span></p></td><td width="212"><p id="ue0ed9c1a" class="ne-p" style="text-align: center"><span class="ne-text">添加/改进/详查文档</span></p></td><td width="531"><p id="uee246b2c" class="ne-p" style="text-align: center"><span class="ne-text">Indicates a need for improvements or additions to documentation</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u05d518b4" class="ne-p" style="text-align: center"><span class="ne-text">duplicate</span></p></td><td width="212"><p id="uee784ab9" class="ne-p" style="text-align: center"><span class="ne-text">重复的问题/requests/讨论</span></p></td><td width="531"><p id="u3a3eccf8" class="ne-p" style="text-align: center"><span class="ne-text">Indicates similar issues, pull requests, or discussions</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u6e0e3cb7" class="ne-p" style="text-align: center"><span class="ne-text">enhancement</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="u529c40d1" class="ne-p" style="text-align: center"><span class="ne-text">增强/新增功能</span></p></td><td width="531"><p id="u7abcf037" class="ne-p" style="text-align: center"><span class="ne-text">Indicates new feature requests</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u947dbd10" class="ne-p" style="text-align: center"><span class="ne-text">good first issue</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="ufe96cb4b" class="ne-p" style="text-align: center"><span class="ne-text">好的想法/灵感</span></p></td><td width="531"><p id="u01874ec4" class="ne-p" style="text-align: center"><span class="ne-text">Indicates a good issue for first-time contributors</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u883f26fd" class="ne-p" style="text-align: center"><span class="ne-text">help wanted</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="u2c12ec31" class="ne-p" style="text-align: center"><span class="ne-text">过程中需要帮助</span></p></td><td width="531"><p id="uf1f58498" class="ne-p" style="text-align: center"><span class="ne-text">Indicates that a maintainer wants help on an issue or pull request</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ud2a85c2c" class="ne-p" style="text-align: center"><span class="ne-text">invalid</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="ue144fca0" class="ne-p" style="text-align: center"><span class="ne-text">没有意义，不再讨论</span></p></td><td width="531"><p id="uc0aa83ca" class="ne-p" style="text-align: center"><span class="ne-text">Indicates that an issue, pull request, or discussion is no longer relevant</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u4d0ff9e6" class="ne-p" style="text-align: center"><span class="ne-text">question</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="uf3471de4" class="ne-p" style="text-align: center"><span class="ne-text">请提供进一步资料</span></p></td><td width="531"><p id="ue29f0928" class="ne-p" style="text-align: center"><span class="ne-text">Indicates that an issue, pull request, or discussion needs more information</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ucbbf8a6d" class="ne-p" style="text-align: center"><span class="ne-text">wontfix</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="uc1630edc" class="ne-p" style="text-align: center"><span class="ne-text">不做处理</span></p></td><td width="531"><p id="u6a6ff953" class="ne-p" style="text-align: center"><span class="ne-text">Indicates that work won't continue on an issue, pull request, or discussion</span></p></td></tr></tbody></table><h3 id="AbJiS"><span class="ne-text">自需添加</span></h3><table id="bLXb2" class="ne-table" style="width: 479px"><tbody><tr style="height: 33px"><td width="239"><p id="a24c7d0b6d9283518f91f4c0317a7bae" class="ne-p"><span class="ne-text">debugging</span></p></td><td width="240"><p id="5394a8ea5a0306ce3ac1e6aa18b98826_p_0" class="ne-p"><span class="ne-text">正在调试</span></p></td></tr><tr style="height: 33px"><td width="239"><p id="920315d99b965a5644fee80c3835ad1e" class="ne-p"><span class="ne-text">fixed</span></p></td><td width="240"><p id="7093202f29ebdfb9d282758af8be662d_p_0" class="ne-p"><span class="ne-text">已被修复</span></p></td></tr></tbody></table><h2 id="AUORQ"><span class="ne-text">Discussion的新革新</span></h2><p id="92b019e096e018cf9ddfc50063e5d71a" class="ne-p"><span class="ne-text">传统的流程是提出issues之后，根据不同的issue来跟进画板（Project）的内容。</span></p><p id="092ba84ad78c26f4415b771106bd6690" class="ne-p"><br></p><p id="36bf279ab58f49ff5d9a08ff59e8542f" class="ne-p"><span class="ne-text">上面的做法其实有一个思维上的bug，一些灵感之类的不好放上去，使用Discussion之后，可以在</span><span class="ne-text">Discussion里面放上想法、灵感等，实际开发从这里面的一个的一个具体的评论转换到实际的issue里面</span></p><h2 id="tbZ3q"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="1acc1b1e05ed6bb38cba9e4b9107e0f3"><a href="http://www.ruanyifeng.com/blog/2017/08/issue.html" data-href="http://www.ruanyifeng.com/blog/2017/08/issue.html" target="_blank" class="ne-link"><span class="ne-text">http://www.ruanyifeng.com/blog/2017/08/issue.html</span></a></li><li id="9ad438665f32035d34baf7a5fab9c8d8"><a href="https://github.com/volantis-x/hexo-theme-volantis/" data-href="https://github.com/volantis-x/hexo-theme-volantis/" target="_blank" class="ne-link"><span class="ne-text">https://github.com/volantis-x/hexo-theme-volantis/</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git push出(10054)/(port 443：time out)错</title>
      <link href="/blog/tttk33/"/>
      <url>/blog/tttk33/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uc53e90c4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624951739057-ebfc3755-1e5a-426b-a7b3-a7841ead1b1f.png" width="441" id="yDPwn" class="ne-image"></p><p id="ub196f5cb" class="ne-p"><span class="ne-text"></span></p><p id="ud8f0faf3" class="ne-p"><strong><span class="ne-text">前言：今年GitHub的各种操作被屏蔽的挺迷的，一开始我只是以为偶尔报个连接失败的port443的错误，但是后来经常性的出现本地push不上GitHub的情况，在此情况记录一下各种情况（clone、pull、push……）连接不上的解决办法。</span></strong></p><p id="uacec6dbf" class="ne-p"><br></p><h2 id="vMQmQ"><span class="ne-text">一、报错信息与原因分析</span></h2><h3 id="mOgXN"><span class="ne-text">报错信息</span></h3><pre data-language="bash" id="NTjxl" class="ne-codeblock">Git push出(10054)/(port 443：time out)错<p>git push error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054</pre><p id="u2aee6d65" class="ne-p"><br></p><h3 id="Kpmuy"><span class="ne-text">原因分析</span></h3><ol class="ne-ol"><li id="u18980f1a"><span class="ne-text">由于 Http 协议错误，当 pull 或者 clone 的时候，或者是 github 某个 CDN 被 qiang 屏蔽所致。</span></li><li id="u5ee232b6"><span class="ne-text">用了 kexueshangwang 工具之后，由于更改代理服务器连接端口，导致本地 push 偶尔失败（但是以前有用）。</span></li></ol><h2 id="nOi29"><span class="ne-text">二、常规解决方案</span></h2><div data-type="success" class="ne-alert"><p id="uab283dd3" class="ne-p"><span class="ne-text">2021.06.29 更新解决方法：【针对 clone 失败】https 的连接不行，那就用 ssh 的连接。</span></p><p id="u63139dec" class="ne-p"><span class="ne-text">2021.07.13 更新解决方案：【针对 pull、push 失败】ssh 连接 push 连接不行，那就用 token 来 push。</span></p></div><p id="ua5aa3a5b" class="ne-p"><span class="ne-text"></span></p><div data-type="success" class="ne-alert"><p id="u97b70ea5" class="ne-p"><span class="ne-text">常规解决方法：</span></p><p id="u4479d0d3" class="ne-p"><span class="ne-text">第一种方法是下面的三条命令，另外如果用了该三条命令还不行，那就 ctrl + c ，再进行输入命令，以此往复，总会出现 GitHub 的登录框的……；</span></p><p id="u2848c832" class="ne-p"><span class="ne-text">第二种方法就是在本地对 host 进行更改，让其可以访问 github 网站的相关 ip；</span></p></div><p id="ua79015bf" class="ne-p"><span class="ne-text"></span></p><h3 id="UOJ1D"><span class="ne-text">常规解决方案 1：改代理</span></h3><div class="ne-quote"><p id="u18fba66e" class="ne-p"><span class="ne-text">10054 的 bug 复制下面的</span></p></div><pre data-language="bash" id="hnaHu" class="ne-codeblock">git config http.postBuffer 524288000</pre><div class="ne-quote"><p id="ufc3918f6" class="ne-p"><span class="ne-text">443 的 bug 复制下面的</span></p></div><pre data-language="bash" id="hrUsd" class="ne-codeblock"># 设置 ss<br>git config --global http.proxy 'socks5://127.0.0.1:10080'<br>git config --global https.proxy 'socks5://127.0.0.1:10080'</p><h1 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h1><p>git config –global https.proxy <a href="http://127.0.0.1:10080/">http://127.0.0.1:10080</a><br>git config –global https.proxy <a href="https://127.0.0.1:10080/">https://127.0.0.1:10080</a></p><h1 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h1><p>git config –global –unset http.proxy<br>git config –global –unset https.proxy</pre><h3 id="SCsCl"><span class="ne-text">常规解决方案 2：改变本地 hosts 文件</span></h3><p id="78ed051236d072ca01dcfb356337895e" class="ne-p"><span class="ne-text">在</span><a href="https://www.ipaddress.com/" data-href="https://www.ipaddress.com/" target="_blank" class="ne-link"><span class="ne-text">https://www.ipaddress.com/</span></a><span class="ne-text">里面查找下面三个域名的 ip 地址</span></p><ul class="ne-ul"><li id="19bb41ac716d33bfc9eefbb90abc83cd"><span class="ne-text">github.com</span></li><li id="7070d7115839d2f0108e4458654d3ca7"><span class="ne-text">github.global.ssl.fastly.net</span></li></ul><ul start="3" class="ne-ul"><li id="61629bb945eb3ea6add4933918a8fc03"><span class="ne-text">codeload.github.com</span></li></ul><p id="ec5a0662d9c737b31b6470c66b3659e4" class="ne-p"><span class="ne-text">将其添加到本电脑 hosts 文件当中</span></p><p id="e389f74b35a35de6376e3f8f9d1a3179" class="ne-p"><code class="ne-code"><span class="ne-text">C:\Windows\System32\drivers\etc\hosts</span></code><span class="ne-text"> </span></p><p id="ub3851647" class="ne-p"><span class="ne-text">类似下面：</span></p><p id="3c99eb4bc70690f460649a291643b991" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615339105733-afb66a55-d96e-4dba-9650-a9d3cb8324fa.png" width="245" id="EhSLV" class="ne-image"></p><p id="d1c2a5c3a0027563e1787158147c15f3" class="ne-p"><span class="ne-text">CMD 窗口刷新 DNS 缓存</span></p><pre data-language="powershell" id="HCuha" class="ne-codeblock">ipconfig /flushdns</pre><h2 id="daQUa"><span class="ne-text">三、针对性解决方案</span></h2><p id="u5f814d65" class="ne-p"><span class="ne-text">上面两种方案理论上解决了问题，但是奇葩的问题年年有，上述两种方案都不能解决，就用如下方案：</span></p><h3 id="GIgvQ"><span class="ne-text">针对 clone 失败</span></h3><p id="u5d77397b" class="ne-p"><span class="ne-text">如果 https 连接失败，使用 ssh 链连接（前提是电脑端配置了 ssh），如果 ssh 连接也不行，那就下面的针对 pull、push 失败的方案。</span></p><p id="u7e654cd7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624953268520-f8c7c56d-6588-4991-b63c-11adc5cdd0ae.png" width="441" id="KCLWc" class="ne-image"></p><h3 id="ZkQc2"><span class="ne-text">针对 pull、push 失败</span></h3><p id="uefd8d8a0" class="ne-p"><span class="ne-text">ssh 连接不行，那就使用 token 来连接</span></p><pre data-language="bash" id="dMrN3" class="ne-codeblock">git push https://一串<a href="mailto:&#116;&#111;&#107;&#101;&#x6e;&#64;&#103;&#105;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#111;&#x6d;">&#116;&#111;&#107;&#101;&#x6e;&#64;&#103;&#105;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#111;&#x6d;</a>/wztlink1013/datastructure-algorithm</pre><h2 id="boevI"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="9a0c30a27e5684596a4353039851aa5e"><a href="https://www.cnblogs.com/mmzs/p/12039888.html" data-href="https://www.cnblogs.com/mmzs/p/12039888.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/mmzs/p/12039888.html</span></a></li><li id="uf80e0f59"><a href="https://www.jianshu.com/p/f98ed938f91a" data-href="https://www.jianshu.com/p/f98ed938f91a" target="_blank" class="ne-link"><span class="ne-text">使用 Personal access tokens 以避免 Windows 下每次 git push 都需要输入账号密码</span></a></li></ul><ul start="3" class="ne-ul"><li id="u696c7627"><a href="https://segmentfault.com/q/1010000039738438" data-href="https://segmentfault.com/q/1010000039738438" target="_blank" class="ne-link"><span class="ne-text">2021 年为什么最近 github 能访问不能 push 代码了</span></a></li></ul><p id="uef725edc" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++链表(单、循环、双向)设计及操作</title>
      <link href="/blog/gu92gu/"/>
      <url>/blog/gu92gu/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="c88ce5764357a091522741724378b1dd" class="ne-p"><span class="ne-text">前言：这篇文章，打算详细记录下链表的相关知识，毕竟是基础中的基础。首先是先记录下在一开始学习过程中的些许疑惑/C的遗忘，然后记录各种代码（实验报告代码，单链表各种操作代码总结，循环链表代码，双向链表代码）</span></p></div><h2 id="fWwcE"><span class="ne-text">实验要求</span></h2><div class="ne-quote"><p id="0a190c74909083860b0ea4ec77a7f8e0" class="ne-p"><span class="ne-text">1、创建一个带头结点的单链表（头指针为head），且遍历此链表（输出链表中各结点的值）；</span></p><p id="39f29f4dc50744c5a850b3f5d4694202" class="ne-p"><span class="ne-text">2、查找单链表中的第i个结点，并输出结点元素的值；</span></p></div><div class="ne-quote"><p id="49447049dc631801c0d0cf98ab90b493" class="ne-p"><span class="ne-text">3、在单链表中的第i个结点前插入一个结点值为e的正整数(从外部输入);</span></p></div><div class="ne-quote"><p id="43c77222ef93623b95e886aeacbe2ddc" class="ne-p"><span class="ne-text">4、删除单链表中的第j个结点；</span></p></div><div class="ne-quote"><p id="e25375651bc08487d6880bc6695fce1d" class="ne-p"><span class="ne-text">*5、将单链表中的各结点就地逆序（不允许另建一个链表）；</span></p></div><h2 id="eP7sU"><span class="ne-text">概念理解</span></h2><h3 id="AEx9L"><span class="ne-text">链表数据结构</span></h3><p id="57e1ef23e935c9b21e2cfea98c4cb69f" class="ne-p" style="text-indent: 2em"><span class="ne-text">链表是一种数据结构，和</span><strong><span class="ne-text">数组同级</span></strong><span class="ne-text">。之前JAVA里面的ArrayList数据结构，其实现原理是数组，而JAVA的LinkedList的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显，其实C/C++抑或是JAVA这些数据结构都一样——地址……引用……</span></p><p id="8c7be3dc4c48c18392ebe9a3a21f453d" class="ne-p"><br></p><p id="58ae00dffdc23c957024b218a4fe2a7f" class="ne-p" style="text-indent: 2em"><span class="ne-text">单向链表是一种线性表，实际上是由</span><strong><span class="ne-text">节点（Node）</span></strong><span class="ne-text">组成的，一个链表拥有不定数量的节点。其数据在</span><strong><span class="ne-text">内存中存储是不连续的</span></strong><span class="ne-text">，它存储的数据分散在内存中，每个结点只能也只有它能知道下一个结点的存储位置。由N各节点（Node）组成单向链表，每一个Node记录本Node的数据及下一个Node。向外暴露的只有一个头节点（Head），</span><strong><span class="ne-text" style="text-decoration: underline">我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。</span></strong></p><p id="0486b484d9c64e85ae8df6456202c9d8" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194076184-195f3044-1083-4244-9eeb-d86c96a37e6f.png" width="491" id="y2G05" class="ne-image"></p><p id="287ed5b5812f8c5dc5acab531ab80a88" class="ne-p" style="text-align: left; text-indent: 2em"><span class="ne-text">上图中最左边的节点即为头结点（Head），但是添加节点的顺序是从右向左的，添加的新节点会被作为新节点。最先添加的节点对下一节点的引用可以为空。引用是引用下一个节点而非下一个节点的对象。因为有着不断的引用，所以</span><strong><span class="ne-text">头节点就可以操作所有节点</span></strong><span class="ne-text">了。</span></p><p id="37a5d5b22afe684dd87bdb37f699fdbc" class="ne-p" style="text-align: left; text-indent: 2em"><br></p><p id="9497ce3266be94b1f9295a37ec97730e" class="ne-p" style="text-indent: 2em"><span class="ne-text">下图描述了单向链表存储情况。存储是分散的，每一个节点只要记录下一节点，就把所有数据串了起来，形成了一个单向链表。</span></p><p id="1cb7d03553cc0fa59abb313b8c76e605" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194105521-d31f8e78-7f2a-4c60-8838-57e15707e27b.png" width="195" id="grJMc" class="ne-image"></p><p id="2b230249e0620a7b7bac08dc0c49afbd" class="ne-p" style="text-indent: 2em"><span class="ne-text">节点（Node）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。下面图是具体的说明：</span></p><p id="55b372445df1ebd0fc079c95a7cdeb52" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194124335-fc6fc00c-35fb-44e1-a01c-de4b8b5531af.png" width="370" id="MPcIA" class="ne-image"></p><p id="3da71b933dc4ba0ab559566e0a5a7a96" class="ne-p"><br></p><h3 id="Aq3FT"><span class="ne-text">关于链表的指向</span></h3><div class="ne-quote"><p id="b9a522a52b21f6716cf72dde48ffebd2" class="ne-p"><span class="ne-text">【1】何为指向？</span></p></div><p id="3fccb63f4a6337e5f88fb28b45873a5a" class="ne-p"><span class="ne-text">个人觉得链表的相关问题及操作就是理解链表的</span><strong><span class="ne-text">“指向”</span></strong><span class="ne-text">这么个概念，先明确以下几点</span></p><ul class="ne-ul"><li id="2cc71630bb88cfed92846d7a93cca40a"><span class="ne-text">每个节点的</span><strong><span class="ne-text">next</span></strong><span class="ne-text">用来存放</span><strong><span class="ne-text">下一个节点的“地址”</span></strong></li><li id="65cf0414c2481a13c6c9a21ef0be7dbf"><strong><span class="ne-text">每个节点的自身就是地址</span></strong><span class="ne-text">，相当于C语言中数组的数组名就是本数组的地址</span></li></ul><p id="bd5c4f3fd8cef0f7caad73699ea58d9d" class="ne-p"><br></p><div class="ne-quote"><p id="66f673c4f6f0bc17dce2567f2e5064b0" class="ne-p"><span class="ne-text">【2】谁指向谁？</span></p></div><p id="c3111db0cf2ee8b8d4fb2a84131fbd4d" class="ne-p"><strong><span class="ne-text">总结：做题用下面总结的方法，绝对好使</span></strong></p><p id="e99ba7156e434dbd6bc32bd816a6f035" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616501415627-ee5d1008-a07d-4acb-821b-e227b5cb7ad8.jpeg" width="55" id="BIrmM" class="ne-image"></p><ul class="ne-ul"><li id="c169699238a96a22f348421cb8d23eb3"><strong><span class="ne-text">读的时候：从左往右读，一般左边是某某的next域，右边是具体的结点</span></strong></li><li id="c217a55e6fabfd14cbcce9084eedf109"><strong><span class="ne-text">画的时候：在图中表示为等号左边指向等号右边</span></strong></li></ul><p id="4c686c860538d538bd106f5ac64721f7" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="e25c398d084c2af531afd302dc939259" class="ne-p"><span class="ne-text">例子：</span></p><p id="55421008445ce977395cfde0ec899cd4" class="ne-p"><span class="ne-text">① </span><code class="ne-code"><span class="ne-text">node.next = prev.next;</span></code></p><p id="c56914d506733f4e7f46b2105d9a08f7" class="ne-p"><span class="ne-text">② </span><code class="ne-code"><span class="ne-text">prev.next = node</span></code></p><p id="2af80e2b9ed35166f790a4a320b7269f" class="ne-p"><span class="ne-text">读法：</span></p><p id="19a7191dca062c4c3a1d9d89c2d086a1" class="ne-p"><span class="ne-text">①“node的next指向prev的下一个结点”</span></p><p id="327d3249675c1750699f5acc083802a6" class="ne-p"><span class="ne-text">（用指针的概念通俗地说，其实就是prev的下一个结点的地址由prev的指针域里面赋值给了node的next指针域里面）</span></p><p id="4f79632f5aecaae5f550faaea0237f6a" class="ne-p"><span class="ne-text">②“prev的next指向node这个结点”</span></p><p id="a92a2aac44c6403f602575bc1f3b116a" class="ne-p"><span class="ne-text">（还可以这么说：将node赋值给prev的next，也就是说prev的下一个结点是node）</span></p><p id="3f0e90b501bed8fa69c01c2bdf014acc" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="56d8b5f2c7ac7c9b9e18f93387a7c499" class="ne-p"><br></p><p id="c6a1d4a8cbe7b36a97ddb92a4eab18d0" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003706-ad779a14-1678-4d0c-86f2-b147752bd252.png" width="328" id="xCmIZ" class="ne-image"></p><p id="378d2212f658d52c8fecd6a063078f6f" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003751-ffeee4d8-9662-416e-8f46-5cf5edf03114.png" width="324" id="SUwQZ" class="ne-image"></p><p id="f33d58f9c2135015e50cd632ee29f224" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003658-46b3e7db-e6dc-4d13-baea-e7e44075e8bc.png" width="344" id="knAnJ" class="ne-image"></p><p id="65d1058f0d85fbe900ec755111ed2582" class="ne-p"><br></p><div class="ne-quote"><p id="0b73013ce5e35f1fc49270bd59ede650" class="ne-p"><span class="ne-text">【3】指向错位？</span></p></div><p id="9652a1886ad8458f39492fcf396b361a" class="ne-p"><strong><span class="ne-text">关注第一个元素节点是不是head，因为有的链表不声明头节点（head），直接就是第一个结点就是元素结点</span></strong></p><h3 id="wCCZi"><span class="ne-text">关于p=L的理解</span></h3><p id="b5903ee1ed44d08989b2aaf858ba1a47" class="ne-p"><span class="ne-text">写代码的时候，还经常遇到下面的情况</span></p><p id="22e2a41b379b545011d6dba722e6440c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616501697301-b63e6312-d8f9-4130-8d25-2d3becd75038.png" width="233" id="sQQqv" class="ne-image"></p><p id="90e4c31faebbcdf8ad4edd95189d5cd0" class="ne-p"><span class="ne-text">p、L就是指向结点的指针类型，将L的值赋给p，也就是p、L指向同一个结点。具体理解可以用下面一个例子来说明：</span></p><p id="e77fbf67f75189f49760964c7edbbb44" class="ne-p"><span class="ne-text">下面图片这个函数就是在一个单链表中，功能就是指定i位置插入e值。下图箭头处如果TraverseList返回的是p那么得出的链表结果就是从插入的那个元素往后这样一个部分链表，返回的是L就是想要的结果，p的功能有点类似在L的中间做了手脚……</span></p><p id="ea6d7ac80e26cac99036b09285d023d1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616501856348-955542eb-258d-473f-b003-c53881275937.png" width="370" id="IhEAo" class="ne-image"></p><h2 id="j3WQa"><span class="ne-text">各种代码</span></h2><h3 id="6qnQd"><span class="ne-text">实验报告代码</span></h3><pre data-language="cpp" id="jc3Ju" class="ne-codeblock language-cpp">#include<bits/stdc++.h><p>using namespace std;</p><p>typedef struct LNode {<br>int data;<br>struct LNode *next;<br>}Lnode, *LinkList;</p><p>LinkList L;</p><p>void InitList(LinkList &amp;L) {<br>L = new LNode;<br>L-&gt;next = NULL;<br>}</p><p>void CreateList_H(LinkList &amp;L) {<br>InitList(L);<br>int n;<br>cout &lt;&lt; “请输入要使用前插法插入的元素个数：”;<br>cin &gt;&gt; n;<br>for (int i = 0; i &lt; n; i++){<br>LNode *p = new LNode;<br>cin &gt;&gt; p-&gt;data;<br>p-&gt;next = L-&gt;next;<br>L-&gt;next = p;<br>}<br>}<br>void TraverseList(LinkList &amp;L){<br>LNode *p = new LNode;<br>p = L-&gt;next;<br>cout &lt;&lt; “此链表打印的结果为：”&lt;&lt;”\n”;<br>while (p != NULL){<br>cout &lt;&lt; p-&gt;data &lt;&lt; “ “;<br>p = p-&gt;next;<br>}<br>cout &lt;&lt; “\n”;<br>}<br>void GetElem(LinkList &amp;L) {<br>int n;<br>cout &lt;&lt; “请输入要查询的链表中第 i 个数：”;<br>cin &gt;&gt; n;<br>LNode *p = new LNode;<br>p = L;<br>for (int i = 0; i &lt; n;i++){<br>p = p-&gt;next;<br>}<br>cout &lt;&lt; “查询的结果为：” &lt;&lt; p-&gt;data&lt;&lt;”\n”;<br>}<br>void ListInsert(LinkList &amp;L){<br>LNode *p = new LNode;<br>p = L;<br>int n;<br>int e;<br>cout &lt;&lt; “请分别输入要在第 n 个位置插入的 e 值：”;<br>cin &gt;&gt; n&gt;&gt; e ;<br>for (int i = 0; i &lt; n;i++) {<br>if (n == i+1){<br>LNode *temp = new LNode;<br>temp-&gt;data = e;<br>temp-&gt;next = p-&gt;next;<br>p-&gt;next = temp;<br>break;<br>}<br>p = p-&gt;next;<br>}<br>TraverseList(L); // 直接返回 L 就可以了，之前返回 p 是不可以的！！！唉，大意了~<br>}<br>void ListDelete(LinkList &amp;L){<br>cout &lt;&lt; “请输入要删除的第 j 个位置的 j 值：”;<br>LNode *p = new LNode;<br>p = L;<br>int j;<br>cin &gt;&gt; j;<br>for (int i = 0; i &lt; j;i++) {<br>if (j == i+1) {<br>p-&gt;next = p-&gt;next-&gt;next;<br>break;<br>}<br>p = p-&gt;next;<br>}<br>TraverseList(L);<br>}<br>void ReverseList(LinkList &amp;L) {<br>LNode *p = L-&gt;next;<br> L-&gt;next = NULL;<br> while(p)<br> {<br>LNode *q = p-&gt;next;<br> p-&gt;next = L-&gt;next;<br> L-&gt;next = p;<br> p = q;<br> }<br>cout &lt;&lt; “通过逆置之后……”;<br>TraverseList(L);<br>}</p><p>int main() {<br>LNode *test = new LNode;<br>CreateList_H(test);//1<br>TraverseList(test);//1<br>GetElem(test);//2<br>ListInsert(test);//3<br>ListDelete(test);//4<br>ReverseList(test);//5<br>}</pre><p id="6924a6f6a888785632ceae0b56ec2c76" class="ne-p"><br></p><h3 id="vUcQ1"><span class="ne-text">单链表各种操作代码总结</span></h3><ul class="ne-tl"><li checked="true" id="d8f54fbe28dd447b243ee72253190acc"><span class="ne-text">单链表存储形式</span></li></ul><pre data-language="cpp" id="uKL3S" class="ne-codeblock language-cpp">typedef struct LNode {<br>int data; //数据域<br>struct LNode *next; //指针域<br>}Lnode, *LinkList; //LinkList 为指向结构体 LNode 的指针类型</pre><ul class="ne-tl"><li checked="true" id="027dcb64e4c7da81c1dce8344a65d6fc"><span class="ne-text">初始化</span></li><li checked="true" id="0c0d3140097f699146d288977fa442b9"><span class="ne-text">创建：前插法</span></li><li checked="true" id="c7a314b61d17dd1aa7915287ece885a1"><span class="ne-text">创建：后插法</span></li><li checked="true" id="dc521ab52463696309916d7834adee61"><span class="ne-text">取值</span></li><li checked="true" id="0040cab7104e6ad31c114f5380f60ead"><span class="ne-text">插值</span></li><li checked="true" id="8eeed69d6492556fbea91c72881e50e7"><span class="ne-text">删除</span></li><li checked="true" id="fd5154d1130614337170b6352b00cc10"><span class="ne-text">打印</span></li><li checked="true" id="9c3c22c01869ff0d25e899ab92ffe053"><strong><span class="ne-text">逆置</span></strong></li></ul><p id="efde38cb18c702fbc13b193fd111d4a5" class="ne-p"><span class="ne-text">逆置多用前插的思想</span></p><pre data-language="cpp" id="P73E6" class="ne-codeblock language-cpp">void ReverseList(LinkList &L) {<br>LNode *p = L->next;<br> L->next = NULL;<br> while(p) {<br>LinkList q = p->next;<br> p->next = L->next;<br> L->next = p;<br> p = q;<br> }<br>}</pre><p id="85d0a02ed4a1f5c0e36e8c9878c2b016" class="ne-p"><span class="ne-text">所有操作如下</span></p><pre data-language="cpp" id="b4dEl" class="ne-codeblock language-cpp">#include<bits/stdc++.h><br>using namespace std;</p><p>/**</p><ul><li>单链表</li><li></li><li>链表的基本操作：初始化、创建（前插、后插）、取值、查找、插值、删除、打印、逆置<br>*/</li></ul><p>/_ 单链表的存储结构 _/<br>typedef struct LNode {<br>int data; //数据域<br>struct LNode *next; //指针域<br>}Lnode, *LinkList; //LinkList 为指向结构体 LNode 的指针类型</p><p>/_ 初始化链表 _/<br>void InitList(LinkList &amp;L) {<br>L = new LNode;<br>L-&gt;next = NULL;<br>}</p><p>/_ 创建：前插 _/<br>void CreateList_H(LinkList &amp;L, int n) {<br>InitList(L);<br>for (int i = 0; i &lt; n; i++){<br>LNode *p = new LNode;<br>cin &gt;&gt; p-&gt;data;<br>p-&gt;next = L-&gt;next;<br>L-&gt;next = p;<br>}<br>}</p><p>/_ 创建：后插 _/<br>void CreateList_R(LinkList &amp;L, int n) {<br>cout &lt;&lt; “请输入” &lt;&lt; n &lt;&lt; “个数字”&lt;&lt; “\n”;<br>InitList(L);<br>// 定义一个在下面循环用来一直操作所加元素的结点 p 来指向头结点 L<br>LinkList p = L;<br>for (int i = 0; i &lt; n;i++) {<br>LinkList q = new Lnode;<br>q-&gt;next = NULL;<br>cin &gt;&gt; q-&gt;data;<br>p-&gt;next = q;<br>p = q; //为了下一次<br>}<br>}</p><p>/_ 取值 _/<br>void GetElem(LinkList &amp;L, int n) {<br>LinkList p = L;<br>for (int i = 0; i &lt; n;i++){<br>p = p-&gt;next;<br>}<br>cout &lt;&lt;n&lt;&lt;”的值为：” &lt;&lt; p-&gt;data&lt;&lt;”\n”&lt;&lt;”\n”;<br>}</p><p>/_ 查找 _/<br>void SearchElem(LinkList &amp;L, int ele) {<br>LinkList p = L;<br>int count = 0;<br>while (p-&gt;data != ele) {<br>p = p-&gt;next;<br>count++;<br>}<br>cout &lt;&lt;ele&lt;&lt;”这个值的索引位置是：”&lt;&lt; count&lt;&lt;”\n”;<br>}</p><p>/_ 插值：在第 n 个位置插入 ele 值_/<br>void ListInsert(LinkList &amp;L, int n, int ele){<br>LinkList p = L;<br>for (int i = 0; i &lt; n;i++) {<br>if (n == i+1){<br>LinkList temp = new LNode;<br>temp-&gt;data = ele;<br>temp-&gt;next = p-&gt;next;<br>p-&gt;next = temp;<br>break;<br>}<br>p = p-&gt;next;<br>}<br>TraverseList(L);<br>}</p><p>/_ 删除：删除第 j 个位置的值 _/<br>void ListDelete(LinkList &amp;L, int j){<br>LinkList p = L;<br>for (int i = 0; i &lt; j;i++) {<br>if (j == i+1) {<br>p-&gt;next = p-&gt;next-&gt;next;<br>break;<br>}<br>p = p-&gt;next;<br>}<br>TraverseList(L);<br>}</p><p>/_ 打印 _/<br>void TraverseList(LinkList &amp; L){<br>LNode _p = new LNode;<br>p = L-&gt;next;<br>cout &lt;&lt; “此链表打印的结果为：”<br>&lt;&lt; “\n”;<br>while (p != NULL)<br>{<br>cout &lt;&lt; p-&gt;data &lt;&lt; “ “;<br>p = p-&gt;next;<br>}<br>cout &lt;&lt; “\n”;<br>}<br>/_ 逆置 */<br>void ReverseList(LinkList &amp;L) {<br>LNode *p = L-&gt;next;<br> L-&gt;next = NULL;<br> while(p)<br> {<br>LNode *q = p-&gt;next;<br> p-&gt;next = L-&gt;next;<br> L-&gt;next = p;<br> p = q;<br> }<br>cout &lt;&lt; “通过逆置之后……”;<br>TraverseList(L);<br>}</p><p>int main() {<br>// LNode *test = new LNode;<br>LinkList test;<br>// struct LNode *test;<br>CreateList_R(test,4);<br>SearchElem(test, 3);<br>// cout &lt;&lt; GetEle(test, 2);<br>// TraverseList(test);<br>// GetElem(test,2);<br>// ListInsert(test);<br>// ListDelete(test);<br>// ReverseList(test);<br>}</pre><h3 id="9cNHm"><span class="ne-text">循环链表代码</span></h3><p id="549db6ef0c251cb77027ad7d5eaff608" class="ne-p"><span class="ne-text"> * 循环链表其实只需要注意最后一个结点所指向的下一个结点为头结点 L 就好了</span></p><p id="da588e22a9aeca27b818a25ed2e924a5" class="ne-p"><span class="ne-text"> * 还要注意头结点存不存元素</span></p><p id="e50f21c2f1c86db9888257f67c4fc1a7" class="ne-p"><span class="ne-text"> * 还有判断的时候条件不是单链表那样判断是否为空了，而是是否为头结点的值了</span></p><pre data-language="cpp" id="qJV3k" class="ne-codeblock language-cpp">#include<bits/stdc++.h><br>using namespace std;</p><p>/**</p><ul><li>循环链表</li><li></li><li>循环链表其实只需要注意最后一个结点所指向的下一个结点为头结点 L 就好了</li><li>还要注意头结点存不存元素</li><li>还有判断的时候条件不是单链表那样判断是否为空了，而是是否为头结点的值了<br>*/</li></ul><p>/_ 定义一个单链表 _/<br>typedef struct LNode {<br>int data;<br>struct LNode *next;<br>}Lnode, *LinkList;</p><p>/**</p><ul><li>初始化单链表<br>*/<br>void InitList(LinkList &amp;L) {<br>L = new LNode;<br>L-&gt;next = NULL;<br>}</li></ul><p>/**</p><ul><li>初始化单链表并将其变成循环链表<br>*/</li></ul><p>void CircleList(LinkList &amp;L, int n) {<br>InitList(L);<br>// 初始化第一个结点的值<br>L-&gt;data = 1;<br>LinkList p = L;<br>for (int i = 2; i &lt;= n; i++) {<br>LinkList temp = new Lnode;<br>temp-&gt;data = i;<br>if (i == n) {<br>temp-&gt;next = L;<br>p-&gt;next = temp;<br>break;<br>}<br>temp-&gt;next = NULL;<br>p-&gt;next = temp;<br>p = p-&gt;next;<br>}<br>}</p><p>/**</p><ul><li>打印输出用来测试是否为循环链表<br>*/<br>void PrintList(LinkList &amp;L, int n) {<br>LinkList p = L;<br>for (int i = 0; i &lt; n;i++) {<br>cout &lt;&lt; p-&gt;data &lt;&lt; “ “;<br>p = p-&gt;next;<br>}<br>}</li></ul><p>int main() {<br>LinkList test;<br>CircleList(test,5);<br>PrintList(test, 12);<br>}</pre><p id="ff79e6e706f18ea894d0ae5a945a8faa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618307254729-8f60bc5d-be41-47fe-a2ad-466715cc740e.png" width="298" id="w18Z2" class="ne-image"></p><h3 id="oJUke"><span class="ne-text">双向链表代码</span></h3><ul class="ne-ul"><li id="7af3cafdf043e6e1bf6359aa4e769148"><span class="ne-text">双向链表从某种意义上来说，更加简单了，因为可操作的“指向更多了”，但正因为这样，所以每次指向操作之后，检查一下有没有“落单的指向”</span></li><li id="86ad4ef024a48d73c326810ae865c10b"><span class="ne-text">删除某个结点的时候，一定要记得删除哪个结点，就操作哪个结点</span></li></ul><pre data-language="cpp" id="dTPE1" class="ne-codeblock language-cpp">#include<bits/stdc++.h><br>using namespace std;</p><p>/**</p><ul><li>双向链表<br>*/</li></ul><p>/_ 双向链表的存储结构 _/<br>typedef struct DuLNode {<br>int data;<br>struct DuLNode *prior;<br>struct DuLNode *next;<br>}DuLnode, *DuLinkList;</p><p>/_ 双向链表的初始化 _/<br>void InitDuLinkList(DuLinkList &amp;L) {<br>L = new DuLNode;<br>L-&gt;prior = NULL;<br>L-&gt;next = NULL;<br>}</p><p>int main() {<br>DuLinkList L;<br>InitDuLinkList(L);<br>// 初始化初始节点值为 100<br>L-&gt;data = 100;<br>// 在 L 结点前面插值 50<br>DuLinkList L_prior;<br>L_prior-&gt;data = 50;<br>L_prior-&gt;next = L;<br>L-&gt;prior = NULL;<br>L-&gt;prior = L_prior;<br>// 在 L 结点后面插值 150<br>DuLinkList L_next;<br>L_next-&gt;data = 150;<br>L_next-&gt;prior = L;<br>L_next-&gt;next = NULL;<br>L-&gt;next = L_next;<br>cout &lt;&lt; L_prior-&gt;data &lt;&lt; “ “ &lt;&lt; L_prior-&gt;next-&gt;data &lt;&lt; “ “ &lt;&lt; L_prior-&gt;next-&gt;next-&gt;data&lt;&lt;”\n”;<br>// 在 50 和 100 之间插值 75（只操作 L 结点）<br>DuLinkList L_prior_L;<br>L_prior_L-&gt;data = 75;<br>L_prior_L-&gt;prior = L-&gt;prior;<br>L-&gt;prior-&gt;next = L_prior_L;<br>L_prior_L-&gt;next = L;<br>L-&gt;prior = L_prior_L;<br>cout &lt;&lt; L-&gt;prior-&gt;prior-&gt;data &lt;&lt; “ “ &lt;&lt; L-&gt;prior-&gt;data &lt;&lt; “ “ &lt;&lt; L-&gt;data &lt;&lt;” “&lt;&lt; L-&gt;next-&gt;data&lt;&lt;”\n”;<br>// 删除 75 这个值的结点(记住一点，删除哪个结点就操作哪个结点)<br>L_prior_L-&gt;next-&gt;prior = L_prior_L-&gt;prior;<br>L_prior_L-&gt;prior-&gt;next = L_prior_L-&gt;next;<br>cout &lt;&lt; L-&gt;prior-&gt;data &lt;&lt; “ “ &lt;&lt; L-&gt;data &lt;&lt; “ “ &lt;&lt; L-&gt;next-&gt;data &lt;&lt; “\n”;<br>}</pre><p id="f11573736063c8fe96bf5ee924812cba" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618309282126-1ad3d5c4-1d3e-425f-b474-27f33261ead6.png" width="263" id="cIkbQ" class="ne-image"></p><h2 id="fi44g"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="62da17fbdf777d52c0d1361001a230c1"><a href="http://shangdixinxi.com/detail-1507915.html" data-href="http://shangdixinxi.com/detail-1507915.html" target="_blank" class="ne-link"><span class="ne-text">链表 p-&gt;next=q-&gt;next,q-&gt;next=p,q=p;的一些解释</span></a></li><li id="fc4623d0caae8ec3ef1caecb202218cf"><a href="https://blog.csdn.net/weixin_44135282/article/details/90348885" data-href="https://blog.csdn.net/weixin_44135282/article/details/90348885" target="_blank" class="ne-link"><span class="ne-text">p-&gt;next=q 与 q=p-&gt;next 区分</span></a></li><li id="47c085a3d88531803ecee1fec885d77d"><a href="https://www.jianshu.com/p/73d56c3d228c" data-href="https://www.jianshu.com/p/73d56c3d228c" target="_blank" class="ne-link"><span class="ne-text">数据结构：链表</span></a></li></ul><p id="0f9e0d8be38732af40953d37ead05312" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数-闭包-this指向</title>
      <link href="/blog/egols2d1kxs2/"/>
      <url>/blog/egols2d1kxs2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="741f292f93959d2a5eba207f29dc837c" class="ne-p"><span class="ne-text">前言：基本上和之前学过的语言一样，return语句、continue语句、break语句、函数的传参用法基本都一样，记录一下js的特征用法</span></p></div><h2 id="X8waC"><span class="ne-text">函数定义使用</span></h2><p id="72f9191dd6c40f9c957d08a6a4fb5fa6" class="ne-p"><span class="ne-text">不像之前的C++、JAVA那样需要一个返回值来声明，JavaScript里面直接一个关键字就搞定了，如果里面有return就返回return的值，没有则返回undefined。下面记录一下js里面的三种函数声明方式和不同情况下的使用场景。</span></p><h3 id="C0pXG"><span class="ne-text">function关键字</span></h3><div class="ne-quote"><p id="cac310a57f721c495201fd8f43fd717a" class="ne-p"><span class="ne-text">自定义函数方式(命名函数)利用函数关键字 function 自定义函数方式</span></p></div><pre data-language="javascript" id="BIKBs" class="ne-codeblock language-javascript">// 声明定义方式<p>function fn() {…}<br>// 调用<br>fn();</pre><ul class="ne-ul"><li id="f79542d89be6709192b07b467ab1226b"><span class="ne-text">调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</span></li></ul><h3 id="LMsru"><span class="ne-text">匿名函数表达式</span></h3><p id="uf48c7914" class="ne-p"><span class="ne-text">函数表达式方式(匿名函数）</span></p><div class="ne-quote"><p id="d040539e6b580f6af5b43432e1718261" class="ne-p"><span class="ne-text">【C++11 里面也有匿名函数的用法，基本上就是</span><strong><span class="ne-text">匿名函数表达式</span></strong><span class="ne-text">】</span></p></div><pre data-language="javascript" id="5BO64" class="ne-codeblock language-javascript">// 这是函数表达式写法，匿名函数后面跟分号结束<br>var fn = function(){...};<br>// 调用的方式，函数调用必须写到函数体下面<br>fn();</pre><ul class="ne-ul"><li id="d283d6025aa0cb9c95c9e5d6432ca365"><span class="ne-text">这个 fn 里面存储的是一个函数</span></li><li id="5426ae5b14dc2793b18c9f79bb1cf86b"><span class="ne-text">函数表达式方式原理跟声明变量方式是一致的</span></li><li id="80bea0e7c9c366bf13aed839abfac9c2"><span class="ne-text">函数调用的代码必须写到函数体后面</span></li></ul><h3 id="RafLV"><span class="ne-text">构造函数</span></h3><ul class="ne-ul"><li id="aeb9c9b1aab71e3be3ce5b0910474db7"><span class="ne-text">所有函数都是 Function 的对象，函数也是对象</span></li></ul><pre data-language="javascript" id="YARYs" class="ne-codeblock language-javascript">var f = new Function('a', 'b', 'console.log(a + b)');<br>f(1, 2);<br>var fn = new Function('参数 1','参数 2'..., '函数体')</pre><h3 id="vy7cQ"><span class="ne-text">立即调用函数</span></h3><p id="5148d536a7c1a11179e615efc56e2e60" class="ne-p"><span class="ne-text">两种表达方式</span></p><ul class="ne-ul"><li id="36fa351c2163d83b6a90d13c2618fe92"><span class="ne-text"> (function(){})()  </span></li><li id="1ce0be7bd7470e70e5278c30052f06d6"><span class="ne-text"> (function(){}())</span></li></ul><p id="a19ec8eb10a2ce44b348888c1c53d78c" class="ne-p"><span class="ne-text">与立即执行函数相关的知识还有在函数前面加上一些符号（！、<del>、+……）会对函数的返回值进行相应的操作，其中加上</del>的意思是对返回值进行按位取反的操作，具体参考下面的参考资料</span></p><p id="af6a791d49ed73883fdd481215144efd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617956106484-c021320c-100a-49b5-a668-99928bf3a720.png" width="472.98846435546875" id="ll11Y" class="ne-image"></p><p id="a0e31616764944a5de93ce19e4cc4c67" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/hot_cool/article/details/77567166" data-href="https://blog.csdn.net/hot_cool/article/details/77567166" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/hot_cool/article/details/77567166</span></a></p><p id="u336b8edc" class="ne-p"><br></p><h2 id="xa3mE"><span class="ne-text">函数参数</span></h2><h3 id="zek5T"><span class="ne-text">arguments</span></h3><p id="f311e77fa167c8ab1de5f667408fff32" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617851666624-a963acb7-8a97-43bc-9998-35738a1a1a7f.png" width="467.5" id="OVrKI" class="ne-image"></p><p id="d6a5429b661f0a926663653c08d5a96f" class="ne-p" style="text-indent: 2em"><span class="ne-text">当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments 实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments 展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</span></p><ul class="ne-ul"><li id="8843827210f3e42e9156792599a0c118"><span class="ne-text">具有 length 属性</span></li><li id="b11e149419c70d416f470742d52ad2ea"><span class="ne-text">按索引方式储存数据</span></li><li id="af2df2e4345f47f3086f4e9675aa2d5e"><span class="ne-text">不具有数组的 push , pop 等方法<br></span><span class="ne-text">注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。</span></li></ul><h3 id="tJe43"><span class="ne-text">箭头函数（ES6）里面的不同</span></h3><p id="d00f8bade49b871e8239cf73671daa98" class="ne-p"><span class="ne-text">es6 的箭头函数用起来很方便，但是一个不方便的就是在这里面</span><span class="ne-text">arguments 不能用了</span></p><p id="a1d8c49b30b7ae2677e321044c51a114" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852137156-ea361bcf-a64d-40e7-9ad4-de9ad5a2789d.png" width="464" id="FOFeI" class="ne-image"></p><p id="46c2b14c2b66de8578ce1092cd594b13" class="ne-p"><span class="ne-text">如果非要用的化，将这个箭头函数放在一个普通函数里面，让箭头函数接受这个普通函数的参数</span></p><p id="494bcad7a1c0a199d65391a31a8e438e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852218090-65cab2f5-0088-41e5-95fa-0845a253fcbd.png" width="377" id="kFJpX" class="ne-image"></p><h3 id="YcdT5"><span class="ne-text">关于值传递</span></h3><p id="828ba1738a54a70ab3e620409dd3bde3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852230127-5b2394d1-82c0-48a4-8bbb-385f5d27760b.png" width="406.5" id="Iq2ke" class="ne-image"></p><h2 id="aZMFF"><span class="ne-text">this</span></h2><h3 id="j2Uih"><span class="ne-text">几个常用 this 指向</span></h3><ul class="ne-ul"><li id="b12db0c1b44a96c0860ec712b67838a8"><span class="ne-text">全局作用域或者普通函数中 this 指向全局对象 window（定时器里面的 this 指向 window）</span></li><li id="d940230ffea7da43e23a70b95c5abe22"><span class="ne-text">方法调用中谁调用 this 指向谁</span></li><li id="3d0a596a8316330855355f25214d49d7"><span class="ne-text">构造函数中 this 指向构造函数的实例</span></li></ul><pre data-language="javascript" id="47qo4" class="ne-codeblock language-javascript"><button>点击</button></p><script>// this 指向问题 一般情况下 this 的最终指向的是那个调用它的对象// 1. 全局作用域或者普通函数中 this 指向全局对象 window（ 注意定时器里面的 this 指向 window）console.log(this);function fn() {console.log(this);}window.fn();window.setTimeout(function() {console.log(this);}, 1000);// 2. 方法调用中谁调用 this 指向谁var o = {sayHi: function() {console.log(this); // this 指向的是 o 这个对象}}o.sayHi();var btn = document.querySelector('button');btn.addEventListener('click', function() {console.log(this); // 事件处理函数中的 this 指向的是 btn 这个按钮对象})// 3. 构造函数中 this 指向构造函数的实例function Fun() {console.log(this); // this 指向的是 fun 实例对象}var fun = new Fun();</script></pre><p id="acee41b3231a5d0b087b28aae39740b0" class="ne-p"><br></p><h3 id="PWOXa"><span class="ne-text">函数内部的 this 指向</span></h3><p id="5ca71d2a3c293a6c76dba7bc8e2f3fbf" class="ne-p" style="text-indent: 2em"><span class="ne-text">这些 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了 this 的指向不同</span></p><p id="0505f7440364baaeb67f7a21dfab8918" class="ne-p"><span class="ne-text">一般指向我们的调用者.</span></p><h3 id="8P2d3"><span class="ne-text">改变函数内部 this 指向</span></h3><div data-type="tips" class="ne-alert"><p id="c3b68770fa3125f0aae3e34d69aa612c" class="ne-p"><span class="ne-text">call 方法</span></p></div><p id="80cca7746d6e3f6ddfbe0d0a13db64e5" class="ne-p"><span class="ne-text">call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向</span></p><p id="7d682c1147cd95a30b2a202e05e6d44a" class="ne-p"><span class="ne-text">应用场景: 经常做继承.</span></p><pre data-language="javascript" id="yt6VQ" class="ne-codeblock language-javascript">var o = {<p>name: ‘andy’<br>}<br>function fn(a, b) {<br>console.log(this);<br>console.log(a+b)<br>};<br>fn(1,2)// 此时的 this 指向的是 window 运行结果为 3<br>fn.call(o,1,2)//此时的 this 指向的是对象 o,参数使用逗号隔开,运行结果为 3</pre><p id="f857770c3f6e97c4731a60811818efc7" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="54a10ff793707999589edafa83f3cd0b" class="ne-p"><span class="ne-text">apply 方法</span></p></div><p id="73b1a29ae377fe1ddecf267dd75876bc" class="ne-p"><span class="ne-text">apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。</span></p><p id="dd98af2b8f1c5e1042c608d46e2719dc" class="ne-p"><span class="ne-text">应用场景: 经常跟数组有关系</span></p><pre data-language="javascript" id="gPrtf" class="ne-codeblock language-javascript">var o = {<br>name: 'andy'<br>}<br>function fn(a, b) {<br>console.log(this);<br>console.log(a+b)<br>};<br>fn()// 此时的 this 指向的是 window 运行结果为 3<br>fn.apply(o,[1,2])//此时的 this 指向的是对象 o,参数使用数组传递 运行结果为 3</pre><p id="53fa2bc8a501d0ec0f451dd46503c36c" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="2d7e30779f32aca48ba123fbc41b2649" class="ne-p"><span class="ne-text">bind 方法</span></p></div><p id="8f2d73d4ff5434244e4816d57d2cb70f" class="ne-p"><span class="ne-text">bind() 方法不会调用函数,但是能改变函数内部 this 指向,返回的是原函数改变 this 之后产生的新函数</span></p><p id="ba3ad094ba0a2a1de54306a05a4b328d" class="ne-p"><span class="ne-text">如果只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind</span></p><p id="8b4f288bfc20dcaa6db7eb9f1f5a02c5" class="ne-p"><span class="ne-text">应用场景:不调用函数,但是还想改变 this 指向</span></p><pre data-language="javascript" id="b7gTh" class="ne-codeblock language-javascript">var o = {<br>name: 'andy'<br>};<br>function fn(a, b) {<br>console.log(this);<br>console.log(a + b);<br>};<br>var f = fn.bind(o, 1, 2); //此处的 f 是 bind 返回的新函数<br>f();//调用新函数 this 指向的是对象 o 参数使用逗号隔开</pre><p id="bbe02b5b391e078302a1b7380c4013f6" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="4b0f89ed2e398c0417e89d133847b189" class="ne-p"><span class="ne-text">call、apply、bind 三者的异同</span></p></div><ul class="ne-ul"><li id="837bea232f7b27b17dfc1aad61300dca"><span class="ne-text">共同点 : 都可以改变 this 指向</span></li><li id="a9e715db538e1cdabc5c18c1fa0b36bc"><span class="ne-text">不同点:</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="19a7e4c1e6fc48212336c8fef1dac5ad"><span class="ne-text">call 和 apply 会调用函数, 并且改变函数内部 this 指向.</span></li><li id="466f286b25babfe9a43ac9c4a313764e"><span class="ne-text">call 和 apply 传递的参数不一样,call 传递参数使用逗号隔开,apply 使用数组传递</span></li><li id="06600e50bdef14fb975e1c3fa12d4f53"><span class="ne-text">bind 不会调用函数, 可以改变函数内部 this 指向.</span></li></ul></ul><ul class="ne-ul"><li id="6da2dd93023b14ff4a91066c042741e8"><span class="ne-text">应用场景</span></li></ul><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="8b224e2fbc010eec2cfde9212337b809"><span class="ne-text">call 经常做继承.</span></li><li id="40e7f61a43b0d91c0459283a016ca67d"><span class="ne-text">apply 经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值</span></li><li id="83fdbccdc3765ef1b5c93004952744e1"><span class="ne-text">bind 不调用函数,但是还想改变 this 指向. 比如改变定时器内部的 this 指向.</span></li></ol></ol><h2 id="XDIRK"><span class="ne-text">闭包</span></h2><p id="76c889831aab9d05eb52cec950336aca" class="ne-p" style="text-indent: 2em"><span class="ne-text">闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。</span></p><h3 id="Jc7Sk"><span class="ne-text">闭包的作用</span></h3><p id="63e908510a6aff59e9327379faa2435c" class="ne-p"><span class="ne-text">作用：延伸变量的作用范围。</span></p><pre data-language="javascript" id="NySmI" class="ne-codeblock language-javascript">function fn() {<br>var num = 10;<br>function fun() {<br>console.log(num);<br>}<br>return fun;<br>}<br>var f = fn();<br>f();</pre><h3 id="1doFa"><span class="ne-text">闭包的案例</span></h3><ol class="ne-ol"><li id="a3a8e47a2abddf99014bff26562b3108"><span class="ne-text">利用闭包的方式得到当前 li 的索引号</span></li></ol><pre data-language="javascript" id="RIEd9" class="ne-codeblock language-javascript">for (var i = 0; i < lis.length; i++) {<br>// 利用 for 循环创建了 4 个立即执行函数<br>// 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的 i 这变量<br>(function(i) {<br>lis[i].onclick = function() {<br>console.log(i);<br>}<br>})(i);<br>}</pre><ol start="2" class="ne-ol"><li id="e23058120f4f4379a7b8c6e3ee120611"><span class="ne-text">闭包应用-3 秒钟之后,打印所有 li 元素的内容</span></li></ol><pre data-language="javascript" id="NyWEd" class="ne-codeblock language-javascript">for (var i = 0; i < lis.length; i++) {<br>(function(i) {<br>setTimeout(function() {<br>console.log(lis[i].innerHTML);<br>}, 3000)<br>})(i);<br>}</pre><ol start="3" class="ne-ol"><li id="9ada127ae1595d7d5d1f035287cb5726"><span class="ne-text">闭包应用-计算打车价格</span></li></ol><pre data-language="javascript" id="BCxTX" class="ne-codeblock language-javascript">/<em>需求分析<br>打车起步价 13(3 公里内), 之后每多一公里增加 5 块钱. 用户输入公里数就可以计算打车价格<br>如果有拥堵情况,总价格多收取 10 块钱拥堵费</em>/<br>var car = (function() {<br>var start = 13; // 起步价 局部变量<br>var total = 0; // 总价 局部变量<br>return {<br>// 正常的总价<br>price: function(n) {<br>if (n <= 3) {<br>total = start;<br>} else {<br>total = start + (n - 3) * 5<br>}<br>return total;<br>},<br>// 拥堵之后的费用<br>yd: function(flag) {<br>return flag ? total + 10 : total;<br>}<br>}<br>})();<br>console.log(car.price(5)); // 23<br>console.log(car.yd(true)); // 33</pre><p id="98b2a169a1398d289874189535e94975" class="ne-p"><br></p><pre data-language="javascript" id="1WZWK" class="ne-codeblock language-javascript">var name = "The Window";<br>var object = {<br>name: "My Object",<br>getNameFunc: function() {<br>return function() {<br>return this.name;<br>};<br>}<br>};<br>console.log(object.getNameFunc()())</p><hr><p>var name = “The Window”;　　<br>var object = {　　　　<br>name: “My Object”,<br>getNameFunc: function() {<br>var that = this;<br>return function() {<br>return that.name;<br>};<br>}<br>};<br>console.log(object.getNameFunc()())</pre><p id="9d3b3410f572bb95a27cf75f4bc16f5d" class="ne-p"><br></p><p id="c99db74015489c411a45aab092ab8b45" class="ne-p"><br></p><h2 id="drews"><span class="ne-text">简单/复杂数据类型传参</span></h2><ul class="ne-ul"><li id="u3f03e3b1"><span class="ne-text"></span><strong><span class="ne-text">简单类型</span></strong><span class="ne-text">（</span><strong><span class="ne-text">基本数据类型</span></strong><span class="ne-text">、</span><strong><span class="ne-text">值类型</span></strong><span class="ne-text">）：在存储时变量中存储的是值本身，包括 string ，number，boolean，undefined，null</span></li><li id="ua853b290"><span class="ne-text"></span><strong><span class="ne-text">复杂数据类型（引用类型）</span></strong><span class="ne-text">：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date 等；</span></li></ul><h3 id="TR3ye"><span class="ne-text">堆栈存储区别</span></h3><p id="81a4f5e06d7fb3b1d78eb160e037ac51" class="ne-p"><span class="ne-text">堆栈空间分配区别：</span></p><p id="aaca0ece83eb7fc7a8610be2adafec5a" class="ne-p"><span class="ne-text">1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；</span></p><p id="bcf03f86ff5f2855c34f14206674e29d" class="ne-p"><span class="ne-text">简单数据类型存放到栈里面</span></p><p id="dbf7d1d8a139ba0922a21d517281e01e" class="ne-p"><span class="ne-text">2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。</span></p><p id="ae62426ee17d5b255182ff89454fc547" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885075555-12234777-10f8-4df1-8a9f-e61078298520.png" width="238" id="N6D51" class="ne-image"></p><p id="254b18f5f99f00234b14878536031e72" class="ne-p"><span class="ne-text">简单数据类型的存储方式：值类型变量的数据直接存放在变量（栈空间）中</span></p><p id="e63b41dc6c62c39fdabfa2c065146e1d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885085102-7ebb3c36-ffc2-4a5b-af50-c8e377f92cef.png" width="394.5" id="hEv5b" class="ne-image"></p><p id="f042d4f33b74c11180f2bf221e2d4438" class="ne-p"><span class="ne-text">复杂数据类型的存储方式：引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中</span></p><p id="ca80154cc8f1848753dcb8a28ae874dd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885116525-3f8ac293-e955-40f9-bbff-1aa589b53efa.png" width="279" id="ZXK4X" class="ne-image"></p><h3 id="afg8t"><span class="ne-text">简单类型传参</span></h3><p id="47e6b97b01f093975de2d0e8f7f61bd9" class="ne-p"><span class="ne-text">函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</span></p><pre data-language="javascript" id="ZLjqe" class="ne-codeblock language-javascript">function fn(a) {<br>a++;<br>console.log(a);<br>}<br>var x = 10;<br>fn(x);<br>console.log(x)；</pre><p id="825dee36f870419103612cd3e291c9b6" class="ne-p"><span class="ne-text">运行结果如下：</span></p><p id="e455c606cc8f7c864fb2b02defa90e8c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885126655-4b3507e8-a666-4dae-b1c5-ecd0ad9f8bdb.png" width="182" id="E6Jxe" class="ne-image"></p><h3 id="EAU0I"><span class="ne-text">复杂数据类型传参</span></h3><p id="a3b4fba5364cfeca5f5daaa0fdc6e01a" class="ne-p"><span class="ne-text">函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</span></p><pre data-language="javascript" id="kz5P4" class="ne-codeblock language-javascript">function Person(name) {<br>this.name = name;<br>}<br>function f1(x) { // x = p<br>console.log(x.name); // 2. 这个输出什么 ?<br> x.name = "张学友";<br>console.log(x.name); // 3. 这个输出什么 ?<br>}<br>var p = new Person("刘德华");<br>console.log(p.name); // 1. 这个输出什么 ?<br>f1(p);<br>console.log(p.name); // 4. 这个输出什么 ?</pre><p id="9236420fb92f5854644e4fb0ec3cf066" class="ne-p"><span class="ne-text"> 运行结果如下：</span></p><p id="242455bd52335173b5d68c04e769b14d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885137269-b37442f2-ea5b-45ce-a974-ff4676772c47.png" width="172.5" id="qL1s3" class="ne-image"></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DOM事件</title>
      <link href="/blog/wgzidzz85o76/"/>
      <url>/blog/wgzidzz85o76/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="QPRCY"><span class="ne-text">事件（低阶）</span></h2><div class="ne-quote"><p id="ba969457d3d481f4f58736bd6c36d828" class="ne-p"><span class="ne-text">事件三要素</span></p></div><ul class="ne-ul"><li id="5e185517246fffbef0739fa305e1a269"><span class="ne-text" style="background-color: #FADB14">Who(</span><span class="ne-text">事件源)：触发事件的元素</span></li><li id="896a369ca82ab809872eecb47593fe13"><span class="ne-text" style="background-color: #FADB14">What(</span><span class="ne-text">事件类型)： eg绑定click点击事件</span></li><li id="185614550c2f6249c6397a554774211d"><span class="ne-text" style="background-color: #FADB14">How(</span><span class="ne-text">事件处理程序)：事件触发后要执行的代码(函数赋值形式)，事件处理函数</span><strong><span class="ne-text"></span></strong></li></ul><p id="5b2cd1a827b3b52e697f8f9935da47fd" class="ne-p"><br></p><h3 id="QFfkk"><span class="ne-text">常见鼠标事件</span></h3><p id="3e300ab9705fb9183b85eece5ca6ad37" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518355975-babb3ede-4626-4ccd-9507-eb4c35c58439.png" width="714" id="lEgEZ" class="ne-image"></p><p id="952b40b9aa1db2e537818188929e4df5" class="ne-p"><br></p><h3 id="ATUpr"><span class="ne-text">addEventListener()</span></h3><div class="ne-quote"><p id="0d6e9dee2f34c5c515d1092ee25274a5" class="ne-p"><span class="ne-text">事件监听（IE9以后支持）</span></p></div><p id="73fd37530a6735c2e2dcaa5f9cc34d55" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360715-05c708e0-db51-4791-b3cc-14ca89b6d9bc.png" width="707" id="ioKxV" class="ne-image"></p><p id="eea6d93e364e9871dd6af834731635c1" class="ne-p"><span class="ne-text">eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。</span></p><ul class="ne-ul"><li id="a00280620bc4a8d0742c710aafb1252f"><span class="ne-text">type：监听事件类型click……（不要加on，要记得加引号）</span></li><li id="250ea7b30c98112381216e44c2987bb9"><span class="ne-text">listener：监听函数（触发之后进行什么样的行为（函数））</span></li><li id="b55cfb7798c0b34c00b574f86e6cde65"><span class="ne-text">useCapture：默认false</span></li></ul><pre data-language="javascript" id="tbntn" class="ne-codeblock language-javascript">var class_down = document.getElementsByClassName('entry-thumb');<p>var over_img_back_index = class_down[0].getElementsByTagName(‘img’);<br>over_img_back_index[0].addEventListener(‘mouseover’,function(){<br>alert(‘鼠标经过左侧图片，触发至即将跳转到首页’);<br>location.href = ‘<a href="https://www.wztlink1013.com&/#39;">https://www.wztlink1013.com&#39;</a>;<br>})</pre><h3 id="pAK2G"><span class="ne-text">attachEvent()</span></h3><div class="ne-quote"><p id="168bdd41b35757469d9dd7d566cacdda" class="ne-p"><span class="ne-text">事件监听（IE678 支持）</span></p></div><p id="u93000583" class="ne-p"><span class="ne-text"></span></p><p id="56c0ebbd489fba897b85e1086fa6c3e8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360822-32bdd41a-9d13-4b76-93db-3f503b39bba7.png" width="696" id="azBrz" class="ne-image"></p><ul class="ne-ul"><li id="a2aa1adbfb03ca99b8a253c85e02926a"><span class="ne-text">和 addEventListener()功能一样，不过这是老版本只带两个参数，而且第一个参数要加 on</span></li></ul><h3 id="w1NHT"><span class="ne-text">兼容性解决注册事件</span></h3><p id="1fbe85f60da132b1ec60b147994d8381" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360652-874303ea-a903-4f8c-93a0-a90c193c661b.png" width="867" id="mEfG9" class="ne-image"></p><p id="dd0475da28d2a7081f17bd64d0f74b23" class="ne-p"><span class="ne-text">封装一个函数，函数中判断浏览器的类型：</span></p><p id="f4837a32f19fbc68970b1d134989a6c5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360935-9054e419-704a-402e-969c-a572f0f322e0.png" width="643" id="jojyL" class="ne-image"></p><h3 id="3zq4i"><span class="ne-text">解绑事件</span></h3><p id="16781f9f62f480e76938fbb67d0bffc2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360992-53947cad-916b-4b2a-baf9-0587c30a33d9.png" width="737" id="ZW5u1" class="ne-image"></p><pre data-language="html" id="5wm39" class="ne-codeblock language-html"><div>1</div></p><div>2</div><div>3</div><script>  var divs = document.querySelectorAll('div');  divs[0].onclick = function() {    alert(11);    // 1. 传统方式删除事件    divs[0].onclick = null;  }  // 2. removeEventListener 删除事件  divs[1].addEventListener('click', fn) // 里面的fn 不需要调用加小括号  function fn() {    alert(22);    divs[1].removeEventListener('click', fn);  }  // 3. detachEvent  divs[2].attachEvent('onclick', fn1);  function fn1() {    alert(33);    divs[2].detachEvent('onclick', fn1);  }</script></pre><div class="ne-quote"><p id="2ff54bd1d4bd426868a23a25308db2a6" class="ne-p"><strong><span class="ne-text">删除事件兼容性解决方案 </span></strong></p></div><p id="40666cbe6d5320d4846b4bbe5e2ff46b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361056-6ce22708-00af-43e8-943d-466fe8fcb053.png" width="713" id="hJ2YZ" class="ne-image"></p><h2 id="r3xe0"><span class="ne-text">常用鼠标事件</span></h2><p id="002c7cabdc9a78deb3d591b99f27e8d6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361860-3dea106f-9140-4836-8e7d-2f160b94435b.png" width="683" id="TkrRA" class="ne-image"></p><h3 id="QuEUR"><span class="ne-text">Demo：禁止选中文字和禁止右键菜单</span></h3><div class="ne-quote"><p id="f79c18b0892e2b84000032b48fe1e47b" class="ne-p"><span class="ne-text">【1】禁止鼠标选中</span></p></div><ul class="ne-ul"><li id="7125b6c7239ac18b49da8bb1898ca4f2"><span class="ne-text">selectstart开始选中</span></li></ul><pre data-language="javascript" id="JF2Dy" class="ne-codeblock language-javascript">document.addEventListener('selectstart', function(e) {  e.preventDefault();})</pre><div class="ne-quote"><p id="fc494d880867d15513a5bffa1c8f808d" class="ne-p"><span class="ne-text">【2】禁止鼠标右键菜单</span></p></div><ul class="ne-ul"><li id="8eb5f8e6b193f716efeae0d29de53e3b"><span class="ne-text">contextmenu主要控制应该合适显示上下文菜单，主要用于程序员取消默认的上下文菜单</span></li></ul><pre data-language="javascript" id="SR42e" class="ne-codeblock language-javascript">document.addEventListener('contextmenu', function(e) {    e.preventDefault();})</pre><h3 id="YIozD"><span class="ne-text">鼠标事件对象</span></h3><p id="4c842015ad6ac6e4f69e5e72c2cae205" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361978-034f2af6-14fa-4ddb-bd8b-2eabe289eb59.png" width="703" id="GXMNi" class="ne-image"></p><h3 id="kM6Ej"><span class="ne-text">Demo：获取鼠标在页面的坐标</span></h3><pre data-language="html" id="0uzRv" class="ne-codeblock language-html"><script>  // 鼠标事件对象 MouseEvent  document.addEventListener('click', function(e) {    console.log('client 鼠标在可视区的x和y坐标');    console.log(e.clientX);    console.log(e.clientY);    console.log('---------------------');    console.log('page 鼠标在页面文档的x和y坐标');    console.log(e.pageX);    console.log(e.pageY);    console.log('---------------------');    console.log('screen 鼠标在电脑屏幕的x和y坐标');    console.log(e.screenX);    console.log(e.screenY);  })</script></pre><h3 id="No1zU"><span class="ne-text">Demo：跟随鼠标的天使</span></h3><p id="e5107b269c65ccd796700aad3cc81a1e" class="ne-p"><br></p><pre data-language="html" id="ayNMj" class="ne-codeblock language-html"><img src="images/angel.gif" alt="">    <script>        var pic = document.querySelector('img');        document.addEventListener('mousemove', function(e) {            // 1. mousemove只要我们鼠标移动1px 就会触发这个事件            // 2.核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标，             // 把这个x和y坐标做为图片的top和left 值就可以移动图片            var x = e.pageX;            var y = e.pageY;            console.log('x坐标是' + x, 'y坐标是' + y);            //3 . 千万不要忘记给left 和top 添加px 单位            pic.style.left = x - 50 + 'px';            pic.style.top = y - 40 + 'px';        });    </script></pre><h3 id="cDws0"><span class="ne-text">mouseenter 和mouseover的区别</span></h3><ul class="ne-ul"><li id="88c115b01a2b6c236f234cf08ef5d7d4"><span class="ne-text">当鼠标移动到元素上时就会触发mouseenter 事件</span></li><li id="f8f15a01a6862e22ba659b724cfd8ce0"><span class="ne-text">类似 mouseover，它们两者之间的差别是</span></li><li id="773ac692fd2f9810e9ed2196af203c10"><span class="ne-text">mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter  只会经过自身盒子触发</span></li><li id="9e4be62c339051eaa945e719c5ba2524"><span class="ne-text">之所以这样，就是因为mouseenter不会冒泡</span></li><li id="696b59f226bc1326eb53ca8b7fa62a5a"><span class="ne-text">跟mouseenter搭配鼠标离开 mouseleave  同样不会冒泡</span></li></ul><h2 id="ct83k"><span class="ne-text">常用键盘事件</span></h2><p id="326f5221d3d3f4d8a6981a19890f683d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362322-f21797ca-1e8e-4702-a243-4e76a8458b7e.png" width="701" id="vLAKo" class="ne-image"></p><ul class="ne-ul"><li id="bd4e3c484424ef8f908369b4086c14b5"><span class="ne-text">三个事件执行的顺序是：keydown->keypress->keyup</span></li></ul><pre data-language="html" id="fMkzy" class="ne-codeblock language-html"><script>        // 常用的键盘事件        //1. keyup 按键弹起的时候触发         document.addEventListener('keyup', function() {            console.log('我弹起了');        })        //3. keypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊        document.addEventListener('keypress', function() {                console.log('我按下了press');        })        //2. keydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊        document.addEventListener('keydown', function() {                console.log('我按下了down');        })        // 4. 三个事件的执行顺序  keydown -- keypress -- keyup    </script></pre><h3 id="Gb0Dv"><span class="ne-text">键盘事件对象</span></h3><p id="8945a6b3aa40369f48ed4e09c58901ba" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362443-95c05d9c-6850-4cc3-a35e-c972b1723658.png" width="700" id="rFUEV" class="ne-image"></p><ul class="ne-ul"><li id="7d80cbe4fe5226cfa7abf4481adc48cd"><span class="ne-text">onkeydown和onkeyup不区分字母大小写，onkeypress区分字母大小写（使用更多的前面两个，能够识别所有键，包括功能键）</span></li><li id="f3ee963cc37dc5d79e3bd27018a9b9c6"><span class="ne-text">keypress不识别功能键，但是keyCode属性能够区分大小写，返回不同的ASCII值</span></li></ul><div class="ne-quote"><p id="cadf8aec7e3856d6ce4b3258b5538441" class="ne-p"><strong><span class="ne-text">使用keyCode属性判断用户按下哪个键</span></strong></p></div><pre data-language="html" id="EdtbF" class="ne-codeblock language-html"><script>        // 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值        document.addEventListener('keyup', function(e) {            console.log('up:' + e.keyCode);            // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键            if (e.keyCode === 65) {                alert('您按下的a键');            } else {                alert('您没有按下a键')            }        })        document.addEventListener('keypress', function(e) {            // console.log(e);            console.log('press:' + e.keyCode);        })    </script></pre><h3 id="qworo"><span class="ne-text">Demo：模拟京东按键输入内容</span></h3><ul class="ne-ul"><li id="7565f06c60c84c01f09d86ad4c9c2972"><span class="ne-text">当我们按下 s 键， 光标就定位到搜索框（文本框获得焦点）。</span></li><li id="c3d8fb836327ccbbbae84a01cba915de"><span class="ne-text">注意：触发获得焦点事件，可以使用 元素对象.focus()</span></li></ul><p id="8c611ea4d1f59d20b33b39115f4fbe00" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616211826182-452dfe9b-0c03-4fe3-845c-afc16697e3ee.png" width="960" id="Zx9kR" class="ne-image"></p><h3 id="ZG4dd"><span class="ne-text">Demo：模拟京东快递单号查询</span></h3><p id="84fd26f435a94167f2954643790cdfe9" class="ne-p"><span class="ne-text">要求：当我们在文本框中输入内容时，文本框上面自动显示大字号的内容。</span></p><p id="9429f4798d18e4859b4475998d830317" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362646-5b0c1da3-32dd-40b4-8b42-1bbb3065c01c.png" width="551" id="GMhtr" class="ne-image"></p><p id="ea68715abcd7776b25fa92976ecbb098" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362734-9740cabb-bd4d-48ce-824d-001b5913b804.png" width="751" id="wAggT" class="ne-image"></p><pre data-language="javascript" id="I71ps" class="ne-codeblock language-javascript"><div class="search">        <div class="con">123</div>        <input type="text" placeholder="请输入您的快递单号" class="jd">    </div>    <script>        // 获取要操作的元素        var con = document.querySelector('.con');        var jd_input = document.querySelector('.jd');        // 给输入框注册keyup事件        jd_input.addEventListener('keyup', function() {                // 判断输入框内容是否为空                if (this.value == '') {                    // 为空，隐藏放大提示盒子                    con.style.display = 'none';                } else {                    // 不为空，显示放大提示盒子，设置盒子的内容                    con.style.display = 'block';                    con.innerText = this.value;                }            })        // 给输入框注册失去焦点事件，隐藏放大提示盒子        jd_input.addEventListener('blur', function() {                con.style.display = 'none';            })        // 给输入框注册获得焦点事件        jd_input.addEventListener('focus', function() {            // 判断输入框内容是否为空            if (this.value !== '') {                // 不为空则显示提示盒子                con.style.display = 'block';            }        })    </script></pre><p id="44e5295e1f2fa53a5af88709aa057e45" class="ne-p"><br></p><h2 id="P79Nv"><span class="ne-text">事件（高阶）</span></h2><h3 id="Rd1zx"><span class="ne-text">DOM事件流</span></h3><pre data-language="plain" id="RzzJ1" class="ne-codeblock language-plain">html中的标签都是相互嵌套的，我们可以将元素想象成一个盒子装一个盒子，document是最外面的大盒子。当你单击一个div时，同时你也单击了div的父元素，甚至整个页面。那么是先执行父元素的单击事件，还是先执行div的单击事件 ？？？</pre><p id="c14f201d94d44c81abb8f2c3000bdd67" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361114-2ab6ad14-e27a-4626-88bd-abbc2badfc0b.png" width="696" id="lErXc" class="ne-image"></p><div class="ne-quote"><p id="78868800be8bc613f36c3edb4b3a1dde" class="ne-p"><span class="ne-text">比如：我们给页面中的一个div注册了单击事件，当你单击了div时，也就单击了body，单击了html，单击了document。</span></p></div><p id="5d4b75ae4678e48d6af7075109db522e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361173-9a6bf5d3-a273-4294-b849-0ebaf79da603.png" width="268" id="GVG7z" class="ne-image"></p><p id="37d68242d49f8b52b1a9676369660126" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361248-0ea0959b-c350-4780-9437-8561fe69f36d.png" width="751" id="EjVGr" class="ne-image"></p><pre data-language="plain" id="fZQ16" class="ne-codeblock language-plain">当时的2大浏览器霸主谁也不服谁！IE 提出从目标元素开始，然后一层一层向外接收事件并响应，也就是冒泡型事件流。Netscape（网景公司）提出从最外层开始，然后一层一层向内接收事件并响应，也就是捕获型事件流。江湖纷争，武林盟主也脑壳疼！！！最终，w3c 采用折中的方式，平息了战火，制定了统一的标准 —--— 先捕获再冒泡。现代浏览器都遵循了此标准，所以当事件发生时，会经历3个阶段。</pre><p id="f556229822e9ba88ea4d1e2850397e9d" class="ne-p"><span class="ne-text">DOM 事件流会经历3个阶段：</span></p><ol class="ne-ol"><li id="12de94fb204e535c5f84f321af9a2479"><span class="ne-text">捕获阶段</span></li><li id="a84b5336e39d35584955ba8353f5e62c"><span class="ne-text">当前目标阶段</span></li><li id="6fadf0984110fb347a97a8f370d60813"><span class="ne-text">冒泡阶段</span></li></ol><p id="f5859b14e6dc68e0781c994a5ca99f01" class="ne-p"><span class="ne-text">    我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过程相当于事件冒泡。</span></p><p id="98adf75e5ed2e0490abafd540d7c00e1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361302-fa0b37f5-a8ec-4898-82b6-e136cd291951.png" width="498" id="pnFlw" class="ne-image"></p><p id="efd402678c9324978a2ea7a626841bff" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361362-b8b1f065-da6a-40c5-8782-b265699cdd49.png" width="757" id="BMWF3" class="ne-image"></p><p id="fa8756cfd13405402d6ac6e0570e8f84" class="ne-p"><strong><span class="ne-text">事件冒泡</span></strong></p><pre data-language="javascript" id="N0HQ6" class="ne-codeblock language-javascript"><div class="father">        <div class="son">son盒子</div>    </div>    <script>        // onclick 和 attachEvent（ie） 在冒泡阶段触发        // 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略         // son -> father ->body -> html -> document        var son = document.querySelector('.son');        // 给son注册单击事件        son.addEventListener('click', function() {            alert('son');        }, false);        // 给father注册单击事件        var father = document.querySelector('.father');        father.addEventListener('click', function() {            alert('father');        }, false);        // 给document注册单击事件，省略第3个参数        document.addEventListener('click', function() {            alert('document');        })    </script></pre><p id="b7914d45fc380407e7f6dfae0f319192" class="ne-p"><strong><span class="ne-text">事件捕获</span></strong></p><pre data-language="javascript" id="TGv0h" class="ne-codeblock language-javascript"><div class="father">        <div class="son">son盒子</div>    </div>    <script>        // 如果addEventListener() 第三个参数是 true 那么在捕获阶段触发        // document -> html -> body -> father -> son         var son = document.querySelector('.son');        // 给son注册单击事件，第3个参数为true         son.addEventListener('click', function() {             alert('son');         }, true);         var father = document.querySelector('.father');        // 给father注册单击事件，第3个参数为true         father.addEventListener('click', function() {             alert('father');         }, true);        // 给document注册单击事件，第3个参数为true        document.addEventListener('click', function() {            alert('document');        }, true)    </script></pre><h3 id="uscVy"><span class="ne-text">事件对象</span></h3><h4 id="lh6g5"><span class="ne-text">什么是事件对象</span></h4><p id="54b33c7d311826ffec4520d2734a16d0" class="ne-p"><span class="ne-text">事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象。</span></p><p id="04803a183bddb874739ed06a3f25dc7b" class="ne-p"><span class="ne-text">比如：</span></p><ol class="ne-ol"><li id="e83b68cae6c31114de58901c5fe78d12"><span class="ne-text">谁绑定了这个事件。</span></li><li id="d8251054a60591581beece42e0f44464"><span class="ne-text">鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。</span></li><li id="87d5ad226aa335770e51d4b3bef54267"><span class="ne-text">键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。</span></li></ol><h4 id="YD8EB"><span class="ne-text">事件对象的使用</span></h4><p id="fdbd2d9f46988811915af195be4083ee" class="ne-p"><span class="ne-text">事件触发发生时就会产生事件对象，并且系统会以实参的形式传给事件处理函数。</span></p><p id="ee813f86056fc9f048d9aef2064de077" class="ne-p"><span class="ne-text">所以，在事件处理函数中声明1个形参用来接收事件对象。</span></p><p id="6bfa54243984b387569aceda77c3cb0a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361420-28ca3202-57b2-48ab-83cb-620191320123.png" width="681" id="yTBu7" class="ne-image"></p><h4 id="MfnbO"><span class="ne-text">事件对象的兼容性处理</span></h4><p id="9761c13e5f19594c776f0c7edfb9a87c" class="ne-p"><span class="ne-text">事件对象本身的获取存在兼容问题：</span></p><ol class="ne-ol"><li id="081e0ad76de02446ef57aff577d7244a"><span class="ne-text">标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。</span></li><li id="b61f1d8104467023001dfc0ef676be65"><span class="ne-text">在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。</span></li></ol><p id="caa7a88343b34d34f785c9d7f093d9f7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361484-fb99b58d-4733-4716-b625-a14e1cd02938.png" width="660" id="AKYdD" class="ne-image"></p><pre data-language="plain" id="4sy4j" class="ne-codeblock language-plain">只要“||”前面为false, 不管“||”后面是true 还是 false，都返回 “||” 后面的值。只要“||”前面为true, 不管“||”后面是true 还是 false，都返回 “||” 前面的值。</pre><pre data-language="javascript" id="Sh0Vu" class="ne-codeblock language-javascript"><div>123</div>    <script>        var div = document.querySelector('div');        div.onclick = function(e) {                // 事件对象                e = e || window.event;                console.log(e);        }    </script></pre><h4 id="v3WbX"><span class="ne-text">事件对象的属性和方法</span></h4><p id="c04df420165c82c6e3649132e76633bd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361541-14665361-d721-4083-8cb2-d2088c6dc0cc.png" width="698" id="xkt42" class="ne-image"></p><h4 id="XwqEo"><span class="ne-text">e.target 和 this 的区别</span></h4><ul class="ne-ul"><li id="255fb1cb53b39afbcb0dfdfe62a7354c"><span class="ne-text">this 是事件绑定的元素（绑定这个事件处理函数的元素） 。</span></li><li id="0eefb6af1c1df629f64df9faa64e79f6"><span class="ne-text">e.target 是事件触发的元素。</span></li></ul><pre data-language="plain" id="e7bcx" class="ne-codeblock language-plain">常情况下terget 和 this是一致的，但有一种情况不同，那就是在事件冒泡时（父子元素有相同事件，单击子元素，父元素的事件处理函数也会被触发执行），    这时候this指向的是父元素，因为它是绑定事件的元素对象，    而target指向的是子元素，因为他是触发事件的那个具体元素对象。</pre><pre data-language="javascript" id="tZJU1" class="ne-codeblock language-javascript"><div>123</div>    <script>        var div = document.querySelector('div');        div.addEventListener('click', function(e) {            // e.target 和 this指向的都是div            console.log(e.target);            console.log(this);        });    </script></pre><p id="7b5afcc4c8774f913e33749bc991a729" class="ne-p"><span class="ne-text">事件冒泡下的e.target和this</span></p><pre data-language="javascript" id="1fTWK" class="ne-codeblock language-javascript"><ul>        <li>abc</li>        <li>abc</li>        <li>abc</li>    </ul>    <script>        var ul = document.querySelector('ul');        ul.addEventListener('click', function(e) {              // 我们给ul 绑定了事件  那么this 就指向ul                console.log(this); // ul              // e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li              console.log(e.target); // li        });    </script></pre><h3 id="cyiXy"><span class="ne-text">阻止默认行为</span></h3><div class="ne-quote"><p id="854c1e3cd2ac3599dc97c6c7e7826ac9" class="ne-p"><span class="ne-text">html中一些标签有默认行为，例如a标签被单击后，默认会进行页面跳转。</span></p></div><pre data-language="javascript" id="QH72H" class="ne-codeblock language-javascript"><a href="http://www.baidu.com">百度</a>    <script>        // 2. 阻止默认行为 让链接不跳转         var a = document.querySelector('a');        a.addEventListener('click', function(e) {             e.preventDefault(); //  dom 标准写法        });        // 3. 传统的注册方式        a.onclick = function(e) {            // 普通浏览器 e.preventDefault();  方法            e.preventDefault();            // 低版本浏览器 ie678  returnValue  属性            e.returnValue = false;            // 我们可以利用return false 也能阻止默认行为 没有兼容性问题            return false;        }    </script></pre><h3 id="EzK38"><span class="ne-text">阻止事件冒泡</span></h3><p id="fbc94145f6de007c1d2edc039decc605" class="ne-p"><span class="ne-text">事件冒泡本身的特性，会带来的坏处，也会带来的好处。</span></p><p id="58c12cf373e0565c0759fea7ff3ef9a2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361625-d482ad01-1332-4d91-b951-664b337c86f3.png" width="667" id="UdMeX" class="ne-image"></p><pre data-language="javascript" id="z7FXp" class="ne-codeblock language-javascript"><div class="father">        <div class="son">son儿子</div>    </div>    <script>        var son = document.querySelector('.son');        // 给son注册单击事件        son.addEventListener('click', function(e) {            alert('son');            e.stopPropagation(); // stop 停止  Propagation 传播            window.event.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡        }, false);        var father = document.querySelector('.father');        // 给father注册单击事件        father.addEventListener('click', function() {            alert('father');        }, false);        // 给document注册单击事件        document.addEventListener('click', function() {            alert('document');        })    </script></pre><p id="3b98a675e82a8647f534b60d88d4aa26" class="ne-p"><strong><span class="ne-text">阻止事件冒泡的兼容性处理</span></strong></p><p id="14666baa432bef3397a3db8126ff71a5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361680-f20195f2-69b6-4d72-a6d5-6a5d08646b73.png" width="685" id="Ts107" class="ne-image"></p><h3 id="imMYA"><span class="ne-text">事件委托</span></h3><p id="e7c48210ad41e1d44e7a2e556b53463b" class="ne-p"><span class="ne-text">事件冒泡本身的特性，会带来的坏处，也会带来的好处。</span></p><h4 id="8IDAK"><span class="ne-text">什么是事件委托</span></h4><pre data-language="plain" id="nxKfE" class="ne-codeblock language-plain">把事情委托给别人，代为处理。</pre><p id="4fa8f0acc6d4268beeb196dbc27fff66" class="ne-p"><span class="ne-text">事件委托也称为事件代理，在 jQuery 里面称为事件委派。</span></p><div class="ne-quote"><p id="faf13b4a845244b53c7160acfc1914c9" class="ne-p"><span class="ne-text">说白了就是，不给子元素注册事件，给父元素注册事件，把处理代码在父元素的事件中执行。</span></p></div><p id="d4f77f6cf7cb9a7fb89c1b075582970c" class="ne-p"><strong><span class="ne-text">生活中的代理：</span></strong></p><p id="e4654954748ae19eecb4a109b529d50b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361736-9861e13e-f31a-4425-b062-883b21374fce.png" width="689" id="Pr1hq" class="ne-image"></p><p id="196dd6988d488b7c8b788af95edeb655" class="ne-p"><strong><span class="ne-text">js事件中的代理：</span></strong></p><p id="9cce8ee5a723fde233923710d585fd31" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361805-81024b8b-f5e4-488a-91fa-d8ffa16d04fa.png" width="698" id="bFULB" class="ne-image"></p><h4 id="r9vbn"><span class="ne-text">事件委托的原理</span></h4><p id="229515cbd20f9d988912c01d1a7f9f59" class="ne-p"><span class="ne-text">    给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。</span></p><h4 id="m9u6H"><span class="ne-text">事件委托的作用</span></h4><ul class="ne-ul"><li id="d3be9d93cb120dca88eb33e7c306e918"><span class="ne-text">我们只操作了一次 DOM ，提高了程序的性能。</span></li><li id="0600d3d420712c5a7ef129876158ca7f"><span class="ne-text">动态新创建的子元素，也拥有事件。</span></li></ul><pre data-language="javascript" id="dthKq" class="ne-codeblock language-javascript"><ul>        <li>知否知否，点我应有弹框在手！</li>        <li>知否知否，点我应有弹框在手！</li>        <li>知否知否，点我应有弹框在手！</li>        <li>知否知否，点我应有弹框在手！</li>        <li>知否知否，点我应有弹框在手！</li>    </ul>    <script>        // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点        var ul = document.querySelector('ul');        ul.addEventListener('click', function(e) {            // e.target 这个可以得到我们点击的对象            e.target.style.backgroundColor = 'pink';        })    </script></pre></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> DOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象体系</title>
      <link href="/blog/zfpg9dfgehog/"/>
      <url>/blog/zfpg9dfgehog/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u9f2794ef" class="ne-p" style="text-indent: 2em"><span class="ne-text">前言：JavaScript首先在ES6没有出来之前，利用一个叫原型的一系列机制来用一段很长的代码来实现类的继承，说白了就是在函数里面默认给你加个一个叫原型的对象属性，再利用一系列指向来完成继承。在ES6之后，才有了形式上的类class及其对象，以及一个单词extends就搞定的继承，虽说搞定，但这里面的机制还是原型相关知识，记录学习一下。</span></p><p id="udc8e4c2c" class="ne-p" style="text-indent: 2em"><span class="ne-text">不管是原型也好，新加的class也罢，就一个目的——为了实现面向对象。从两个体系来展开详述。</span></p><h2 id="yj3wW"><span class="ne-text">体系一：原型+原型链</span></h2><ul class="ne-ul"><li id="u3d362539"><span class="ne-text">讲解的很透彻：</span><a href="https://www.bilibili.com/video/BV1Q64y1v7fW" data-href="https://www.bilibili.com/video/BV1Q64y1v7fW" target="_blank" class="ne-link"><span class="ne-text">https://www.bilibili.com/video/BV1Q64y1v7fW</span></a></li></ul><h3 id="LnxeQ"><span class="ne-text">隐式原型__proto__</span></h3><p id="ud0a1f80e" class="ne-p"><span class="ne-text" style="text-decoration: underline">每个对象里面都有__proto__属性</span><span class="ne-text">，这个叫对象原型，这个玩意指向</span><strong><span class="ne-text">构造函数的prototype对象</span></strong></p><div class="ne-quote"><p id="u5184b156" class="ne-p"><span class="ne-text">__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</span></p></div><p id="u9a75c883" class="ne-p"><span class="ne-text">比如说，有一个Person类，有一个Student类，Student类继承自Person类，Student有一个实例student_1，那么student_1会有__proto__对象属性，并且展开该__proto__，会发现里面是Person类的方法和属性</span></p><h3 id="CLRny"><span class="ne-text">显式原型prototype</span></h3><p id="7c59d55d4430a46b8ffc2c7b51f1e256" class="ne-p"><span class="ne-text" style="text-decoration: underline">每个构造函数里面都有一个属性，这个属性叫prototype，</span><strong><span class="ne-text" style="text-decoration: underline">指向另一个对象</span></strong><span class="ne-text" style="text-decoration: underline">（</span><span class="ne-text">有什么用？在后面原型链就会发现有用了），并且这个属性是一个对象，叫做构造函数原型</span></p><div class="ne-quote"><p id="66d8017956949710921f46829a08c3d8" class="ne-p"><span class="ne-text">这样可以解决一个问题，就是创建不同实例，这些事例所用的方法都是同一个内存下的方法，实现共享</span></p></div><h3 id="w9Uhl"><span class="ne-text">constructor构造函数</span></h3><ol class="ne-ol"><li id="fccf204ee8c9f63131ce572e4bd9135c"><span class="ne-text">对象原型（ __proto__）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它</span><strong><span class="ne-text" style="text-decoration: underline">指回构造函数本身</span></strong><span class="ne-text">。</span></li><li id="43bf14b0a19dae4f626eb4be000d8fce"><span class="ne-text">constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</span></li><li id="052026097e14bd2660b57547591740ee"><span class="ne-text">一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor  就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</span></li></ol><h3 id="zGyP9"><span class="ne-text">instanceof</span></h3><p id="ucbd81d9b" class="ne-p"><span class="ne-text">a instanceof b</span></p><p id="uff532746" class="ne-p"><span class="ne-text">判断是true还是false</span></p><p id="ub45967b4" class="ne-p"><span class="ne-text">看a的constructor是什么</span></p><p id="uea8ad4ec" class="ne-p"><span class="ne-text">当b为   a的constructor或a的__proto__的constructor……</span></p><p id="u574656e6" class="ne-p"><span class="ne-text">结果都是true</span></p><h3 id="y8vLN"><span class="ne-text">原型链和成员查找机制</span></h3><p id="u5702aa15" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651672328368-25e71aa6-4015-4469-9a67-5d841645aebe.png" width="1268.333282934297" id="ue6601372" class="ne-image"></p><p id="4598fd72a5cc5f9d913bdf73126385d4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622632967349-b2adf38c-b51f-445b-b4c8-7d0408e96390.png" width="501" id="B3Eo8" class="ne-image"></p><h3 id="V8jhV"><span class="ne-text">原型体系中的继承</span></h3><p id="512dd492c06f7b4ac69269f1b091b237" class="ne-p"><span class="ne-text">call方法可以改变一个函数的指向</span></p><ol class="ne-ol"><li id="344c83abd47ab0a088a47b2c6337455d"><span class="ne-text">继承父构造函数里面的属性</span></li></ol><pre data-language="javascript" id="ngHQt" class="ne-codeblock language-javascript">// 1. 父构造函数<p>function Father(uname, age) {<br>// this 指向父构造函数的对象实例<br>this.uname = uname;<br>this.age = age;<br>}<br>// 2 .子构造函数<br>function Son(uname, age, score) {<br>// this 指向子构造函数的对象实例<br>// 3.使用 call 方式实现子继承父的属性<br>Father.call(this, uname, age);<br>this.score = score;<br>}<br>var son = new Son(‘刘德华’, 18, 100);<br>console.log(son);</pre><ol start="2" class="ne-ol"><li id="a3855cf3ab3a5f5c35c51d1dd654cb4f"><span class="ne-text">继承方法</span></li></ol><pre data-language="javascript" id="AbSOK" class="ne-codeblock language-javascript">// 1. 父构造函数<br>function Father(uname, age) {<br>// this 指向父构造函数的对象实例<br>this.uname = uname;<br>this.age = age;<br>}<br>Father.prototype.money = function() {<br>console.log(100000);<br>};<br>// 2 .子构造函数<br>function Son(uname, age, score) {<br>// this 指向子构造函数的对象实例<br>Father.call(this, uname, age);<br>this.score = score;<br>}<br>// Son.prototype = Father.prototype; 这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化<br>Son.prototype = new Father();<br>// 如果利用对象的形式修改了原型对象,别忘了利用 constructor 指回原来的构造函数<br>Son.prototype.constructor = Son;<br>// 这个是子构造函数专门的方法<br>Son.prototype.exam = function() {<br>console.log('孩子要考试');<br>}<br>var son = new Son('刘德华', 18, 100);<br>console.log(son);</pre><h2 id="2AkCh"><span class="ne-text">体系二：类(class)【ES6】</span></h2><p id="cad140a8200f42428c7a238d32d88835" class="ne-p" style="text-indent: 2em"><span class="ne-text">在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象。其创建的方式和之前学过的语言很类似。</span></p><p id="7b4f5c68d9e46b566eed60b98ec029de" class="ne-p" style="text-indent: 2em"><span class="ne-text">在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象</span></p><h3 id="EQmnS"><span class="ne-text">创建+继承+使用</span></h3><pre data-language="javascript" id="kZ21w" class="ne-codeblock language-javascript">// 奥特曼类<br>class Aoteman {<br>// 构造函数里面放共有属性、方法<br>constructor(name, age) {<br>this.name = name;<br>this.age = age;<br>}<br>Ability(abi) {<br>console.log(this.name + " can " + abi);<br>}<br>}</p><p>// 假奥特曼类 继承 奥特曼<br>class Jia extends Aoteman {<br>constructor (x, y) {<br>// 继承父类的构造函数<br>super(x,y);<br>// 方便写自己的函数<br>this.x = x;<br>this.y = y;<br>}<br>// 自己内部的函数<br>Chuiniu() {<br>console.log(this.x + “ chuiniu”);<br>}</p><p>}</p><p>// 创建迪迦对象<br>let dijia = new Aoteman(‘dijia’, 100);<br>console.log(dijia);<br>dijia.Ability(“X-ray”);<br>let dijia_jia = new Jia(“dijia_jia”, 50);<br>dijia_jia.Ability(“xxx”);<br>dijia_jia.Chuiniu();</pre><p id="cb14a18ef0b052581ff2c955bf1a0ffc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622622728600-59f47873-c895-4686-b771-f1f538198f26.png" width="441" id="JN882" class="ne-image"></p><h2 id="Pieyx"><span class="ne-text">对象的各种创建方式</span></h2><h3 id="zit4E"><span class="ne-text">字面量</span></h3><p id="083a4934aac2b8be69b10cc6f6d4f323" class="ne-p"><span class="ne-text">属性和方法的调用：</span></p><p id="36235a6d55d24a73c9da43f5eef64605" class="ne-p"><span class="ne-text">属性可以用”.”和[“属性名”]来调用</span></p><p id="60c09abb79feb2bc609b8822c6ece536" class="ne-p"><span class="ne-text">方法用”.”来调用</span></p><h3 id="qieAE"><span class="ne-text">模式工厂</span></h3><p id="12f03a76db50bccfcb65ebd419d35599" class="ne-p"><span class="ne-text">new 一个空对象，</span><code class="ne-code"><span class="ne-text">let obj = new Object();</span></code></p><p id="76e77acf462c0d5fc6711fe41458c5b8" class="ne-p"><span class="ne-text">然后利用”.”的方式给其添加属性和方法</span></p><p id="9a7c3df6d0ab8823ad10b9d56da71806" class="ne-p"><span class="ne-text">内置的 Object()构造函数</span></p><p id="c1e35870ec274c5a60120cec9b6a71c8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622623002064-1297005b-76a6-4d94-9b12-a83cf709e3a1.png" width="529.5" id="hDM2I" class="ne-image"></p><h3 id="6Kx17"><span class="ne-text">构造函数</span></h3><div class="ne-quote"><p id="4bb010f534c4432e61c5acfc8ed7f78d" class="ne-p"><span class="ne-text">构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</span></p></div><pre data-language="javascript" id="hTLsM" class="ne-codeblock language-javascript">function 构造函数名(形参 1,形参 2,形参 3) {<br>this.属性名 1 = 参数 1;<br>this.属性名 2 = 参数 2;<br>this.属性名 3 = 参数 3;<br>this.方法名 = 函数体;<br>}</p><p>let obj = new 构造函数名(实参 1，实参 2，实参 3)</pre><p id="4c6617820231460b3d1a5ba0052650cc" class="ne-p"><br></p><ul class="ne-ul"><li id="42ddfc91739b54f0db3ad2360bfa2a11"><span class="ne-text">构造函数约定</span><strong><span class="ne-text">首字母大写</span></strong><span class="ne-text">。</span></li><li id="107ab55d6bdb5fc8852a8ba09058c242"><span class="ne-text">函数内的属性和方法前面需要添加 </span><strong><span class="ne-text">this</span></strong><span class="ne-text"> ，表示当前对象的属性和方法。</span></li><li id="a40659a6a97972cbe2892ca3ba220606"><span class="ne-text">构造函数中</span><strong><span class="ne-text">不需要 return 返回结果</span></strong><span class="ne-text">。</span></li><li id="d5ada7fd51b068d3faab947354a6172c"><span class="ne-text">当我们创建对象的时候，</span><strong><span class="ne-text">必须用 new 来调用构造函数</span></strong><span class="ne-text">。</span></li></ul><h3 id="1QZhm"><span class="ne-text">原型模式</span></h3><p id="70c37cafa4ed06b8de783a9a800765ed" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622623181327-bd4b5d09-8525-4c59-b550-9af381526f23.png" width="529.5" id="qBvgN" class="ne-image"></p><p id="cab84c8c6b9a31635a96b6562e393404" class="ne-p"><span class="ne-text">下面详述什么是原型</span></p><h2 id="sxsBG"><span class="ne-text">对象的内置方法</span></h2><p id="u0e9e74a8" class="ne-p"><span class="ne-text">参考教程：</span></p><ul class="ne-ul"><li id="uc70efeef"><a href="https://zh.javascript.info/object-basics" data-href="https://zh.javascript.info/object-basics" target="_blank" class="ne-link"><span class="ne-text">https://zh.javascript.info/object-basics</span></a></li></ul><h3 id="7WtOk"><span class="ne-text">Object.defineProperty</span></h3><p id="e403193d89184c9e7039f12f52d5c627" class="ne-p"><span class="ne-text">Object.defineProperty 设置或修改对象中的属性</span></p><pre data-language="javascript" id="hiwmH" class="ne-codeblock language-javascript">Object.defineProperty(对象，修改或新增的属性名，{<br>value:修改或新增的属性的值,<br>writable:true/false,//如果值为 false 不允许修改这个属性值<br>enumerable: false,//enumerable 如果值为 false 则不允许遍历<br>configurable: false //configurable 如果为 false 则不允许删除这个属性 属性是否可以被删除或是否可以再次修改特性<br>})</pre><h3 id="lQpR4"><span class="ne-text">删除对象属性</span></h3><ul class="ne-ul"><li id="ue8b0d3cd"><span class="ne-text">直接用 delete，暴力简单</span></li><li id="uc28fcad7"><span class="ne-text">也可以参考：</span><a href="https://segmentfault.com/q/1010000013891861" data-href="https://segmentfault.com/q/1010000013891861" target="_blank" class="ne-link"><span class="ne-text">如何优雅的删除对象中的指定属性？</span></a></li></ul><h3 id="Aliaq"><span class="ne-text">assign()</span></h3><ul class="ne-ul"><li id="u4c6a6bde"><span class="ne-text">Object.assign 后者覆盖前者，再返回前者</span></li><li id="u33bd510a"><span class="ne-text">常用于深拷贝浅拷贝数据</span></li></ul><h2 id="vJuVU"><span class="ne-text">对象的遍历</span></h2><h3 id="yyCtR"><span class="ne-text">for…in </span></h3><div data-type="info" class="ne-alert"><p id="u49da1b9d" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">语句用于对数组或者对象的属性进行循环操作。</span></p></div><p id="uc155870c" class="ne-p"><span class="ne-text">其语法如下：</span></p><pre data-language="javascript" id="iRrmU" class="ne-codeblock language-javascript">for (变量 in 对象名字) {<br>// 在此执行代码<br>}</pre><ul class="ne-ul"><li id="ud155867e"><span class="ne-text">语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。书里面建议用 const 来加持。</span></li></ul><pre data-language="javascript" id="PAVgB" class="ne-codeblock language-javascript">for (let k in obj) {<br>console.log(k); // 这里的 k 是属性名<br>console.log(obj[k]); // 这里的 obj[k] 是属性值<br>}</pre><h3 id="Thzwk"><span class="ne-text">Object.keys(obj)</span></h3><div data-type="info" class="ne-alert"><p id="u1ab14861" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">获取属性名</span></p></div><pre data-language="javascript" id="W93F9" class="ne-codeblock language-javascript">var obj = {<br>id: 1,<br>pname: '小米',<br>price: 1999,<br>num: 2000<br>};<br>var result = Object.keys(obj)<br>console.log(result)//[id，pname,price,num]</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery事件+插件</title>
      <link href="/blog/3_day03_jquery/"/>
      <url>/blog/3_day03_jquery/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="6nKXU"><span class="ne-text">jQuery 事件注册</span></h2><p id="1e079f7fc93138d41c83e6307322c395" class="ne-p"><span class="ne-text">jQuery 为我们提供了方便的事件注册机制，是开发人员抑郁操作优缺点如下：</span></p><ul class="ne-ul"><li id="c808388301fd63bad9c767da948c322e"><span class="ne-text">优点: 操作简单，且不用担心事件覆盖等问题。</span></li><li id="bbabe8c7d4fe4c8da0d39350a99614c6"><span class="ne-text">缺点: 普通的事件注册不能做事件委托，且无法实现事件解绑，需要借助其他方法。</span></li></ul><p id="1864e480f8d3149886b1a2fd5e7313d8" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="ef9109cb2e57e3ef815add54e5b29f5b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493434-c3ba216b-4d64-4229-b788-30947c24ab77.png" width="620" id="fMqr8" class="ne-image"></p><p id="edd9c3d61ded33e7aa40fe0899623f7e" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre data-language="javascript" id="vMMgJ" class="ne-codeblock language-javascript"><body><pre><code>&lt;div&gt;&lt;/div&gt;&lt;script&gt;    $(function() &#123;        // 1. 单个事件注册        $(&quot;div&quot;).click(function() &#123;            $(this).css(&quot;background&quot;, &quot;purple&quot;);        &#125;);        $(&quot;div&quot;).mouseenter(function() &#123;            $(this).css(&quot;background&quot;, &quot;skyblue&quot;);        &#125;);    &#125;)&lt;/script&gt;</code></pre></body></pre><h2 id="epxS2"><span class="ne-text">jQuery 事件处理</span></h2><p id="f54334778311efa0f4e4d14ad229f9e1" class="ne-p"><span class="ne-text">因为普通注册事件方法的不足，jQuery又开发了多个处理方法，重点讲解如下：</span></p><ul class="ne-ul"><li id="34055378e712e493b6d4161b573a3301"><span class="ne-text">on(): 用于事件绑定，目前最好用的事件绑定方法</span></li><li id="ea25e2366c24c0d05647b2495c51c58c"><span class="ne-text">off(): 事件解绑</span></li></ul><ul class="ne-ul"><li id="3830ab27a86e1c0bb3526650198a5818"><span class="ne-text">trigger() / triggerHandler(): 事件触发</span></li></ul><h3 id="0uqBm"><span class="ne-text">1.2.1 事件处理 on() 绑定事件</span></h3><p id="62799bd1a890cfa043aa589978cb7501" class="ne-p"><span class="ne-text">    因为普通注册事件方法的不足，jQuery又创建了多个新的事件绑定方法bind() / live() / delegate() / on()等，其中最好用的是: on()</span></p><p id="25d79611f4bd96e0bf439cba3f7b1e6b" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="84ebca37ae4dea24c1bf49f572a9ed85" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493540-3a234b93-0493-427d-9113-4a801e391e60.png" width="620" id="RIdT9" class="ne-image"></p><p id="07fa4c678f8a92f5afdcee0b00cbaa24" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493614-d618db76-bdb5-4284-a6c3-433bf44340b2.png" width="620" id="hBFH2" class="ne-image"></p><p id="9aa581dd60172652dea0f6ada276c2b4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493684-be1891f4-c228-49eb-ac9d-47e233dafaad.png" width="620" id="Cd9At" class="ne-image"></p><p id="7a614249218469849607c38bae692545" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre data-language="javascript" id="iSHNJ" class="ne-codeblock language-javascript"><body>    <div></div>    <ul>        <li>我们都是好孩子</li>        <li>我们都是好孩子</li>        <li>我们都是好孩子</li>    </ul>    <ol></ol>    <script>        $(function() {            // (1) on可以绑定1个或者多个事件处理程序            // $("div").on({            //     mouseenter: function() {            //         $(this).css("background", "skyblue");            //     },            //     click: function() {            //         $(this).css("background", "purple");            //     }            // });            $("div").on("mouseenter mouseleave", function() {                $(this).toggleClass("current");            });  <pre><code>        // (2) on可以实现事件委托（委派）        // click 是绑定在ul 身上的，但是 触发的对象是 ul 里面的小li        // $(&quot;ul li&quot;).click();        $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123;            alert(11);        &#125;);        // (3) on可以给未来动态创建的元素绑定事件        $(&quot;ol&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123;            alert(11);        &#125;)        var li = $(&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;);        $(&quot;ol&quot;).append(li);    &#125;)&lt;/script&gt;</code></pre></body></pre><h3 id="vjmrz"><span class="ne-text">1.2.3. 事件处理 off() 解绑事件</span></h3><p id="ca7ede028a7f07a37020cca741ad544e" class="ne-p"><span class="ne-text">    当某个事件上面的逻辑，在特定需求下不需要的时候，可以把该事件上的逻辑移除，这个过程我们称为事件解绑。jQuery 为我们提供 了多种事件解绑方法：die() / undelegate() / off() 等，甚至还有只触发一次的事件绑定方法 one()，在这里我们重点讲解一下 off() ;</span></p><p id="2b51b5149f611a9d07c7d645f9c35f48" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="3cd4aeb1c4533c26e80f568526c2b6a3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493756-82ebfacb-9794-47bf-8776-6b7d80437782.png" width="620" id="IIuR6" class="ne-image"></p><p id="07e0b707fcfb0a1d83cf889e34013983" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre data-language="javascript" id="ZYdSf" class="ne-codeblock language-javascript"><body>    <div></div>    <ul>        <li>我们都是好孩子</li>        <li>我们都是好孩子</li>        <li>我们都是好孩子</li>    </ul>    <p>我是一个P标签</p>    <script>        $(function() {              // 事件绑定            $("div").on({                click: function() {                    console.log("我点击了");                },                mouseover: function() {                    console.log('我鼠标经过了');                }            });            $("ul").on("click", "li", function() {                alert(11);            });  <pre><code>        // 1. 事件解绑 off         // $(&quot;div&quot;).off();  // 这个是解除了div身上的所有事件        $(&quot;div&quot;).off(&quot;click&quot;); // 这个是解除了div身上的点击事件        $(&quot;ul&quot;).off(&quot;click&quot;, &quot;li&quot;);        // 2. one() 但是它只能触发事件一次        $(&quot;p&quot;).one(&quot;click&quot;, function() &#123;            alert(11);        &#125;)    &#125;)&lt;/script&gt;</code></pre></body></pre><h3 id="Su6fF"><span class="ne-text">1.2.4. 事件处理 trigger() 自动触发事件</span></h3><p id="acb3bfcd1cb90bffd26c7cb83eafe110" class="ne-p"><span class="ne-text">    有些时候，在某些特定的条件下，我们希望某些事件能够自动触发, 比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。由此 jQuery 为我们提供了两个自动触发事件 trigger() 和 triggerHandler() ;</span></p><p id="ef781c11379caf67e369b3f700f76e6c" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="59181ab615f875d06d8ca08d3e313c9a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493822-a72c8dfb-7860-407e-b410-60c073ed48d7.png" width="620" id="wy7Zt" class="ne-image"></p><p id="f6c2275990ad9334331cf0d35879a0d5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493901-f1048b8f-64aa-4cf6-98df-0ea9245e813e.png" width="620" id="EXulM" class="ne-image"></p><p id="0beed4a3a038cb320bab570e717fe2c1" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre data-language="javascript" id="Aq5Lb" class="ne-codeblock language-javascript"><body>    <div></div>    <input type="text">      <pre><code>&lt;script&gt;$(function() &#123;  // 绑定事件  $(&quot;div&quot;).on(&quot;click&quot;, function() &#123;    alert(11);  &#125;);  // 自动触发事件  // 1. 元素.事件()  // $(&quot;div&quot;).click();会触发元素的默认行为    // 2. 元素.trigger(&quot;事件&quot;)  // $(&quot;div&quot;).trigger(&quot;click&quot;);会触发元素的默认行为  $(&quot;input&quot;).trigger(&quot;focus&quot;);    // 3. 元素.triggerHandler(&quot;事件&quot;) 就是不会触发元素的默认行为  $(&quot;input&quot;).on(&quot;focus&quot;, function() &#123;    $(this).val(&quot;你好吗&quot;);  &#125;);  // 一个会获取焦点，一个不会  $(&quot;div&quot;).triggerHandler(&quot;click&quot;);  // $(&quot;input&quot;).triggerHandler(&quot;focus&quot;);&#125;);&lt;/script&gt;</code></pre></body></pre><h2 id="SbVO0"><span class="ne-text">1.3. jQuery 事件对象</span></h2><p id="9b3a2941d9219d9ebcb67c406212630a" class="ne-p"><span class="ne-text">    jQuery 对DOM中的事件对象 event 进行了封装，兼容性更好，获取更方便，使用变化不大。事件被触发，就会有事件对象的产生。</span></p><p id="1dc5008c0c73b7cb053a1838dda7a5d5" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="67696560df2bb412b30ce75bb122e9fb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493975-78588b8f-4bb7-4720-b637-d256b2831b0b.png" width="635" id="rOjnn" class="ne-image"></p><p id="4ffc343e626eb7f053cb813ba022d447" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre data-language="javascript" id="O05zx" class="ne-codeblock language-javascript"><body>    <div></div>    <script>        $(function() {            $(document).on("click", function() {                console.log("点击了document");            })            $("div").on("click", function(event) {                // console.log(event);                console.log("点击了div");                event.stopPropagation();            })        })    </script></body></pre><p id="9ac2c2b45e418decb3e4c13e8ab72b61" class="ne-p"><span class="ne-text">注意：jQuery中的 event 对象使用，可以借鉴 API 和 DOM 中的 event 。</span></p><h2 id="UgRln"><span class="ne-text">1.4.  jQuery 拷贝对象</span></h2><p id="15c266e5200f2f66a3eff4916e44d816" class="ne-p"><span class="ne-text">    jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。</span></p><p id="869f035caae2b45702879fe7323f2d7c" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="11ba8533e184fa5d4f27f50e085c0f5d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073494039-54be8373-5ba6-4c40-af84-3c6e7cd37d79.png" width="620" id="n5zBz" class="ne-image"></p><p id="23a58add2fafe93a5463bb367c440635" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre data-language="javascript" id="ckS1W" class="ne-codeblock language-javascript"><script>        $(function() {               // 1.合并数据            var targetObj = {};            var obj = {                id: 1,                name: "andy"            };            // $.extend(target, obj);            $.extend(targetObj, obj);            console.log(targetObj);   <pre><code>           // 2. 会覆盖 targetObj 里面原来的数据        var targetObj = &#123;            id: 0        &#125;;        var obj = &#123;            id: 1,            name: &quot;andy&quot;        &#125;;        // $.extend(target, obj);        $.extend(targetObj, obj);        console.log(targetObj);     &#125;)&lt;/script&gt;&lt;/pre&gt;&lt;h2 id=&quot;IZRrF&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;1.5.  jQuery 多库共存&lt;/span&gt;&lt;/h2&gt;&lt;p id=&quot;8357c305cb60e4e6bd222ed243746fbb&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;    实际开发中，很多项目连续开发十多年，jQuery版本不断更新，最初的 jQuery 版本无法满足需求，这时就需要保证在旧有版本正常运行的情况下，新的功能使用新的jQuery版本实现，这种情况被称为，jQuery 多库共存。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;84f1b795d31729a8ef17e94444b4afe4&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;语法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p id=&quot;dad15e0707e5aa7de311deb335cd7451&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073494111-229f7c73-4d09-4074-bd62-0da6a2f0db40.png&quot; width=&quot;620&quot; id=&quot;iTQQD&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;p id=&quot;9e10ca41123f0ffc0022f9e7a9f62d98&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;演示代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre data-language=&quot;javascript&quot; id=&quot;nPXah&quot; class=&quot;ne-codeblock language-javascript&quot;&gt;&lt;script&gt;$(function() &#123;      // 让jquery 释放对$ 控制权 让用自己决定      var suibian = jQuery.noConflict();      console.log(suibian(&quot;span&quot;));&#125;)</code></pre><p></script></pre><h2 id="Eo5OD"><span class="ne-text">1.6.  jQuery 插件</span></h2><p id="daf396b48b366501c68ccb82100ec403" class="ne-p"><span class="ne-text">    jQuery 功能比较有限，想要更复杂的特效效果，可以借助于 jQuery 插件完成。 这些插件也是依赖于jQuery来完成的，所以必须要先引入</span></p><p id="036d0840c4e2478e6952e488682e8d22" class="ne-p"><span class="ne-text">jQuery文件，因此也称为 jQuery 插件。</span></p><p id="38b20ceb5f76880fd855d36dac6fca19" class="ne-p"><span class="ne-text">    jQuery 插件常用的网站：</span></p><ol class="ne-ol"><li id="9d22b08c02d16cafbb40bf0b639d18e3"><span class="ne-text">jQuery 插件库  </span><a href="http://www.jq22.com/" data-href="http://www.jq22.com/" target="_blank" class="ne-link"><span class="ne-text">http://www.jq22.com/</span></a></li><li id="337d3a12c6c66a565df7a5643b75d9a9"><span class="ne-text">jQuery 之家   </span><a href="http://www.htmleaf.com/" data-href="http://www.htmleaf.com/" target="_blank" class="ne-link"><span class="ne-text">http://www.htmleaf.com/</span></a></li></ol><p id="299c9ce426a47c386d83d47df8ded0af" class="ne-p"><span class="ne-text">jQuery 插件使用步骤：</span></p><ol start="3" class="ne-ol"><li id="7acafff7d2dae86e620b77bbd2fafa62"><span class="ne-text">引入相关文件。（jQuery 文件 和 插件文件）</span></li><li id="f1945fe734388a83aae5600f016a34d3"><span class="ne-text">复制相关html、css、js (调用插件)。</span></li></ol><h3 id="9ieHe"><span class="ne-text">1.4.1.  瀑布流插件（重点讲解）</span></h3><p id="c62102b4462dbbcf1ea1e1159e2e0726" class="ne-p"><span class="ne-text">    我们学习的第一个插件是jQuery之家的开源插件，瀑布流。我们将重点详细讲解，从找到插件所在网页，然后点击下载代码，到插件的使用等，后面的插件使用可参考瀑布流插件的使用。</span></p><p id="7c61ac3e9a0b612a3123a1dc94a06977" class="ne-p"><strong><span class="ne-text">下载位置</span></strong></p><p id="af159dae35f3653f36af11c7fc25fc66" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073494174-fb4a286c-0558-4af1-98d7-08102ae5bb99.png" width="1200" id="noBRx" class="ne-image"></p><p id="6a1ec52e2ca33b6fdad168330f77751f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073494257-d73dc383-f99b-465d-908e-703a4c023f36.png" width="318" id="MxV60" class="ne-image"></p><p id="e7cd3e319b356b85a72c5af9d097b2db" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><p id="c2e0bd7ee791ae82e37ec48b0a6de92e" class="ne-p"><span class="ne-text">    插件的使用三点：   1. 引入css.           2.引入JS            3.引入html。 （有的简单插件只需引入html和js，甚至有的只需引入js）</span></p><ul class="ne-ul"><li id="87b0cbdb6a03055295f6bc8d7258bee3"><span class="ne-text">1.引入css.</span></li></ul><pre data-language="javascript" id="sJ2we" class="ne-codeblock language-javascript"><link rel="stylesheet" href="css/normalize.css"></p><link rel="stylesheet" type="text/css" href="css/default.css">  <!-- 下面的样式代码为页面布局，可以引入，也可以自己写，自己设计页面样式，一般为直接引入，方便 --><style type="text/css">  #gallery-wrapper {    position: relative;    max-width: 75%;    width: 75%;    margin: 50px auto;  }  img.thumb {    width: 100%;    max-width: 100%;    height: auto;  }  .white-panel {    position: absolute;    background: white;    border-radius: 5px;    box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.3);    padding: 10px;  }  .white-panel h1 {    font-size: 1em;  }  .white-panel h1 a {    color: #A92733;  }  .white-panel:hover {    box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.5);    margin-top: -5px;    -webkit-transition: all 0.3s ease-in-out;    -moz-transition: all 0.3s ease-in-out;    -o-transition: all 0.3s ease-in-out;    transition: all 0.3s ease-in-out;  }</style></pre><ul class="ne-ul"><li id="ee295205b3258810652f6c1ad7676327"><span class="ne-text">2.引入js.</span></li></ul><pre data-language="javascript" id="Jjg1t" class="ne-codeblock language-javascript"><!-- 前两个必须引入 --><script src="js/jquery-1.11.0.min.js"></script><script src="js/pinterest_grid.js"></script><!-- 下面的为启动瀑布流代码，参数可调节属性，具体功能可参考readme.html --><script type="text/javascript">    $(function() {      $("#gallery-wrapper").pinterest_grid({          no_columns: 5,          padding_x: 15,          padding_y: 10,          margin_bottom: 50,          single_column_breakpoint: 700      });    });</script></pre><ul class="ne-ul"><li id="90429a79ea9868bf175ab694ae467f90"><span class="ne-text">3.引入html.</span></li></ul><pre data-language="javascript" id="T5Oh6" class="ne-codeblock language-javascript"><!-- html结构一般为事先写好，很难修改结构，但可以修改内容及图片的多少（article标签） --><pre><code>&lt;section id=&quot;gallery-wrapper&quot;&gt;    &lt;article class=&quot;white-panel&quot;&gt;        &lt;img src=&quot;images/P_000.jpg&quot; class=&quot;thumb&quot;&gt;        &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;        &lt;p&gt;里面很精彩哦&lt;/p&gt;    &lt;/article&gt;    &lt;article class=&quot;white-panel&quot;&gt;        &lt;img src=&quot;images/P_005.jpg&quot; class=&quot;thumb&quot;&gt;        &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;        &lt;p&gt;里面很精彩哦&lt;/p&gt;    &lt;/article&gt;    &lt;article class=&quot;white-panel&quot;&gt;        &lt;img src=&quot;images/P_006.jpg&quot; class=&quot;thumb&quot;&gt;        &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;        &lt;p&gt;里面很精彩哦&lt;/p&gt;    &lt;/article&gt;    &lt;article class=&quot;white-panel&quot;&gt;        &lt;img src=&quot;images/P_007.jpg&quot; class=&quot;thumb&quot;&gt;        &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;        &lt;p&gt;里面很精彩哦&lt;/p&gt;    &lt;/article&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p id=&quot;2cebc871eb4858041be0c6b2ea1bd12f&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;总结：jQuery插件就是引入别人写好的：html 、css、js  （有时也可以只引入一部分，读懂后也可以修改部分内容）&lt;/span&gt;&lt;/p&gt;&lt;h3 id=&quot;corv0&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;1.4.2. 图片懒加载插件&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;d669e8fd16cf0d8cbea91ec3b8879eab&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;    图片的懒加载就是：当页面滑动到有图片的位置，图片才进行加载，用以提升页面打开的速度及用户体验。（下载略）&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;e2c1c3f950a6b51f4a783d5063b8dd4c&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;代码演示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p id=&quot;a4174de760805276de05839765c52752&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;    懒加载只需引入html 和 js操作 即可，此插件不涉及css。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;87e94090f81a3a53278fe1805a1c1e1f&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;1.引入js&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-language=&quot;javascript&quot; id=&quot;5PuOt&quot; class=&quot;ne-codeblock language-javascript&quot;&gt;&lt;script src=&quot;js/EasyLazyload.min.js&quot;&gt;&lt;/script&gt;</code></pre><script>       lazyLoadInit({           showTime: 1100,           onLoadBackEnd: function(i, e) {             console.log("onLoadBackEnd:" + i);           },           onLoadBackStart: function(i, e) {             console.log("onLoadBackStart:" + i);           }     });</script></pre><ul class="ne-ul"><li id="c44d3b912972c9d6c87268b258b700e6"><span class="ne-text">2.引入html</span></li></ul><pre data-language="javascript" id="12Zqr" class="ne-codeblock language-javascript"><img data-lazy-src="upload/floor-1-3.png" alt=""></pre><h3 id="ghjB7"><span class="ne-text">1.4.3. 全屏滚动插件</span></h3><p id="a3c5f0983e30aaf690050ecec1840821" class="ne-p"><span class="ne-text">    全屏滚动插件比较大，所以，一般大型插件都会有帮助文档，或者网站。全屏滚动插件介绍比较详细的网站为：</span></p><p id="3d1a46b3ad0ec1f2446db67cef761ccc" class="ne-p"><a href="http://www.dowebok.com/demo/2014/77/" data-href="http://www.dowebok.com/demo/2014/77/" target="_blank" class="ne-link"><span class="ne-text">http://www.dowebok.com/demo/2014/77/</span></a></p><p id="d9277d1c714013ed864b4f8ebec617c9" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><p id="3c8ac7a28432302ee64f04c98bfac2a7" class="ne-p"><span class="ne-text">    全屏滚动因为有多重形式，所以不一样的风格html和css也不一样，但是 js 变化不大。所以下面只演示js的引入，html和css引入根据自己实际</span></p><p id="e287944b65da3c8440df4c4dba0ef07c" class="ne-p"><span class="ne-text">项目需要使用哪种风格引入对应的HTML和CSS。</span></p><pre data-language="javascript" id="86ZXL" class="ne-codeblock language-javascript"><script src="js/jquery.min.js"></script><script src="js/fullpage.min.js"></script><script>      $(function() {          $('#dowebok').fullpage({            sectionsColor: ['pink', '#4BBFC3', '#7BAABE', '#f90'],            navigation: true          });    });</script></pre><p id="2f7f87435ce98177fd89bfdab4cc6b76" class="ne-p"><span class="ne-text">注意：实际开发，一般复制文件，然后在文件中进行修改和添加功能。</span></p><h3 id="98lES"><span class="ne-text">1.4.4. bootstrap组件</span></h3><p id="50234f7e89ffa7a36c8cc0085a266321" class="ne-p"><span class="ne-text">    Bootstrap是 Twitter 公司设计的基于HTML、CSS、JavaScript开发的简洁、直观、强悍的前端开发框架，他依靠jQuery实现，且支持响应式</span></p><p id="8f56f32642a879204a210868af4e763a" class="ne-p"><span class="ne-text">布局，使得 Web 开发更加方便快捷。</span></p><p id="c8e213a8d8f91767729d58ef025d6f61" class="ne-p"><span class="ne-text">    </span><strong><span class="ne-text">凡是在软件开发中用到了软件的复用，被复用的部分都可以称为组件，凡是在应用程序中已经预留接口的组件就是插件</span></strong><span class="ne-text">。Bootstrap组件使</span></p><p id="368dd2f0fa47cebfbab2bf2c7399daaa" class="ne-p"><span class="ne-text">用非常方便:  1.引入bootstrap相关css和js        2.去官网复制html</span></p><p id="4a9225b1c8e31ed25c4d6ebdae4988e0" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><ol class="ne-ol"><li id="4a472d790db2f22b81f27a91c87e19a0"><span class="ne-text">引入bootstrap相关css和js</span></li></ol><pre data-language="javascript" id="6ipQN" class="ne-codeblock language-javascript"><link rel="stylesheet" href="bootstrap/css/bootstrap.min.css"><script src="bootstrap/js/jquery.min.js"></script><script src="bootstrap/js/bootstrap.min.js"></script></pre><ol start="2" class="ne-ol"><li id="bf12ebc8e0315ae0176857a9c5c7759b"><span class="ne-text">去官网复制html的功能模块</span></li></ol><pre data-language="javascript" id="2xSxe" class="ne-codeblock language-javascript"><div class="container"><pre><code>    &lt;!-- Single button --&gt;    &lt;div class=&quot;btn-group&quot;&gt;        &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;          Action &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;        &lt;/button&gt;        &lt;ul class=&quot;dropdown-menu&quot;&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt;            &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;     &lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;h3 id=&quot;raOoE&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;1.4.5. bootstrap插件（JS）&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;c0414aa19be56e28edc03d11e744fdf3&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;    bootstrap中的js插件其实也是组件的一部分，只不过是需要js调用功能的组件，所以一般bootstrap的js插件一般会伴随着js代码（有的也可以&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;60eca7467a6a6d0b4088869c14a4b473&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;省略js，用属性实现）。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;e45e9aec6dbcc78cf247f3e846c6a3a2&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;    步骤： 1.引入bootstrap相关css和js        2.去官网复制html        3.复制js代码，启动js插件。&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;7c5e733d100b5c5e68cadf1a2c2ed718&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;代码演示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ol class=&quot;ne-ol&quot;&gt;&lt;li id=&quot;e18e9a0b2dff0f2a70cb9ccda6ab5a76&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;引入bootstrap相关css和js&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-language=&quot;javascript&quot; id=&quot;waROx&quot; class=&quot;ne-codeblock language-javascript&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt;</code></pre><script src="bootstrap/js/jquery.min.js"></script><script src="bootstrap/js/bootstrap.min.js"></script></pre><ol start="2" class="ne-ol"><li id="5c0b585808c162fedf482a8320273a86"><span class="ne-text">去官网复制html的功能模块</span></li></ol><pre data-language="javascript" id="7ZUs3" class="ne-codeblock language-javascript"><!-- 模态框 --><!-- Large modal --><p><button type="button" class="btn btn-primary" data-toggle="modal" data-target=".bs-example-modal-lg">Large modal</button></p><div class="modal fade bs-example-modal-lg" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">    <div class="modal-dialog modal-lg" role="document">        <div class="modal-content">            里面就是模态框        </div>    </div></div></pre><ol start="3" class="ne-ol"><li id="d9ce2af0a9b472020ce2d76ef872b8d0"><span class="ne-text">复制js代码，启动js插件。</span></li></ol><pre data-language="javascript" id="FJdF9" class="ne-codeblock language-javascript"><script>    // 当我们点击了自己定义的按钮，就弹出模态框    $(".myBtn").on("click", function() {        // alert(11);        $('#btn').modal()    })</script></pre><h3 id="ew7V0"><span class="ne-text">1.4.6. bootstrap案例-阿里百秀</span></h3><div class="ne-quote"><p id="c8d8cd4d291f85a5d849fbadaf2de451" class="ne-p"><span class="ne-text">1.通过调用组件实现导航栏</span></p><p id="def90a1ecb0b6791eb0b21b59195f115" class="ne-p"><span class="ne-text">2.通过调用插件实现登录</span></p><p id="f27406bc15cbc2e5a7e2322fa61f11be" class="ne-p"><span class="ne-text">3.通过调用插件标签页实现 tab 栏</span></p></div><p id="a14550fd94b926128c9a99ae9f926815" class="ne-p"><span class="ne-text">    代码实现略。(详情参考源代码)</span></p><h2 id="hzD6P"><span class="ne-text">1.7. 综合案例: toDoList案例分析（代码略）</span></h2><h3 id="flTdM"><span class="ne-text">1.7.1 案例：案例介绍</span></h3><pre data-language="javascript" id="saDMk" class="ne-codeblock language-javascript">// 1. 文本框里面输入内容，按下回车，就可以生成待办事项。// 2. 点击待办事项复选框，就可以把当前数据添加到已完成事项里面。// 3. 点击已完成事项复选框，就可以把当前数据添加到待办事项里面。// 4. 但是本页面内容刷新页面不会丢失。</pre><h3 id="Ipy2e"><span class="ne-text">1.7.2 案例：toDoList 分析</span></h3><pre data-language="javascript" id="3Mw4o" class="ne-codeblock language-javascript">// 1. 刷新页面不会丢失数据，因此需要用到本地存储 localStorage// 2. 核心思路： 不管按下回车，还是点击复选框，都是把本地存储的数据加载到页面中，这样保证刷新关闭页面不会丢失数据// 3. 存储的数据格式：var todolist =  [{ title : ‘xxx’, done: false}]// 4. 注意点1： 本地存储 localStorage 里面只能存储字符串格式 ，因此需要把对象转换为字符串 JSON.stringify(data)。// 5. 注意点2： 获取本地存储数据，需要把里面的字符串转换为对象格式JSON.parse() 我们才能使用里面的数据。</pre><h3 id="2WmZi"><span class="ne-text">1.7.3 案例：toDoList 按下回车把新数据添加到本地存储里面</span></h3><pre data-language="javascript" id="roH3C" class="ne-codeblock language-javascript">// 1.切记： 页面中的数据，都要从本地存储里面获取，这样刷新页面不会丢失数据，所以先要把数据保存到本地存储里面。// 2.利用事件对象.keyCode判断用户按下回车键（13）。// 3.声明一个数组，保存数据。// 4.先要读取本地存储原来的数据（声明函数 getData()），放到这个数组里面。// 5.之后把最新从表单获取过来的数据，追加到数组里面。// 6.最后把数组存储给本地存储 (声明函数 savaDate())</pre><h3 id="EYpyG"><span class="ne-text">1.7.4 案例：toDoList 本地存储数据渲染加载到页面</span></h3><pre data-language="javascript" id="a0ez7" class="ne-codeblock language-javascript">// 1.因为后面也会经常渲染加载操作，所以声明一个函数 load，方便后面调用// 2.先要读取本地存储数据。（数据不要忘记转换为对象格式）// 3.之后遍历这个数据（$.each()），有几条数据，就生成几个小li 添加到 ol 里面。// 4.每次渲染之前，先把原先里面 ol 的内容清空，然后渲染加载最新的数据。</pre><h3 id="Bq0CI"><span class="ne-text">1.7.5 案例：toDoList 删除操作</span></h3><pre data-language="javascript" id="GqvS4" class="ne-codeblock language-javascript">// 1.点击里面的a链接，不是删除的li，而是删除本地存储对应的数据。// 2.核心原理：先获取本地存储数据，删除对应的数据，保存给本地存储，重新渲染列表li// 3.我们可以给链接自定义属性记录当前的索引号// 4.根据这个索引号删除相关的数据----数组的splice(i, 1)方法// 5.存储修改后的数据，然后存储给本地存储// 6.重新渲染加载数据列表// 7.因为a是动态创建的，我们使用on方法绑定事件</pre><h3 id="4xnMN"><span class="ne-text">1.7.6 案例：toDoList  正在进行和已完成选项操作</span></h3><pre data-language="javascript" id="Nx2ls" class="ne-codeblock language-javascript">// 1.当我们点击了小的复选框，修改本地存储数据，再重新渲染数据列表。// 2.点击之后，获取本地存储数据。// 3.修改对应数据属性 done 为当前复选框的checked状态。// 4.之后保存数据到本地存储// 5.重新渲染加载数据列表// 6.load 加载函数里面，新增一个条件,如果当前数据的done为true 就是已经完成的，就把列表渲染加载到 ul 里面// 7.如果当前数据的done 为false， 则是待办事项，就把列表渲染加载到 ol 里面</pre><h3 id="yB6r9"><span class="ne-text">1.7.7 案例：toDoList 统计正在进行个数和已经完成个数</span></h3><pre data-language="javascript" id="ZhuSH" class="ne-codeblock language-javascript">// 1.在我们load 函数里面操作// 2.声明2个变量 ：todoCount 待办个数  doneCount 已完成个数   // 3.当进行遍历本地存储数据的时候， 如果 数据done为 false， 则 todoCount++, 否则 doneCount++// 4.最后修改相应的元素 text()</pre><h2 id="Xmq62"><span class="ne-text">1.8. 今日总结</span></h2><p id="05f8df70e9447b2bb650af82331e3c22" class="ne-p"><img src="images/%E6%80%BB%E7%BB%93.png" id="M74oU" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery元素+属性操作</title>
      <link href="/blog/2_day02_jquery/"/>
      <url>/blog/2_day02_jquery/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="a84WB"><span class="ne-text">jQuery 属性操作</span></h2><p id="a8defb124f5e5a9575153fec51a39e0b" class="ne-p"><span class="ne-text">jQuery 常用属性操作有三种：prop() / attr() / data() ;</span></p><h3 id="3uR5P"><span class="ne-text">元素固有属性值 prop()</span></h3><p id="b8a37df535bfa26833c1ed9f7513401d" class="ne-p"><span class="ne-text">所谓元素固有属性就是元素本身自带的属性，比如  元素里面的 href ，比如  元素里面的 type。</span></p><p id="a9487485bd2d576830eb3683b8133305" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="c67bac1140207aad202dec5763ae612e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492194-d6d9ff5b-5c98-495b-bebb-c3be7790bbf4.png" width="619" id="F3BQ7" class="ne-image"></p><p id="f6f44187171a3efbebbb6447243d6f25" class="ne-p"><span class="ne-text">注意：prop() 除了普通属性操作，更适合操作表单属性：disabled / checked / selected 等。</span></p><h3 id="4q3oJ"><span class="ne-text">元素自定义属性值 attr()</span></h3><p id="1e90bde4e6989ac8347119f1cf6c2c3b" class="ne-p"><span class="ne-text">用户自己给元素添加的属性，我们称为自定义属性。 比如给 div 添加 index =“1”。</span></p><p id="8a1aabfa4ec49b05bfc0060d7fc95a2b" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="fe9ca068f651da492fabea6d7b7516ea" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492261-f36c35ad-cba6-4c24-ac2d-18781c30b41a.png" width="616" id="ULnKR" class="ne-image"></p><p id="ef1900287a2293f5a2cb993d6b0cf328" class="ne-p"><span class="ne-text">    注意：attr() 除了普通属性操作，更适合操作自定义属性。（该方法也可以获取 H5 自定义属性）</span></p><h3 id="EKaoU"><span class="ne-text">数据缓存 data()</span></h3><p id="44d6f8942be4dd8afaed4a940dcdaf62" class="ne-p"><span class="ne-text">    data() 方法可以在指定的元素上存取数据，并不会修改 DOM 元素结构。一旦页面刷新，之前存放的数据都将被移除。</span></p><p id="24c6921186ca6d63500beddc86d91c7f" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="4fcfe1d6594d886fe9b1e0165d692b29" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492334-8d7a046e-854f-4449-a169-2820244ff75f.png" width="616" id="teEJx" class="ne-image"></p><p id="3343a230869e6af51123f0592ff78b20" class="ne-p"><span class="ne-text">注意：同时，还可以读取 HTML5 自定义属性  data-index ，得到的是数字型。</span></p><p id="ccd713e912a51f9648ef08f6b4f37aea" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre data-language="javascript" id="xR65O" class="ne-codeblock language-javascript"><body><pre><code>&lt;a href=&quot;http://www.itcast.cn&quot; title=&quot;都挺好&quot;&gt;都挺好&lt;/a&gt;&lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; checked&gt;&lt;div index=&quot;1&quot; data-index=&quot;2&quot;&gt;我是div&lt;/div&gt;&lt;span&gt;123&lt;/span&gt;&lt;script&gt;    $(function() &#123;        //1. element.prop(&quot;属性名&quot;) 获取元素固有的属性值        console.log($(&quot;a&quot;).prop(&quot;href&quot;));        $(&quot;a&quot;).prop(&quot;title&quot;, &quot;我们都挺好&quot;);        $(&quot;input&quot;).change(function() &#123;            console.log($(this).prop(&quot;checked&quot;));        &#125;);        // console.log($(&quot;div&quot;).prop(&quot;index&quot;));        // 2. 元素的自定义属性 我们通过 attr()        console.log($(&quot;div&quot;).attr(&quot;index&quot;));        $(&quot;div&quot;).attr(&quot;index&quot;, 4);        console.log($(&quot;div&quot;).attr(&quot;data-index&quot;));        // 3. 数据缓存 data() 这个里面的数据是存放在元素的内存里面        $(&quot;span&quot;).data(&quot;uname&quot;, &quot;andy&quot;);        console.log($(&quot;span&quot;).data(&quot;uname&quot;));        // 这个方法获取data-index h5自定义属性 第一个 不用写data-  而且返回的是数字型        console.log($(&quot;div&quot;).data(&quot;index&quot;));    &#125;)&lt;/script&gt;</code></pre></body></pre><h2 id="Zge0q"><span class="ne-text">jQuery 文本属性值</span></h2><p id="5dedcb1fae70b3e970d22cf12f74224d" class="ne-p"><span class="ne-text">jQuery的文本属性值常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性。</span></p><h3 id="pHXtm"><span class="ne-text">jQuery内容文本值</span></h3><p id="1c68e4140afbb05fe6c9039e32ce483c" class="ne-p"><span class="ne-text">常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性，主要针对元素的内容还有表单的值操作。</span></p><p id="c731a7625b28369eb5cc172761a1aec0" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="9390d9f3727b9b4d762371d4e296475d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492400-d8ee58ad-1d5e-42a0-a07f-52d7558fb341.png" width="663" id="WFDE9" class="ne-image"></p><p id="fe96f366f951c6e6593d7640219a72d1" class="ne-p"><span class="ne-text">注意：html() 可识别标签，text() 不识别标签。</span></p><p id="d0ec0a582e10753e0d7879ab68d48642" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre data-language="javascript" id="VcVFt" class="ne-codeblock language-javascript"><body>    <div>        <span>我是内容</span>    </div>    <input type="text" value="请输入内容">    <script>        // 1. 获取设置元素内容 html()        console.log($("div").html());        // $("div").html("123");        // 2. 获取设置元素文本内容 text()        console.log($("div").text());        $("div").text("123");        // 3. 获取设置表单值 val()        console.log($("input").val());        $("input").val("123");    </script></body></pre><h2 id="c2kiZ"><span class="ne-text">jQuery 元素操作</span></h2><p id="d4dd32c8b56d740c5000658a8051fcbf" class="ne-p"><span class="ne-text">jQuery 元素操作主要讲的是用jQuery方法，操作标签的遍历、创建、添加、删除等操作。</span></p><h3 id="LTUXw"><span class="ne-text">遍历元素</span></h3><p id="da559053930325ccc78d10eed450cbc8" class="ne-p"><span class="ne-text">jQuery 隐式迭代是对同一类元素做了同样的操作。 如果想要给同一类元素做不同操作，就需要用到遍历。</span></p><p id="bc3b6d6af0dd36ad44979f953823bfff" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492472-0f31ef63-133b-40cf-b438-391dde571eb4.png" width="622" id="kRNyG" class="ne-image"></p><p id="4e8e29b1e454c9573443c3dc25a4c65d" class="ne-p"><span class="ne-text">注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。</span></p><p id="90f8868709a602071b2ed5c829c476fd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492553-9c2ac31d-49a0-4e91-bf4e-d2279e74ff32.png" width="617" id="W8TwJ" class="ne-image"></p><p id="d560c0796978ee3038a0252c52c75a74" class="ne-p"><span class="ne-text">注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。</span></p><p id="c457090a7ff195c6728e2f0ce715073c" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre data-language="javascript" id="XaNZ1" class="ne-codeblock language-javascript"><body>    <div>1</div>    <div>2</div>    <div>3</div>    <script>        $(function() {            // 如果针对于同一类元素做不同操作，需要用到遍历元素（类似for，但是比for强大）            var sum = 0;            var arr = ["red", "green", "blue"];            // 1. each() 方法遍历元素             $("div").each(function(i, domEle) {                // 回调函数第一个参数一定是索引号  可以自己指定索引号号名称                // console.log(i);                // 回调函数第二个参数一定是 dom 元素对象，也是自己命名                // console.log(domEle);  // 使用jQuery方法需要转换 $(domEle)                $(domEle).css("color", arr[i]);                sum += parseInt($(domEle).text());            })            console.log(sum);            // 2. $.each() 方法遍历元素 主要用于遍历数据，处理数据            // $.each($("div"), function(i, ele) {            //     console.log(i);            //     console.log(ele);            // });            // $.each(arr, function(i, ele) {            //     console.log(i);            //     console.log(ele);            // })            $.each({                name: "andy",                age: 18            }, function(i, ele) {                console.log(i); // 输出的是 name age 属性名                console.log(ele); // 输出的是 andy  18 属性值            })        })    </script></body></pre><h3 id="b1i7j"><span class="ne-text">创建、添加、删除</span></h3><p id="22331a7c4bac55bdabf10be2d0cd3b45" class="ne-p"><span class="ne-text">jQuery方法操作元素的创建、添加、删除方法很多，则重点使用部分，如下：</span></p><p id="ae75d84aaedc75e27004c537ab734f2d" class="ne-p"><strong><span class="ne-text">语法总和</span></strong></p><p id="b084aa5675b44665b99fa086aa3cf755" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492632-06694ce7-f376-454f-9c85-c4f7a0ba0338.png" width="624" id="yRDsg" class="ne-image"></p><p id="09d17b60e40b36a044d0f790df349c0b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492709-dbf5e1ae-fcee-4283-8cc2-5ecb0bcc1b83.png" width="623" id="jQMTc" class="ne-image"></p><p id="2c2af8ddf2ff10d519825d26564b9f84" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492783-28f74b87-b629-477d-9ca2-47e4588c4b96.png" width="621" id="YQmbb" class="ne-image"></p><p id="72c38b32527c6926ba9e0d65ee4e84d9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492861-e9f292d0-aaf9-4b05-b013-77a589f3bf2a.png" width="625" id="YVMfw" class="ne-image"></p><p id="8d1b437df37981f98a63c0a1976308bf" class="ne-p"><span class="ne-text">    注意：以上只是元素的创建、添加、删除方法的常用方法，其他方法请参详API。</span></p><p id="122596ffaae400a0c8adf0a6cf8c7b00" class="ne-p"><strong><span class="ne-text">案例代码</span></strong></p><pre data-language="html" id="CPLnH" class="ne-codeblock language-html"><body>    <ul>        <li>原先的li</li>    </ul>    <div class="test">我是原先的div</div>    <script>        $(function() {            // 1. 创建元素            var li = $("<li>我是后来创建的li</li>");      <pre><code>        // 2. 添加元素        //     2.1 内部添加        // $(&quot;ul&quot;).append(li);  内部添加并且放到内容的最后面         $(&quot;ul&quot;).prepend(li); // 内部添加并且放到内容的最前面        //  2.2 外部添加        var div = $(&quot;&lt;div&gt;我是后妈生的&lt;/div&gt;&quot;);        // $(&quot;.test&quot;).after(div);        $(&quot;.test&quot;).before(div);          // 3. 删除元素        // $(&quot;ul&quot;).remove(); 可以删除匹配的元素 自杀        // $(&quot;ul&quot;).empty(); // 可以删除匹配的元素里面的子节点 孩子        $(&quot;ul&quot;).html(&quot;&quot;); // 可以删除匹配的元素里面的子节点 孩子    &#125;)&lt;/script&gt;</code></pre></body></pre><h2 id="4p0dj"><span class="ne-text">jQuery 尺寸、位置操作</span></h2><p id="48388913479dff10690233a08f9860ba" class="ne-p"><span class="ne-text">jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。</span></p><h3 id="uwWhH"><span class="ne-text">jQuery 尺寸操作</span></h3><p id="c8aaa1b81d5817ab46a9041c62bf29f3" class="ne-p"><span class="ne-text">jQuery 尺寸操作包括元素宽高的获取和设置，且不一样的API对应不一样的盒子模型。</span></p><p id="94a1c1107dcc132d20661ab9850a3f6f" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="c775a5b617646febd7150a498ab8fb00" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492939-79b5b959-2700-496c-adb0-d049e25f6490.png" width="629" id="sD1iA" class="ne-image"></p><p id="111930a35a9b8d2157f54007cfcb8235" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><pre data-language="javascript" id="4DZ0D" class="ne-codeblock language-javascript"><body>    <div></div>    <script>        $(function() {            // 1. width() / height() 获取设置元素 width和height大小             console.log($("div").width());            // $("div").width(300);            // 2. innerWidth() / innerHeight()  获取设置元素 width和height + padding 大小             console.log($("div").innerWidth());            // 3. outerWidth()  / outerHeight()  获取设置元素 width和height + padding + border 大小             console.log($("div").outerWidth());            // 4. outerWidth(true) / outerHeight(true) 获取设置 width和height + padding + border + margin            console.log($("div").outerWidth(true));        })    </script></body></pre><p id="87df67f798730df6655125418d43a041" class="ne-p"><span class="ne-text">注意：有了这套 API 我们将可以快速获取和子的宽高，至于其他属性想要获取和设置，还要使用 css() 等方法配合。</span></p><h3 id="oNnlJ"><span class="ne-text">jQuery 位置操作</span></h3><p id="9139b8677f3c1d005f6fce8ae1788241" class="ne-p"><span class="ne-text">jQuery的位置操作主要有三个： offset()、position()、scrollTop()/scrollLeft() , 具体介绍如下:</span></p><p id="64e6daca86565ba5a3bd127b34da1fae" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="cde3dca760a02c5526209a3a07b40b18" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493024-1b363784-6614-4dd9-8ddc-dd97531a3cb6.png" width="663" id="No6MP" class="ne-image"></p><p id="331d1daa4a3c747bf22b136812e7e456" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493095-d18b82ae-83d0-465b-bf27-4fb9449ee6c6.png" width="663" id="uRPbe" class="ne-image"></p><p id="60be9a06b093c0bc7b909727767cdcfa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493171-f3d23a41-7256-4fe7-9818-1624a3ab45ce.png" width="663" id="q9MPG" class="ne-image"></p><p id="52420ede99fa7dfcd6a1af6949acadc9" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><pre data-language="javascript" id="KPbJB" class="ne-codeblock language-javascript"><body>    <div class="father">        <div class="son"></div>    </div>        <pre><code>&lt;div class=&quot;back&quot;&gt;返回顶部&lt;/div&gt;&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;&lt;script&gt;    $(function() &#123;        // 1. 获取设置距离文档的位置（偏移） offset        console.log($(&quot;.son&quot;).offset());        console.log($(&quot;.son&quot;).offset().top);        // $(&quot;.son&quot;).offset(&#123;        //     top: 200,        //     left: 200        // &#125;);          // 2. 获取距离带有定位父级位置（偏移） position   如果没有带有定位的父级，则以文档为准        // 这个方法只能获取不能设置偏移        console.log($(&quot;.son&quot;).position());        // $(&quot;.son&quot;).position(&#123;        //     top: 200,        //     left: 200        // &#125;);            // 3. 被卷去的头部          $(document).scrollTop(100);        // 被卷去的头部 scrollTop()  / 被卷去的左侧 scrollLeft()        // 页面滚动事件        var boxTop = $(&quot;.container&quot;).offset().top;        $(window).scroll(function() &#123;            // console.log(11);            console.log($(document).scrollTop());            if ($(document).scrollTop() &gt;= boxTop) &#123;                $(&quot;.back&quot;).fadeIn();            &#125; else &#123;                $(&quot;.back&quot;).fadeOut();            &#125;        &#125;);        // 返回顶部        $(&quot;.back&quot;).click(function() &#123;            // $(document).scrollTop(0);            $(&quot;body, html&quot;).stop().animate(&#123;                scrollTop: 0            &#125;);            // $(document).stop().animate(&#123;            //     scrollTop: 0            // &#125;); 不能是文档而是 html和body元素做动画        &#125;)    &#125;)&lt;/script&gt;</code></pre></body></pre></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery选择器+样式操作+动画效果</title>
      <link href="/blog/1_day01_jquery/"/>
      <url>/blog/1_day01_jquery/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="8Ek4z"><span class="ne-text">jQuery 介绍</span></h2><h3 id="KqIXV"><span class="ne-text">JavaScript 库</span></h3><p id="1182ed20e25accc5fbd9143d687f6c07" class="ne-p"><span class="ne-text">JavaScript库：即 library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show，比如获取元素等。</span></p><div class="ne-quote"><p id="89d908b18207376577ae8cc53af60e5c" class="ne-p"><span class="ne-text">简单理解： 就是一个JS 文件，里面对我们原生js代码进行了封装，存放到里面。这样我们可以快速高效的使用这些封装好的功能了。</span></p><p id="a6ec09241f96424cab0d9be5df79a994" class="ne-p"><span class="ne-text">比如 jQuery，就是为了快速方便的操作DOM，里面基本都是函数（方法）。</span></p></div><p id="0427ba38e93e82b2a3d289aa1fc3b4d9" class="ne-p"><span class="ne-text">常见的JavaScript 库：jQuery、Prototype、YUI、Dojo、Ext JS、移动端的zepto等，这些库都是对原生 JavaScript 的封装，内部都是用 JavaScript 实现的，我们主要学习的是 jQuery。</span></p><h3 id="4SEJ9"><span class="ne-text">jQuery的概念</span></h3><p id="47e5877d4eb321532eccc0128e9515af" class="ne-p"><span class="ne-text">jQuery总体概况如下 :</span></p><ul class="ne-ul"><li id="6fdb9a8e1f3d9da6b783eff0d2f0e8a3"><span class="ne-text">jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。</span></li><li id="f94375b9bc1b990b73aa941ff7365fbf"><span class="ne-text">j 就是 JavaScript；   Query 查询； 意思就是查询js，把js中的DOM操作做了封装，我们可以快速的查询使用里面的功能。</span></li></ul><ul class="ne-ul"><li id="70723e35bcaf5be7cc5bd40732363cb3"><span class="ne-text">jQuery 封装了 JavaScript 常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 Ajax 交互。</span></li><li id="934ff02a78cc1adfb530a19375b126ae"><span class="ne-text">学习jQuery本质： 就是学习调用这些函数（方法）。</span></li></ul><ul class="ne-ul"><li id="7f63453d84012af519d0990d13470253"><span class="ne-text">jQuery 出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率。</span></li></ul><h3 id="34zpI"><span class="ne-text">jQuery的优点</span></h3><ol class="ne-ol"><li id="54115ba1d6e8f841c0e60eb142d7ba7d"><span class="ne-text">轻量级。核心文件才几十kb，不会影响页面加载速度。</span></li><li id="727281aa54326002957b4cb7c923ab55"><span class="ne-text">跨浏览器兼容，基本兼容了现在主流的浏览器。</span></li></ol><ol start="3" class="ne-ol"><li id="6efed6014d1bc336e5f55d5eee4daecc"><span class="ne-text">链式编程、隐式迭代。</span></li><li id="b26b37f7cb86f312d5f27bcc6bc2c448"><span class="ne-text">对事件、样式、动画支持，大大简化了DOM操作。</span></li></ol><ol start="5" class="ne-ol"><li id="6b26dec636a34b31fdd0b573b899c3e1"><span class="ne-text">支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等。</span></li><li id="8c812f001480b530e4aad998df0eca9f"><span class="ne-text">免费、开源。</span></li></ol><h2 id="18WMh"><span class="ne-text">jQuery 的基本使用</span></h2><h3 id="wJ15y"><span class="ne-text">jQuery 的下载</span></h3><p id="867f0b84a73e837656a8e417ea851cc0" class="ne-p"><span class="ne-text">jQuery的官网地址： </span><a href="https://jquery.com/" data-href="https://jquery.com/" target="_blank" class="ne-link"><span class="ne-text">https://jquery.com/</span></a><span class="ne-text">，官网即可下载最新版本。</span></p><div class="ne-quote"><p id="2fef01ecc28078472419fcc46b8fab90" class="ne-p"><span class="ne-text">各个版本的下载：</span><a href="https://code.jquery.com/" data-href="https://code.jquery.com/" target="_blank" class="ne-link"><span class="ne-text">https://code.jquery.com/</span></a></p></div><p id="bd5c5ad29252aa4b3f3f55125afcadcf" class="ne-p"><span class="ne-text">版本介绍：</span></p><div class="ne-quote"><p id="8bddad0a025599de58d1aef78f52bf1b" class="ne-p"><span class="ne-text">1x ：兼容 IE 678 等低版本浏览器， 官网不再更新</span></p><p id="a9d6041ed889a999dc5d2e207deb18b7" class="ne-p"><span class="ne-text">2x ：不兼容 IE 678 等低版本浏览器， 官网不再更新</span></p><p id="dc445a36ad5d4ead3db6ca4c08e263b3" class="ne-p"><span class="ne-text">3x ：不兼容 IE 678 等低版本浏览器， 是官方主要更新维护的版本</span></p></div><h3 id="gQGyH"><span class="ne-text">jQuery的入口函数</span></h3><p id="930452f0e22e096c9e91ba76df805407" class="ne-p"><span class="ne-text">jQuery中常见的两种入口函数：</span></p><pre data-language="javascript" id="GgQmy" class="ne-codeblock language-javascript">// 第一种: 简单易用。<p>$(function () {<br>    …  // 此处是页面 DOM 加载完成的入口<br>}) ;<br>// 第二种: 繁琐，但是也可以实现<br>$(document).ready(function(){<br>… // 此处是页面 DOM 加载完成的入口<br>});</pre><p id="4137ae0c08ddfbbdc35f9bb25fab0a32" class="ne-p"><span class="ne-text">总结：</span></p><ol class="ne-ol"><li id="702afba3d76b335eb7f5f6ee13d6fb68"><span class="ne-text">等着 DOM 结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery 帮我们完成了封装。</span></li><li id="fef8c6c594017f4a36d613903afcba23"><span class="ne-text">相当于原生 js 中的 DOMContentLoaded。</span></li></ol><ol start="3" class="ne-ol"><li id="3966a73057b576f4fb354b1c319921b6"><span class="ne-text">不同于原生 js 中的 load 事件是等页面文档、外部的 js 文件、css 文件、图片加载完毕才执行内部代码。</span></li><li id="e4946db59715c38c5704f0292060129f"><span class="ne-text">更推荐使用第一种方式。</span></li></ol><h3 id="77r7T"><span class="ne-text">jQuery 中的顶级对象$</span></h3><ol class="ne-ol"><li id="36d2bcdc0d5dd72ee958df908e2c4c93"><span class="ne-text">$是 jQuery 的别称，在代码中可以使用 jQuery 代替，但一般为了方便，通常都直接使用 $ 。</span></li><li id="a4ed960ba7251da7e7a4fa568a74d579"><span class="ne-text">$是jQuery的顶级对象，相当于原生JavaScript中的 window。把元素利用$包装成 jQuery 对象，就可以调用 jQuery 的方法。</span></li></ol><h3 id="luvkQ"><span class="ne-text">jQuery 对象和 DOM 对象</span></h3><p id="6c165ae2a5431e0e40917ff04cae2b55" class="ne-p"><span class="ne-text">使用 jQuery 方法和原生 JS 获取的元素是不一样的，总结如下 :</span></p><ol class="ne-ol"><li id="cb1a96b529e1e8c0590a5739529364a3"><span class="ne-text">用原生 JS 获取来的对象就是 DOM 对象</span></li><li id="994792250516d232528543d6adf94dff"><span class="ne-text">jQuery 方法获取的元素就是 jQuery 对象。</span></li></ol><ol start="3" class="ne-ol"><li id="6e09e2361690febe741b4bd8016a0123"><span class="ne-text">jQuery 对象本质是： 利用$对DOM 对象包装后产生的对象（伪数组形式存储）。</span></li></ol><div class="ne-quote"><p id="190b19ef2498ddbda5b40f6fac9f554d" class="ne-p"><span class="ne-text">注意：</span></p><p id="1d18c24b0bbd0ffe0ce089de583233c9" class="ne-p"><span class="ne-text">只有 jQuery 对象才能使用 jQuery 方法，DOM 对象则使用原生的 JavaScirpt 方法。</span></p></div><h3 id="gMhvh"><span class="ne-text">jQuery 对象和 DOM 对象转换</span></h3><p id="c20d3fa584d4735bc1f6fdcf11aaac95" class="ne-p"><span class="ne-text">DOM 对象与 jQuery 对象之间是可以相互转换的。因为原生js 比 jQuery 更大，原生的一些属性和方法 jQuery没有给我们封装. 要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。</span></p><pre data-language="javascript" id="emRTS" class="ne-codeblock language-javascript">// 1.DOM对象转换成jQuery对象，方法只有一种<br>var box = document.getElementById('box');  // 获取DOM对象<br>var jQueryObject = $(box);  // 把DOM对象转换为 jQuery 对象<br>// 2.jQuery 对象转换为 DOM 对象有两种方法：<br>//   2.1 jQuery对象[索引值]<br>var domObject1 = $('div')[0]<br>//   2.2 jQuery对象.get(索引值)<br>var domObject2 = $('div').get(0)</pre><p id="b2649e984275afcf11127f6ed1c7f91f" class="ne-p"><span class="ne-text">总结：实际开发比较常用的是把DOM对象转换为jQuery对象，这样能够调用功能更加强大的jQuery中的方法。</span></p><h2 id="ktAhE"><span class="ne-text">jQuery 选择器</span></h2><p id="8d915d7e8be2007eae4e53e7df18a87c" class="ne-p"><span class="ne-text">原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。</span></p><p id="udb9b1577" class="ne-p"><span class="ne-text">参考：</span><a href="https://www.runoob.com/jquery/jquery-selectors.html" data-href="https://www.runoob.com/jquery/jquery-selectors.html" target="_blank" class="ne-link"><span class="ne-text">https://www.runoob.com/jquery/jquery-selectors.html</span></a></p><h3 id="lHMbX"><span class="ne-text">基础选择器</span></h3><pre data-language="js" id="1BMGs" class="ne-codeblock language-js">$("选择器") // 里面选择器直接写 CSS 选择器即可，但是要加引号</pre><h3 id="KXygK"><span class="ne-text">层级选择器</span></h3><p id="b9c7844ef17f3fc98abcedfc0c93eb9c" class="ne-p"><span class="ne-text">层级选择器最常用的两个分别为：后代选择器和子代选择器。</span></p><p id="211aa1bc3e828ef4044aaaafc077e7dd" class="ne-p"><strong><span class="ne-text">基础选择器和层级选择器案例代码</span></strong></p><pre data-language="javascript" id="S789M" class="ne-codeblock language-javascript"><body></p><div>我是 div</div><div class="nav">我是 nav div</div><p>我是 p</p><ul><li>我是 ul 的</li><li>我是 ul 的</li>   <li>我是 ul 的</li></ul><script>$(function() {            console.log($(".nav"));console.log($("ul li"));})</script></body></pre><h3 id="8Ie2G"><span class="ne-text">筛选选择器</span></h3><p id="6b9a2e3242e899100e8da670172def21" class="ne-p"><span class="ne-text">筛选选择器，顾名思义就是在所有的选项中选择满足条件的进行筛选选择。常见如下 :</span></p><pre data-language="html" id="eoxCO" class="ne-codeblock language-html"><body>    <ul>        <li>多个里面筛选几个</li>        <li>多个里面筛选几个</li>        <li>多个里面筛选几个</li>        <li>多个里面筛选几个</li>        <li>多个里面筛选几个</li>        <li>多个里面筛选几个</li>    </ul>    <ol>        <li>多个里面筛选几个</li>        <li>多个里面筛选几个</li>        <li>多个里面筛选几个</li>        <li>多个里面筛选几个</li>        <li>多个里面筛选几个</li>        <li>多个里面筛选几个</li>    </ol>    <script>        $(function() {            $("ul li:first").css("color", "red");            $("ul li:eq(2)").css("color", "blue");            $("ol li:odd").css("color", "skyblue");            $("ol li:even").css("color", "pink");        })    </script></body></pre><p id="5616b4eb0ad58311565ee67efc781d46" class="ne-p"><span class="ne-text">另:  jQuery中还有一些筛选方法，类似DOM中的通过一个节点找另外一个节点，父、子、兄以外有所加强。</span></p><p id="42756e9054f54f3b4b93785466b00bc0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073490928-8c91de0f-b9b1-41c3-8a06-ab51b23cfb98.png" width="1002" id="oIGOe" class="ne-image"></p><h2 id="THC2V"><span class="ne-text">jQuery 样式操作</span></h2><p id="7af30d2ef8b5bbbfeb1e81a4df86098b" class="ne-p"><span class="ne-text">jQuery中常用的样式操作有两种：css() 和 设置类样式方法</span></p><h3 id="TFScD"><span class="ne-text">方法1: 操作 css 方法</span></h3><p id="6b1cdc342891d41f2302466d0b0ebd33" class="ne-p"><span class="ne-text">jQuery 可以使用 css 方法来修改简单元素样式； 也可以操作类，修改多个样式。常用以下三种形式 :</span></p><pre data-language="javascript" id="lu6Gt" class="ne-codeblock language-javascript">// 1.参数只写属性名，则是返回属性值var strColor = $(this).css('color');// 2.参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号$(this).css(''color'', ''red'');// 3.  参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开， 属性可以不用加引号$(this).css({ "color":"white","font-size":"20px"});</pre><p id="7dcd2e5fdb2a96a92824ac0d36473d98" class="ne-p"><span class="ne-text">注意：css() 多用于样式少时操作，多了则不太方便。</span></p><h3 id="jScRR"><span class="ne-text">方法2: 设置类样式方法</span></h3><p id="e0c1ea636dcb2989941876c8fe934775" class="ne-p"><span class="ne-text">作用等同于以前的 classList，可以操作类样式， 注意操作类里面的参数不要加点。常用的三种设置类样式方法：</span></p><pre data-language="javascript" id="fD4xM" class="ne-codeblock language-javascript">// 1.添加类$("div").addClass("current");// 2.删除类$("div").removeClass("current");// 3.切换类$("div").toggleClass("current");</pre><p id="d0fe2c914d179f1b39eed2ba6b1f99c9" class="ne-p"><span class="ne-text">注意：</span></p><ol class="ne-ol"><li id="b948cd658011062da26edc2fd8cc75c2"><span class="ne-text">设置类样式方法比较适合样式多时操作，可以弥补css()的不足。</span></li><li id="1e301e65e0bdebef5b03d8daec3aaf26"><span class="ne-text">原生 JS 中 className 会覆盖元素原先里面的类名，jQuery 里面类操作只是对指定类进行操作，不影响原先的类名。</span></li></ol><h2 id="NExrh"><span class="ne-text">jQuery 效果</span></h2><p id="09a892292bf997e01b28fd9034e6a6da" class="ne-p"><span class="ne-text">jQuery 给我们封装了很多动画效果，最为常见的如下：</span></p><ul class="ne-ul"><li id="ffa413f426cfa4b6a3c88697b4621ba6"><span class="ne-text">显示隐藏：show() / hide() / toggle() ;</span></li><li id="03430495a40cf5ad63ce6b178ee2bc9d"><span class="ne-text">划入画出：slideDown() / slideUp() / slideToggle() ;</span></li></ul><ul class="ne-ul"><li id="c351f774709f458e374596f03c13188e"><span class="ne-text">淡入淡出：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ;</span></li><li id="43f14f3792457b4703837fa1a4a61df1"><span class="ne-text">自定义动画：animate() ;</span></li></ul><div class="ne-quote"><p id="e99e03ba521df73423339073ebc39127" class="ne-p"><span class="ne-text">注意：</span></p><p id="d822bcecc9bfebe3c1bc84dae64a1d9f" class="ne-p"><span class="ne-text">动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。</span></p><p id="287cd3b3d4b8ef3bd476fbde0134c041" class="ne-p"><span class="ne-text">jQuery为我们提供另一个方法，可以停止动画排队：stop() ;</span></p></div><h3 id="I8g10"><span class="ne-text">显示隐藏切换</span></h3><p id="ba35a434e38a303b51fe45bb6b2283c9" class="ne-p"><span class="ne-text">显示隐藏动画，常见有三个方法：show() / hide() / toggle() ;</span></p><p id="2ee1cf188e6e4a659376dba53b3dfab4" class="ne-p"><span class="ne-text">语法规范如下:</span></p><p id="416abaa38bfefaa419861d8287198643" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491028-773a9d46-839b-4afc-bee1-17d55ed0a4ad.png" width="624" id="q0jwB" class="ne-image"></p><p id="c6c6910b9f6200fa8c9367be6990c80d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491164-e18ddc74-6cd9-4758-98be-8a4ba4a5659b.png" width="624" id="Jbw7X" class="ne-image"></p><p id="5f96e6b2edf4067f78883bba72d320fb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491265-475bb990-b1e3-4aa8-b58a-089a14539935.png" width="625" id="j1sLx" class="ne-image"></p><p id="829da9d5bf2a7ac1d61394ec386f2a96" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><pre data-language="javascript" id="85lKD" class="ne-codeblock language-javascript"><body>    <button>显示</button>    <button>隐藏</button>    <button>切换</button>    <div></div>    <script>        $(function() {            $("button").eq(0).click(function() {                $("div").show(1000, function() {                    alert(1);                });            })            $("button").eq(1).click(function() {                $("div").hide(1000, function() {                    alert(1);                });            })            $("button").eq(2).click(function() {              $("div").toggle(1000);            })            // 一般情况下，我们都不加参数直接显示隐藏就可以了        });    </script></body></pre><h3 id="CDLRs"><span class="ne-text">滑入滑出</span></h3><p id="80d7ab8a022efd9bee75d2f0266ee9fb" class="ne-p"><span class="ne-text">    滑入滑出动画，常见有三个方法：slideDown() / slideUp() / slideToggle() ;</span></p><p id="7dc11fc9a03cb4dc6729a2db14c5c5d7" class="ne-p"><span class="ne-text">    语法规范如下:</span></p><p id="f4b449101218606ab0bdef84f539bc90" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491339-dc77fd79-125f-48b7-a6e8-3d44db54fba8.png" width="624" id="WXVZd" class="ne-image"></p><p id="8c22b416d87c55e443bc009db57f05c0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491433-2cf9c8e4-43ce-4c72-849f-2d23bf822215.png" width="624" id="DlH5f" class="ne-image"></p><p id="f6e22f3389e5c250fc41ebfd1fa1876e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491518-8e00011c-f004-4d1b-81f4-e0ade442f00f.png" width="624" id="L8ZSu" class="ne-image"></p><p id="0342ef4909abaa63c533d2c6e683096e" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><pre data-language="javascript" id="1rle6" class="ne-codeblock language-javascript"><body>    <button>下拉滑动</button>    <button>上拉滑动</button>    <button>切换滑动</button>    <div></div>    <script>        $(function() {            $("button").eq(0).click(function() {                // 下滑动 slideDown()                $("div").slideDown();            })            $("button").eq(1).click(function() {                // 上滑动 slideUp()                $("div").slideUp(500);            })            $("button").eq(2).click(function() {                // 滑动切换 slideToggle()                $("div").slideToggle(500);            });        });    </script></body></pre><h3 id="CiMj0"><span class="ne-text">淡入淡出</span></h3><p id="462c12910e033a89114c6d7d41f8b49b" class="ne-p"><span class="ne-text">    淡入淡出动画，常见有四个方法：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ;</span></p><p id="d4f5b63d28c6d4e41ea043204ec3e6c5" class="ne-p"><span class="ne-text">    语法规范如下:</span></p><p id="4af8d14843a6a63e09ae03ac59e38312" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491592-b675c8b8-6d7a-40b5-a4be-d51dc9bd1c86.png" width="624" id="bTN9b" class="ne-image"></p><p id="cee2eb25ba4d625f5b8d37430b16171b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491668-703fa0c6-d2f4-48e6-a78c-5db0cb33df17.png" width="624" id="B9SjO" class="ne-image"></p><p id="030f1fd88e9045db226a17a4bce78044" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491743-2587d517-38fd-4633-9273-d99234bb35e4.png" width="624" id="lDuyr" class="ne-image"></p><p id="1582730df5ca6787b9552289f39c8678" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491838-9409127c-665d-4c7e-b4b0-180ef10ffa61.png" width="664" id="VB0bu" class="ne-image"></p><p id="99b19770e0353d6597f9d0fee0e904c6" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><pre data-language="javascript" id="VZvSM" class="ne-codeblock language-javascript"><body>    <button>淡入效果</button>    <button>淡出效果</button>    <button>淡入淡出切换</button>    <button>修改透明度</button>    <div></div>    <script>        $(function() {            $("button").eq(0).click(function() {                // 淡入 fadeIn()                $("div").fadeIn(1000);            })            $("button").eq(1).click(function() {                // 淡出 fadeOut()                $("div").fadeOut(1000);            })            $("button").eq(2).click(function() {                // 淡入淡出切换 fadeToggle()                $("div").fadeToggle(1000);            });            $("button").eq(3).click(function() {                //  修改透明度 fadeTo() 这个速度和透明度要必须写                $("div").fadeTo(1000, 0.5);            });        });    </script></body></pre><h3 id="5qt9U"><span class="ne-text">自定义动画</span></h3><p id="94b51ee08aa9de70ccdaf4af4e2d8c54" class="ne-p"><span class="ne-text">自定义动画非常强大，通过参数的传递可以模拟以上所有动画，方法为：animate() ;</span></p><p id="63538bb320e15d684798de366bf5f08e" class="ne-p"><span class="ne-text">语法规范如下:</span></p><p id="5b6452a6bf2aec5a1a52ffc39f496f9d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491922-87ac5de5-e3b5-410a-afee-89e862531e62.png" width="624" id="qdJ6i" class="ne-image"></p><p id="0b52743fd294c7b48e02306787939ecf" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><pre data-language="javascript" id="6GCVt" class="ne-codeblock language-javascript"><body>    <button>动起来</button>    <div></div>    <script>        $(function() {            $("button").click(function() {                $("div").animate({                    left: 500,                    top: 300,                    opacity: .4,                    width: 500                }, 500);            })        })    </script></body></pre><h3 id="2pqIY"><span class="ne-text">停止动画排队</span></h3><p id="8617b206957a15f156970392d25d694f" class="ne-p"><span class="ne-text">动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。</span></p><p id="ceade3f7ed7c37ca934aedf9b5c17eb2" class="ne-p"><span class="ne-text">停止动画排队的方法为：stop() ;</span></p><ul class="ne-ul"><li id="e4919040ecd04f675b45b00b2664d8b8"><span class="ne-text">stop() 方法用于停止动画或效果。</span></li><li id="e63109e8006775328abff943efc1510d"><span class="ne-text">stop() 写到动画或者效果的前面， 相当于停止结束上一次的动画。</span></li></ul><p id="b9dc36a4c7653e2a46f4771d932835ea" class="ne-p"><span class="ne-text">总结: 每次使用动画之前，先调用 stop() ,在调用动画。</span></p><h3 id="kiJtl"><span class="ne-text">事件切换hover()</span></h3><p id="8445780ebcf32907088caee425f296c0" class="ne-p"><span class="ne-text">jQuery中为我们添加了一个新事件 hover() ; 功能类似 css 中的伪类 :hover 。介绍如下</span></p><p id="4de11ed9eb7fac9a6a137f01677b2c9a" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><pre data-language="javascript" id="LIW7v" class="ne-codeblock language-javascript">hover([over,]out)     // 其中over和out为两个函数</pre><ul class="ne-ul"><li id="0fd0f5bb603299c8fe9f560e417e72e4"><span class="ne-text">over:鼠标移到元素上要触发的函数（相当于mouseenter）</span></li><li id="57fddb0388d5f83d790ae99a1397fa49"><span class="ne-text">out:鼠标移出元素要触发的函数（相当于mouseleave）</span></li></ul><ul class="ne-ul"><li id="9930c2cd83b177ec4b093104f6df99ad"><span class="ne-text">如果只写一个函数，则鼠标经过和离开都会触发它</span></li></ul><p id="e3e188a059e4045dc90d9c249b6c1a43" class="ne-p"><strong><span class="ne-text">hover事件和停止动画排列案例</span></strong></p><pre data-language="javascript" id="sCqR0" class="ne-codeblock language-javascript"><body>    <ul class="nav">        <li>            <a href="#">微博</a>            <ul><li><a href="">私信</a></li><li><a href="">评论</a></li><li><a href="">@我</a></li></ul>        </li>        <li>            <a href="#">微博</a>            <ul><li><a href="">私信</a></li><li><a href="">评论</a></li><li><a href="">@我</a></li></ul>        </li>    </ul>    <script>        $(function() {            // 鼠标经过            // $(".nav>li").mouseover(function() {            //     // $(this) jQuery 当前元素  this不要加引号            //     // show() 显示元素  hide() 隐藏元素            //     $(this).children("ul").slideDown(200);            // });            // // 鼠标离开            // $(".nav>li").mouseout(function() {            //     $(this).children("ul").slideUp(200);            // });            // 1. 事件切换 hover 就是鼠标经过和离开的复合写法            // $(".nav>li").hover(function() {            //     $(this).children("ul").slideDown(200);            // }, function() {            //     $(this).children("ul").slideUp(200);            // });            // 2. 事件切换 hover  如果只写一个函数，那么鼠标经过和鼠标离开都会触发这个函数            $(".nav>li").hover(function() {                // stop 方法必须写到动画的前面                $(this).children("ul").stop().slideToggle();            });        })    </script></body></pre><h2 id="x3QNW"></h2></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算方法各实验流程图汇总</title>
      <link href="/blog/hizlew/"/>
      <url>/blog/hizlew/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uc3674619" class="ne-p"><span class="ne-text">前言：大三</span><strong><span class="ne-text">计算方法</span></strong><span class="ne-text">课程所有实验报告的流程图，做个存档，以备不时之需~~</span><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1616633908079-3d59dbee-c4dc-4c51-899f-0708e3570b0d.gif" width="100" id="q5k8l" class="ne-image"><span class="ne-text">具体代码改天再找找再放上来。</span></p><p id="u715c090f" class="ne-p"><span class="ne-text"></span></p><p id="u45288615" class="ne-p"><span class="ne-text">目录</span></p><ul class="ne-ul"><li id="ub5e60a7d"><span class="ne-text">非线性方程的解法</span></li><li id="uee0b8ede"><span class="ne-text">线性方程组的解法</span></li><li id="uffbd453a"><span class="ne-text">Hermite插值</span></li><li id="u99f24e01"><span class="ne-text">最小二乘算法</span></li><li id="u6877ed26"><span class="ne-text">正态分布表复现</span></li></ul><p id="43476ec5ee1337c0526f302132b1eb5a" class="ne-p"><br></p><h2 id="27gMO"><span class="ne-text">非线性方程的解法</span></h2><p id="2cfd22a07c562b87d8010d893591d618" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633632638-fc4a4508-6a92-4c8e-ae80-6d7326f9e13a.jpeg" width="404" id="Px9X1" class="ne-image"></p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633610151-eed94d68-d147-4478-9c56-730fbe696d47.jpeg" id="zQMmN" style="display: block; width: 100%"><h2 id="fGbAk"><span class="ne-text">线性方程组的解法</span></h2><p id="960efc81107f3eaa62ed453a605ac22f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633672598-12d949b6-91f6-4b78-9825-21bd836c6dee.jpeg" width="445" id="ysuDu" class="ne-image"></p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633610254-fa45fc83-037a-4ef6-8335-15363df8051a.jpeg" id="uvwN0" style="display: block; width: 100%"><h2 id="6Oij3"><span class="ne-text">Hermite插值</span></h2><p id="3a88eb522d73ab9a56f2ca568fd3a2ea" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633702383-7da5e39f-e899-4034-acdd-7e0c417a1487.jpeg" width="459" id="dDpcv" class="ne-image"></p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633692587-90b66863-8a3c-4b63-8046-674f80dc04d9.jpeg" id="fOBI6" style="display: block; width: 100%"><h2 id="YRxKM"><span class="ne-text">最小二乘算法</span></h2><p id="973db9654ec87443e729d056bcabfbeb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633760214-e8df0fdd-19f5-44a7-97dc-7d3e5b05e0d3.jpeg" width="519" id="V41YV" class="ne-image"></p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633747782-b4fd3da7-09fe-4bed-bd37-e9bec306e6a6.jpeg" id="jtqHT" style="display: block; width: 100%"><h2 id="Yu8LW"><span class="ne-text">正态分布表复现</span></h2><p id="0cf80d4ab888f5c09a733d68185aadff" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633788535-61ef6425-b386-4a92-b3d8-44a136c3ee88.jpeg" width="416" id="NeiyB" class="ne-image"></p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633747770-5c3e05b2-2b4a-4187-9aa8-e4063434dfc0.jpeg" id="ZQOdI" style="display: block; width: 100%"></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 其他算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]前端PS操作-蓝湖</title>
      <link href="/blog/gqw2qf/"/>
      <url>/blog/gqw2qf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u26794714" class="ne-p"><span class="ne-text">前言：现在蓝湖做设计貌似非常多……</span></p><p id="ufe391f4b" class="ne-p"><span class="ne-text">插眼……</span></p><p id="u3510905b" class="ne-p"><span class="ne-text"></span></p><p id="ud3295ad2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1638108278654-c145b08a-a44d-4b0f-a532-0da59d850756.gif" width="218" id="T3DQk" class="ne-image"></p><h2 id="HuXqp"><span class="ne-text">ps基本操作以及常用快捷键：</span></h2><p id="4c10cfcabcc9afd35206c8752cacec54" class="ne-p"><span class="ne-text">因为网页美工大部分效果图都是利用ps 来做的，所以，以后我们大部分切图工作都是在ps里面完成。</span></p><ul class="ne-ul"><li id="02c7bb750bf77f927ed714ee6181402b"><span class="ne-text">文件--打开 --  可以打开 我们要测量的图片</span></li><li id="169913326b9010996b5277abee2f9204"><span class="ne-text">ctrl+r 可以打开标尺  或者  视图 --  标尺</span></li></ul><ul class="ne-ul"><li id="03a377893e3694e94bb1f41dd8356969"><span class="ne-text">右击标尺，  把里面的单位改为  像素</span></li><li id="6b481eb2927503e7f1831c1428fb7526"><span class="ne-text">ctrl+ 加号 键  可以 放大  视图  ctrl+ 减号 缩小视图</span></li></ul><ul class="ne-ul"><li id="89d8ed94688fc34ee0150c8a03d39835"><span class="ne-text">按住空格键，  鼠标可以 变成小手 ，拖动 ps 视图</span></li><li id="3efb60451603937b1dfc15df3e0672a3"><span class="ne-text">用选区 拖动  可以 测量 大小</span></li></ul><ul class="ne-ul"><li id="7bb3569dc3b21e8b9653de4fa7489bb6"><span class="ne-text">ctrl+ d  可以取消选区  或者旁边空白处点击一下也可以取消选区</span></li></ul><p id="29c33d3129166d574577a943837d90e4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549556960-d43dc95b-ceed-4eb5-bc70-d527bfd6790f.png" width="849" id="BrF58" class="ne-image"></p><h2 id="AUxLJ"><span class="ne-text">Photoshop 切图</span></h2><p id="dedb8b760e3ad491df7a2b079fb3d286" class="ne-p"><strong><span class="ne-text">常见的图片格式</span></strong></p><pre data-language="plain" id="WNvuY" class="ne-codeblock language-plain">1. jpg图像格式：<p>JPEG（.JPG）对色彩的信息保留较好，高清，颜色较多，我们产品类的图片经常用 jpg 格式的 2. gif 图像格式：<br>GIF 格式最多只能储存 256 色，所以通常用来显示简单图形及字体，但是可以保存透明背景和动画效果 3. png 图像格式<br>是一种新兴的网络图形格式，结合了 GIF 和 JPEG 的优点，具有存储形式丰富的特点，能够保持透明背景 4. PSD 图像格式<br>PSD 格式是 Photoshop 的专用格式，里面可以存放图层、通道、遮罩等多种设计草稿。</pre><p id="f40748ed259e3da17ab9f6060ec38eba" class="ne-p"><span class="ne-text">PS 切图 可以 分为 利用切片工具切图 以及 利用 PS 的插件快速切图。</span></p><h3 id="1RjVX"><span class="ne-text">1). PS 切片工具</span></h3><p id="77188d4acce468e126343b0937830292" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549558330-2bb506e1-9230-4d4c-a031-7de0b5d2077a.png" width="306" id="Vf7om" class="ne-image"></p><p id="d9fc11224189043318e33a256f2b3fab" class="ne-p"><span class="ne-text">ps 切图片，分两大步：</span></p><p id="c5bec983b60f28de6b7664e2315253dd" class="ne-p"><strong><span class="ne-text">1). 用切片选中图片</span></strong></p><ul class="ne-ul"><li id="e5b7f8f6615040ee8b9226d74efd7a11"><span class="ne-text">利用切片工具手动划出</span></li><li id="33ea21a5fd9a36348c937df3876bc407"><span class="ne-text">图层菜单—新建基于图层的切片</span></li></ul><ul class="ne-ul"><li id="7b9597bd920c15ffd95f966944ae05b3"><span class="ne-text">利用辅助线 来切图 – 基于参考线的切片<br></span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549558387-e6ea82e1-e85f-4b2e-a724-7eb095932273.png" width="640" id="hu6mY" class="ne-image"></li></ul><p id="9d2958c4fa4b2801821fa3edfc92c607" class="ne-p"><strong><span class="ne-text">2). 导出切片</span></strong></p><p id="edeec80a02e8e522ec39a0627e9e4f71" class="ne-p"><span class="ne-text">文件菜单 – 存储为 web 设备所用格式 —- 选择 我们要的图片格式 —- 点存储 — 别忘了选中的切片</span></p><div class="ne-quote"><p id="da1bb8ed3de50fd649c52d0010b9351c" class="ne-p"><span class="ne-text">辅助线和切片使用及清除</span></p></div><p id="5f1b1dcfbf2ec8142741a746149ee5d6" class="ne-p"><span class="ne-text">视图菜单– 清除 辅助线/ 清除切片</span></p><h3 id="wXSUi"><span class="ne-text">2). 切图插件</span></h3><p id="3d227d79d184b46496f41d79a60375c9" class="ne-p"><span class="ne-text">Cutterman 是一款运行在 photoshop 中的插件，能够自动将你需要的图层进行输出， 以替代传统的手工 “导出 web 所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 它支持各种各样的图片尺寸、格式、形态输出，方便你在 pc、ios、Android 等端上使用。 它不需要你记住一堆的语法、规则，纯点击操作，方便、快捷，易于上手。</span></p><p id="7560265b551870170e023ace9e606f4a" class="ne-p"><span class="ne-text">官网: </span><a href="http://www.cutterman.cn/zh/cutterman" data-href="http://www.cutterman.cn/zh/cutterman" target="_blank" class="ne-link"><span class="ne-text">http://www.cutterman.cn/zh/cutterman</span></a></p><p id="bcca3f9593bfa635d4c8b59c2d2dbb6b" class="ne-p"><span class="ne-text">注意： cutterman 插件要求你的 ps 必须是完整版，不能是绿色版，所以大家需要从新安装完整版本。</span></p><p id="113fa41311baa799f5e1f0165246308d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1611549558445-f9023a37-7339-4590-907e-a71d004899ff.gif" width="644" id="LnDfZ" class="ne-image"></p></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 后期制作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>响应式布局rem</title>
      <link href="/blog/rm1i2lgosgh2/"/>
      <url>/blog/rm1i2lgosgh2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="di2Wv"><span class="ne-text">rem</span></h2><h3 id="Iq49g"><span class="ne-text">em</span></h3><div data-type="danger" class="ne-alert"><ul class="ne-ul"><li id="u876c1de9"><span class="ne-text">相对单位</span></li><li id="u843ab563"><span class="ne-text">em是父元素字体大小</span></li></ul></div><h3 id="EjSri"><span class="ne-text">rem</span></h3><div data-type="danger" class="ne-alert"><ul class="ne-ul"><li id="u88601b52"><span class="ne-text">相对单位</span></li><li id="uc85a19de"><span class="ne-text">rem的基准是相对于html元素的字体大小。</span></li></ul></div><p id="9794fe54ba1509e1addc4fb844c10209" class="ne-p"><span class="ne-text">比如，根元素（html）设置font-size=12px; 非根元素设置width:2rem; 则换成px表示就是24px。</span></p><pre data-language="css" id="gHekn" class="ne-codeblock language-css">/* 根html 为 12px */<p>html {<br>font-size: 12px;<br>}<br>/_ 此时 div 的字体大小就是 24px _/<br>div {<br>font-size: 2rem;<br>}</pre><p id="83b267967fecdd7b664bb0b08ce1b457" class="ne-p"><span class="ne-text">rem 的优势：父元素文字大小可能不一致， 但是整个页面只有一个 html，可以很好来控制整个页面的元素大小。</span></p><h3 id="zJUmq"><span class="ne-text">vm 和 vh</span></h3><ul class="ne-ul"><li id="uac223e5b"><span class="ne-text">视口的宽高</span></li><li id="u693c9403"><span class="ne-text">按照 100 来划分</span></li></ul><p id="ub948ddb5" class="ne-p"><span class="ne-text">用过的例子：</span></p><pre data-language="css" id="TOGA8" class="ne-codeblock language-css">.test {<br>height: calc(100vh);<br>padding: calc((100vh - 60px - 10px) / 4) 10px;<br>}</pre><h2 id="nlt2Y"><span class="ne-text">rem 适配方案</span></h2><p id="72ccd932e896c120d6d5205580e88fd8" class="ne-p"><span class="ne-text">1.让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备。</span></p><p id="70fbc3a2e996c196764c6200c9158755" class="ne-p"><span class="ne-text">2.使用媒体查询根据不同设备按比例设置 html 的字体大小，然后页面元素使用 rem 做尺寸单位，当 html 字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配。</span></p><p id="e9eb1c5f6b036c6037509282a03983df" class="ne-p"><span class="ne-text">技术方案：</span></p><p id="e21f3ae7a185b3d70436fed9a04ca485" class="ne-p"><span class="ne-text">1.less+rem+媒体查询</span></p><p id="479ce89db4df183c888da091a8df805f" class="ne-p"><span class="ne-text">2.lflexible.js+rem</span></p><p id="bbd16f79c8cd0945db7f5f154a826315" class="ne-p"><span class="ne-text">总结：</span></p><p id="006e55f0360a249208d2e260bfd29874" class="ne-p"><span class="ne-text">两种方案现在都存在。</span></p><p id="246c94aafbf7afd64954e2e6e15a3854" class="ne-p"><span class="ne-text">方案 2 更简单，现阶段大家无需了解里面的 js 代码。</span></p><h3 id="lGEBf"><span class="ne-text">rem 适配方案 1</span></h3><p id="0fabd5e4d19b82930559d17ccaa824e3" class="ne-p"><span class="ne-text">① 假设设计稿是 750px</span></p><p id="bc78e17155075c61cf0f9f4a677dc540" class="ne-p"><span class="ne-text">② 假设我们把整个屏幕划分为 15 等份（划分标准不一可以是 20 份也可以是 10 等份）</span></p><p id="a13c9fcd3659f85ffcbe87f6971de920" class="ne-p"><span class="ne-text">③ 每一份作为 html 字体大小，这里就是 50px</span></p><p id="7b9bb779c2a2c4535405556e6a1856a0" class="ne-p"><span class="ne-text">④ 那么在 320px 设备的时候，字体大小为 320/15 就是 21.33px</span></p><p id="945a4707c73032b2de9db785cb59d095" class="ne-p"><span class="ne-text">⑤ 用我们页面元素的大小除以不同的 html 字体大小会发现他们比例还是相同的</span></p><p id="7c3a8e052d9361e7ee943c7addfb3554" class="ne-p"><span class="ne-text">⑥ 比如我们以 750 为标准设计稿</span></p><p id="2e76cafeb1d872b057b83dc77a75f27a" class="ne-p"><span class="ne-text">⑦ 一个 100</span><em><span class="ne-text">100 像素的页面元素在 750 屏幕下， 就是 100/ 50 转换为 rem 是 2rem</span></em><span class="ne-text">2rem 比例是 1 比 1</span></p><p id="14619e9cfa606e7b11e47d2a435191b1" class="ne-p"><span class="ne-text">⑧320 屏幕下， html 字体大小为 21.33 则 2rem= 42.66px 此时宽和高都是 42.66 但是宽和高的比例还是 1 比 1</span></p><p id="fd7677e685482b484c39ab3d358bd4f5" class="ne-p"><span class="ne-text">⑨ 但是已经能实现不同屏幕下 页面元素盒子等比例缩放的效果</span></p><p id="8fbe03ab6927da91f406c2adf763a33e" class="ne-p"><span class="ne-text">总结：</span></p><p id="dfb56d67ffe1f41a619247b5044ef7a8" class="ne-p"><span class="ne-text">① 最后的公式：页面元素的 rem 值 = 页面元素值（px） / （屏幕宽度 / 划分的份数）</span></p><p id="0854f6cf818b1d9b145bd5c8dbb5ae33" class="ne-p"><span class="ne-text">② 屏幕宽度/划分的份数就是 htmlfont-size 的大小</span></p><p id="459e7a4ad69b867c942824e4d4b2d4db" class="ne-p"><span class="ne-text">③ 或者：页面元素的 rem 值 = 页面元素值（px） / html font-size 字体大小</span></p><h3 id="jNtjj"><span class="ne-text">苏宁首页</span></h3><p id="c5f3a15e766da5beb0f6408a0e189db3" class="ne-p"><span class="ne-text">苏宁首页地址 ：</span><a href="m.suning.com" data-href="m.suning.com" class="ne-link"><span class="ne-text">苏宁首页</span></a></p><p id="5683829706fc014721ec45c0fddf3c86" class="ne-p"><span class="ne-text">1、 技术选型</span></p><p id="90d04822287edfa989ae2506aa58ac30" class="ne-p"><span class="ne-text">方案：我们采取单独制作移动页面方案</span></p><p id="342af9b22f2c90acff2abdc5e0ca9b02" class="ne-p"><span class="ne-text">技术：布局采取 rem 适配布局（less + rem + 媒体查询）</span></p><p id="abb16eca1af82ed1bb587067762346cb" class="ne-p"><span class="ne-text">设计图： 本设计图采用 750px 设计尺寸</span></p><p id="ad9ecc98e2a24d594e7262e59b1697f6" class="ne-p"><span class="ne-text">2、搭建文件结构</span></p><p id="0efc58c7090e946f079901a5a5af686b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325682-7e3f3397-a6e1-47eb-9774-d632ea98c710.jpg" width="466" id="JeBWG" class="ne-image"></p><p id="7d861253120af1ff5071ef59f96b1388" class="ne-p"><span class="ne-text">3、设置视口标签以及引入初始化样式</span></p><pre data-language="plain" id="HTZpl" class="ne-codeblock language-plain"><meta name="viewport" content="width=device-width, user-scalable=no,         initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"></p><link rel="stylesheet" href="css/normalize.css"></pre><p id="54b82b94bfd32257df43d14cd8035d4a" class="ne-p"><span class="ne-text">4、设置公共common.less文件</span></p><ul class="ne-ul"><li id="c25e78c15c62fbbb4a10bc895779fb24"><span class="ne-text">新建common.less    设置好最常见的屏幕尺寸，利用媒体查询设置不同的html字体大小，因为除了首页其他页面也需要</span></li><li id="39c5e26a6fce19b056e26b8b8d63b625"><span class="ne-text">我们关心的尺寸有 320px、360px、375px、384px、400px、414px、424px、480px、540px、720px、750px</span></li><li id="96e58eeb513fe7026126ee633b42cf95"><span class="ne-text">划分的份数我们定为 15等份</span></li><li id="6c699bebfbb42c377b14162e869fdcd7"><span class="ne-text">因为我们pc端也可以打开我们苏宁移动端首页，我们默认html字体大小为 50px，注意这句话写到最上面</span></li></ul><h3 id="A1Y4x"><span class="ne-text">rem 适配方案2</span></h3><p id="421b7de7f1346eaf8e7c7edae3e60d45" class="ne-p"><span class="ne-text">手机淘宝团队出的简洁高效 移动端适配库</span></p><p id="f22ae3c8658642db05aa0b948a85e94e" class="ne-p"><span class="ne-text">我们再也不需要在写不同屏幕的媒体查询，因为里面js做了处理</span></p><p id="87934ad09701bbaf47be7b0c6c634318" class="ne-p"><span class="ne-text">它的原理是把当前设备划分为10等份，但是不同设备下，比例还是一致的。</span></p><p id="9a31d36488ef29c7036301acff1ea9e3" class="ne-p"><span class="ne-text">我们要做的，就是确定好我们当前设备的html 文字大小就可以了</span></p><p id="b0cfb361a495ce5c6eb5e9299c4a6a89" class="ne-p"><span class="ne-text">比如当前设计稿是 750px， 那么我们只需要把 html 文字大小设置为 75px(750px / 10) 就可以</span></p><p id="1c408b06482c45277a14102f82633604" class="ne-p"><span class="ne-text">里面页面元素rem值： 页面元素的px 值 /  75</span></p><p id="931f0f2044123e3450f71d104250f23f" class="ne-p"><span class="ne-text">剩余的，让flexible.js来去算</span></p><p id="e962dab7f016e4c01ff7787c69685eaa" class="ne-p"><span class="ne-text">github地址：</span><a href="https://link.jianshu.com/?t=https://github.com/amfe/lib-flexible" data-href="https://link.jianshu.com/?t=https://github.com/amfe/lib-flexible" target="_blank" class="ne-link"><span class="ne-text">https://github.com/amfe/lib-flexible</span></a></p><p id="a7ce2ff53830ba636e2db6c6b7aaeebb" class="ne-p"><span class="ne-text">总结：</span></p><p id="a4ffa14094eedc7a6fdab882c4ce8d23" class="ne-p"><span class="ne-text">因为flexible是默认将屏幕分为10等分</span></p><p id="e48c36b3c59dd21db612887004aeba5c" class="ne-p"><span class="ne-text">但是当屏幕大于750的时候希望不要再去重置html字体了</span></p><p id="15d93bbaa66cb68cf8a746b012424655" class="ne-p"><span class="ne-text">所以要自己通过媒体查询设置一下</span></p><p id="46ca7b65a4e06a8707bb58eb6a2ebb1b" class="ne-p"><span class="ne-text">并且要把权重提到最高</span></p><p id="cd28daa22748ef32f1b13254d7079d11" class="ne-p"><span class="ne-text">VSCode  px 转换rem 插件 cssrem</span></p><p id="2399e7cf6b1aafe65ed9ceae7478d810" class="ne-p"><span class="ne-text">因为cssrem中css自动转化为rem是参照默认插件的16转换的所以需要自己配置</span></p><p id="fd1ec7c8e8205367d56584910bcf7105" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325777-63efe343-7fb5-46ff-a976-757d50df3556.jpg" width="713" id="UABvV" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325891-a1820b7f-bdbf-47e8-b04b-723db8329cf8.jpg" width="566" id="alFe1" class="ne-image"></p><h2 id="liQps"><span class="ne-text">响应式开发原理</span></h2><h3 id="9tybR"><span class="ne-text">响应式开发原理</span></h3><div data-type="success" class="ne-alert"><p id="295fc47ec7030c8a60586927723cff10" class="ne-p"><span class="ne-text">就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的</span></p></div><p id="df38333cd1aca3452a0c05f5f2ecd791" class="ne-p"><span class="ne-text">设备的划分情况</span></p><ul class="ne-ul"><li id="18daf0aa56f892429cb4665c8f894e88"><span class="ne-text">小于768的为超小屏幕（手机）</span></li><li id="d8f91fac26a10c5469ef3f219001cfb6"><span class="ne-text">768~992之间的为小屏设备（平板）</span></li><li id="7ae16c51f2202ef45bc671eb86f33558"><span class="ne-text">992~1200的中等屏幕（桌面显示器）</span></li><li id="d8300c847748e7fada9f9cafe0735f10"><span class="ne-text">大于1200的宽屏设备（大桌面显示器）</span></li></ul><h3 id="bKScf"><span class="ne-text">响应式布局容器</span></h3><div data-type="info" class="ne-alert"><p id="fcfaf4bd52142005517e295680216ba9" class="ne-p"><span class="ne-text">响应式需要一个父级做为布局容器，来配合子级元素来实现变化效果。</span></p><p id="d8201961a1ae3342eb92187470a9b0b4" class="ne-p"><span class="ne-text">原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化。</span></p></div><p id="b78dfdb71954e555a42a5ba55908a10a" class="ne-p"><span class="ne-text">父容器版心的尺寸划分</span></p><ul class="ne-ul"><li id="12ca9ef7f4888c66bc08fe1ea1d8233f"><span class="ne-text">超小屏幕（手机，小于 768px）：设置宽度为 100%</span></li><li id="a0d552a99518fe4c8b5f9e995693ed9f"><span class="ne-text">小屏幕（平板，大于等于 768px）：设置宽度为 750px</span></li><li id="24333d919c22c372cf04d4eeec590266"><span class="ne-text">中等屏幕（桌面显示器，大于等于 992px）：宽度设置为 970px</span></li><li id="a1f154c1bb235302656b0fd8c75f1231"><span class="ne-text">大屏幕（大桌面显示器，大于等于 1200px）：宽度设置为 1170px</span></li></ul><p id="300bf3d5f63e5c09c0e2c9a4e2643243" class="ne-p"><span class="ne-text">但是我们也可以根据实际情况自己定义划分</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 布局 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Flex布局</title>
      <link href="/blog/ogynfghwtsa7/"/>
      <url>/blog/ogynfghwtsa7/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="uextT"><span class="ne-text">flex布局原理</span></h2><ul class="ne-ul"><li id="4641d586b67817f416de2a5f3e5bf6e0"><span class="ne-text">flex 是 flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。</span></li><li id="6b7990dc2c54d02b8778b8bd0643896d"><span class="ne-text">当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</span></li><li id="06bf7504af475a9813718a5218cd058a"><span class="ne-text">flex布局又叫伸缩布局 、弹性布局 、伸缩盒布局 、弹性盒布局</span></li><li id="ecdd1b91b949fd3ce6dead99a38ccd8c"><span class="ne-text">采用 Flex 布局的元素，称为 Flex 容器（flex</span></li></ul><p id="3afae559b46cfd8ccaed336730ffbcb8" class="ne-p"><span class="ne-text">container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex</span></p><p id="90300683e7b4b3835bc800fa73e079e1" class="ne-p"><span class="ne-text">item），简称"项目"。</span></p><p id="159e1bdb88544fa763b9fa33f8a69db7" class="ne-p"><strong><span class="ne-text">总结</span></strong><span class="ne-text">：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式</span></p><h2 id="JWis1"><span class="ne-text">父项常见属性</span></h2><ul class="ne-ul"><li id="b823754e73b6319e580583ff1182e0d0"><span class="ne-text">flex-direction：设置主轴的方向</span></li><li id="db8e2987cdd403f2a59746cc782b1508"><span class="ne-text">justify-content：设置主轴上的子元素排列方式</span></li><li id="68bc1c65af5bbb39a9883447cea32907"><span class="ne-text">flex-wrap：设置子元素是否换行</span></li><li id="b56793027cc608d909118811f4fb6e3b"><span class="ne-text">align-content：设置侧轴上的子元素的排列方式（多行）</span></li><li id="52c02f2f8fa2b16a7c561eee3f6b8cfb"><span class="ne-text">align-items：设置侧轴上的子元素排列方式（单行）</span></li><li id="0b25460301aec512ff08504603d7e166"><span class="ne-text">flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap</span></li></ul><h3 id="TWwcR"><span class="ne-text">flex-direction设置主轴的方向</span></h3><ul class="ne-ul"><li id="17a64700d6bf0e26f65a67e6bad5db92"><span class="ne-text">在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有 ： 行和列、x 轴和y 轴</span></li><li id="313115a9c216db17eea25dad0edab817"><span class="ne-text">默认主轴方向就是 x 轴方向，水平向右</span></li><li id="4734be80603f500f47d575bf3b6776da"><span class="ne-text">默认侧轴方向就是 y 轴方向，水平向下</span></li></ul><p id="4d5aa5ac16192614c134ef8792dfd4df" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561167817-709457f2-58f3-47b2-82f2-36a27c5ffbac.png" width="485" id="cmnlC" class="ne-image"></p><ul class="ne-ul"><li id="16f34e0e11dfd0c58fbaefc3c12401e9"><span class="ne-text">注意： 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的</span></li></ul><p id="u5b5e1785" class="ne-p"><span class="ne-text"></span></p><p id="f99db99500e1337f8924eca3a2517e0e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561179498-b513941e-0741-403e-a156-bf3794692e74.png" width="463.5" id="p4Lox" class="ne-image"></p><h3 id="V5Jhm"><span class="ne-text">justify-content 设置主轴上的子元素排列方式</span></h3><p id="5b3fc1a0ad8baaf0468d30f2c83108b9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561189187-37fb2250-6a7a-4b7e-8da7-8bfbed134942.png" width="614" id="Ucr9M" class="ne-image"></p><h3 id="Nm7PW"><span class="ne-text">flex-wrap设置是否换行</span></h3><ul class="ne-ul"><li id="b3612a7815994c14c468bb3b8485f358"><span class="ne-text">默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，flex布局中默认是不换行的。</span></li><li id="eba8dc63cb97b7e2ffb9c2c528fa6648"><span class="ne-text">nowrap 不换行</span></li><li id="ff0ab6d6ee5d9835c03306ff602add24"><span class="ne-text">wrap 换行</span></li></ul><h3 id="EZp2l"><span class="ne-text">align-items 设置侧轴上的子元素排列方式（单行 ）</span></h3><ul class="ne-ul"><li id="018ecaeab353d72404753e6fc8bcd205"><span class="ne-text">该属性是控制子项在侧轴（默认是y轴）上的排列方式  在子项为单项（单行）的时候使用</span></li><li id="9a5b5622b2ee3bf3d1168a3f1d01bd16"><span class="ne-text">flex-start 从头部开始</span></li><li id="d7cd2384dbbb1ba09cf5972040075289"><span class="ne-text">flex-end 从尾部开始</span></li><li id="7ed5e14b71d688301deec4fa7918cd0d"><span class="ne-text">center 居中显示</span></li><li id="dc05ed293e836ef3de9756c479bf6670"><span class="ne-text">stretch 拉伸</span></li></ul><h3 id="BNYTF"><span class="ne-text">align-content  设置侧轴上的子元素的排列方式（多行）</span></h3><p id="7973d0841f73d45571d9e9df87b95b68" class="ne-p"><span class="ne-text">设置子项在侧轴上的排列方式 并且只能用于子项出现 换行 的情况（多行），在单行下是没有效果的。</span></p><p id="450ba76159bc9a969fd603e70a5615f4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561203043-769de419-37f6-47ac-8a01-7353fb2fbcd4.png" width="542" id="C4BgP" class="ne-image"></p><h3 id="WbfsQ"><span class="ne-text">align-content 和align-items区别</span></h3><ul class="ne-ul"><li id="d658600aec23697915a23530805b5b2a"><span class="ne-text">align-items  适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸</span></li><li id="7263d49e37aa9db3dec13f9264ba1200"><span class="ne-text">align-content适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。</span></li><li id="d93fb4b456ed4e4eadbce54cbdc23e0c"><span class="ne-text">总结就是单行找align-items  多行找 align-content</span></li></ul><h3 id="mNc0j"><span class="ne-text">flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性</span></h3><pre data-language="plain" id="nn3hA" class="ne-codeblock language-plain">flex-flow:row wrap;</pre><h2 id="Mc8HC"><span class="ne-text">flex布局子项常见属性</span></h2><ul class="ne-ul"><li id="55fc33f9eb6697b685614141c9066557"><span class="ne-text">flex子项目占的份数</span></li><li id="5dcd0eafa6fd8700ca2cbc030c6420ee"><span class="ne-text">align-self控制子项自己在侧轴的排列方式</span></li><li id="b4dff300df24f3d15c639111c46a84b1"><span class="ne-text">order属性定义子项的排列顺序（前后顺序）</span></li></ul><h3 id="pJZVV"><span class="ne-text">flex 属性</span></h3><p id="945d7173aeb46338f01aacf272a8cdef" class="ne-p"><span class="ne-text">flex 属性定义子项目分配剩余空间，用flex来表示占多少份数。</span></p><pre data-language="plain" id="4rQxt" class="ne-codeblock language-plain">.item {<pre><code>flex: &lt;number&gt;; /* 默认值 0 */</code></pre><p>}</pre><h3 id="Zg5De"><span class="ne-text">align-self 控制子项自己在侧轴上的排列方式</span></h3><p id="015ee5a428996ea1c44d89c086632a5f" class="ne-p"><span class="ne-text">align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。</span></p><p id="1130288394efc75ec8e6107000cfa89f" class="ne-p"><span class="ne-text">默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</span></p><pre data-language="plain" id="xmnpe" class="ne-codeblock language-plain">span:nth-child(2) {<br>/_ 设置自己在侧轴上的排列方式 _/<br>align-self: flex-end;<br>}</pre><h3 id="nogLK"><span class="ne-text">order 属性定义项目的排列顺序</span></h3><p id="2fe6cf3e8589b179bf9f58a254c26185" class="ne-p"><span class="ne-text">数值越小，排列越靠前，默认为 0。</span></p><p id="48c1abdf0b4380be44712312a681e847" class="ne-p"><span class="ne-text">注意：和 z-index 不一样。</span></p><pre data-language="plain" id="ADbyH" class="ne-codeblock language-plain">.item {<br>order: <number>;<br>}</pre><h2 id="fqJAn"><span class="ne-text">携程网首页案例制作</span></h2><p id="4c42d29f9679b39d6a46dee2f04f7617" class="ne-p"><span class="ne-text">携程网链接：</span><a href="http://m.ctrip.com" data-href="http://m.ctrip.com" target="_blank" class="ne-link"><span class="ne-text">http://m.ctrip.com</span></a></p><p id="bb30fb4a553196661876850e3eb722af" class="ne-p"><span class="ne-text">1.技术选型</span></p><p id="ec5fe9ea8b49f67a58214508dcb65a84" class="ne-p"><span class="ne-text">方案：我们采取单独制作移动页面方案</span></p><p id="a228b77a49f9b2bfb9fd6e903d8148ee" class="ne-p"><span class="ne-text">技术：布局采取 flex 布局</span></p><p id="abff4b8f88d360e6d777f9824517589e" class="ne-p"><span class="ne-text">2.搭建相关文件夹</span></p><p id="21af76ebfc98f12813d36e8f6d3e89b3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561216425-7cb96807-082c-4f58-a8e6-7fd089ad6c35.png" width="194" id="RYYOf" class="ne-image"></p><p id="87675e462c5b518fe45c310745b077c5" class="ne-p"><span class="ne-text">3.设置视口标签以及引入初始化样式</span></p><pre data-language="plain" id="hIlMV" class="ne-codeblock language-plain"><meta name="viewport" content="width=device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"></p><link rel="stylesheet" href="css/normalize.css"><link rel="stylesheet" href="css/index.css"></pre><p id="1d303f7680d961e7f410b7995b7c2fa4" class="ne-p"><span class="ne-text">4.常用初始化样式</span></p><pre data-language="plain" id="CPuk2" class="ne-codeblock language-plain">body {  max-width: 540px;  min-width: 320px;  margin: 0 auto;  font: normal 14px/1.5 Tahoma,"Lucida Grande",Verdana,"Microsoft Yahei",STXihei,hei;  color: #000;  background: #f2f2f2;  overflow-x: hidden;  -webkit-tap-highlight-color: transparent;}</pre><p id="3dad3ae7d3793f495517aaa1cea1cafe" class="ne-p"><span class="ne-text">5.模块名字划分</span></p><p id="8f82a5428aa90eb86100221cd52e6e3f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561231614-a9ccc256-3219-41a4-a610-588d72137519.png" width="517.5" id="A2cyp" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 布局 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>百分比布局</title>
      <link href="/blog/oxqtosvrfeg8/"/>
      <url>/blog/oxqtosvrfeg8/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="6oTsX"><span class="ne-text">meta标签viewport</span></h2><p id="uee036b2f" class="ne-p"><br></p><p id="770978c4aa3b4bccc710aa4fe5a55bdd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615360134988-de179521-dfc1-419f-a1b6-5e45b5b40096.png" width="1043" id="IIJLj" class="ne-image"></p><h2 id="2hDHo"><span class="ne-text">normalize.css</span></h2><p id="ec551c93bcab2996bf33232a61a2a5bf" class="ne-p"><span class="ne-text">移动端 CSS 初始化推荐使用 normalize.css/</span></p><p id="af02910c3aefafb0e9d646a2c81c0e23" class="ne-p"><span class="ne-text">Normalize.css：保护了有价值的默认值</span></p><p id="fa70175d47970c925f56b7a844bf0752" class="ne-p"><span class="ne-text">Normalize.css：修复了浏览器的bug</span></p><p id="5ebc772fdaba896863a433e28ac5f67c" class="ne-p"><span class="ne-text">Normalize.css：是模块化的</span></p><p id="8be05c9f23069cb701ea13274d073012" class="ne-p"><span class="ne-text">Normalize.css：拥有详细的文档</span></p><p id="19eca2d97cc15ebf95dddfbb11422d3b" class="ne-p"><span class="ne-text">官网地址： </span><a href="http://necolas.github.io/normalize.css/" data-href="http://necolas.github.io/normalize.css/" target="_blank" class="ne-link"><span class="ne-text">http://necolas.github.io/normalize.css/</span></a></p><h2 id="IpFMf"><span class="ne-text">box-sizing</span></h2><div data-type="danger" class="ne-alert"><p id="78cb920c38acc26b0208ead9a5246b94" class="ne-p"><span class="ne-text">传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding</span></p></div><div data-type="success" class="ne-alert"><p id="241d7c01ea8bbb781df383a25eaed6c3" class="ne-p"><span class="ne-text">CSS3盒子模型：盒子的宽度=  CSS中设置的宽度width 里面包含了 border 和 padding</span></p></div><p id="8d97bd396911cca22eb2595f00be8672" class="ne-p"><span class="ne-text">也就是说，我们的CSS3中的盒子模型， padding 和 border 不会撑大盒子了</span></p><pre data-language="css" id="1jjbr" class="ne-codeblock language-css">/*CSS3盒子模型*/<p>box-sizing: border-box;<br>/<em>传统盒子模型</em>/<br>box-sizing: content-box;</pre><p id="892b3e63b59ca750957572aa57c42683" class="ne-p"><span class="ne-text">移动端可以全部 CSS3 盒子模型</span></p><div data-type="danger" class="ne-alert"><p id="ac1830f00ab6326d34aaac3a73118a94" class="ne-p"><span class="ne-text">PC 端如果完全需要兼容，我们就用传统模式，如果不考虑兼容性，我们就选择 CSS3 盒子模型</span></p></div><p id="9eaec18c8a81c19d1900c25c4837fb1f" class="ne-p"><br></p><pre data-language="css" id="Ro79H" class="ne-codeblock language-css">-webkit-box-sizing: border-box /_ CSS3 盒模型 <em>/<br>-moz-box-sizing: border-box /</em> CSS3 盒模型 <em>/<br>box-sizing: border-box /</em> CSS3 盒模型 _/</pre><h3 id="btPxJ"><span class="ne-text">移动端特殊样式</span></h3><pre data-language="css" id="9FR90" class="ne-codeblock language-css">/<em>CSS3 盒子模型</em>/<br>box-sizing: border-box;<br>-webkit-box-sizing: border-box;<br>/<em>点击高亮我们需要清除清除 设置为 transparent 完成透明</em>/<br>-webkit-tap-highlight-color: transparent;<br>/<em>在移动端浏览器默认的外观在 iOS 上加上这个属性才能给按钮和输入框自定义样式</em>/<br>-webkit-appearance: none;<br>/<em>禁用长按页面时的弹出菜单</em>/<br>img,a { -webkit-touch-callout: none; }</pre><h2 id="3b1Sw"><span class="ne-text">移动端常见布局</span></h2><h3 id="GSP4w"><span class="ne-text">移动端单独制作</span></h3><div data-type="success" class="ne-alert"><p id="88cf1185b32f87d64bbd9bff44e9a662" class="ne-p"><span class="ne-text">流式布局（百分比布局）</span></p></div><p id="9f3abf9c2b3779387c5e07ce199bdee3" class="ne-p"><span class="ne-text">流式布局，就是百分比布局，也称非固定像素布局。通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。流式布局方式是移动 web 开发使用的比较常见的布局方式。</span></p><p id="e9b3459c824ce950fc1603e31ed3dd80" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 布局 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS3的3D效果</title>
      <link href="/blog/03_html5css3_day03/"/>
      <url>/blog/03_html5css3_day03/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="gg8e7"><span class="ne-text">一、 认识 </span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 转换</span></h2><ol class="ne-ol"><li id="6a8943a427946ad326f216bebbb85c8c"><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 的特点</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="de1118194a467567a8c9f026bdbc1607"><span class="ne-text">近大远小</span></li><li id="4837dc465064a20d75132f232dfd44fe"><span class="ne-text">物体和面遮挡不可见</span></li></ul></ul><ol start="2" class="ne-ol"><li id="09beb4ea5c1f403d57366f79c8c65365"><span class="ne-text">三维坐标系</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="d8b9f5e23ba2ae5795261f4a92b29f82"><span class="ne-text">x 轴：水平向右  -- </span><strong><span class="ne-text">注意：x 轴右边是正值，左边是负值</span></strong></li><li id="5f4ab0c95dbfc804c3170e411c15411d"><span class="ne-text">y 轴：垂直向下  -- </span><strong><span class="ne-text">注意：y 轴下面是正值，上面是负值</span></strong></li><li id="711d2793702c464daa838a1e6a22bd0a"><span class="ne-text">z 轴：垂直屏幕  --  </span><strong><span class="ne-text">注意：往外边的是正值，往里面的是负值</span></strong><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561054770-fd36ec08-dafd-4b7b-b075-847435ec7bed.png" width="482.5" id="Ca0uC" class="ne-image"></li></ul></ul><h2 id="19d2w"><span class="ne-text">二、</span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 转换</span></h2><ol class="ne-ol"><li id="2456bb67f8e3c54d36c8d0c411aa571a"><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 转换知识要点</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="df809b141b43e83b168de1507d26d385"><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 位移：</span><code class="ne-code"><span class="ne-text">translate3d(x, y, z)</span></code></li><li id="0888bd2e128d5d0ab0b9f9b1f548c2a6"><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 旋转：</span><code class="ne-code"><span class="ne-text">rotate3d(x, y, z)</span></code></li><li id="a61be4446f63ad635bfea4b076c7e382"><span class="ne-text">透视：</span><code class="ne-code"><span class="ne-text">perspctive</span></code></li><li id="c2353e1e14cee59a4da5899f5287b067"><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text">呈现 </span><code class="ne-code"><span class="ne-text">transfrom-style</span></code></li></ul></ul><ol start="2" class="ne-ol"><li id="6e8f3bf37e2d8523b7dc599db6d3d8ce"><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 移动 </span><code class="ne-code"><span class="ne-text">translate3d</span></code></li></ol><ul class="ne-ul"><li id="8ab6b2d4a9daf4dffa4a3632cf611be6"><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 移动就是在 </span><code class="ne-code"><span class="ne-text">2D</span></code><span class="ne-text"> 移动的基础上多加了一个可以移动的方向，就是 z 轴方向</span></li><li id="75ba3ffa547715357e657bfad3e1a214"><code class="ne-code"><span class="ne-text">transform: translateX(100px)</span></code><span class="ne-text">：仅仅是在 x 轴上移动</span></li><li id="024409b747e6c611a69ea95153c01e32"><code class="ne-code"><span class="ne-text">transform: translateY(100px)</span></code><span class="ne-text">：仅仅是在 y 轴上移动</span></li><li id="9f27c7b6366d07981e13e6c8d105379f"><code class="ne-code"><span class="ne-text">transform: translateZ(100px)</span></code><span class="ne-text">：仅仅是在 z 轴上移动</span></li><li id="11984676632e214933a41a567c797f39"><code class="ne-code"><span class="ne-text">transform: translate3d(x, y, z)</span></code><span class="ne-text">：其中x、y、z 分别指要移动的轴的方向的距离</span></li><li id="6e1bd39915c9ae56b80ca30b34ab53fd"><strong><span class="ne-text">注意：x, y, z 对应的值不能省略，不需要填写用 0 进行填充</span></strong></li></ul><ol start="3" class="ne-ol"><li id="6e60e2414dfa03caececa3835c560a1a"><span class="ne-text">语法</span></li></ol><pre data-language="css" id="EXl4r" class="ne-codeblock language-css">transform: translate3d(x, y, z)</pre><ol start="4" class="ne-ol"><li id="983c48c63729c399a367eb2e6c3b9eb0"><span class="ne-text">代码演示</span></li></ol><pre data-language="css" id="gDIX8" class="ne-codeblock language-css">transform: translate3d(100px, 100px, 100px)<p>/_ 注意：x, y, z 对应的值不能省略，不需要填写用 0 进行填充 _/<br>transform: translate3d(100px, 100px, 0)</pre><h2 id="DmKKA"><span class="ne-text">三、透视 </span><code class="ne-code"><span class="ne-text">perspective</span></code></h2><ol class="ne-ol"><li id="97f74a97faf7bb3b2cf1c8c78e916b76"><span class="ne-text">知识点讲解</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="57e6b4c49415fb7ebc3c1c1c5af5d89d"><span class="ne-text">如果想要网页产生 </span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 效果需要透视(理解成 </span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 物体投影的 </span><code class="ne-code"><span class="ne-text">2D</span></code><span class="ne-text"> 平面上)</span></li><li id="4d55bd37fcbe53224610decdeca037cd"><span class="ne-text">实际上模仿人类的视觉位置，可视为安排一直眼睛去看</span></li><li id="f912e39364efb7b98a05f620d7f665d3"><span class="ne-text">透视也称为视距，所谓的视距就是人的眼睛到屏幕的距离</span></li><li id="212cfbc8765f3a1622430e11e24e5c66"><span class="ne-text">距离视觉点越近的在电脑平面成像越大，越远成像越小</span></li><li id="540f0fb0ab711174cfb6789dc23c1492"><span class="ne-text">透视的单位是像素</span></li></ul></ul><ol start="2" class="ne-ol"><li id="bdb689472a04e97bcc160c30c047f711"><span class="ne-text">知识要点</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="1fed3529dd50f83abe26063f06416609"><strong><span class="ne-text">透视需要写在被视察元素的父盒子上面</span></strong></li><li id="0e16c08e2b966c20e74018dae7d311ff"><span class="ne-text">注意下方图片</span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="3763d8cb6956d6956d157a22f54d44a2"><span class="ne-text">d：就是视距，视距就是指人的眼睛到屏幕的距离</span></li><li id="f265e4eaa9beef675ee628666c5ab02a"><span class="ne-text">z：就是 z 轴，z 轴越大(正值)，我们看到的物体就越大</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561069343-d9028767-2dde-4e2f-8d2e-a1066091d6f4.png" width="428" id="Jguym" class="ne-image"></li></ul></ul></ul><ol start="3" class="ne-ol"><li id="993a3610463c7841aa119bcede0f1d01"><span class="ne-text">代码演示</span></li></ol><pre data-language="css" id="0SR74" class="ne-codeblock language-css">body {<br>perspective: 1000px;<br>}</pre><h2 id="GqRGF"><span class="ne-text">四、 </span><code class="ne-code"><span class="ne-text">translateZ</span></code></h2><ol class="ne-ol"><li id="134cc6ae321724eaff238ca73d5ba740"><code class="ne-code"><span class="ne-text">translateZ</span></code><span class="ne-text"> 与 </span><code class="ne-code"><span class="ne-text">perspecitve</span></code><span class="ne-text"> 的区别</span></li></ol><ul class="ne-ul"><li id="410f503784cb158bd0292c3e37625636"><code class="ne-code"><span class="ne-text">perspecitve</span></code><span class="ne-text"> 给父级进行设置，</span><code class="ne-code"><span class="ne-text">translateZ</span></code><span class="ne-text"> 给 子元素进行设置不同的大小</span></li></ul><h2 id="RJRWd"><span class="ne-text">五、</span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 旋转</span><code class="ne-code"><span class="ne-text">rotateX</span></code></h2><div class="ne-quote"><p id="b43070cdd7aeb4839f900490305f8021" class="ne-p"><span class="ne-text">3D 旋转指可以让元素在三维平面内沿着 x 轴、y 轴、z 轴 或者自定义轴进行旋转</span></p></div><ol class="ne-ol"><li id="cd40d1e84d3dd8c584d1454850bc582d"><span class="ne-text">语法</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="c20eb1afbd47f21924b75b92f3811b6f"><code class="ne-code"><span class="ne-text">transform: rotateX(45deg)</span></code><span class="ne-text"> – 沿着 x 轴正方向旋转 45 度</span></li><li id="23bda4d627b45f0757e7e2d7bbe41a70"><code class="ne-code"><span class="ne-text">transform: rotateY(45deg)</span></code><span class="ne-text"> – 沿着 y 轴正方向旋转 45 度</span></li><li id="8c99d7d60a335b2f3d6cf621c9b4bf47"><code class="ne-code"><span class="ne-text">transform: rotateZ(45deg)</span></code><span class="ne-text"> – 沿着 z 轴正方向旋转 45 度</span></li><li id="7d2dd0fe7b3507ea8b2fe1779647f689"><code class="ne-code"><span class="ne-text">transform: rotate3d(x, y, z, 45deg)</span></code><span class="ne-text"> – 沿着自定义轴旋转 45 deg 为角度</span></li></ul></ul><ol start="2" class="ne-ol"><li id="6a0b2ec4fd6fd872151a2a8981a4796a"><span class="ne-text">代码案例</span></li></ol><pre data-language="css" id="3Znfi" class="ne-codeblock language-css">div {<br>perspective: 300px;<br>}<br>img {<br>display: block;<br>margin: 100px auto;<br>transition: all 1s;<br>}<br>img:hover {<br>transform: rotateX(-45deg)<br>}</pre><ol start="3" class="ne-ol"><li id="aa4eb50708eb9265b2443a59425e2752"><span class="ne-text">左手准则</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="fbc244c4a19b0c8e3216979ebc41db7e"><span class="ne-text">左手的手拇指指向 x 轴的正方向</span></li><li id="98e6444702c6334f422363d653bdcbcf"><span class="ne-text">其余手指的弯曲方向就是该元素沿着 x 轴旋转的方向</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561085007-085d7541-71bf-4dd9-bb17-f69476ba1a47.png" width="525" id="Q2KAY" class="ne-image"></li></ul></ul><h2 id="SPeAj"><span class="ne-text">六、</span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 旋转 </span><code class="ne-code"><span class="ne-text">rotateY</span></code></h2><ol class="ne-ol"><li id="79a37132f70ba794bad1374b3be49098"><span class="ne-text">代码演示</span></li></ol><pre data-language="css" id="gRg74" class="ne-codeblock language-css">div {<br>perspective: 500px;<br>}<br>img {<br>display: block;<br>margin: 100px auto;<br>transition: all 1s;<br>}<br>img:hover {<br>transform: rotateY(180deg)<br>}</pre><ol start="2" class="ne-ol"><li id="5f1b9c2daecabe49422ea4fd44b6d37a"><span class="ne-text">左手准则</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="4bd8a468434dea375a8c1f64ed4121e7"><span class="ne-text">左手的拇指指向 y 轴的正方向</span></li><li id="dfd8ce08cfc0e02dd4d4405f702fc908"><span class="ne-text">其余的手指弯曲方向就是该元素沿着 y 轴旋转的方向(正值)</span></li></ul></ul><p id="cc487b98018b91ef20255d9c7be9fcc8" class="ne-p" style="margin-left: 2em"><br></p><p id="c0d836522c5b69f2f610e499704a6cda" class="ne-p" style="margin-left: 2em"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561115468-180fac93-a772-4b1f-8067-d49baaa69573.png" width="475" id="kQmph" class="ne-image"></p><h2 id="Uu8ef"><span class="ne-text">七、 </span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 旋转 </span><code class="ne-code"><span class="ne-text">rotateZ</span></code></h2><ol class="ne-ol"><li id="937701eb3c83fb9ec6a0eedea4cdd659"><span class="ne-text">代码演示</span></li></ol><pre data-language="css" id="eILHs" class="ne-codeblock language-css">div {<br>perspective: 500px;<br>}<br>img {<br>display: block;<br>margin: 100px auto;<br>transition: all 1s;<br>}<br>img:hover {<br>transform: rotateZ(180deg)<br>}</pre><ol start="2" class="ne-ol"><li id="ddb921dd95f860b7b67073a35b113e48"><code class="ne-code"><span class="ne-text">rotate3d</span></code></li></ol><ul class="ne-ul"><li id="a7883ac2c47b88a5f7249a59e83cefe7"><code class="ne-code"><span class="ne-text">transform: rotate3d(x, y, z, deg)</span></code><span class="ne-text"> – 沿着自定义轴旋转 deg 为角度</span></li><li id="b2f407e560af3630a666984b0f1c7472"><span class="ne-text">x, y, z 表示旋转轴的矢量，是标识你是否希望沿着该轴进行旋转，最后一个标识旋转的角度</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="268ac0a8d29ef59103036e7b14f7ed3b"><code class="ne-code"><span class="ne-text">transform: rotate3d(1, 1, 0, 180deg)</span></code><span class="ne-text"> – 沿着对角线旋转 45deg</span></li><li id="bcf7471439009f2d0d71a110610bca8d"><code class="ne-code"><span class="ne-text">transform: rotate3d(1, 0, 0, 180deg)</span></code><span class="ne-text"> – 沿着 x 轴旋转 45deg</span></li></ul></ul><ol start="3" class="ne-ol"><li id="5281401e5215ad9f154bdb33fe53096e"><span class="ne-text">代码演示</span></li></ol><pre data-language="css" id="A2eyn" class="ne-codeblock language-css">div {<br>perspective: 500px;<br>}<br>img {<br>display: block;<br>margin: 100px auto;<br>transition: all 1s;<br>}<br>img:hover {<br>transform: rotate3d(1, 1, 0, 180deg)<br>}</pre><h2 id="LxsRM"><span class="ne-text">八、</span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 呈现 </span><code class="ne-code"><span class="ne-text">transform-style</span></code></h2><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="3f964fbbdc50f66c8b579965a409b21f"><code class="ne-code"><span class="ne-text">transform-style</span></code></li></ol></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="29b0c81191db3289ab4903ce3a6955e6"><span class="ne-text">☆☆☆☆☆</span></li><li id="74725547c6008ae93de0153860ed2e7a"><span class="ne-text">控制子元素是否开启三维立体环境</span></li><li id="0a8473fe37574c7a8036a023bc17b293"><code class="ne-code"><span class="ne-text">transform-style: flat</span></code><span class="ne-text"> 代表子元素不开启 </span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 立体空间，默认的</span></li><li id="78f4271ffedb7dfa8f7f84771991f584"><code class="ne-code"><span class="ne-text">transform-style: preserve-3d</span></code><span class="ne-text"> 子元素开启立体空间</span></li><li id="124fd07856c3d7916b85f4bcd9e44b27"><span class="ne-text">代码写给父级，但是影响的是子盒子</span></li></ul></ul><ol class="ne-list-wrap"><ol start="2" ne-level="1" class="ne-ol"><li id="08cb7891d17722257deee751811e8255"><span class="ne-text">代码演示</span></li></ol></ol></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 动画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS3的2D效果</title>
      <link href="/blog/02_html5css3_day02/"/>
      <url>/blog/02_html5css3_day02/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="translate"><span class="ne-text">translate</span></h2><div class="ne-quote"><p id="04a5937cce8e938c2cf996a4a9f16010" class="ne-p"><code class="ne-code"><span class="ne-text">2D</span></code><span class="ne-text"> 转换</span></p></div><ul class="ne-ul"><li id="29384dceb5b50821fce44adbc500eb54"><code class="ne-code"><span class="ne-text">2D</span></code><span class="ne-text"> 转换是改变标签在二维平面上的位置和形状</span></li><li id="1eee507a5fc604e79a0d13ad686cc9fd"><span class="ne-text">移动： </span><code class="ne-code"><span class="ne-text">translate</span></code></li><li id="a4ae850c7f51d397dc2f96c5a10c7aab"><span class="ne-text">旋转： </span><code class="ne-code"><span class="ne-text">rotate</span></code></li><li id="b91b37fa65cc0b78628242e63e3e4251"><span class="ne-text">缩放： </span><code class="ne-code"><span class="ne-text">scale</span></code></li></ul><div class="ne-quote"><p id="5525ee43071d43ee9cf13abf80c7bc32" class="ne-p"><code class="ne-code"><span class="ne-text">translate</span></code><span class="ne-text"> 语法</span></p></div><ul class="ne-ul"><li id="79be9c9fbcb091ba060718be95280000"><span class="ne-text">x 就是 x 轴上水平移动</span></li><li id="c24748c65334ee0efc958660ab76c083"><span class="ne-text">y 就是 y 轴上水平移动</span></li></ul><pre data-language="css" id="fOep7" class="ne-codeblock language-css">transform: translate(x, y)<p>transform: translateX(n)<br>transfrom: translateY(n)</pre><p id="39673fc6277dee8b168db0efd168ec8b" class="ne-p"><br></p><ul class="ne-ul"><li id="6386d541bfeb5fd27f0ea33e3ba3dd05"><code class="ne-code"><span class="ne-text">2D</span></code><span class="ne-text"> 的移动主要是指 水平、垂直方向上的移动</span></li><li id="d7cb5914dd63811c7f6a7ea7c611f628"><code class="ne-code"><span class="ne-text">translate</span></code><span class="ne-text"> 最大的优点就是不影响其他元素的位置</span></li><li id="d26465f9a0ddb8661c05ffdbe2509935"><code class="ne-code"><span class="ne-text">translate</span></code><span class="ne-text"> 中的 100%单位，</span><span class="ne-text" style="background-color: #FADB14">是相对于本身的宽度和高度来进行计算的</span></li></ul><p id="851bb8235374656b9795f978b628c308" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616205104693-ec7eec39-aa37-44fe-879c-3f9b7dd4e90d.png" width="960" id="lYB1a" class="ne-image"></p><div class="ne-quote"><p id="a4926865550eb4a68091f9f5c8b62900" class="ne-p"><span class="ne-text">这也是盒子居中的另一种方法</span></p></div><ul class="ne-ul"><li id="9e5a6d19c6d0452cb65e86e47bbdaa7e"><span class="ne-text">行内标签没有效果</span></li></ul><p id="47e0413776abdd3c20d89e91712693b7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616204546631-96431c20-82e7-4d39-8f87-3bd6a2ab3be4.png" width="960" id="iatwu" class="ne-image"></p><p id="31e3079277e44a4617cb419853dee25d" class="ne-p"><br></p><h2 id="BhXls"><span class="ne-text">十六、</span><code class="ne-code"><span class="ne-text">2D 转换 rotate</span></code></h2><ol class="ne-ol"><li id="b464f405f16fa4a40a7709f352b096e0"><span class="ne-text">rotate 旋转</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ecf4367280a1e92318f25f6077deffca"><code class="ne-code"><span class="ne-text">2D</span></code><span class="ne-text"> 旋转指的是让元素在二维平面内顺时针或者逆时针旋转</span></li></ul></ul><ol start="2" class="ne-ol"><li id="a705fbf254cbfe658524ec0b99062903"><code class="ne-code"><span class="ne-text">rotate</span></code><span class="ne-text"> 语法</span></li></ol><pre data-language="css" id="fGPSZ" class="ne-codeblock language-css">/_ 单位是：deg <em>/<br>transform: rotate(度数)</pre><ol start="3" class="ne-ol"><li id="46c2d83b4692eaf97374e327747b6249"><span class="ne-text">重点知识点</span></li></ol><ul class="ne-ul"><li id="f2da925ee2fedc12956630c73280dcab"><code class="ne-code"><span class="ne-text">rotate</span></code><span class="ne-text"> 里面跟度数，单位是 </span><code class="ne-code"><span class="ne-text">deg</span></code></li><li id="cebb988d11cb7dc9f88900f6aecc3e01"><span class="ne-text">角度为正时，顺时针，角度为负时，逆时针</span></li><li id="24af52f34750a97ab517a145522c4a51"><span class="ne-text">默认旋转的中心点是元素的中心点</span></li></ul><ol start="4" class="ne-ol"><li id="cef2c77309c566b376bddd5a1d39a500"><span class="ne-text">代码演示</span></li></ol><pre data-language="css" id="D5PPc" class="ne-codeblock language-css">img:hover {<br>transform: rotate(360deg)<br>}</pre><h2 id="qHXpR"><span class="ne-text">一、rotate</span></h2><div class="ne-quote"><p id="4b51da4b42192910373ea1d79d3735cd" class="ne-p"><span class="ne-text">2d 旋转指的是让元素在 2 维平面内顺时针旋转或者逆时针旋转</span></p></div><p id="f05ed87ad9287f6f052c2a24caf18dd9" class="ne-p"><span class="ne-text">使用步骤：</span></p><ol class="ne-ol"><li id="bce316654b08f530874cfd23d43d810d"><span class="ne-text">给元素添加转换属性 </span><code class="ne-code"><span class="ne-text">transform</span></code></li><li id="14386718e69af881fc5f1eff1a86f0b2"><span class="ne-text">属性值为 </span><code class="ne-code"><span class="ne-text">rotate(角度)</span></code><span class="ne-text"> 如 </span><code class="ne-code"><span class="ne-text">transform:rotate(30deg)</span></code><span class="ne-text"> 顺时针方向旋转</span><strong><span class="ne-text">30 度</span></strong></li></ol><pre data-language="css" id="t0urU" class="ne-codeblock language-css">div{<br>transform: rotate(0deg);<br>}</pre><h2 id="5vqSB"><span class="ne-text">二、三角</span></h2><ul class="ne-ul"><li id="4554d7c1ebed9296330c070a3bdcc89d"><span class="ne-text">代码演示</span></li></ul><h6 id="xG3l8"><span class="ne-text">二、设置元素旋转中心点(transform-origin)</span></h6><ol class="ne-ol"><li id="adb4753e4a270d584f12c09682615e41"><code class="ne-code"><span class="ne-text">transform-origin</span></code><span class="ne-text"> 基础语法</span></li></ol><pre data-language="css" id="OSaAM" class="ne-codeblock language-css">transform-origin: x y;</pre><ol start="2" class="ne-ol"><li id="cee08e784ba923f5e267daf35124e308"><span class="ne-text">重要知识点</span></li></ol><ul class="ne-ul"><li id="180f2ab50fa9f9c5de29aa4e0c20f4c1"><span class="ne-text">注意后面的参数 x 和 y 用空格隔开</span></li><li id="86d555901d4b58d053701187f0dfe875"><span class="ne-text">x y 默认旋转的中心点是元素的中心 (50% 50%)，等价于 </span><code class="ne-code"><span class="ne-text">center</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">center</span></code></li><li id="31ee1b02316ca940d687efbf7c172c75"><span class="ne-text">还可以给 x y 设置像素或者方位名词(</span><code class="ne-code"><span class="ne-text">top</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">bottom</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">left</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">right</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">center</span></code><span class="ne-text">)</span></li></ul><h2 id="cm0x8"><span class="ne-text">三、旋转中心案例</span></h2><ul class="ne-ul"><li id="82ed6ab990c04888c6b1b1354a983974"><span class="ne-text">代码演示</span></li></ul><h2 id="wkK66"><span class="ne-text">四、</span><code class="ne-code"><span class="ne-text">2D</span></code><span class="ne-text"> 转换之 </span><code class="ne-code"><span class="ne-text">scale</span></code></h2><ol class="ne-ol"><li id="939b55284a600b32b1c39e537becf79f"><code class="ne-code"><span class="ne-text">scale</span></code><span class="ne-text"> 的作用</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="e0d29c29abe3cc16f88a39cc034b6ea0"><span class="ne-text">用来控制元素的放大与缩小</span></li></ul></ul><ol start="2" class="ne-ol"><li id="cb92b81fb026b4f43eb3ad72898c9eec"><span class="ne-text">语法</span></li></ol><pre data-language="css" id="qzNy6" class="ne-codeblock language-css">transform: scale(x, y)</pre><ol class="ne-ol"><li id="ae5866f258d33ca07600e7158b734a31"><span class="ne-text">知识要点</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="84ac319006cba66341289ead9ae0aadd"><span class="ne-text">注意，x 与 y 之间使用逗号进行分隔</span></li><li id="7e0e04e294deb8edced84f5c2ea9dde5"><code class="ne-code"><span class="ne-text">transform: scale(1, 1)</span></code><span class="ne-text">: 宽高都放大一倍，相当于没有放大</span></li><li id="b7e4683300c8349216973c02920656bb"><code class="ne-code"><span class="ne-text">transform: scale(2, 2)</span></code><span class="ne-text">: 宽和高都放大了二倍</span></li><li id="767a6adbf3b25919c026f8092a36f2c3"><code class="ne-code"><span class="ne-text">transform: scale(2)</span></code><span class="ne-text">: 如果只写了一个参数，第二个参数就和第一个参数一致</span></li><li id="c3b8bd26961f86ac3f214d9df6ff7ad2"><code class="ne-code"><span class="ne-text">transform:scale(0.5, 0.5)</span></code><span class="ne-text">: 缩小</span></li><li id="ea48b7f68ca0889ade4c6266ec09bf5f"><code class="ne-code"><span class="ne-text">scale</span></code><span class="ne-text"> 最大的优势：可以设置转换中心点缩放，默认以中心点缩放，而且不影响其他盒子</span></li></ul></ul><ol start="2" class="ne-ol"><li id="ba63f7717247be9fb4808fa0a07b7131"><span class="ne-text">代码演示</span></li></ol><pre data-language="css" id="LT1gR" class="ne-codeblock language-css">div:hover {<br>/</em> 注意，数字是倍数的含义，所以不需要加单位 <em>/<br>/</em> transform: scale(2, 2) _/</p><pre><code>   /* 实现等比缩放，同时修改宽与高 */   /* transform: scale(2) */   /* 小于 1 就等于缩放*/   transform: scale(0.5, 0.5)</code></pre><p>}</pre><h2 id="wfwBH"><span class="ne-text">五、图片放大案例</span></h2><ul class="ne-ul"><li id="f3b7a6cb871cc5ddbebfe2dc659d0576"><span class="ne-text">代码演示</span></li></ul><h2 id="7gljD"><span class="ne-text">六、分页按钮案例</span></h2><ul class="ne-ul"><li id="565616bd855b96c5f4659a0c61025e3f"><span class="ne-text">代码演示</span></li></ul><h2 id="F5eZJ"><span class="ne-text">七、 </span><code class="ne-code"><span class="ne-text">2D</span></code><span class="ne-text"> 转换综合写法以及顺序问题</span></h2><ol class="ne-ol"><li id="4cebe013202d86f01cf36605d64132e5"><span class="ne-text">知识要点</span></li></ol><ul class="ne-ul"><li id="457a91980e350f6a665ce8d7523f44e6"><span class="ne-text">同时使用多个转换，其格式为 </span><code class="ne-code"><span class="ne-text">transform: translate() rotate() scale()</span></code></li><li id="9bf3347d5f62e79639829072dd0ff377"><span class="ne-text">顺序会影响到转换的效果(先旋转会改变坐标轴方向)</span></li><li id="8f0d86537398ab4a4d2fc85440284d33"><span class="ne-text">但我们同时有位置或者其他属性的时候，要将位移放到最前面</span></li></ul><ol start="2" class="ne-ol"><li id="42db8af2ee71a774d78f6d8eabbb1a8d"><span class="ne-text">代码演示</span></li></ol><pre data-language="css" id="fY1us" class="ne-codeblock language-css">div:hover {<br>transform: translate(200px, 0) rotate(360deg) scale(1.2)<br>}</pre><h2 id="w9cCQ"><span class="ne-text">八、 动画(animation)</span></h2><ol class="ne-ol"><li id="61500cbf461ed1471eecb272946dd1f7"><span class="ne-text">什么是动画</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="03409d0983e9faab0440f9caeaca4dc7"><span class="ne-text">动画是 </span><code class="ne-code"><span class="ne-text">CSS3</span></code><span class="ne-text"> 中最具颠覆性的特征之一，可通过设置多个节点来精确的控制一个或者一组动画，从而实现复杂的动画效果</span></li></ul></ul><ol start="2" class="ne-ol"><li id="e0d55a514b73df27ba2376f80552708d"><span class="ne-text">动画的基本使用</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="3110b6fbaf8a8b4a39350cdebf507e43"><span class="ne-text">先定义动画</span></li><li id="332dce494df8de0e3e88ccf2427e9768"><span class="ne-text">在调用定义好的动画</span></li></ul></ul><ol start="3" class="ne-ol"><li id="cca4817af470ea63e876c21facf03d38"><span class="ne-text">语法格式(定义动画)</span></li></ol><pre data-language="css" id="lLAG0" class="ne-codeblock language-css">@keyframes 动画名称 {<br>0% {<br>width: 100px;<br>}<br>100% {<br>width: 200px<br>}<br>}</pre><ol class="ne-ol"><li id="1df01c5b616186ecb6bc9e4e66a60d3d"><span class="ne-text">语法格式(使用动画)</span></li></ol><pre data-language="plain" id="3ZA0n" class="ne-codeblock language-plain">div {<br>/_ 调用动画 <em>/<br>animation-name: 动画名称;<br>/</em> 持续时间 <em>/<br>animation-duration: 持续时间；<br>}</pre><ol start="5" class="ne-ol"><li id="7107a5aae474935731e019717e16f61c"><span class="ne-text">动画序列</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="883898f79fcae5714aedd5f1e91e3b12"><span class="ne-text">0% 是动画的开始，100 % 是动画的完成，这样的规则就是动画序列</span></li><li id="4ce200efbc2e814feabd5c904b0c71a0"><span class="ne-text">在 </span><a href="/keyframs " data-href="/keyframs " class="ne-link"><em><span class="ne-text">@</span></em><span class="ne-text">keyframs </span></a><span class="ne-text"> 中规定某项 CSS 样式，就由创建当前样式逐渐改为新样式的动画效果 </span></li><li id="0d9772729dbba6d4f2343def8e6bb77f"><span class="ne-text">动画是使元素从一个样式逐渐变化为另一个样式的效果，可以改变任意多的样式任意多的次数</span></li><li id="5923a5881f6bffc9a56671f22d207c7b"><span class="ne-text">用百分比来规定变化发生的时间，或用 </span><code class="ne-code"><span class="ne-text">from</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">to</span></code><span class="ne-text">，等同于 0% 和 100%</span></li></ul></ul><ol start="6" class="ne-ol"><li id="b49187747eb89c574d6ab7f02da08524"><span class="ne-text">代码演示</span></li></ol><pre data-language="css" id="bilI5" class="ne-codeblock language-css"><style><br>div {<br>width: 100px;<br>height: 100px;<br>background-color: aquamarine;<br>animation-name: move;<br>animation-duration: 0.5s;<br>}<br>@keyframes move{<br>0% {<br>transform: translate(0px)<br>}<br>100% {<br>transform: translate(500px, 0)<br>}<br>}<br></style></pre><h2 id="JTKas"><span class="ne-text">九、动画序列</span></h2><ul class="ne-ul"><li id="c12287aba88d2b23c0e26e4c25227054"><span class="ne-text">代码演示</span></li></ul><h2 id="VIQDZ"><span class="ne-text">十、动画常见属性</span></h2><ol class="ne-ol"><li id="1be96e164f13cbdaf16c2451e38033f2"><span class="ne-text">常见的属性</span></li></ol><p id="4382f77869387647d5b3e1acc5234c78" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561017110-4a2da65a-dd0d-42e6-b3cf-b4f698e56f95.png" width="602.5" id="uwLLK" class="ne-image"></p><ol start="2" class="ne-ol"><li id="937fc40a74a817e22968d47bb3747cff"><span class="ne-text">代码演示</span></li></ol><pre data-language="css" id="toyhB" class="ne-codeblock language-css">div {<br>width: 100px;<br>height: 100px;<br>background-color: aquamarine;<br>/</em> 动画名称 <em>/<br>animation-name: move;<br>/</em> 动画花费时长 <em>/<br>animation-duration: 2s;<br>/</em> 动画速度曲线 <em>/<br>animation-timing-function: ease-in-out;<br>/</em> 动画等待多长时间执行 <em>/<br>animation-delay: 2s;<br>/</em> 规定动画播放次数 infinite: 无限循环 <em>/<br>animation-iteration-count: infinite;<br>/</em> 是否逆行播放 <em>/<br>animation-direction: alternate;<br>/</em> 动画结束之后的状态 <em>/<br>animation-fill-mode: forwards;<br>}<br>div:hover {<br>/</em> 规定动画是否暂停或者播放 <em>/<br>animation-play-state: paused;<br>}</pre><h2 id="39QNS"><span class="ne-text">十一、 动画简写方式</span></h2><ol class="ne-ol"><li id="d5c2dae0bfba40ca421ed7c6968c39cf"><span class="ne-text">动画简写方式</span></li></ol><pre data-language="css" id="zeW8N" class="ne-codeblock language-css">/</em> animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 起始与结束状态 _/<br>animation: name duration timing-function delay iteration-count direction fill-mode</pre><ol start="2" class="ne-ol"><li id="e25b7e0ab44fa6f12f438883dfc5b374"><span class="ne-text">知识要点</span></li></ol><ul class="ne-ul"><li id="a8f3e5f1361dfeb24cffa6bada70c486"><span class="ne-text">简写属性里面不包含 </span><code class="ne-code"><span class="ne-text">animation-paly-state</span></code></li><li id="627e851573eed2fd79193f212d510144"><span class="ne-text">暂停动画 </span><code class="ne-code"><span class="ne-text">animation-paly-state: paused</span></code><span class="ne-text">; 经常和鼠标经过等其他配合使用</span></li><li id="5636018db8a71f8385b17ab30d17bc72"><span class="ne-text">要想动画走回来，而不是直接调回来：</span><code class="ne-code"><span class="ne-text">animation-direction: alternate</span></code></li><li id="a306cf97c153b6fbf9e8dc1abd178034"><span class="ne-text">盒子动画结束后，停在结束位置：</span><code class="ne-code"><span class="ne-text">animation-fill-mode: forwards</span></code></li></ul><ol start="3" class="ne-ol"><li id="015cc67f23dd0724f488f1d170bc5f20"><span class="ne-text">代码演示</span></li></ol><pre data-language="css" id="PqnQZ" class="ne-codeblock language-css">animation: move 2s linear 1s infinite alternate forwards;</pre><h2 id="sSz2P"><span class="ne-text">十二、速度曲线细节</span></h2><ol class="ne-ol"><li id="7943349b59d1d14af0dcce535167a70f"><span class="ne-text">速度曲线细节</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="66d53ce3d67e36c89fffeae9793191fe"><code class="ne-code"><span class="ne-text">animation-timing-function</span></code><span class="ne-text">: 规定动画的速度曲线，默认是</span><code class="ne-code"><span class="ne-text">ease</span></code></li></ul></ul><p id="ef10f6cd9275725090820c0912495131" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561032196-9bb59857-8c59-4c84-a309-c7018dfc0d17.png" width="617.5" id="Rf1vn" class="ne-image"></p><ol start="2" class="ne-ol"><li id="acf203371dd584f3e9d1320e7f1c66fc"><span class="ne-text">代码演示</span></li></ol><pre data-language="css" id="infUv" class="ne-codeblock language-css">div {<br>width: 0px;<br>height: 50px;<br>line-height: 50px;<br>white-space: nowrap;<br>overflow: hidden;<br>background-color: aquamarine;<br>animation: move 4s steps(24) forwards;<br>}<br>@keyframes move {<br>0% {<br>width: 0px;<br>}<br>100% {<br>width: 480px;<br>}<br>}</pre><h2 id="dSwR4"><span class="ne-text">十三、奔跑的熊大</span></h2><ol class="ne-ol"><li id="dcf63a58b64deb9a3a2c1c5cd758d41e"><span class="ne-text">代码演示</span></li></ol><pre data-language="html" id="EaQEq" class="ne-codeblock language-html"><!DOCTYPE html></p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        body {            background-color: #ccc;        }              div {            position: absolute;            width: 200px;            height: 100px;            background: url(media/bear.png) no-repeat;            /* 我们元素可以添加多个动画， 用逗号分隔 */            animation: bear .4s steps(8) infinite, move 3s forwards;        }        <pre><code>    @keyframes bear &#123;        0% &#123;            background-position: 0 0;        &#125;        100% &#123;            background-position: -1600px 0;        &#125;    &#125;        @keyframes move &#123;        0% &#123;            left: 0;        &#125;        100% &#123;            left: 50%;            /* margin-left: -100px; */            transform: translateX(-50%);        &#125;    &#125;&lt;/style&gt;</code></pre></head><body>    <div></div></body></html></pre><h2 id="6NnU6"></h2></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 动画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS/CSS3选择器总结</title>
      <link href="/blog/01_html5css3_day01/"/>
      <url>/blog/01_html5css3_day01/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="syHma"><span class="ne-text">基础选择器</span></h2><p id="u38a5cf83" class="ne-p"><br></p><h3 id="mCD5v"><span class="ne-text">标签选择器</span></h3><ul class="ne-ul"><li id="da3b4a3538a9624aaec278393d9402dd"><span class="ne-text">概念：<p></span><span class="ne-text">标签选择器（元素选择器）是指用</span><strong><span class="ne-text">HTML 标签名</span></strong><span class="ne-text">称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式。</span></li><li id="4ad3e1a06b86c986679a1708194add63"><span class="ne-text">语法：</span></li></ul><pre data-language="css" id="YhAN2" class="ne-codeblock language-css">标签名{属性 1:属性值 1; 属性 2:属性值 2; 属性 3:属性值 3; }</pre><h3 id="WpT3R"><span class="ne-text">类选择器</span></h3><ul class="ne-ul"><li id="f4332b33b7876776617db0261b2ba1b8"><span class="ne-text">类选择器使用“.”（英文点号）进行标识，后面紧跟类名.</span></li><li id="39a8bd3f3ff297f1dab2281bca0729d7"><span class="ne-text">语法：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="e5cb199640ca7fd286dabe51919d83e4"><span class="ne-text">类名选择器</span></li></ul></ul><pre data-language="css" id="iZCTr" class="ne-codeblock language-css">.类名 {<br> 属性 1:属性值 1;<br>属性 2:属性值 2;<br>属性 3:属性值 3;<br>}</pre><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="40c4f00fa4186974b01b7bcfa38e5e28"><span class="ne-text">标签</span></li></ul></ul><pre data-language="css" id="yT9SJ" class="ne-codeblock language-css"><p class='类名'></p></pre><p id="1a493e84cfccb115d1c9b4b0a01d9e5f" class="ne-p"><br></p><div class="ne-quote"><p id="b6d0b20e98583d2ddeb639ba9c6a2451" class="ne-p"><span class="ne-text">类选择器特殊用法- 多类名</span></p></div><p id="46f7a3ace43239a6fbf7c5092aeb14f6" class="ne-p"><span class="ne-text">我们可以给标签指定多个类名，从而达到更多的选择目的。各个类名中间用空格隔开。</span></p><pre data-language="html" id="5WLY5" class="ne-codeblock language-html"><div class="pink fontWeight font20">亚瑟</div></p><div class="font20">刘备</div><div class="font14 pink">安其拉</div><div class="font14">貂蝉</div></pre><h3 id="ixyaq"><span class="ne-text">id选择器</span></h3><p id="11ea7783cf240869f507126f52713a18" class="ne-p"><span class="ne-text">id选择器使用</span><code class="ne-code"><span class="ne-text">#</span></code><span class="ne-text">进行标识，后面紧跟id名</span></p><ul class="ne-ul"><li id="72161acb06e788cb47611980aff22a9b"><span class="ne-text">其基本语法格式如下：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="697eec58ee0b2bdb033af0fe6707dc2c"><span class="ne-text">id选择器</span></li></ul></ul><pre data-language="plain" id="KfDWt" class="ne-codeblock language-plain">#id名 {属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }</pre><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="6dd930c19907ad60dd9329b8d1730299"><span class="ne-text">标签</span></li></ul></ul><pre data-language="plain" id="fjfh3" class="ne-codeblock language-plain"><p id="id名"></p></pre><ul class="ne-ul"><li id="1464d5043f18c4e91db2a3657aff541f"><span class="ne-text">元素的id值是唯一的，只能对应于文档中某一个具体的元素。</span></li><li id="f5822383dda17826926d34fafe90b78f"><span class="ne-text">用法基本和类选择器相同。</span></li></ul><div class="ne-quote"><p id="4f5223946669468ebd8f349585a01fa1" class="ne-p"><span class="ne-text">id选择器和类选择器区别</span></p></div><ul class="ne-ul"><li id="d0e893dbb5f16b78844f01f9a1d02ce2"><span class="ne-text">W3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="eedec2cd41e06cc374415e34ca69ea95"><span class="ne-text">类选择器（class） 好比人的名字，  是可以多次重复使用的， 比如  张伟  王伟  李伟  李娜</span></li><li id="819c39047f46dce3401305e9654ff47b"><span class="ne-text">id选择器     好比人的身份证号码，  全中国是唯一的， 不得重复。 只能使用一次。</span></li></ul></ul><p id="9e4b23787db9136cfae876a2737a3a89" class="ne-p"><em><strong><span class="ne-text">id选择器和类选择器最大的不同在于 使用次数上。</span></strong></em></p><p id="7fba188a47fa857a52f82c8c9b22d2d6" class="ne-p"><strong><span class="ne-text">pink老师 总结他们</span></strong></p><ul class="ne-ul"><li id="e022beed77c6964afd324f35f63e4424"><span class="ne-text">类选择器我们在修改样式中，用的最多。</span></li><li id="384751deb9a272ab01d3e379228fb931"><span class="ne-text">id选择器一般用于页面唯一性的元素身上，经常和我们后面学习的javascript 搭配使用。</span></li></ul><h3 id="rL3HL"><span class="ne-text">通配符选择器</span></h3><ul class="ne-ul"><li id="f84430fbdb9cd8a0fdf86731f332f7d1"><span class="ne-text">概念</span><span class="ne-text">通配符选择器用</span><code class="ne-code"><span class="ne-text">*</span></code><span class="ne-text">号表示，  *   就是 选择所有的标签      他是所有选择器中作用范围最广的，能匹配页面中所有的元素。</span></li><li id="a6f76af3710113384b2f1edfcdc6666e"><span class="ne-text">其基本语法格式如下：</span></li></ul><pre data-language="plain" id="OJot6" class="ne-codeblock language-plain">* { 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }</pre><p id="bf94a62ace13454ad9a1c1c9843aca1e" class="ne-p"><span class="ne-text">例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。</span></p><pre data-language="css" id="OtzDB" class="ne-codeblock language-css">* {  margin: 0;                    /* 定义外边距*/  padding: 0;                   /* 定义内边距*/}</pre><ul class="ne-ul"><li id="9f3251b104db3ef49e4705ccd3e1499d"><span class="ne-text">注意：</span></li></ul><pre data-language="plain" id="m3TbW" class="ne-codeblock language-plain">会匹配页面所有的元素，降低页面响应速度，不建议随便使用</pre><h2 id="WOt8C"><span class="ne-text">复合选择器</span></h2><p id="39108452ebef686b0eaf6beb0b7c90e1" class="ne-p"><span class="ne-text">目标</span></p><ul class="ne-ul"><li id="fdfb0c979a904f860a73a1b049cc3485"><span class="ne-text">理解</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ecfb4d5cc79c65b18d4ca356c409699f"><span class="ne-text">理解css复合选择器分别的应用场景</span></li></ul></ul><ul class="ne-ul"><li id="49ce03bf6b589bb62a5645339bf7a940"><span class="ne-text">应用</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="725b6c86ca4c7c383d9b743fb8c2aefa"><span class="ne-text">使用后代选择器给元素添加样式</span></li><li id="344111586057cf44b492a6eeb2edca5a"><span class="ne-text">使用并集选择器给元素添加样式</span></li><li id="003047ea76d7756eeeb9e2188af09bd7"><span class="ne-text">使用伪类选择器</span></li></ul></ul><p id="9a47da7dbd67754532f3689ba268bb2a" class="ne-p"><strong><span class="ne-text">为什么要学习css复合选择器</span></strong></p><p id="73672a7ebea090a6094fc5efd0e581cb" class="ne-p"><span class="ne-text">CSS选择器分为 基础选择器 和 复合选择器 ，但是基础选择器不能满足我们实际开发中，快速高效的选择标签。</span></p><ul class="ne-ul"><li id="5b88e5a6c40c2b89b47ee902196be529"><span class="ne-text">目的是为了可以选择更准确更精细的目标元素标签。</span></li><li id="5a21cafdee1487ae4f3db3cdf26e7087"><span class="ne-text">复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的</span></li></ul><h3 id="HvZl4"><span class="ne-text">后代选择器（重点）</span></h3><ul class="ne-ul"><li id="e437d31943132d0cf334a6c404ccd907"><span class="ne-text">概念：</span><span class="ne-text">后代选择器又称为包含选择器</span></li><li id="2b2022cea45f76092838d7d986588e3b"><span class="ne-text">作用：</span><span class="ne-text">用来选择元素或元素组的</span><strong><span class="ne-text">子孙后代</span></strong></li><li id="0235285f1eb08dfd51332b1be23ca980"><span class="ne-text">其写法就是把外层标签写在前面，内层标签写在后面，中间用</span><strong><span class="ne-text">空格</span></strong><span class="ne-text">分隔，先写父亲爷爷，在写儿子孙子。</span></li></ul><pre data-language="plain" id="FuHx0" class="ne-codeblock language-plain">父级 子级{属性:属性值;属性:属性值;}</pre><ul class="ne-ul"><li id="e15afdb58ef417ee269267c4a0ef4acf"><span class="ne-text">语法：</span></li></ul><pre data-language="plain" id="zMKmC" class="ne-codeblock language-plain">.class h3{color:red;font-size:16px;}</pre><p id="b2121a7373fae32fc99583d6aa3e8781" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549554841-0a0e11a6-a82e-48b9-bff2-2c00c4a8c530.png" width="420" id="FxqG0" class="ne-image"></p><ul class="ne-ul"><li id="bcfe4dda17ca6112ef95479f7ebdf7b1"><span class="ne-text">当标签发生嵌套时，内层标签就成为外层标签的后代。</span></li><li id="3ae133821f23f75c0bf7a63a89498d47"><span class="ne-text">子孙后代都可以这么选择。 或者说，它能选择任何包含在内 的标签。</span></li></ul><h3 id="GDsx0"><span class="ne-text">子元素选择器</span></h3><ul class="ne-ul"><li id="b1f768b5646454c306659ce16b1de47a"><span class="ne-text">作用：</span><span class="ne-text">子元素选择器只能选择作为某元素</span><strong><span class="ne-text">子元素(亲儿子)</span></strong><span class="ne-text">的元素。</span></li><li id="565fb3d27d5dfd5fbe685d9258534e46"><span class="ne-text">其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 </span><code class="ne-code"><span class="ne-text">></span></code><span class="ne-text"> 进行连接</span></li><li id="1e527c474f4b80132e1c89bfcc1816cd"><span class="ne-text">语法：</span></li></ul><pre data-language="plain" id="8PDub" class="ne-codeblock language-plain">.class>h3{color:red;font-size:14px;}</pre><p id="5c1027a98455a7491e077c1f449233c9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549554907-2e3512aa-8c99-4039-b68b-ccda01ac5f64.png" width="420" id="LiuXE" class="ne-image"></p><p id="c051f36b477038e60b05ac9edd81240c" class="ne-p"><strong><span class="ne-text">pink老师一句话说出他们</span></strong></p><div class="ne-quote"><p id="a23924b77da3df8b1d6a293a7dfeb880" class="ne-p"><span class="ne-text">这里的子 指的是 亲儿子  不包含孙子 重孙子之类。</span></p></div><p id="ff95fedb8205b405adc2780ec74669b4" class="ne-p"><span class="ne-text">白话：</span></p><pre data-language="plain" id="3tNOO" class="ne-codeblock language-plain">比如：  .demo > h3 {color: red;}   说明  h3 一定是demo 亲儿子。  demo 元素包含着h3。</pre><h3 id="AE4h0"><span class="ne-text">交集选择器</span></h3><ul class="ne-ul"><li id="1ce08c552920cde5e6bb19c1dca78179"><span class="ne-text">条件</span><span class="ne-text">交集选择器由两个选择器构成，找到的标签必须满足：既有标签一的特点，也有标签二的特点。</span></li></ul><p id="ba9ba28983a6b2e700e8f88375243276" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555013-a53d587a-d286-4835-8b50-d03595cda0de.png" width="724" id="XHJen" class="ne-image"></p><ul class="ne-ul"><li id="c78c5d1b9ce23eed1e13037fec04eae2"><span class="ne-text">语法：</span></li></ul><p id="d570aa40fb55e744b3e6ea93608e1bbf" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555090-6a9ccb8a-1627-4f6c-83ce-51ec419d23ba.png" width="420" id="Q23h6" class="ne-image"></p><ul class="ne-ul"><li id="ffacc6edcaa9618a0be864a2505fb91c"><span class="ne-text">其中第一个为标签选择器，第二个为class选择器，两个选择器之间</span><strong><span class="ne-text">不能有空格</span></strong><span class="ne-text">，如h3.special。</span></li></ul><p id="e02e6a207bd66cc04651d6c095d413e4" class="ne-p"><strong><span class="ne-text">记忆技巧：</span></strong></p><p id="eb9ff47a10fe4b476423eac2de5e14fd" class="ne-p"><span class="ne-text">交集选择器 是 并且的意思。  即...又...的意思</span></p><pre data-language="plain" id="Jjf44" class="ne-codeblock language-plain">比如：   p.one   选择的是： 类名为 .one  的 段落标签。</pre><p id="b84c98f604aa11e3ffac93dcf1efa9ea" class="ne-p"><span class="ne-text">用的相对来说比较少，不太建议使用。</span></p><h3 id="okTVH"><span class="ne-text">并集选择器（重点）</span></h3><ul class="ne-ul"><li id="b6b26c90ead1522cfad595b90dcb64a2"><span class="ne-text">应用：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="2f5dd73bf1350960397e1950f78ba1ee"><span class="ne-text">如果某些选择器定义的相同样式，就可以利用并集选择器，可以让代码更简洁。</span></li></ul></ul><ul class="ne-ul"><li id="b6cc2a4ced50a95eb9bee29ee84c2416"><span class="ne-text">并集选择器（CSS选择器分组）是各个选择器通过</span><code class="ne-code"><span class="ne-text">,</span></code><span class="ne-text">连接而成的，通常用于集体声明。</span></li><li id="f11f296bd2010a4354a14b84c9581bbf"><span class="ne-text">语法：</span></li></ul><p id="ccf21d082ec63b1c5036369ae8d5eaeb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555153-fb31a194-1c09-47d5-bab6-eb250ebaa118.png" width="420" id="V4Cud" class="ne-image"></p><ul class="ne-ul"><li id="ab1b77d9bfcd424e2c100e6ae367cc7c"><span class="ne-text">任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。</span></li><li id="f984330c1d2b1acd3d0dc1a4b23cea1c"><span class="ne-text">记忆技巧：</span><span class="ne-text">并集选择器通常用于集体声明  ，逗号隔开的，所有选择器都会执行后面样式，逗号可以理解为 和的意思。</span></li></ul><pre data-language="plain" id="gipJq" class="ne-codeblock language-plain">比如  .one, p , #test {color: #F00;}  表示   .one 和 p  和 #test 这三个选择器都会执行颜色为红色。 通常用于集体声明。</pre><p id="bb5b61d687b26eaf4eeb4e528a574a5d" class="ne-p"><br></p><h3 id="vKNbA"><span class="ne-text">链接伪类选择器（重点）</span></h3><div data-type="tips" class="ne-alert"><p id="a7a66ed7083b4207eb9b144fbf98b7e2" class="ne-p"><span class="ne-text" style="background-color: #FFF6B6">用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素。因为伪类选择器很多，比如链接伪类，结构伪类等等。我们这里先给大家讲解链接伪类选择器。</span></p></div><p id="f7c375a83ea8a92b32f235d66903e9ce" class="ne-p"><br></p><ul class="ne-ul"><li id="f7c52037e88328555502fc29a8e0986c"><span class="ne-text">a:link      /</span><em><span class="ne-text"> 未访问的链接 </span></em><span class="ne-text">/</span></li><li id="d4dd471b8880f202504a7dd5a7f865e1"><span class="ne-text">a:visited   /</span><em><span class="ne-text"> 已访问的链接 </span></em><span class="ne-text">/</span></li><li id="238594354804660610d7325df097ca3a"><span class="ne-text">a:hover     /</span><em><span class="ne-text"> 鼠标移动到链接上 </span></em><span class="ne-text">/</span></li><li id="11bf9fa717b673cd2e98b8601026b665"><span class="ne-text">a:active    /</span><em><span class="ne-text"> 选定的链接 </span></em><span class="ne-text">/</span></li><li id="98a61817e929def698d7be74e93f946e"><span class="ne-text">注意：写的时候，他们的顺序尽量不要颠倒  按照  lvha 的顺序。否则可能引起错误。</span></li></ul><pre data-language="css" id="3O0VN" class="ne-codeblock language-css">a {   /* a是标签选择器  所有的链接 */            font-weight: 700;            font-size: 16px;            color: gray;}a:hover {   /* :hover 是链接伪类选择器 鼠标经过 */            color: red; /*  鼠标经过的时候，由原来的 灰色 变成了红色 */}</pre><h2 id="uWQ1h"><span class="ne-text">七、</span><code class="ne-code"><span class="ne-text">CSS3</span></code><span class="ne-text"> 属性选择器(上)</span></h2><ol class="ne-ol"><li id="11e69e9da840c669afd3d4c0755d87be"><span class="ne-text">什么是 </span><code class="ne-code"><span class="ne-text">CSS3</span></code></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="bda7a8a373c541abba6c0b94516af70f"><span class="ne-text">在 </span><code class="ne-code"><span class="ne-text">CSS2</span></code><span class="ne-text"> 的基础上拓展、新增的样式</span></li></ul></ul><ol start="2" class="ne-ol"><li id="fdd2cdef843d5ec2d3ee7ef2778de178"><code class="ne-code"><span class="ne-text">CSS3</span></code><span class="ne-text"> 发展现状</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="0e6e02675af4c96827f21eaaeba2f640"><span class="ne-text">移动端支持优于 </span><code class="ne-code"><span class="ne-text">PC</span></code><span class="ne-text"> 端</span></li><li id="39581f8c55b9f4469de6004da1ac74c8"><code class="ne-code"><span class="ne-text">CSS3</span></code><span class="ne-text"> 目前还草案，在不断改进中</span></li><li id="4d92e101d660a82ee1cd6e5572306a5b"><code class="ne-code"><span class="ne-text">CSS3</span></code><span class="ne-text"> 相对 </span><code class="ne-code"><span class="ne-text">H5</span></code><span class="ne-text">，应用非常广泛</span></li></ul></ul><ol start="3" class="ne-ol"><li id="75d6a7bd428411db15cdbe12b4c49571"><span class="ne-text">属性选择器列表</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560941419-cf3cbc9c-220a-40a1-8f0b-ed243d38a53e.png" width="600.5" id="dIQ5a" class="ne-image"></li><li id="cbeea92b4bf45bd91bb3407f6ed6e4a2"><span class="ne-text">属性选择器代码演示</span></li></ol><pre data-language="css" id="kwKrm" class="ne-codeblock language-css">button {  cursor: pointer;}button[disabled] {  cursor: default}</pre><h2 id="RF1pz"><span class="ne-text">八、</span><code class="ne-code"><span class="ne-text">CSS3</span></code><span class="ne-text"> 属性选择器(下)</span></h2><ol class="ne-ol"><li id="278893ee9b42fa6c6380bc24296de97d"><span class="ne-text">代码演示</span></li></ol><pre data-language="css" id="QCb3I" class="ne-codeblock language-css">input[type=search] {  color: skyblue;}span[class^=black] {  color: lightgreen;}span[class$=black] {  color: lightsalmon;}span[class*=black] {  color: lightseagreen;}</pre><h2 id="V3rR6"><span class="ne-text">九、结构伪类选择器</span></h2><ol class="ne-ol"><li id="268ffef32b9a0b27ba393d85746a8c3d"><span class="ne-text">属性列表</span><span class="ne-text">  </span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560953518-b31659af-60a9-425e-a173-c52117fa5ce1.png" width="597.5" id="hq2VM" class="ne-image"></li><li id="dfa5d2e9c45aa2b994bb9c871ad0039d"><span class="ne-text">代码演示</span></li></ol><pre data-language="css" id="z9di3" class="ne-codeblock language-css">ul li:first-child {  background-color: lightseagreen;}ul li:last-child {  background-color: lightcoral;}ul li:nth-child(3) {  background-color: aqua;}</pre><h2 id="YlqpL"><span class="ne-text">十、</span><code class="ne-code"><span class="ne-text">nth-child</span></code><span class="ne-text"> 参数详解</span></h2><ol class="ne-ol"><li id="571aaf96cf5e3ebbe5ece8a24c1ac864"><span class="ne-text">nth-child 详解</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="092416165a91ed83b3f4637074e64513"><span class="ne-text">注意：本质上就是选中第几个子元素</span></li><li id="afddd891cd4f34b5920e6f6214068824"><span class="ne-text">n 可以是数字、关键字、公式</span></li><li id="8b385ad8a1c63c87737292fc488285dc"><span class="ne-text">n 如果是数字，就是选中第几个</span></li><li id="b9bef76a807c4d3c8906d6fe52e0f441"><span class="ne-text">常见的关键字有 </span><code class="ne-code"><span class="ne-text">even</span></code><span class="ne-text"> 偶数、</span><code class="ne-code"><span class="ne-text">odd</span></code><span class="ne-text"> 奇数</span></li><li id="745b8fab5750bc03454142923612578f"><span class="ne-text">常见的公式如下(如果 n 是公式，则从 0 开始计算)</span></li><li id="1dbd88449fda90ad526e3bf7c0bdefa2"><span class="ne-text">但是第 0 个元素或者超出了元素的个数会被忽略</span><span class="ne-text">   </span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560964893-79ea2620-3fbe-4c17-93b7-f8f9ce6f681e.png" width="570" id="OnMbZ" class="ne-image"></li></ul></ul><ol start="2" class="ne-ol"><li id="2ccb58db9e8941ab7a1afeea60f098e2"><span class="ne-text">代码演示</span></li></ol><pre data-language="css" id="gVgsw" class="ne-codeblock language-css"><style>  /* 偶数 */  ul li:nth-child(even) {    background-color: aquamarine;  }  /* 奇数 */  ul li:nth-child(odd) {    background-color: blueviolet;  }  /*n 是公式，从 0 开始计算 */  ul li:nth-child(n) {    background-color: lightcoral;  }  /* 偶数 */  ul li:nth-child(2n) {    background-color: lightskyblue;  }  /* 奇数 */  ul li:nth-child(2n + 1) {    background-color: lightsalmon;  }  /* 选择第 0 5 10 15, 应该怎么选 */  ul li:nth-child(5n) {    background-color: orangered;  }  /* n + 5 就是从第5个开始往后选择 */  ul li:nth-child(n + 5) {    background-color: peru;  }  /* -n + 5 前五个 */  ul li:nth-child(-n + 5) {    background-color: tan;  }</style></pre><h2 id="8alEL"><span class="ne-text">十一、</span><code class="ne-code"><span class="ne-text">nth-child</span></code><span class="ne-text"> 和  </span><code class="ne-code"><span class="ne-text">nt-of-type</span></code><span class="ne-text"> 的区别</span></h2><ol class="ne-ol"><li id="6a240e0cd5e0c67010c5f3140df6633c"><span class="ne-text">代码演示</span></li></ol><pre data-language="css" id="5Opew" class="ne-codeblock language-css"><style>  div :nth-child(1) {    background-color: lightblue;  }  div :nth-child(2) {    background-color: lightpink;  }  div span:nth-of-type(2) {    background-color: lightseagreen;  }  div span:nth-of-type(3) {    background-color: #fff;  }</style></pre><ol start="2" class="ne-ol"><li id="ca32b21dadd45a60b2ff6b9db9b12b60"><span class="ne-text">区别</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="65611212985ee293f0e2691f38a41d9f"><code class="ne-code"><span class="ne-text">nth-child</span></code><span class="ne-text">  选择父元素里面的第几个子元素，不管是第几个类型</span></li><li id="a2e4284d7c41056b0d557b989fd53911"><code class="ne-code"><span class="ne-text">nt-of-type</span></code><span class="ne-text">  选择指定类型的元素</span></li></ul></ul><h2 id="chOOD"><span class="ne-text">十二、伪元素选择器</span></h2><ol class="ne-ol"><li id="7d1552d014e26870ee140b207b2b9469"><span class="ne-text">伪类选择器</span><span class="ne-text">  </span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560977673-8652488a-11a5-4e15-8f24-b93bdf1b9c88.png" width="602" id="KcslO" class="ne-image"></li><li id="36f8376b20101cc9fc162ab8cd3e844f"><span class="ne-text">伪类选择器注意事项</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="43fbfea61483d3ea1aaf9dd700d0829c"><code class="ne-code"><span class="ne-text">before</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">after</span></code><span class="ne-text"> 必须有 </span><code class="ne-code"><span class="ne-text">content</span></code><span class="ne-text"> 属性</span></li><li id="14ee139319e92aea7c4a006b4b69bd99"><code class="ne-code"><span class="ne-text">before</span></code><span class="ne-text"> 在内容前面，after 在内容后面</span></li><li id="a84cef62487caf1c7cc693d57649be93"><code class="ne-code"><span class="ne-text">before</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">after</span></code><span class="ne-text"> 创建的是一个元素，但是属于行内元素</span></li><li id="5f41383361181c53de49a5978f450ae7"><span class="ne-text">创建出来的元素在 </span><code class="ne-code"><span class="ne-text">Dom</span></code><span class="ne-text"> 中查找不到，所以称为伪元素</span></li><li id="c7405c74bc396e916e548cded122cc8d"><span class="ne-text">伪元素和标签选择器一样，权重为 1</span></li></ul></ul><ol start="3" class="ne-ol"><li id="8830cc8db634fb2eb442daba118f4ac6"><span class="ne-text">代码演示</span></li></ol><pre data-language="css" id="pNo0U" class="ne-codeblock language-css"><style>    div {      width: 100px;      height: 100px;      border: 1px solid lightcoral;    }    div::after,    div::before {      width: 20px;      height: 50px;      text-align: center;      display: inline-block;    }    div::after {      content: '德';      background-color: lightskyblue;    }    div::before {      content: '道';      background-color: mediumaquamarine;    }  </style></pre><h2 id="QzHfc"><span class="ne-text">十三、伪元素的案例</span></h2><ol class="ne-ol"><li id="5b409e4b5cccc5c8a0afb44b51b25341"><span class="ne-text">添加字体图标</span></li></ol><pre data-language="css" id="yEKcd" class="ne-codeblock language-css">p {   width: 220px;   height: 22px;   border: 1px solid lightseagreen;   margin: 60px;   position: relative;}p::after {  content: '\ea50';  font-family: 'icomoon';  position: absolute;  top: -1px;  right: 10px;}</pre><h2 id="dbdL3"></h2></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA当中栈和队列常用方法</title>
      <link href="/blog/oylyeh/"/>
      <url>/blog/oylyeh/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><p id="ed13560de6a7ec9b1eda86979c2cc929" class="ne-p"><span class="ne-text">Java里有一个叫做Stack的类，却没有叫做Queue的类（它是个接口名字）。当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；</span></p></div><div class="ne-quote"><p id="a61fde9420972de7ad3023c639a8454d" class="ne-p"><span class="ne-text">既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了（次选是LinkedList）。</span></p></div><h2 id="DNrKW"><span class="ne-text">队列常用方法</span></h2><div class="ne-quote"><p id="669ccf1ddf6db7985144999f4db9d1ff" class="ne-p"><span class="ne-text">初始化</span></p></div><p id="u79e3622b" class="ne-p"><span class="ne-text"></span></p><pre data-language="java" id="yRBVd" class="ne-codeblock language-java">import java.util.LinkedList;<p>import java.util.Queue;</p><p>Queue<Integer> queue_input = new LinkedList&lt;&gt;();</pre><p id="80236d6d508a247e1bdeb8786c427278" class="ne-p"><br></p><table id="f1ea7225" class="ne-table" style="width: 676px"><tbody><tr style="height: 33px"><td width="196"><p id="ub8f323f3" class="ne-p"><span class="ne-text">Queue Method</span></p></td><td width="226"><p id="u84b0529d" class="ne-p"><span class="ne-text">Equivalent Deque Method</span></p></td><td width="254"><p id="ud33ae7a9" class="ne-p"><span class="ne-text">说明</span></p></td></tr><tr style="height: 33px"><td width="196"><p id="u8fa7d8f3" class="ne-p"><span class="ne-text">add(e)</span></p></td><td width="226"><p id="u7361f04c" class="ne-p"><span class="ne-text">addLast(e)</span></p></td><td width="254"><p id="u7705ed20" class="ne-p"><span class="ne-text">向队尾插入元素，失败则抛出异常</span></p></td></tr><tr style="height: 33px"><td width="196"><p id="ue59b1a2c" class="ne-p"><span class="ne-text">offer(e)</span></p></td><td width="226"><p id="u3abdec16" class="ne-p"><span class="ne-text">offerLast(e)</span></p></td><td width="254"><p id="b9e17585c170a48179234823803e5277" class="ne-p"><span class="ne-text">向队尾插入元素，失败则返回 false，offer(E e)操作是专为容量受限的队列实现而设计的，在大多数实现中，插入操作不会失败</span></p></td></tr><tr style="height: 33px"><td width="196"><p id="u73a85312" class="ne-p"><span class="ne-text">remove()</span></p></td><td width="226"><p id="u0fa47dee" class="ne-p"><span class="ne-text">removeFirst()</span></p></td><td width="254"><p id="ubfd2bd45" class="ne-p"><span class="ne-text">获取并删除队首元素，失败则抛出异常</span></p></td></tr><tr style="height: 33px"><td width="196"><p id="u6c4615ca" class="ne-p"><span class="ne-text">poll()</span></p></td><td width="226"><p id="u726ad4ec" class="ne-p"><span class="ne-text">pollFirst()</span></p></td><td width="254"><p id="ueee98e65" class="ne-p"><span class="ne-text">获取并删除队首元素，失败则返回 null</span></p></td></tr><tr style="height: 33px"><td width="196"><p id="u2610504a" class="ne-p"><span class="ne-text">element()</span></p></td><td width="226"><p id="u1d5f6660" class="ne-p"><span class="ne-text">getFirst()</span></p></td><td width="254"><p id="ub895706c" class="ne-p"><span class="ne-text">获取但不删除队首元素，失败则抛出异常</span></p></td></tr><tr style="height: 33px"><td width="196"><p id="u018de360" class="ne-p"><span class="ne-text">peek()</span></p></td><td width="226"><p id="ufe072106" class="ne-p"><span class="ne-text">peekFirst()</span></p></td><td width="254"><p id="u263a739b" class="ne-p"><span class="ne-text">获取但不删除队首元素，失败则返回 null</span></p></td></tr></tbody></table><h2 id="4mxoW"><span class="ne-text">栈常用方法</span></h2><table id="e1bd6743" class="ne-table" style="width: 760px"><tbody><tr style="height: 33px"><td width="253"><p id="ue61c19ac" class="ne-p"><span class="ne-text">Stack Method</span></p></td><td width="253"><p id="ua44f8d57" class="ne-p"><span class="ne-text">Equivalent Deque Method</span></p></td><td width="254"><p id="u78e311d0" class="ne-p"><span class="ne-text">说明</span></p></td></tr><tr style="height: 33px"><td width="253"><p id="u88229ae2" class="ne-p"><span class="ne-text">push(e)</span></p></td><td width="253"><p id="ud47aae9c" class="ne-p"><span class="ne-text">addFirst(e)</span></p></td><td width="254"><p id="u711e2955" class="ne-p"><span class="ne-text">向栈顶插入元素，失败则抛出异常</span></p></td></tr><tr style="height: 33px"><td width="253"><p id="ue9461341" class="ne-p"><span class="ne-text">无</span></p></td><td width="253"><p id="ue1fb42ef" class="ne-p"><span class="ne-text">offerFirst(e)</span></p></td><td width="254"><p id="u69a8175b" class="ne-p"><span class="ne-text">向栈顶插入元素，失败则返回 false</span></p></td></tr><tr style="height: 33px"><td width="253"><p id="u6d83e19f" class="ne-p"><span class="ne-text">pop()</span></p></td><td width="253"><p id="u834e64f1" class="ne-p"><span class="ne-text">removeFirst()</span></p></td><td width="254"><p id="u38a790d1" class="ne-p"><span class="ne-text">获取并删除栈顶元素，失败则抛出异常</span></p></td></tr><tr style="height: 33px"><td width="253"><p id="ud1895fe8" class="ne-p"><span class="ne-text">无</span></p></td><td width="253"><p id="u458b9742" class="ne-p"><span class="ne-text">pollFirst()</span></p></td><td width="254"><p id="uc2f801e7" class="ne-p"><span class="ne-text">获取并删除栈顶元素，失败则返回 null</span></p></td></tr><tr style="height: 33px"><td width="253"><p id="ue079cbd5" class="ne-p"><span class="ne-text">peek()</span></p></td><td width="253"><p id="u72e787fe" class="ne-p"><span class="ne-text">peekFirst()</span></p></td><td width="254"><p id="u7c260756" class="ne-p"><span class="ne-text">获取但不删除栈顶元素，失败则抛出异常</span></p></td></tr><tr style="height: 33px"><td width="253"><p id="u611f152d" class="ne-p"><span class="ne-text">无</span></p></td><td width="253"><p id="uac3786e6" class="ne-p"><span class="ne-text">peekFirst()</span></p></td><td width="254"><p id="u996c94ef" class="ne-p"><span class="ne-text">获取但不删除栈顶元素，失败则返回 null</span></p></td></tr></tbody></table><h2 id="ZVu6R"><span class="ne-text">关于 ArrayDeque</span></h2><div class="ne-quote"><p id="9e141997ce9104b3870e5fd54cacc514" class="ne-p"><span class="ne-text">ArrayDeque 和 LinkedList 是 Deque 的两个通用实现，由于官方更推荐使用 AarryDeque 用作栈和队列，</span></p><p id="53a4f11749e2e66a47917c942a74d069" class="ne-p"><span class="ne-text">从名字可以看出 ArrayDeque 底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。ArrayDeque 是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入 null 元素。</span></p></div><p id="2d36075aa731cf91bb285f067dbd44da" class="ne-p"><br></p><pre data-language="java" id="4PifD" class="ne-codeblock language-java">import java.util.*;</p><p>public class ArrayDequeStack {<br>public static void main(String[] args) {<br>ArrayDeque stack = new ArrayDeque();<br>// 依次将三个元素 push 入“栈”，先进后出<br>stack.push(“疯狂 Java 讲义”);<br>stack.push(“轻量级 Java EE 企业应用实战”);<br>stack.push(“疯狂 Android 讲义”);<br>System.out.println(stack); // [疯狂 Android 讲义, 轻量级 Java EE 企业应用实战, 疯狂 Java 讲义]<br>System.out.println(stack.peek()); // 疯狂 Android 讲义<br>System.out.println(stack); // [疯狂 Android 讲义, 轻量级 Java EE 企业应用实战, 疯狂 Java 讲义]<br>System.out.println(stack.pop()); // 疯狂 Android 讲义<br>System.out.println(stack);//[轻量级 Java EE 企业应用实战, 疯狂 Java 讲义]</p><pre><code>    // 当做队列来使用,先进先出    ArrayDeque queue = new ArrayDeque();    queue.offer(&quot;疯狂Java讲义&quot;);    queue.offer(&quot;轻量级JavaEE企业应用实践&quot;);    queue.offer(&quot;疯狂Android讲义&quot;);    System.out.println(queue); //[疯狂Java讲义, 轻量级JavaEE企业应用实践, 疯狂Android讲义]    // 访问队列头部元素，但不将其poll出队列    System.out.println(queue.peek());    System.out.println(queue);    // poll出第一个元素    System.out.println(queue.poll());    System.out.println(queue);// [轻量级JavaEE企业应用实践, 疯狂Android讲义]&#125;</code></pre><p>}</pre><pre data-language="plain" id="prXHN" class="ne-codeblock language-plain">[疯狂 Android 讲义, 轻量级 Java EE 企业应用实战, 疯狂 Java 讲义]<br>疯狂 Android 讲义<br>[疯狂 Android 讲义, 轻量级 Java EE 企业应用实战, 疯狂 Java 讲义]<br>疯狂 Android 讲义<br>[轻量级 Java EE 企业应用实战, 疯狂 Java 讲义]<br>[疯狂 Java 讲义, 轻量级 JavaEE 企业应用实践, 疯狂 Android 讲义]<br>疯狂 Java 讲义<br>[疯狂 Java 讲义, 轻量级 JavaEE 企业应用实践, 疯狂 Android 讲义]<br>疯狂 Java 讲义<br>[轻量级 JavaEE 企业应用实践, 疯狂 Android 讲义]</pre><p id="acf9f3857a7d8138cea03a0bc41e17ab" class="ne-p"><span class="ne-text">例子参考：</span><a href="https://www.cnblogs.com/jiqing9006/p/6107491.html" data-href="https://www.cnblogs.com/jiqing9006/p/6107491.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/jiqing9006/p/6107491.html</span></a></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>225/232. 队列和栈的相互实现🔖队列🔖栈</title>
      <link href="/blog/le21wf/"/>
      <url>/blog/le21wf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="a29a1b8e333ebb6218a4a850e5fe17c2" class="ne-p"><span class="ne-text">简单实现一下，熟悉一下写题目，这几天找找状态……</span><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1615278756585-fb0d9f38-8031-472f-9a19-8545be93a548.gif" width="100" id="QjErw" class="ne-image"></p><p id="ef899eed96ff8a1bcaaa60a81c23e200" class="ne-p"><br></p><p id="u880365d5" class="ne-p"><br></p><h2 id="o2VfU"><span class="ne-text">P232. 栈实现队列</span></h2><pre data-language="java" id="xxz59" class="ne-codeblock language-java">package com.wztlink1013.problems.leetcode.editor.cn;<p>// P232.用栈实现队列<br>// P232.implement-queue-using-stacks<br>//请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：<br>//<br>// 实现 MyQueue 类：<br>//<br>//<br>// void push(int x) 将元素 x 推到队列的末尾<br>// int pop() 从队列的开头移除并返回元素<br>// int peek() 返回队列开头的元素<br>// boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>//<br>//<br>//<br>//<br>// 说明：<br>//<br>//<br>// 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>//<br>// 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>//<br>//<br>//<br>//<br>// 进阶：<br>//<br>//<br>// 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。<br>//<br>//<br>//<br>//<br>// 示例：<br>//<br>//<br>//输入：<br>//[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>//[[], [1], [2], [], [], []]<br>//输出：<br>//[null, null, null, 1, 1, false]<br>//<br>//解释：<br>//MyQueue myQueue = new MyQueue();<br>//myQueue.push(1); // queue is: [1]<br>//myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)<br>//myQueue.peek(); // return 1<br>//myQueue.pop(); // return 1, queue is [2]<br>//myQueue.empty(); // return false<br>//<br>//<br>//<br>//<br>//<br>//<br>//<br>// 提示：<br>//<br>//<br>// 1 &lt;= x &lt;= 9<br>// 最多调用 100 次 push、pop、peek 和 empty<br>// 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）<br>//<br>// Related Topics 栈 设计<br>// 👍 361 👎 0</p><p>import java.util.Stack;</p><p>public class P232ImplementQueueUsingStacks{<br>public void main(String[] args) {<br>MyQueue myQueue = new MyQueue();<br>//本地调试需要将 MyQueue 类和主函数加上静态 static 修饰字<br>//具体解释：<a href="https://www.cnblogs.com/dolphin0520/p/3799052.html">https://www.cnblogs.com/dolphin0520/p/3799052.html</a><br>myQueue.push(1); // queue is: [1]<br>myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)<br>myQueue.pop();<br>myQueue.peek();<br>// myQueue.peek(); // return 1<br>// myQueue.pop(); // return 1, queue is [2]<br>// myQueue.empty(); // return false<br>// System.out.println(myQueue);<br>}</p><p>//leetcode submit region begin(Prohibit modification and deletion)<br>class MyQueue {<br>Stack<Integer> stack_input = new Stack&lt;&gt;();<br>Stack<Integer> stack_output = new Stack&lt;&gt;();<br>/*_ Initialize your data structure here. _/<br>public MyQueue() {<br>// Stack<Integer> stack_input = new Stack&lt;&gt;();<br>// Stack<Integer> stack_output = new Stack&lt;&gt;();<br>}</p><pre><code>/** Push element x to the back of queue. */public void push(int x) &#123;    stack_input.push(x);    int temp = stack_input.size();    if (stack_output.size() == 0) &#123;        for (int i=0; i&lt;temp; i++)&#123;            stack_output.push(stack_input.pop());        &#125;    &#125;&#125;/** Removes the element from in front of queue and returns that element. */public int pop() &#123;    int temp = stack_input.size();    if (stack_output.size() == 0) &#123;        for (int i=0; i&lt;temp; i++)&#123;            stack_output.push(stack_input.pop());        &#125;    &#125;    return stack_output.pop();&#125;/** Get the front element. */public int peek() &#123;    int temp = stack_input.size();    if (stack_output.size() == 0) &#123;        for (int i=0; i&lt;temp; i++)&#123;            stack_output.push(stack_input.pop());        &#125;    &#125;    return stack_output.peek();&#125;/** Returns whether the queue is empty. */public boolean empty() &#123;    if (stack_input.size() == 0 &amp;&amp; stack_output.size() == 0) &#123;        return true;    &#125;    return false;&#125;</code></pre><p>}</p><p>/**</p><ul><li>Your MyQueue object will be instantiated and called as such:</li><li>MyQueue obj = new MyQueue();</li><li>obj.push(x);</li><li>int param_2 = obj.pop();</li><li>int param_3 = obj.peek();</li><li>boolean param_4 = obj.empty();<br>*/<br>//leetcode submit region end(Prohibit modification and deletion)</li></ul><p>}</pre><h2 id="YtwL8"><span class="ne-text">P225. 队列实现栈</span></h2><pre data-language="java" id="Lphd1" class="ne-codeblock language-java">package com.wztlink1013.problems.leetcode.editor.cn;</p><p>// P225.用队列实现栈<br>// P225.implement-stack-using-queues<br>//请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。<br>//<br>// 实现 MyStack 类：<br>//<br>//<br>// void push(int x) 将元素 x 压入栈顶。<br>// int pop() 移除并返回栈顶元素。<br>// int top() 返回栈顶元素。<br>// boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。<br>//<br>//<br>//<br>//<br>// 注意：<br>//<br>//<br>// 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。<br>// 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。<br>//<br>//<br>//<br>//<br>// 示例：<br>//<br>//<br>//输入：<br>//[“MyStack”, “push”, “push”, “top”, “pop”, “empty”]<br>//[[], [1], [2], [], [], []]<br>//输出：<br>//[null, null, null, 2, 2, false]<br>//<br>//解释：<br>//MyStack myStack = new MyStack();<br>//myStack.push(1);<br>//myStack.push(2);<br>//myStack.top(); // 返回 2<br>//myStack.pop(); // 返回 2<br>//myStack.empty(); // 返回 False<br>//<br>//<br>//<br>//<br>// 提示：<br>//<br>//<br>// 1 &lt;= x &lt;= 9<br>// 最多调用 100 次 push、pop、top 和 empty<br>// 每次调用 pop 和 top 都保证栈不为空<br>//<br>//<br>//<br>//<br>// 进阶：你能否实现每种操作的均摊时间复杂度为 O(1) 的栈？换句话说，执行 n 个操作的总时间复杂度 O(n) ，尽管其中某个操作可能需要比其他操作更长的<br>//时间。你可以使用两个以上的队列。<br>// Related Topics 栈 设计<br>// 👍 291 👎 0</p><p>import java.util.LinkedList;<br>import java.util.Queue;</p><p>public class P225ImplementStackUsingQueues{<br>public void main(String[] args) {<br>// Solution solution = new P225ImplementStackUsingQueues().new Solution();</p><pre><code>&#125;</code></pre><p>//leetcode submit region begin(Prohibit modification and deletion)<br>class MyStack {<br>Queue<Integer> queue_input = new LinkedList&lt;&gt;();<br>Queue<Integer> queue_output = new LinkedList&lt;&gt;();<br>/*_ Initialize your data structure here. _/<br>public MyStack() {</p><pre><code>&#125;/** Push element x onto stack. */public void push(int x) &#123;    queue_input.add(x);&#125;/** Removes the element on top of the stack and returns that element. */public int pop() &#123;    int temp_2 = queue_input.size();    for (int i=0; i&lt;temp_2; i++) &#123;        queue_output.add(queue_input.remove());    &#125;    int temp_3 = queue_output.size();    for (int i=0; i&lt;temp_3-1; i++) &#123;        queue_input.add(queue_output.remove());    &#125;    return queue_output.remove();&#125;/** Get the top element. */public int top() &#123;    int top = 0;    int temp_4 = queue_input.size();    for (int i=0; i&lt;temp_4; i++) &#123;        queue_output.add(queue_input.remove());    &#125;    int temp_5 = queue_output.size();    for (int i=0; i&lt;temp_5; i++) &#123;        if (i == temp_5-1) &#123;            top = queue_output.element();        &#125;        queue_input.add(queue_output.remove());    &#125;    return top;&#125;/** Returns whether the stack is empty. */public boolean empty() &#123;    if (queue_input.size() == 0 &amp;&amp; queue_output.size() == 0) &#123;        return true;    &#125;    return false;&#125;</code></pre><p>}</p><p>/**</p><ul><li>Your MyStack object will be instantiated and called as such:</li><li>MyStack obj = new MyStack();</li><li>obj.push(x);</li><li>int param_2 = obj.pop();</li><li>int param_3 = obj.top();</li><li>boolean param_4 = obj.empty();<br>*/<br>//leetcode submit region end(Prohibit modification and deletion)</li></ul><p>}</pre><p id="c85ff563fe7096567c2ba4ddbe4a46f7" class="ne-p"><br></p><p id="978d3b8ea3f6378eb757293446e8714d" class="ne-p"><br></p><p id="177934f4fd8489d50ebbf77c3edd6caf" class="ne-p"><br></p><p id="955b42ad8438ffa991a6e0e0d5a36501" class="ne-p"><br></p><p id="e9d6c34d897fe5fda361fea40c76df6d" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>站点文章导航</title>
      <link href="/blog/guide_post/"/>
      <url>/blog/guide_post/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="6cdfe4959cea6bc45c926eaf91f7c335" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622192869413-b170ca0a-ff41-434d-bafb-5499b6b3636e.jpeg" width="548.0208740234375" id="ucc1528f2" class="ne-image"></p><p id="uae379227" class="ne-p" style="text-align: left"><br></p><div data-type="info" class="ne-alert"><p id="u41739b00" class="ne-p" style="text-align: left"><span class="ne-text">建站初衷就是从大学伊始做一些文字记录，站点所有文章大类分两类：『技术』和『随笔』，具体的文章整理我是依据文章分类来划分的，下面内容会详述之。所有文章都可能二次修改，比如更新，增加，删除内容等。</span></p></div><div data-type="success" class="ne-alert"><p id="ud8f33ce6" class="ne-p" style="text-align: left"><span class="ne-text">✨欢迎交流！</span></p></div><p id="u9cdf2cd2" class="ne-p"><br></p><h2 id="VSZJe"><span class="ne-text">一、技术博客</span></h2><ul class="ne-ul"><li id="uf46548f2"><a href="https://www.wztlink1013.com/blog/" data-href="https://www.wztlink1013.com/blog/" target="_blank" class="ne-link"><span class="ne-text">https://www.wztlink1013.com/blog/</span></a></li></ul><div data-type="warning" class="ne-alert"><p id="u8bfde5e4" class="ne-p"><span class="ne-text">对技术的分类比较细，是因为想让自己的CS知识体系在不断的学习过程中不断完善精进。</span></p></div><div data-type="danger" class="ne-alert"><p id="u943c4661" class="ne-p"><span class="ne-text">注意：部分文章为个人知识学习笔记，其排版抑或是内容可能不会完整，个人笔记方式为搭建知识框架，其内容不一定全部书写记录。</span></p></div><h2 id="OfZVe"><span class="ne-text">二、生活随笔</span></h2><ul class="ne-ul"><li id="u3fb46cb5"><a href="https://www.wztlink1013.com/essay/" data-href="https://www.wztlink1013.com/essay/" target="_blank" class="ne-link"><span class="ne-text">https://www.wztlink1013.com/essay/</span></a></li></ul><div data-type="warning" class="ne-alert"><p id="udefa7e92" class="ne-p"><span class="ne-text">生活随笔的分类并没有上面技术博客那么细致，是因为我大多数是随心随性写随笔，不想太拘束于文本的框架。</span></p></div><p id="72f32932d12fc37d4a370a5545a0267f" class="ne-p"><br></p><div class="ne-quote"><p id="c2bd7f441d2171f23cd2dbe056ddb57c" class="ne-p"><span class="ne-text">另外，如果你想了解博主，可以前往以下页面查看~</span></p><p id="u4cfcd8cb" class="ne-p"><span class="ne-text">『</span><a href="https://www.wztlink1013.com/about/" data-href="https://www.wztlink1013.com/about/" target="_blank" class="ne-link"><span class="ne-text">https://www.wztlink1013.com/about/</span></a><span class="ne-text">』</span></p></div><p id="71826c00f1635a70634851fc1b33cc1e" class="ne-p"><br></p><p id="a3a3c0235c39bfb106adb1f8780cea16" class="ne-p"><br></p><p id="d86efc1483debdd3fb60eab03826c650" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA公钥密码算法</title>
      <link href="/blog/ccd10c/"/>
      <url>/blog/ccd10c/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><p id="1361ac60683f4eb70b67453160b38ffb" class="ne-p"><span class="ne-text">最近利用自己曾经写过的一篇文章『</span><a href="https://www.wztlink1013.com/blog/bw80k6/" data-href="https://www.wztlink1013.com/blog/bw80k6/" target="_blank" class="ne-link"><span class="ne-text">https://www.wztlink1013.com/blog/bw80k6/</span></a><span class="ne-text">』（利用一次抓包来复习学习过的计网知识）</span></p></div><p id="12f629a7bde08826aa213fbf1f470fd0" class="ne-p"><br></p><p id="e6f62102d4830f4e633a1f91f8184228" class="ne-p"><span class="ne-text">前言：在分析HTTPS和HTTP这两个协议之间的区别的时候，我感觉HTTPS的SSL(Secure Sockets Layer 安全套接字协议)证书很类似之前老师讲过的RSA算法，做此篇文章复习下RSA算法和加深HTTPS的理解。</span></p><p id="f0a10b85ff0e50d2f4d8727451589e45" class="ne-p"><br></p><p id="6ea55680c18e8a51b28317e8cfb2eeab" class="ne-p"><span class="ne-text">在密码学当中，由对称密钥和非对称密钥之分。</span></p><p id="u4665cf23" class="ne-p"><span class="ne-text"></span></p><h2 id="YrgFk"><span class="ne-text">对称密钥</span></h2><p id="f8843ff5e287cfc067fcc2e3cb10feee" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612943343546-b8330998-9019-40a1-9759-12b459d5379b.png" width="491" id="rvUuR" class="ne-image"></p><p id="0253454387d002137ebad0e59b33b2dd" class="ne-p"><span class="ne-text">用一个简单的凯撒密码例子来讲解一下对称密钥：</span></p><p id="dc29144aad9a00526749aabb1736e11b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612943823633-5283daed-a125-46fd-a785-93851daf5269.png" width="478.5" id="g4j6n" class="ne-image"></p><p id="8782cf33b87bc57ee69803d5ff8be64a" class="ne-p"><span class="ne-text">上图是凯撒密码的定义，先说一下怎么用：</span></p><p id="7d0edaf4b7aecb5b3ca582cd4e6c54cd" class="ne-p"><br></p><p id="69615f37631954ed545f7ea9221e7516" class="ne-p"><span class="ne-text">假如张三和李四两个人之间需要传输一段密码apple，他们之间共同约定使用密钥-3（再上图表示就为e字母编程b字母了，以此类推），而这个算法是基于</span><a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E9%99%A4" data-href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E9%99%A4" target="_blank" class="ne-link"><span class="ne-text">mod运算</span></a><span class="ne-text">（在这里看成是一种加密/解密机制）的。</span></p><p id="1b4a2b23c390a92cdc1554605a9767d2" class="ne-p"><br></p><p id="c8f51bd99b13e7fc6580b62a4e6c9e72" class="ne-p"><span class="ne-text">张三利用mod运算加密机制（mod运算）将apple转换位xmmfb</span></p><p id="e0000b51e016347fa172d5c63020f986" class="ne-p"><span class="ne-text">李四利用mod运算解密机制（mod运算）将xmmfb转换位apple</span></p><p id="5073e25392e5c848891f287eb64d7814" class="ne-p"><br></p><div class="ne-quote"><p id="c13de66d78c8a604676a5ad0ae9b9bd8" class="ne-p"><span class="ne-text">a为什么到x：（0-3）mod26可以看成（23-26）mod26=23，所以a往后退三位还是x</span></p></div><p id="ecde1210f865a4584d48be7b1302be0e" class="ne-p"><span class="ne-text">上述例子的加密机制和解密机制算法一样（mod运算），实际上也可以不一样，不做详述。但是可以说名对称加密的密钥都一样，该例子中表现为-3</span></p><p id="2909d93dbe7bd2f9afc48e7fcdc0f8f1" class="ne-p"><br></p><h2 id="n5gMm"><span class="ne-text">RSA公钥密码算法</span></h2><p id="74861a7195564ccaef58a46d61cd18f6" class="ne-p"><span class="ne-text">RSA公钥密码算法是非对称加密。</span></p><p id="fed6a505df0d0be6454dcdaa8d2ae556" class="ne-p"><br></p><p id="f0e137f855d14f9ef1af860a29c2a479" class="ne-p"><span class="ne-text">先说一下和上面的对称密钥的不同，很简单，不同之处就是对称密钥只有一个密钥，而非对称密钥有两个（我觉得严谨来说可以有多个，但在这里先局限地说有两个），而且一个叫公钥，一个叫密钥。</span></p><p id="51b6876de43586349e6b79e5fb738ce9" class="ne-p"><br></p><p id="c0112ecb1b92f214b202e28eb89dcb58" class="ne-p"><span class="ne-text">还是上面的张三李四例子，就相当于张三这次用公钥来加密apple这个单词，加密成一段密文，这段密文</span><strong><span class="ne-text">只能由密钥来解密</span></strong><span class="ne-text">，即便是你有了公钥，也不能将其解密。</span></p><p id="dca5320b6a290dce7be5a1d91c22d727" class="ne-p"><br></p><p id="39123083f61d0fadc3b489a2ad6936f9" class="ne-p"><span class="ne-text">然后来抛出几个问题来分析之：</span></p><p id="0e3ea83e5ac90a208a407f4fdf5a71a4" class="ne-p"><br></p><div class="ne-quote"><p id="c51b3fc104abbfbb81668de279ad0bb0" class="ne-p"><span class="ne-text">【Q1】公钥和密钥怎么来规定呢？我要是一个网络攻击者，我利用公钥来推理出密钥，那我岂不是直接解密了？！</span></p></div><p id="80ba919176ce9e46abe9a5d84a74c831" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945567958-1cd39a87-ba61-4dd8-955e-1a4fc130378d.png" width="237" id="WyGPZ" class="ne-image"></p><p id="07935626abdfc2478c0253eb7b878bdb" class="ne-p"><span class="ne-text">具体的相关mod运算在此不做详述</span></p><p id="a7f586f83fa0b771a6cfe81d536ec0fa" class="ne-p"><br></p><div class="ne-quote"><p id="2b8bf37984341886a7547465fc06d5fb" class="ne-p"><span class="ne-text">【Q2】算法可靠与否</span></p></div><p id="247e0b16e3d47a9222e60a1d70b214a2" class="ne-p"><span class="ne-text">为了保证严谨，同时也证明了这种算法的</span></p><ul class="ne-ul"><li id="76ab6859bb1a650c7bf530e1bfd01468"><span class="ne-text">可行性，所计算出来的算法复杂度最高是4次方，对计算机而言，可计算</span></li><li id="1f60f8619bb765e108cfe23d06aad01b"><span class="ne-text">不可攻破，在学界，大数因子分解不可行，或者说，如今的科技还不能轻易的破解</span></li></ul><p id="c200e268cf270e2c75385c57d177fd8e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945767363-ee62dad7-357d-42d3-a932-78cc10d29866.png" width="492.5" id="jZ5AI" class="ne-image"></p><p id="6d27d977f5d2a5274128284457747b67" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945781929-bea0946c-3f24-472d-a4d4-3c40abd83ee3.png" width="493.5" id="gpoCJ" class="ne-image"></p><p id="06af2cbce95bd37f0c5fb45adc7dadeb" class="ne-p"><br></p><p id="69f63303f8273a258c7a5bd5f5263c30" class="ne-p"><br></p><p id="a7d9f4d3b0cbb47eefac08194e29d7b8" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> RSA算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS较HTTP安全在哪？</title>
      <link href="/blog/pl8gro/"/>
      <url>/blog/pl8gro/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ef44f44e02f83438b51c1e60da737802" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612949716697-1ceb6a5c-fa5e-4129-9c0a-63e01ce75057.png" width="564" id="VgkSz" class="ne-image"></p><h2 id="nbD9e"><span class="ne-text">HTTPS的精妙之处</span></h2><p id="1b2cc6e57561a893317018494b067755" class="ne-p"><span class="ne-text">在我写的算法相关文章里面，有一篇RSA相关的文章</span><a href="https://www.yuque.com/wztlink1013/blog/ccd10c" data-href="https://www.yuque.com/wztlink1013/blog/ccd10c" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/blog/ccd10c</span></a><span class="ne-text">，里面解释了对称加密和的非对称加密</span></p><p id="fca7d676a2041b66a43f19be381c59f0" class="ne-p"><br></p><p id="3dda5208b6006b366bc9df58f5eb0e1b" class="ne-p"><span class="ne-text">我觉得HTTPS的精妙之处就是在于它同时运用了</span><strong><span class="ne-text">对称加密（AES）</span></strong><span class="ne-text">和</span><strong><span class="ne-text">非对称加密（RSA）</span></strong><span class="ne-text">两种加密，下面我解释一下：</span></p><p id="04e746d4f38ba2204dc437f3b5ee4a5d" class="ne-p"><br></p><h2 id="DZDTA"><span class="ne-text">HTTP为何不安全？</span></h2><p id="8b2dbe2c550f978dfb29652f2d297b01" class="ne-p"><span class="ne-text">客户端对服务端做出请求，然后服务端做出响应，这个大家都知道，但是HTTP是明文传输，我在</span><a href="https://www.yuque.com/wztlink1013/blog/bw80k6/" data-href="https://www.yuque.com/wztlink1013/blog/bw80k6/" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/blog/bw80k6/</span></a><span class="ne-text">这篇文章里面也详细抓包展示了HTTP的明文传输</span></p><p id="c3332cf857ffd6689b1db7cd518c0f52" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612946821326-d568e02e-1173-4af4-93c5-539275023ba3.png" width="772" id="rZuDh" class="ne-image"></p><p id="46ca81dc18fe96e1631b9c7b97b77295" class="ne-p"><span class="ne-text">这样传输的信息就不安全，</span><span class="ne-text">攻击者就能轻易得到，进一步讲，得到了就不安全吗？</span></p><ul class="ne-ul"><li id="e15cee96579d1486429a3621d6807ba1"><span class="ne-text">因为假如此时服务端响应给客户端的是很重要的诸如密码或者个人信息之类的敏感信息，就会被窃听</span></li><li id="c411fc4875eac717e794ef868e487e35"><span class="ne-text">中途截取，将所传输的信息不完整等等</span></li></ul><h2 id="ueEPX"><span class="ne-text">HTTPS安全在哪？精妙之处！</span></h2><p id="17fa4cd519be4730f49e54e40240ca73" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612947167321-69c11c8d-9f8d-4f78-80a9-b2ee1c02e6b8.png" width="496" id="m1HhZ" class="ne-image"></p><p id="2ac687b6be968c414849fd62f7225f41" class="ne-p"><span class="ne-text">由上图所示，HTTPS的协议栈相较HTTP协议栈多了安全层，也就是SSL(安全套接层)或者TSL(安全传输层)协议</span></p><p id="495928fc11abdbb78b4fc323b28606d5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651901470392-70830d5a-2402-4dd5-90d2-f1f52004da65.png" width="436.015625" id="u6c39ea43" class="ne-image"></p><ol class="ne-ol"><li id="146220d0b0bcc0e2440ea73c4e443935"><span class="ne-text">客户端向服务端发出一个https请求，其中端口位443</span></li></ol><div class="ne-quote"><p id="f7bc1600a71b76bbc0ed2da6dd723479" class="ne-p"><span class="ne-text">说明：采用https的网站都会有相应的ssl证书，在服务器那里，这个证书内容就是颁发的机构、到期时间……，而这个证书的形式就是以公钥的形式存在于服务器的。</span></p></div><ol start="2" class="ne-ol"><li id="3a7fc489e47e11ae95816e3e18b54ad2"><span class="ne-text">服务端响应给客户端这个证书（公钥的形式）</span></li><li id="34fd67235c159a89145b2fdf352389e7"><span class="ne-text">客户端解析响应来的公钥，因为需要验证这个ssl是不是伪造的还是过期了等等，假如验证不成功，就会如下：</span></li></ol><p id="5917ab143fdd8845150c324469c3754e" class="ne-p" style="text-indent: 2em"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612948950125-219e56dd-b6cd-4245-8aa5-44ad8e6e381c.png" width="302.5" id="orB4W" class="ne-image"></p><ol start="4" class="ne-ol"><li id="7a7a7031f934d2224627928938e2a58f"><span class="ne-text">然后客户端（浏览器）利用这个公钥随机得出的私钥，然后将这个私钥发给服务端，以后客户端和服务端就可以利用这个密钥来解密双方传来传去的加密信息了</span></li></ol><div class="ne-quote"><p id="80643695a94aaccb1ae4649ca85f582c" class="ne-p"><span class="ne-text">说明：随机的出的私钥并不是那么“随机”，因为要保证不可攻破性，具体可以看我的RSA算法相关文章</span></p></div><hr id="xRZXg" class="ne-hr"><ol start="5" class="ne-ol"><li id="0119dd35a254fac92a480d631d6e31b4"><span class="ne-text">服务端将要展示给客户端的具体信息利用上述私钥来加密</span></li><li id="1eab2922dcf081d630dc21591f689100"><span class="ne-text">客户端接收到服务端发过来的加密信息，用共同都有的私钥解密查看之</span></li></ol><div class="ne-quote"><p id="779b869a4738d08bea8e3a00693656af" class="ne-p"><span class="ne-text">整个过程对外人而言看到的都是加密后的信息，而不是明文</span></p></div><p id="a30deaf8ed626553f4d5259efac2ae2f" class="ne-p"><br></p><p id="9a2f0d53f6fdc898bd4a23c1c6a6fb06" class="ne-p"><span class="ne-text">综上，56条是采用了AES对称加密，而前面是利用RSA算法得到私钥</span></p><h2 id="05Oaf"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="bb90bf4c12e98aa4e84667fc6ebdfa18"><span class="ne-text">这位博主（</span><span class="ne-text" style="color: #555555; font-size: 16px">数据中心网络工程师</span><span class="ne-text">）将SSL讲解的更加细致，可以常看：</span><a href="https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/" data-href="https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/" target="_blank" class="ne-link"><span class="ne-text">SSL/TLS协议详解</span></a></li></ul><p id="1ff4d3d0b158c3a218a8dcfa09409d63" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于CDN的一些概念</title>
      <link href="/blog/fxzcy3/"/>
      <url>/blog/fxzcy3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="xlZLV"><span class="ne-text">CDN回源</span></h2><p id="8147a44fca09bde09c02881a9e4a1a5e" class="ne-p" style="text-indent: 2em"><span class="ne-text">cdn回源是什么意思？CDN回源包括回源地址和加速</span><a href="https://www.west.cn/services/domain/" data-href="https://www.west.cn/services/domain/" target="_blank" class="ne-link"><span class="ne-text">域名</span></a><span class="ne-text">。常规的CDN都是回源的。即：当有用户访问某一个URL的时候，如果被解析到的那个CDN节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。如果没有人访问，那么CDN节点不会主动去源站拿的。</span></p><p id="df3d30da288ba66e5421c2de49ba544c" class="ne-p" style="text-indent: 2em"><span class="ne-text">回源地址：可以使回源域名，也可以是回源IP，主要作用是CDN加速节点同步更新的一个地址；</span></p><p id="f887357ea519facb15d65e85522e4f4a" class="ne-p" style="text-indent: 2em"><span class="ne-text">加速域名：使用CDN</span><a href="https://www.west.cn/cloudhost/" data-href="https://www.west.cn/cloudhost/" target="_blank" class="ne-link"><span class="ne-text">服务器</span></a><span class="ne-text">需要加速的一个域名，一般会将加速域名做别名解析为CDN运营商提供的域名，来做CDN加速访问。</span></p><p id="e4ad4f76e9862f7c014be679163f923c" class="ne-p"><a href="https://www.west.cn/docs/wp-content/uploads/2018/05/n-40.jpg" target="_blank" id="YP5GO" class="ne-image-link"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1612941062375-753094ca-dc39-494d-abaf-022708a631a3.jpeg" width="581" class="ne-image"></a></p><p id="f7c0ae2f7d8a5fc7accc3f59767fdd1f" class="ne-p"><span class="ne-text">回源域名一般是cdn领域的专业术语，通常情况下，是直接用ip进行回源的，但是如果客户源站有多个ip，并且ip地址会经常变化，对于cdn厂商来说，为了避免经常更改配置（回源ip），会采用回源域名方式进行回源，这样即使源站的ip变化了，也不影响原有的配置。</span></p><p id="a1694293675c8addd427bbbd8335c381" class="ne-p"><span class="ne-text">CDN本来是给网站加速的，但是有时会因为不合适的回源策略给服务器带来负担，只有选择正确的策略才能给自己的网站带来更高的访问效率。</span></p><h2 id="7wDA9"><span class="ne-text">网站优化</span></h2><h3 id="Ubg6y"><span class="ne-text">Gzip智能压缩</span></h3><p id="7c9bb2201a947bd86254630fa6addae7" class="ne-p"><span class="ne-text" style="color: #121212">gzip是GNUzip的缩写，最早用于UNIX系统的文件压缩</span></p><p id="8c09cd046b5ff4dc7da82b45d1fdd90e" class="ne-p"><span class="ne-text" style="color: #121212"></span></p><p id="61809721e669f5ea235636ee92be6f5b" class="ne-p"><span class="ne-text" style="color: #121212">HTTP协议上的gzip编码是一种用来改进web应用程序性能的技术，web服务器和客户端（浏览器）必须共同支持gzip</span></p><p id="750bf35fb9c8308bb9a206b4bd7dd707" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612939525023-772b71d1-11ea-4f13-8629-500d71865e16.png" width="545.5" id="l3xba" class="ne-image" style="color: #121212"></p><h3 id="GDGzg"><span class="ne-text">Brotli智能压缩</span></h3><p id="6e26adf45fc4e624dc1405056096cb66" class="ne-p"><span class="ne-text">也是一种静态资源压缩算法，并且也支持HTTPS</span></p><h3 id="q5q0o"><span class="ne-text">页面压缩</span></h3><p id="70523bee88418a138db5cb3d37e4024e" class="ne-p"><span class="ne-text">去除掉页面的注释或空格提高传输效率</span></p><h3 id="9w5Jh"><span class="ne-text">302调度</span></h3><p id="b3547cf5b8a9c590c713f6b57548489b" class="ne-p"><a href="https://cloud.tencent.com/developer/article/1445728" data-href="https://cloud.tencent.com/developer/article/1445728" target="_blank" class="ne-link"><span class="ne-text">CDN系列学习文章（三）——302调度</span></a></p><p id="c9cb1ade36b8107051bae0d28240f11d" class="ne-p"><br></p><p id="6941b6b7a0204626b2a326d0ad41802b" class="ne-p"><span class="ne-text">作者：深蓝加菲</span></p><p id="5bd143e7b27c49eda394f7555cedb0f0" class="ne-p"><span class="ne-text">链接：</span><a href="https://www.zhihu.com/question/32148047/answer/70920110" data-href="https://www.zhihu.com/question/32148047/answer/70920110" target="_blank" class="ne-link"><span class="ne-text">https://www.zhihu.com/question/32148047/answer/70920110</span></a></p><p id="bfa1566da694ef475a631cd2598b60bc" class="ne-p"><span class="ne-text">来源：知乎</span></p><p id="c92cab146699c2df5ea88d3e06861438" class="ne-p"><span class="ne-text">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></p><p id="a8281bee7ae2b52b851e477eaa32cf96" class="ne-p"><br></p><p id="cf26933da576dbb1eba35c829f32e15c" class="ne-p"><span class="ne-text">一般是两者结合，DNS做省市级别和跨运营商的调度， 302做基于内容和精确IP的精确调度</span></p><p id="fb0e0da0e3970b343d165b23e095e412" class="ne-p"><span class="ne-text">DNS的优点：</span></p><p id="d0b49b103e5f250e6a4bec72eae41d7e" class="ne-p"><span class="ne-text">DNS系统是天然的分布式结构</span></p><p id="b83a034b7310f32d30140c28ee3fa30b" class="ne-p"><span class="ne-text">客户端本机，LDNS都可以实现cache，</span><strong><span class="ne-text">架构本身就能实现高的伸缩性和性能</span></strong></p><p id="2586f057c40a0bd7abbac121d52fe068" class="ne-p"><span class="ne-text">---------------------------------------------------------</span></p><p id="ba693bbcb4b7216e40dbb2eeac28994a" class="ne-p"><span class="ne-text">DNS的缺点：</span></p><p id="2afde6a094044f4aaccef5c0605dd1c9" class="ne-p"><span class="ne-text">DNS并不是为GSLB设计的</span></p><p id="4f40287c6dbbd10959137b825b4ca1ec" class="ne-p"><span class="ne-text">GSLB 基于 local DNS的地址判断，</span><strong><span class="ne-text">粒度较粗</span></strong><span class="ne-text">。而且LDNS可能和end user网络距离很远。</span></p><p id="808be923fa1dfdb78812b4f98e078aeb" class="ne-p"><span class="ne-text">用户可能会设置错误的Local DNS，该服务器和用户实际距离较远，比如8.8.8.8等(edns-client-subnet可以部分解决该问题)</span></p><p id="905db8f74bc30c9b5fef1b8e39bc768e" class="ne-p"><span class="ne-text">DNS请求里面</span><strong><span class="ne-text">不会带有内容信息</span></strong><span class="ne-text">，GSLB只能拥有LDNS ip信息，无法针对内容作出更加灵活的判断</span></p><p id="8f50b8be270d59a468c3ec6211309502" class="ne-p"><span class="ne-text">因为DNS reply TTL，所以某个用户一段时间内的请求都会导向同一个site (解决：趋向于较短的TTL) </span></p><p id="a3de8afbfd0e83eeb65fbc0f14646c6c" class="ne-p"><span class="ne-text">因为local dns缓存和TTL的存在，你很难判断某次的返回会对负载有多大影响</span></p><p id="b90a5cd8a8edb7a3df0c934854817480" class="ne-p"><span class="ne-text">某些Local DNS会忽略DNS TTL信息，而采用固定的TTL时间，对此我们无能为力</span></p><p id="1cf01151d692257ffd9a946029e4b7e2" class="ne-p"><span class="ne-text">电信系统倾向于直接使用ip地址访问，不使用域名</span></p><p id="ba0552461696b82cf73b73a1e0fe4c86" class="ne-p"><span class="ne-text">---------------------------------------------------------</span></p><p id="d763e5bff7ef8971cdaf3872c1970a3d" class="ne-p"><span class="ne-text">302的优点：</span></p><p id="f98286666e0a731230bfb6f431b6f40f" class="ne-p"><span class="ne-text">可以直接得到end user ip和内容的地址，可以</span><strong><span class="ne-text">做出精确的redirect</span></strong></p><p id="606abac10ad4266cd78798880aa13184" class="ne-p"><span class="ne-text">每个请求都需要访问GSLB,可以做出单独的处理</span></p><p id="fc7abb017f2c035fbdd1d57eae77dee7" class="ne-p"><span class="ne-text">可以在一个点方便的作出统计和认证</span></p><p id="e109ce7deb66847d7fd65745ca76a6b7" class="ne-p"><span class="ne-text">---------------------------------------------------------</span></p><p id="3045bd660fa83e43212a891d669cf4d3" class="ne-p"><span class="ne-text">302的缺点：</span></p><p id="8c9b3af29d6721b73477a4f77215503e" class="ne-p"><span class="ne-text">需要应用层协议支持(http / rtsp)</span></p><p id="0121d9e5215eb45a43d19857d5c823eb" class="ne-p"><span class="ne-text">一般有重定向次数限制</span></p><p id="7fea09c798deac6017f299ef161346e1" class="ne-p"><span class="ne-text">GSLB需要处理较多的请求，却没有LDNS作为cache</span></p><p id="474e649138cf8c6a1278cf134882100e" class="ne-p"><span class="ne-text">GSLB暴露给end user ， 容易遭受攻击</span></p><p id="b2777f5e0342b77e9da69dc14ebe60a7" class="ne-p"><span class="ne-text">用户访问GSLB本身就会带来时延，可能深圳的用户需要访问北京的GSLB</span></p><p id="d86afd889f24785f359500623fc2af61" class="ne-p"><span class="ne-text">单点故障(可以通过GSLB服务群集解决)</span></p><p id="eaea7a0c6c9b41d669ef7f0a154f1618" class="ne-p"><span class="ne-text">某些应用对URL变化敏感，比如WEB</span></p><p id="3e3362b77e87f0fabcc20d9ec12fc727" class="ne-p"><span class="ne-text">某些客户端支持不好(中文字符集等问题)</span></p><h3 id="gK3Zg"><span class="ne-text">TLS1.3</span></h3><p id="b6fb70efc58af69baf04ab89bbc3b72e" class="ne-p"><span class="ne-text">TLS 1.3 是一种全新的加密协议，它既能提高终端用户的访问速度，又能增强安全性</span></p><p id="373bd96eee79913463315d2257b944f0" class="ne-p"><br></p><div id="0dxvR" class="ne-bookmark"><a href="https://zhuanlan.zhihu.com/p/44980381" target="_blank">TLS1.3 VS TLS1.2，让你明白TLS1.3的强大</a></div><h3 id="nQNaE"><span class="ne-text">HTTP/2 + Server Push</span></h3><div id="RLYjg" class="ne-bookmark"><a href="https://www.ruanyifeng.com/blog/2018/03/http2_server_push.html" target="_blank">HTTP/2 服务器推送（Server Push）教程</a></div><h3 id="7fZkP"><span class="ne-text">WebP 自适应</span></h3><p id="f2ed59db935ef176eb39c41b4a558f42" class="ne-p"><span class="ne-text">WebP 自适应功能是 CDN 平台智能判断客户端浏览器是否支持 WebP 解码，如支持则返回 WebP 格式图片，否则返回原图，客户端以及源站无需任何改动。开启该特性，可以有效节省 CDN 传输带宽，加速图片渲染速度。</span></p><p id="b75cf7af42d73f151d4527a77372a282" class="ne-p"><br></p><h2 id="TJ0xN"><span class="ne-text">网站防攻击</span></h2><h3 id="RhH3k"><span class="ne-text">IP限制访问</span></h3><h3 id="mJNT8"><span class="ne-text">CC防护</span></h3></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web其他知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『Re：从零开始的异世界生活』</title>
      <link href="/essay/ghnpqy/"/>
      <url>/essay/ghnpqy/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-traditional" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B9%2C0%2C0%2C0%5D%2C%5B9%2C0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="f82967bdc4f33d74704b90cc17462368" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">“我可是经历过死亡的人！”</p></blockquote><p data-lake-id="9582e6df9c987b482d5ae48d02c1207a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">第一次听到486说这句话的时候，我是有很大的感触的，甚至是共鸣，因为，见过地狱的人啊……被历史所记载下来的人，总有异于常人的行为准则。</p><p data-lake-id="93f88d7b67a29f6e5043166a785be1a7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="748c5d0ccf51ff03bb7ffb8ae680b705" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">希特勒，大三寒假在家那会在家看了郭伟强作者译作的《希特勒》一书，以前，我觉得我或多或少了解那个恶魔，因为二战，我觉得这人应该是人们脑海中残酷战争的人形代表吧。或在少年时期，一个人的精神和心智都是极其可变的……</p><p data-lake-id="ea13745d49ec3d0d175d5512c05a82d1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="623c379379a9be6c5b0afa3cafaede57" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">如果把思维换一下来思考，如果，我明天就死了，那么现在的我会做出什么样的行为呢？因为懂得地狱的可怕，那可怕来自心里面的恐惧、来自亲人爱人的离去、来自一切想要去守护的人的离去……</p><p data-lake-id="3f708d4e7760af998e9917ebb5f534fb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="4a036f0e7c834ee8e8133f7fb45ddfb5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">见过地狱的人啊。</p><p data-lake-id="28bca212f0929138b04e3bb7b9562f15" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="2ad95152849478bfedeb874ea2d3c77e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">如果真爱有颜色，那么一定是蓝色</p></blockquote><p data-lake-id="9ed6dea072e29351ce02dd1b1a0799b5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『进击的巨人』是信仰</title>
      <link href="/essay/ebg1s8/"/>
      <url>/essay/ebg1s8/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B1%2C0%2C6%5D%2C%5B1%2C0%2C6%5D%5D%2C%22active%22%3Atrue%7D"><div data-card-type="block" data-lake-card="hr" id="1hlOB"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="839fa5a74076a91fd8a9efafff6083df" id="839fa5a74076a91fd8a9efafff6083df" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>21.05更</span></p><p data-lake-id="5097b817a0f098f248b241986ed021cd" id="5097b817a0f098f248b241986ed021cd" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="b602fce0790b25ea19dfb9d2b3dc357a" id="b602fce0790b25ea19dfb9d2b3dc357a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span style="text-decoration: line-through;"><span>海的那边，是自由。</span></span></p><p data-lake-id="ea8283829c3eb468b290fd73e112a5ff" id="ea8283829c3eb468b290fd73e112a5ff" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="899f17bd9c2b0a163e7903c1fb2a3ae1" id="899f17bd9c2b0a163e7903c1fb2a3ae1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>海的那边，是杀千刀的jsc</span><span data-card-type="inline" data-lake-card="image" id="uLVJZ"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623928492929-ffc048a0-5a85-4f9c-81d6-c71ceda450b5.jpeg" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="75px" style="visibility: visible; width: 75px;"></span></p><p data-lake-id="u0e3d2f1f" id="u0e3d2f1f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ua85c884d" id="ua85c884d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u4fee72c6" id="u4fee72c6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="oqhQI"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623928497065-1e541eba-d224-4125-acee-eb249a83bb3b.jpeg" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="50px" style="visibility: visible; width: 50px;"></span></p><p data-lake-id="1c0798c40473c4568795382dab34c1b6" id="1c0798c40473c4568795382dab34c1b6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="i1e7M"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>兵长永远是最强的……</span></p><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="a7f15d06ca2c0995d66a7da1b165d31d" id="a7f15d06ca2c0995d66a7da1b165d31d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>你刚才玩的挺开心啊~ </span></p></blockquote><p data-lake-id="9289e6820487cb3409cda6b787257264" id="9289e6820487cb3409cda6b787257264" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u0a7b4f25" id="u0a7b4f25" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="u0d61af7a" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619319047360-440f4560-ea7d-4751-822c-0451f0fa40f0.jpeg" data-raw-src="" class="image lake-drag-image" alt="011.jpg" title="011.jpg" data-height="814px" style="visibility: visible; width: 1100px;"></span></p><p data-lake-id="u4b9307cc" id="u4b9307cc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="27142e226e7527b83e8ddfcece1c2609" id="27142e226e7527b83e8ddfcece1c2609" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="GvVBt" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482927278-c7d820d9-9797-45ff-89a6-3fc5b4a10304.png" data-raw-src="" class="image lake-drag-image" alt="04.png" title="04.png" data-height="1080px" style="visibility: visible; width: 1920px;"></span></p><p data-lake-id="fd087ac5a1d6d2d8ba543b8f88885c02" id="fd087ac5a1d6d2d8ba543b8f88885c02" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="LStyO" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482904818-7bc6ef93-00d8-4fc1-ac3b-75338fb25a41.png" data-raw-src="" class="image lake-drag-image" alt="Snipaste_2020-12-21_11-03-35.png" title="Snipaste_2020-12-21_11-03-35.png" data-height="1080px" style="visibility: visible; width: 1920px;"></span></p><p data-lake-id="2a043388ce9bc1b8ca2fc03e7a60384f" id="2a043388ce9bc1b8ca2fc03e7a60384f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="ExxI6" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482905865-3e7b798f-1888-4ecc-86fd-8200bc78b73b.png" data-raw-src="" class="image lake-drag-image" alt="Snipaste_2021-01-18_12-39-58.png" title="Snipaste_2021-01-18_12-39-58.png" data-height="1080px" style="visibility: visible; width: 1920px;"></span></p><p data-lake-id="udff024df" id="udff024df" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="d19b4a6ad39c6f287df567df62781f89" id="d19b4a6ad39c6f287df567df62781f89" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="W3TmY" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482909799-aec5bedb-ce37-4f2c-959a-b15c3bd34e8f.png" data-raw-src="" class="image lake-drag-image" alt="ZE5}I@{~]L4$KBF{[@DYK3Q(1).png" title="ZE5}I@{~]L4$KBF{[@DYK3Q(1).png" data-height="1080px" style="visibility: visible; width: 1920px;"></span></p><p data-lake-id="u3c1697cb" id="u3c1697cb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u07da6580" id="u07da6580" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ucbeaa1fe" id="ucbeaa1fe" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="7d22db10ae09c5cbd7d4f68c1097bab9" id="7d22db10ae09c5cbd7d4f68c1097bab9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NPM包的发布、调试、使用</title>
      <link href="/blog/auczes/"/>
      <url>/blog/auczes/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uecac80f3" class="ne-p"><span class="ne-text">介绍Node.js的包管理工具NPM的使用，同时介绍两种调试包的方式。</span></p><h2 id="9Vx2M"><span class="ne-text">注册一个包</span></h2><ul class="ne-ul"><li id="u4e482340"><span class="ne-text"></span><a href="https://www.npmjs.com/" data-href="https://www.npmjs.com/" target="_blank" class="ne-link"><span class="ne-text">https://www.npmjs.com/</span></a><span class="ne-text">注册的用户账号</span></li></ul><p id="7b67f700fc2618c4889c569f03571a45" class="ne-p"><span class="ne-text">新建一个文件夹</span><code class="ne-code"><span class="ne-text">npm-wzutao</span></code><span class="ne-text">再此文件夹下进入bash</span></p><h3 id="elCKh"><span class="ne-text">npm login</span></h3><p id="uc8c7b1a6" class="ne-p"><span class="ne-text">登录自己的npm账号，所发布的包在该账号下。</span></p><p id="75c981f231fa9b50abcdd5eef37d4c4f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612782412366-aeecc92e-a5e0-4f3d-9172-c607a5c06199.png" width="441" id="eG8zD" class="ne-image"></p><h3 id="B8iD4"><span class="ne-text">npm init</span></h3><p id="u7921e441" class="ne-p"><span class="ne-text">初始化该包</span></p><div class="ne-quote"><p id="uaa29513c" class="ne-p"><span class="ne-text">也可以快速创建 </span><code class="ne-code"><span class="ne-text">npm init -y</span></code></p></div><p id="032261ab2267b7c64df525e1d6e2d3c8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612782805229-e691af8b-0440-4fdb-baa6-63f5089017bb.png" width="421.5" id="QpvJz" class="ne-image"></p><p id="a7c376cf9eb4f7346c5981827ee5eedc" class="ne-p"><span class="ne-text">然后在该文件夹下新建index.js文件，写入如下测试代码</span></p><pre data-language="javascript" id="hJo27" class="ne-codeblock language-javascript">exports.sum = function() {<pre><code>var res = 0;for (var i=0; i&lt;arguments.length; i++) &#123;    res+=arguments[i];&#125;return res;</code></pre><p>}</pre><h2 id="e92rp"><span class="ne-text">发布包</span></h2><h3 id="vlmJW"><span class="ne-text">npm publish</span></h3><p id="ef1594fce6927ef0a6c3fe35e331be5a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612782959102-a6d78720-76a0-472a-b0d9-430c83ce7c8b.png" width="380.5" id="JUrwH" class="ne-image"></p><p id="517f6963d46ea21049e4ad7f6edda445" class="ne-p"><span class="ne-text">去官网可以搜索到</span></p><p id="1501a24fc0895f6a88a06ec83e16247c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612783041850-acf55586-80aa-4cf5-b19a-7f538396fadd.png" width="463" id="nvASC" class="ne-image"></p><h3 id="kmtU6"><span class="ne-text">npm version</span></h3><p id="uabc37cf1" class="ne-p"><span class="ne-text">更新版本号</span></p><p id="a0d0d96455a0e3a034f8e033af18abda" class="ne-p"><span class="ne-text">1.0.1 版本，注意，是最后一位修改了增 1</span></p><pre data-language="bash" id="mknca" class="ne-codeblock language-bash">npm version patch</pre><p id="ff342aeb04f702778cf00a0c9dfadc9c" class="ne-p"><span class="ne-text">1.1.0 版本，注意，是第二位修改了增 1</span></p><pre data-language="bash" id="QAmlF" class="ne-codeblock language-bash">npm version minor</pre><p id="b34da549bdc61335754b6988ab38b6b5" class="ne-p"><span class="ne-text">2.0.0 版本，注意，是第一位修改了增 1</span></p><pre data-language="bash" id="Sz0z7" class="ne-codeblock language-bash">npm version major </pre><p id="1dc8e97068b5cfadf1a2ad64162082b0" class="ne-p"><span class="ne-text"></span></p><p id="a6500e075d8e03725ce3d17a22a57c3a" class="ne-p"><span class="ne-text">最后再提交到远端 npm 中</span></p><pre data-language="bash" id="KPLJX" class="ne-codeblock language-bash">npm publish </pre><h2 id="PDNY3"><span class="ne-text">package.json 文件</span></h2><p id="b761fef007e6bb33a345dcdf85f049db" class="ne-p"><span class="ne-text">项目依赖和开发依赖</span></p><ul class="ne-ul"><li id="4614784420d8f64bbdcb445b0f829234"><span class="ne-text">项目依赖就是这个产品线上运营所依赖的模块，在文件的 dependencies 字段</span></li></ul><p id="64010e5fb89e52bc8b6ccd04d935aea5" class="ne-p"><span class="ne-text">npm install 包名</span></p><ul class="ne-ul"><li id="481ea4498a95cd9ed976a3b016461235"><span class="ne-text">开发依赖就是项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖，devDependencies 字段     </span></li></ul><p id="db25e905713c554b8d8d279b0f9dc82b" class="ne-p"><span class="ne-text">npm install 包名 –save-dev</span></p><ul class="ne-ul"><li id="5c921b891c22a21e22ee6a23c743d80f"><span class="ne-text">npm install –production，在本地下载依赖的包</span></li><li id="cec76de0e88669a59486d6591be4c196"><span class="ne-text">里面的 script 使用：npm run XXX</span></li></ul><h3 id="DnH6J"><span class="ne-text">scripts</span></h3><p id="u134b217d" class="ne-p"><span class="ne-text">参考：</span><a href="https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" data-href="https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" class="ne-link"><span class="ne-text">npm scripts 使用指南-阮一峰的网络日志</span></a></p><p id="u9d1be141" class="ne-p"><br></p><p id="u0299a0e3" class="ne-p"><span class="ne-text">package.josn</span></p><pre data-language="json" id="J9MLD" class="ne-codeblock language-json">{<br>"name": "learn-scripts",<br>"version": "1.0.0",<br>"description": "",<br>"main": "index.js",<br>"scripts": {<br>"test": "echo &quot;Error: no test specified&quot; && exit 1",<br>"runFile": "node index.js",<br>"commit": "git status && git add . && git-cz",<br>"runBashCommand": "git --version && git help -a"<br>},<br>"keywords": [],<br>"author": "",<br>"license": "ISC"<br>}</pre><h2 id="PXskd"><span class="ne-text">package-lock.json 文件</span></h2><ul class="ne-ul"><li id="u00fdb77d"><span class="ne-text">  锁定包的版本，确保再次下载时不会因为包版本不同而产生问题</span></li><li id="uc636257e"><span class="ne-text"> 加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作</span></li></ul><h2 id="mOhk4"><span class="ne-text">本地调试 npm 包的问题</span></h2><h3 id="zx2aQ"><span class="ne-text">相对路径测试所开发的 npm 包</span></h3><div class="ne-quote"><p id="ucd601d24" class="ne-p"><span class="ne-text">适合项目所需的某一个 npm 包</span></p></div><p id="u06f37694" class="ne-p"><span class="ne-text">比如 a 文件夹下有 npm 包 b 文件夹和测试插件的 c 文件夹，那么在 c 文件夹下使用</span><code class="ne-code"><span class="ne-text">npm i ../b</span></code><span class="ne-text">命令来下载本地开发的 npm 包。</span></p><h3 id="GGa6K"><span class="ne-text">npm link 链接全局测试</span></h3><div class="ne-quote"><p id="u35c0d46a" class="ne-p"><span class="ne-text">适合脚手架类型的 npm 包</span></p></div><p id="ud70dcdbf" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644571675015-971bcbde-3119-43dd-90ed-8ef33c5bb478.png" width="436" id="ue70d5364" class="ne-image"></p><p id="ufb736e32" class="ne-p"><span class="ne-text">node 全局包目录如下：其实就是链接使用一下而已</span></p><p id="ua4546a51" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644571733855-7615cfb8-8648-4468-ad35-199c95161160.png" width="428" id="u1fb22cf2" class="ne-image"></p><h3 id="HXz0k"><span class="ne-text">jest 测试框架</span></h3><div class="ne-quote"><p id="u78b7ba06" class="ne-p"><span class="ne-text">适合各种项目，不仅是 npm 包，vue 项目等也需要这种测试工具</span></p></div><ul class="ne-ul"><li id="u2b874769"><span class="ne-text">详细查看：</span><a href="https://www.wztlink1013.com/blog/blhxct/#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Jest" data-href="https://www.wztlink1013.com/blog/blhxct/#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Jest" target="_blank" class="ne-link"><span class="ne-text">https://www.wztlink1013.com/blog/blhxct</span></a></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA环境下的Javaweb开发bug汇总</title>
      <link href="/blog/aiuif3/"/>
      <url>/blog/aiuif3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="haJK6"><span class="ne-text">Unsupported major.minor version 52.0</span></h2><div class="ne-quote"><p id="8b6445fca96b6712b87ad3cd7cf9f186" class="ne-p"><span class="ne-text">版本过低</span></p></div><pre data-language="java" id="KdMur" class="ne-codeblock language-java">[2021-02-07 08:25:52,537] Artifact javaweb-blog:war exploded: Error during artifact deployment. See server log for details.</pre><pre data-language="java" id="iaZyf" class="ne-codeblock language-java"> java.lang.UnsupportedClassVersionError: com/nic/filter/AdminFilter : Unsupported major.minor version 52.0 (unable to load class com.nic.filter.AdminFilter)</pre><p id="277c3637042e99ad42b2160eefccc7ec" class="ne-p"><span class="ne-text">一直报错，网上找一直是说和jdk的版本有关，但是jdk的版本尝试更换几个都无效。事实上是Tomcat的版本问题，项目开始用的是Tomcat8.1升级至8.5.34即可（升级Tomcat9可以否？会对下兼容吗？trytry）</span></p><h2 id="gN7tT"><span class="ne-text">org.apache.tomcat.util.descriptor.web.WebXml.setVersion Unknown version string [4.0]</span></h2><div class="ne-quote"><p id="c4f1c8b91c3989e72d1e0ddcde6fbed2" class="ne-p"><span class="ne-text">warning：4.0太高</span></p></div><pre data-language="java" id="yHWM5" class="ne-codeblock language-java">org.apache.tomcat.util.descriptor.web.WebXml.setVersion Unknown version string [4.0]</pre><ul class="ne-ul"><li id="77c385a4bfefd7ab229818af44b46978"><span class="ne-text">解决：</span><a href="https://blog.csdn.net/qq_32483145/article/details/80292463" data-href="https://blog.csdn.net/qq_32483145/article/details/80292463" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/qq_32483145/article/details/80292463</span></a></li></ul><h2 id="sc9fQ"><span class="ne-text">用到servlet的页面跳转404</span></h2><h3 id="egmby"><span class="ne-text">web.xml配置有误</span></h3><p id="720ced33822230ccd0a1638e30626880" class="ne-p"><span class="ne-text">页面能访问，也成功部署到tomcat下面的weapps文件夹下面，但是在进行页面跳转的过程中，会出现下面的404情况。分析之后是我这个项目是新建的一个空项目，然后代码是之前在eclipse下运行过的，而后直接将内容代码复制过来，却没复制web.xml，导致现项目的web.xml是“空的”，无配置。</span></p><p id="2afa0a40ee013ac80d38eccef28697e1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612753264339-b79c791c-6814-4c38-b42d-6b85bb9c1d5f.png" width="960" id="VxL8Y" class="ne-image"></p><h3 id="DzlOe"><span class="ne-text">Tomcat路径配置有误</span></h3><p id="933000fed5ab6a8a438b766c6990a595" class="ne-p"><span class="ne-text">还有一种情况，就是tomcat配置过程中的那两个路径也要注意下</span></p><p id="808e36351971917c539103a32c77cfdf" class="ne-p"><span class="ne-text">调整为如下配置，不然会出现访问/jsp-peojectname/jsp-</span><span class="ne-text">peojectname</span><span class="ne-text">/index.jsp页面为404的情况</span></p><p id="5d1ec0127af429a814e1f0826c870ac1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756924057-55c60ad3-85b8-4cf0-aa9d-6184bfbd296e.png" width="805.5" id="rdvlv" class="ne-image"></p><p id="ae4a94dd9ea0f3ddaaafe1de77482ba4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756936656-72d837f5-46ef-4d35-8e39-e49d2c6f077d.png" width="805.5" id="qzUm9" class="ne-image"></p><h3 id="k4028"><span class="ne-text">其他类型错误</span></h3><p id="57df7bd56a6945c07c448efdaebd0b9f" class="ne-p"><span class="ne-text">可能还有其他类型错误，参考以下的总结</span></p><p id="1d717f539e59f4168a0041eae023681c" class="ne-p"><br></p><ul class="ne-ul"><li id="81517281bc6077014324468ebe1af49d"><a href="https://blog.csdn.net/DBC_121/article/details/79204340" data-href="https://blog.csdn.net/DBC_121/article/details/79204340" target="_blank" class="ne-link"><span class="ne-text">Web开发：关于Tomcat出现The origin server did not find a current representation for the target resourc...的问题</span></a></li></ul><h2 id="e1ijn"><span class="ne-text">数据库报错</span></h2><p id="951707ef5652cfb006c0098cc2a8c3d2" class="ne-p"><span class="ne-text">navicat也不能查看该数据库</span></p><pre data-language="java" id="5uIlz" class="ne-codeblock language-java">HTTP Status 500 – Internal Server Error<p>Type Exception Report</p><p>Message get connection error!</p><p>Description The server encountered an unexpected condition that prevented it from fulfilling the request.</p><p>Exception</p><p>java.lang.RuntimeException: get connection error!<br>com.nic.util.JdbcUtil.getConnection(JdbcUtil.java:55)<br>com.nic.dao.ArticleDao.findArticle(ArticleDao.java:56)<br>com.nic.service.ArticleService.findArticle(ArticleService.java:20)<br>com.nic.servlet.PostlistServlet.doGet(PostlistServlet.java:50)<br>javax.servlet.http.HttpServlet.service(HttpServlet.java:635)<br>javax.servlet.http.HttpServlet.service(HttpServlet.java:742)<br>org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)<br>Root Cause</p><p>java.lang.ClassNotFoundException: com.mysql.jdbc.Driver<br>org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1309)<br>org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1137)<br>java.lang.Class.forName0(Native Method)<br>java.lang.Class.forName(Class.java:264)<br>com.nic.util.JdbcUtil.getConnection(JdbcUtil.java:52)<br>com.nic.dao.ArticleDao.findArticle(ArticleDao.java:56)<br>com.nic.service.ArticleService.findArticle(ArticleService.java:20)<br>com.nic.servlet.PostlistServlet.doGet(PostlistServlet.java:50)<br>javax.servlet.http.HttpServlet.service(HttpServlet.java:635)<br>javax.servlet.http.HttpServlet.service(HttpServlet.java:742)<br>org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)<br>Note The full stack trace of the root cause is available in the server logs.</p><p>Apache Tomcat/8.5.34</pre><p id="00f4969e188ff08a736523f47b566cc3" class="ne-p"><span class="ne-text">初步分析是用的 phpstudy 里面的 mysql 数据库不能生效，删除电脑之前的 mysql，用 phpstudy 数据库恢复</span></p><p id="ebe37768bdb0e8d77497b3646c0c6097" class="ne-p"><br></p><hr id="sDbaj" class="ne-hr"><p id="c3a3977ed9581b78769ef322e738ad5e" class="ne-p"><br></p><p id="7ee329e34b272736f7371a549825b9b7" class="ne-p"><span class="ne-text">但是还会报错，判断应该是代码文件出错【不过不用将这个 jar 包导入到 lib 文件夹下（反而会报错），只需要将其导入到 tomcat 文件夹下的 lib 文件夹，即可】</span></p><p id="d85975554ed07e722c2c5206034f904a" class="ne-p"><a href="https://www.yuque.com/attachments/yuque/0/2021/jar/1484158/1612768356808-4c69cbaa-cbc7-4ebe-9232-423cad8ef54f.jar" id="xrOhc" class="ne-card-file">📎mysql-connector-java-5.1.49.jar</a><span class="ne-text">（或者直接上网搜再下载）</span></p><p id="c7fe26f2bacf06bbc7f62483c99bf7cd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756117413-4649efa1-9274-4ae5-aa1a-463750acd571.png" width="645.5" id="ISElc" class="ne-image"><span class="ne-text" style="text-decoration: line-through"></span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA创建JavaWeb项目</title>
      <link href="/blog/qi1ddv/"/>
      <url>/blog/qi1ddv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h2 data-lake-id="63edee382d63173f31043ce80330d00c" id="Dj8JX" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">一、Tomcat下载</h2><h3 id="7730a6e8" data-lake-id="513d1fed45f203afb36a3282392efce6" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">1. 下载并安装</h3><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="cdeb1a2587df0cff6bc0867ac63ae028" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">假如不是集成开发环境（比如phpstudy），电脑要有jdk环境</p></blockquote><p data-lake-id="bc94ef466687aa2d0d5c348c89a605b1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【1】官网下载：<a href="http://tomcat.apache.org/" target="_blank">http://tomcat.apache.org/</a><br></p><p data-lake-id="8522c6b890b66cefcf2157063ae6ec6b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914511-a035ba93-0b7a-450b-b391-5d1452435ca7.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="220px" style="visibility: visible; width: 425px;"></span></p><p data-lake-id="c448ace09b5ab2511b5eaae7a7198390" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【2】下载并解压到自己的相应盘区，再检验是否成功<br><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914448-2ef2e1a1-2966-4d35-8bfe-82162aa1588b.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="273px" style="visibility: visible; width: 431px;"></span></p><p data-lake-id="4ca05aa2f9fe762f0022dfa8a6113f7c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">点击第二个框不出现闪退情况则证明成功<br><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914507-87063aec-884a-4180-b124-568478d81bc0.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="222px" style="visibility: visible; width: 425px;"></span></p><p data-lake-id="4915bda3aec13cd32e89560157a6b5cd" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【3】浏览器进入端口<a href="http://localhost:8080/" target="_blank">http://localhost:8080/</a>上述配置成功则表明成功<br><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914624-248148e3-3f5f-45ca-ad93-c063216a7aff.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="270px" style="visibility: visible; width: 482px;"></span></p><h3 data-lake-id="377cdb334b9f35b942b445fb097803a4" id="iCBvN" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">2. 过程中可能会出现的问题</h3><p data-lake-id="1b07bf46e0e492e2d6dadc399e9717b2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【1】点击startup.bat文件出现闪退</p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="d0708110248ea1defede037ed433609d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">电脑中java jdk有无（JAVA_HOME）</p></blockquote><p data-lake-id="85ad0082aa384b1084a06bd69738afb5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【2】端口被占用</p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="24a8ae1eb8271058383cc3b3e898f668" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">进入Tomcat文件夹下的conf文件下的server.xml文件，用记事本查找8080，下面复制一个新的初始端口<br><span data-card-type="inline" data-lake-card="image"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914513-8083bc6e-4c6f-436e-b0b0-98d3d70b9dea.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="80px" style="visibility: visible; width: 557px;"></span></p></blockquote><h2 data-lake-id="6bc83becd1fe9c21f1844e5bdf59ecad" id="2V0Nz" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">二、利用IDEA创建一个JavaWeb项目</h2><h3 data-lake-id="ea6285186d8d02895a9f1ab20d84c474" id="kX4ZX" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">1. 创建新项目</h3><p data-lake-id="a33553342d0f213e7d6dafc265f4ca1a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">依次点击：<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">File </code>-> <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">New </code>-> <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Project</code></p><p data-lake-id="85b492a8a49c44e13da27c1a31ffcd6e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612697874347-fef7ad38-7ff2-4567-89a9-f5d47a1f4824.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="316px" style="visibility: visible; width: 468px;"></span></p><p data-lake-id="44f05783ba13cbcdd975831c5213e32a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h3 data-lake-id="a7b20ac4ecdef728f599dee7b2b355c6" id="ca24o" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">2. 项目工程配置</h3><p data-lake-id="f7187cc17ab2441a7628f7dd3098f399" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【1】在<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">WEB-INF</code>下创建两个空文件夹 <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">classes</code> <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">lib</code></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="60d32c5535bfbcd0d5f213ef9c70bd1e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">目的：</p><ul data-lake-id="feba500e96a86bb1041a43d559e44693" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="48148cfee554a99d0ac033caa07961f1">classes文件夹用于存放编译后的class文件</li><li data-lake-id="2b9fb8455249c12ae514e84b2c663eb9">lib文件夹用于存放依赖的jar包</li></ul></blockquote><p data-lake-id="9cd21d9459c6fa83fbd7072ac0a7ed5e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612697966439-ab639870-61ab-429e-919a-4109c8cefdc5.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="237px" style="visibility: visible; width: 234.5px;"></span></p><p data-lake-id="fbc92aea63ea53816bc2e2d9bb37eb57" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【2】依次点击<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">file</code> -> <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Project Structure</code></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="d311fad424dbaa32f13ed38da6f1aef1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">目的：将后面编译的class文件默认生成到刚刚新建的classes目录下</p></blockquote><p data-lake-id="a7a1d5bf2941814cd63ec1061062229a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698144393-24e78472-430b-47a4-b423-e091597bb4f3.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="364px" style="visibility: visible; width: 767.5px;"></span></p><p data-lake-id="18f53294b5e9ef9d29dc9be26d13d2a2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>【3】</span>依次点击<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">file</code> -> <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Project Structure</code></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="26a7a3be5c0b93cda4d7bd3186de182f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>目的：添加jar包依赖</span></p><span>（项目所需要的jar包都放到刚刚新建的lib文件夹）</span></blockquote><p data-lake-id="505a9f1841b26a39c285413b254e094d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698241583-99ff6441-6e2a-4776-addb-9f8f1eda6636.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="268px" style="visibility: visible; width: 637px;"></span></p><p data-lake-id="46932e6db80853ecaf2db465130f6659" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698274993-98e1b314-c726-41e6-973e-1dbb07ef7312.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="169px" style="visibility: visible; width: 273px;"></span></p><p data-lake-id="01d3b67e0258655ffbd019fb957650e3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【4】配置打包方式Artifacts</p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="b30429f17ec665ec50adada7955b5fc9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span style="text-decoration: line-through;">点击 Artifacts选项卡，IDEA会为该项目自动创建一个名为“JavaWeb:war exploded”的打包方式，表示 打包成war包，并且是文件展开性的，输出路径为当前项目下的 out 文件夹，保持默认即可。另外勾选下“Build on make”，表示编译的时候就打包部署，勾选“Show content of elements”，表示显示详细的内容列表。</span></p></blockquote><p data-lake-id="be492de58b2f1a37b3074ca9d0524030" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><em>如果按照上面说的，那么会发现发布的项目并没有在 tomcat目录下的webapps目录下，如果项目以前在其他电脑抑或是其他环境下运行过，可能会导致项目的很多子页面默认URL404。</em></p><p data-lake-id="6adde888c2dad0692e419aedbdf59fba" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span style="text-decoration: line-through;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612711385355-7645f327-ad5c-40aa-a165-b975f957ebe3.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="239px" style="visibility: visible; width: 442px;"></span></span></p><p data-lake-id="4b4bf89f80972d983c5b16b0eadb929e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">正确解决办法：<span>项目一开始</span>依次点击<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">file</code> -> <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Project Structure</code></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="8f12efa200105c52f3d15779ed9a898b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">1区域：将output路径指定到<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">tomcat</code>的<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">webapps</code>下面（新建一个本项目的同名文件夹）</p><p data-lake-id="abd9ea5850d1befff3660892bbc72fba" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">2区域：Output Layout就是配置这个路径里面生成的所有文件</p><p data-lake-id="25e60282edc2d2048febc6c1313737de" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">3区域：将右边的文件内容脱拉到左边的3区域即可</p></blockquote><p data-lake-id="598c7b395be110ce8f8e6f0209c7f4ec" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612763067214-29b72122-e8c6-4df1-a112-50ffb6c43084.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="327px" style="visibility: visible; width: 767.5px;"></span></p><h3 data-lake-id="3f143700f8c1c638ae9fe4906888c52e" id="Jd8NS" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">3. Tomcat配置</h3><p data-lake-id="89eeb898fab17ee770d0f6380c33770c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【1】点击如下位置进入tomcat容器编辑板块</p><p data-lake-id="03d43cde06396254ee53f33d382247c0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698536983-4544013a-5e2a-43d7-ae31-7aa5c871fb3a.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="151px" style="visibility: visible; width: 960px;"></span></p><p data-lake-id="91aa0bcd803a07deb850e72dd6568301" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【2】默认会自动给我们生成一个Tomcat容器，基本上只需要配置<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Deployment</code>即可，如果没有默认生成就新建一个。其中<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Application server</code>填写本地tomcat的安装目录文件夹即可（因为一台电脑开发可能会有多个tomcat版本）</p><p data-lake-id="8897380c9075558f3b5018b5942afb76" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612711521404-673143aa-f3fd-4b37-aed1-919d0ea1de1f.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="370px" style="visibility: visible; width: 581.5px;"></span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="4751dfc4719d21e52368c7c4ef84abaf" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">❗ <span>❗ </span><span>❗</span>如果要换不同版本的tomcat来运行项目，改如下地方：</p><ol data-lake-id="42e3b85723f57f051a6ec4bc28942807" start="1" lake-indent="0" style="list-style-type: decimal; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="0983b81ebaea8201edd8956e9ad40b99">先将上面图片<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Application server</code>tomcat版本更换至新的tomcat版本</li><li data-lake-id="26b9a9a2728881d7dfee51df01a30de7">去<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">2. 项目工程配置</code>步骤中，减去原先的tomcat，加上新的tomcat</li></ol></blockquote><p data-lake-id="3d05edbd6075f8407205daa224f41d6d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698612335-158bfcb3-3016-478c-b86a-770ad57ad2a9.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="511px" style="visibility: visible; width: 805.5px;"></span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="fcc6e35f22cc90a3a23b0e1033060116" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>此处的Application context是指定本工程的根目录</span></p></blockquote><h3 data-lake-id="ef11a24b23822ed53d0781dea7a16aac" id="W4nNn" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">4. 结果测试</h3><p data-lake-id="b40187367ae12b3231bc40304f6bd804" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">在<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">index.jsp</code>文件下添加显示代码</p><p data-lake-id="21666df89e434eec5b18db1bb37d2438" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698732177-5bedf912-6a16-47d4-ab96-d5527b9567d1.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="271px" style="visibility: visible; width: 939.5px;"></span></p><p data-lake-id="f7a3fd3c65825d81fea868fc06d0eb25" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">直接运行</p><p data-lake-id="09e25ce396481e2b3aca5f7f8c6e5696" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698844575-2952fffc-3616-43f1-be90-138dbe0df86d.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="128px" style="visibility: visible; width: 553.5px;"></span></p><p data-lake-id="7deb6792d8c9120fbbac6a28ebf7672b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698866551-55b0f5c6-fc7e-423a-8c59-2af2cbe08953.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="152px" style="visibility: visible; width: 413.5px;"></span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="b6085e3cc0216f8d35d519a0e562b8a4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">如果在Tomcat配置过程中的部署路径为 <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">/</code> ，会出现下面第二张图的结果，都能访问，但是最好还是上面的方式，符合服务器“一个文件夹一个站点”的思想，路径访问的相关问题不会挖坑。</p></blockquote><p data-lake-id="6384b0824cca3550d175a9f631244f72" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698976241-4d798089-9581-4cdf-893b-dbbc11b18057.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="511px" style="visibility: visible; width: 805.5px;"></span></p><p data-lake-id="88b571e3f5827d45128c9ac83412bfa7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698989649-0fdabed2-a690-450a-b11f-3900a477a68a.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="170px" style="visibility: visible; width: 431px;"></span></p><h3 data-lake-id="83ca51e3f13e327e51a0cc56069e46b8" id="R1vic" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">❗ JavaWeb项目结构分析</h3><p data-lake-id="7d1d88201c20f123f60fad58a0d335d1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612752142869-4f7db98f-6d15-4ce5-be4b-1e0e13dcab08.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="444px" style="visibility: visible; width: 160.5px;"></span></p><ul data-lake-id="e48218114418eee1c6b225cb0b6c0c11" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="de7105846ee25dd96541b08de713abb5">src文件夹：编写的java代码，编译后会放到WEB-INF文件夹下的classes文件夹</li><li data-lake-id="960358f6438e9c8ad4b73c49ef577158">web文件夹：web应用程序的根目录，web应用程序所有的文件都在该目录下</li><li data-lake-id="861313a8e731c7a452d7b8f08d8d437c">WEB-INF：客户不能直接通过浏览器进行访问</li></ul><ul data-lake-id="ec317f8b6e69c1a32043410ff2186cd4" lake-indent="1" style="list-style-type: none; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><ul data-lake-id="d9ce5de85e244dcc12509c7162990199" lake-indent="0" style="list-style-type: circle; margin: 0px; padding-left: 23px;"><li data-lake-id="f58091f122a7030992877d2098635262">classes：存放servlet和其他有用的class文件（编译后的）</li><li data-lake-id="19c93315661297cf7c5b2a2b97c30248">lib：存放web应用程序所需要的jar包</li><li data-lake-id="1b3c16c77c397e317eb79651fce558c2">web.xml：存放部署和配置信息的文件（当前WEB项目的核心配置，Servlet2.5必须有，3.0以后可省略）</li></ul></ul><h2 data-lake-id="dcb67ca02d1f3f693cf0cf7c3f5ed759" id="D87OL" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">参考</h2><ul data-lake-id="c1af10cc941e86734905873a536c92de" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="617d69fcbc37a9ed735a1064f8b9fb13"><a href="https://blog.csdn.net/m0_37499059/article/details/78806617" target="_blank"><span>Intellij idea创建javaWeb项目</span></a></li><li data-lake-id="2f592f55bd18fbf7ed8491f0704f90ef"><span><a target="_blank" href="https://blog.csdn.net/c_little_white/article/details/89435646?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">IDEA启动tomcat不报错，tomcat的webapps文件夹没有项目文件，项目的默认URL404</a></span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>window五大对象</title>
      <link href="/blog/window_five_obj_webapis/"/>
      <url>/blog/window_five_obj_webapis/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="Ga8tW"><span class="ne-text">什么是BOM</span></h2><p id="058ef4e02219954f5ec808e64a3a5fe2" class="ne-p"><span class="ne-text">BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。</span></p><p id="207aa15a466633c36e4f19108bdb2d4c" class="ne-p"><span class="ne-text">BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。</span></p><p id="c54dbafcadc13b73267b0c50ffabc251" class="ne-p"><span class="ne-text">BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分。</span></p><p id="f10624593cf2df7ba60d41ba9eeb2f58" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362800-e37d0116-7afb-4099-9d0e-d06e4a1e5127.png" width="866" id="AK9gT" class="ne-image"></p><p id="1d09b07fec86db6338249e251740a360" class="ne-p"><span class="ne-text">BOM 比 DOM 更大，它包含 DOM。</span></p><p id="f9e6ea6272c9755736daff0697dddc38" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362856-04ac0f7c-e251-4985-ba14-9d8839bd2fcf.png" width="629" id="AS3Ek" class="ne-image"></p><h2 id="aujcX"><span class="ne-text">window对象</span></h2><h3 id="nFKGI"><span class="ne-text">window.alert、</span><span class="ne-text">window.</span><span class="ne-text">prompt</span></h3><ul class="ne-ul"><li id="448376cc99c3150fa4b0fb3153e5afe2"><span class="ne-text">是js访问浏览器窗口的一个接口</span></li><li id="619dde06a5576c7276c6340dbde3a7ec"><span class="ne-text">之前学的这两种输入输出都是window的对象方法，window.alert的window可以省略</span></li></ul><h3 id="WoQ2w"><span class="ne-text">window.</span><span class="ne-text">name</span></h3><p id="e728e0d7e9622bf55557bbbc6e189fb8" class="ne-p"><span class="ne-text">window.name的使用</span></p><ul class="ne-ul"><li id="44285870c101813ab27b9383d18fe554"><span class="ne-text">参考：</span><a href="https://www.zhangxinxu.com/wordpress/2019/09/window-name/" data-href="https://www.zhangxinxu.com/wordpress/2019/09/window-name/" target="_blank" class="ne-link"><span class="ne-text">https://www.zhangxinxu.com/wordpress/2019/09/window-name/</span></a><span class="ne-text">（基本没啥用了）</span></li></ul><h3 id="QAl5V"><span class="ne-text">window.onload和DOMContentLoaded</span></h3><p id="aeb0cf48a35574ba4a68dc083679a6f1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362978-a9a37865-ed21-4388-9d6b-9c95cf4e2c03.png" width="697" id="GEaKk" class="ne-image"></p><ul class="ne-ul"><li id="bdf0e78738974823f652880fd6911c36"><span class="ne-text">窗口 (页面）加载事件</span></li><li id="2b026f52a699d91c0bbddbb1ed20d945"><strong><span class="ne-text">当文档内容完全加载完成</span></strong><span class="ne-text">会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。</span></li></ul><p id="6b3bdbdaef0e05dc9e6db7f016df3e15" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363060-d1b0c898-d05e-45d2-b969-d625f094716e.png" width="717" id="iqFg7" class="ne-image"><span class="ne-text"></span></p><p id="bb2671e68beee3d95ce638daa16ce12d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363117-b08edff8-a5e7-4d72-af87-30d266da9644.png" width="692" id="FuxJM" class="ne-image"></p><p id="420e728cbe52b3dbf084874ff4d6cec8" class="ne-p"><span class="ne-text">事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。</span></p><p id="3982d9ee0bdbb878262e7a319d0ad56a" class="ne-p"><span class="ne-text">IE9以上才支持</span></p><p id="5c9f5027770267f4ddba29f78f88589c" class="ne-p"><span class="ne-text">适用场景：如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适。</span></p><pre data-language="javascript" id="ptj86" class="ne-codeblock language-javascript"><script><pre><code>    window.addEventListener(&#39;load&#39;, function() &#123;        var btn = document.querySelector(&#39;button&#39;);        btn.addEventListener(&#39;click&#39;, function() &#123;            alert(&#39;点击我&#39;);        &#125;)    &#125;)    window.addEventListener(&#39;load&#39;, function() &#123;        alert(22);    &#125;)    document.addEventListener(&#39;DOMContentLoaded&#39;, function() &#123;        alert(33);    &#125;)&lt;/script&gt;&lt;/pre&gt;&lt;h3 id=&quot;XoAZx&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;window.onresize&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;03c87d57037c484fa747a2535560251d&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363174-36e0247a-e870-47b7-ad70-a39e8204f778.png&quot; width=&quot;698&quot; id=&quot;Yml18&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;559622a62f442fabf2a1522d46cb5777&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;window.onresize 是调整窗口大小加载事件,  当触发时就调用的处理函数。&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;725c5aabe697f4cefd5a63ea317f2a9e&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;只要窗口大小发生像素变化，就会触发这个事件。&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;ed29a664c947925f7e00cd6712b391fc&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;利用这个事件完成响应式布局&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;71ee46687c911ea3e392664b8bbee534&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt; window.innerWidth 当前屏幕的宽度&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-language=&quot;javascript&quot; id=&quot;Qdxpw&quot; class=&quot;ne-codeblock language-javascript&quot;&gt;&lt;script&gt;    // 注册页面加载事件    window.addEventListener(&#39;load&#39;, function() &#123;        var div = document.querySelector(&#39;div&#39;);        // 注册调整窗口大小事件        window.addEventListener(&#39;resize&#39;, function() &#123;            // window.innerWidth 获取窗口大小            console.log(&#39;变化了&#39;);            if (window.innerWidth &lt;= 800) &#123;                div.style.display = &#39;none&#39;;            &#125; else &#123;                div.style.display = &#39;block&#39;;            &#125;        &#125;)    &#125;)&lt;/script&gt;&lt;div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;h3 id=&quot;sCtq2&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;setTimeout()和&lt;/span&gt;&lt;span class=&quot;ne-text&quot;&gt;clearTimeout()&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;e533d711b4937d2912983dd7006213ff&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363237-7fb4b99d-18cc-4621-9153-99ee3b219faa.png&quot; width=&quot;695&quot; id=&quot;zmYE6&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;p id=&quot;ed00cc3be52d6c3c859af99f74d1ab73&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363294-245f3e69-65be-425b-8390-cedcea50e6b9.png&quot; width=&quot;687&quot; id=&quot;YGNul&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;d76a7ea67bb840a6822b490fef9ff820&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;默认的延迟毫秒数默认是0，单位必须是毫秒&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;9a652084583376f52ccf7c2acde54563&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;通常定义了一个这种函数就给其“名”，赋予其一个标识符，因为一个项目里面可能有很多的定时器。&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;ne-quote&quot;&gt;&lt;p id=&quot;106a138231405a9ef34bdfd5ab12e7dc&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;什么是回调函数呢？&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;p id=&quot;af57320e5d23b3abb419bdf7cb1bbb68&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;普通函数是按照代码顺序直接调用。回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。例如：定时器中的调用函数，事件处理函数，也是回调函数。element.onclick = function()&#123;&#125;   或者  element.addEventListener(“click”, fn);   里面的 函数也是回调函数。&lt;/span&gt;&lt;/p&gt;&lt;pre data-language=&quot;cpp&quot; id=&quot;Meg3I&quot; class=&quot;ne-codeblock language-cpp&quot;&gt;&lt;script&gt;    // 回调函数是一个匿名函数     setTimeout(function() &#123;         console.log(&#39;时间到了&#39;);     &#125;, 2000);    function callback() &#123;        console.log(&#39;爆炸了&#39;);    &#125;    // 回调函数是一个有名函数    var timer1 = setTimeout(callback, 3000);    var timer2 = setTimeout(callback, 5000);&lt;/script&gt;&lt;/pre&gt;&lt;p id=&quot;26d89d5e64d61cd27ce8f64d1bcf9bc6&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p id=&quot;cd070e19d0fd983567a628f0b2484eae&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363519-c36076ed-0e62-471c-a193-001186cebc77.png&quot; width=&quot;703&quot; id=&quot;k1kyd&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;2b4bc620787233ab3c288843dd3f5461&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;类似在炸弹爆炸前拆除的意思&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-language=&quot;javascript&quot; id=&quot;xC3Nx&quot; class=&quot;ne-codeblock language-javascript&quot;&gt;&lt;button&gt;点击停止定时器&lt;/button&gt;&lt;script&gt;    var btn = document.querySelector(&#39;button&#39;);    // 开启定时器    var timer = setTimeout(function() &#123;        console.log(&#39;爆炸了&#39;);    &#125;, 5000);    // 给按钮注册单击事件    btn.addEventListener(&#39;click&#39;, function() &#123;        // 停止定时器        clearTimeout(timer);    &#125;)&lt;/script&gt;&lt;/pre&gt;&lt;h3 id=&quot;T4tK9&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;setInterval()和&lt;/span&gt;&lt;span class=&quot;ne-text&quot;&gt;clearInterval()&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;226b7599882b655bfcae881af34a1d3e&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;会多次进行调用，直到清除&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p id=&quot;500758cf6759c3c60ba07c436b732f09&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1484158/1616033160668-637ca99a-723f-4f14-9576-6de4f4fdd383.png&quot; width=&quot;719&quot; id=&quot;lb5Xh&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;h3 id=&quot;fvsZV&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;Demo：倒计时&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;1e36f8f161cc0cb3b86563f97daae6f3&quot; class=&quot;ne-p&quot; style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1484158/1616035667401-0c467c6a-2509-4b0c-a1b3-ea2a9b3d4f85.png&quot; width=&quot;158&quot; id=&quot;Vxs7R&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;pre data-language=&quot;javascript&quot; id=&quot;iHmcC&quot; class=&quot;ne-codeblock language-javascript&quot;&gt;&lt;!DOCTYPE html&gt;</code></pre><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        div {            margin: 200px;        }        <pre><code>    span &#123;        display: inline-block;        width: 40px;        height: 40px;        background-color: #333;        font-size: 20px;        color: #fff;        text-align: center;        line-height: 40px;    &#125;&lt;/style&gt;</code></pre></head><body>    <div>        <span class="hour">1</span>        <span class="minute">2</span>        <span class="second">3</span>    </div>    <script>        // 1. 获取元素         var hour = document.querySelector('.hour'); // 小时的黑色盒子        var minute = document.querySelector('.minute'); // 分钟的黑色盒子        var second = document.querySelector('.second'); // 秒数的黑色盒子        var inputTime = +new Date('2021-3-18 19:00:00'); // 返回的是用户输入时间总的毫秒数        countDown(); // 我们先调用一次这个函数，防止第一次刷新页面有空白         // 2. 开启定时器        setInterval(countDown, 1000);<pre><code>    function countDown() &#123;        var nowTime = +new Date(); // 返回的是当前时间总的毫秒数        var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数        var h = parseInt(times / 60 / 60 % 24); //时        h = h &lt; 10 ? &#39;0&#39; + h : h;        hour.innerHTML = h; // 把剩余的小时给 小时黑色盒子        var m = parseInt(times / 60 % 60); // 分        m = m &lt; 10 ? &#39;0&#39; + m : m;        minute.innerHTML = m;        var s = parseInt(times % 60); // 当前的秒        s = s &lt; 10 ? &#39;0&#39; + s : s;        second.innerHTML = s;    &#125;&lt;/script&gt;</code></pre></body><p>&lt;/html</pre><h3 id="0Vvqr"><span class="ne-text">Demo：短信倒计时</span></h3><p id="1475bd120e9f3a2ce379477879949b72" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616036201989-deced5f6-9ec3-4392-8e1d-cf10d7c1c55b.png" width="641" id="KNBAm" class="ne-image"></p><div class="ne-quote"><p id="65d9f85f2c6c622b5e3f8d4122b98dde" class="ne-p"><span class="ne-text">案例：发送短信倒计时</span></p><p id="5cd325b6cb2702993f40532b5c641e19" class="ne-p"><span class="ne-text">同时这个例子还用到了闭包的相关知识</span></p></div><p id="007bfc06d5261a27005b5317bf6da7aa" class="ne-p"><span class="ne-text">点击按钮后，该按钮 60 秒之内不能再次点击，防止重复发送短信。</span></p><p id="61dd7f4004ca51e32c3314cb9730d98a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363854-8efb51de-f962-4ce9-b686-4166d4ef3bfe.png" width="364" id="KGTIA" class="ne-image"></p><pre data-language="javascript" id="gcQoH" class="ne-codeblock language-javascript">手机号码： <input type="number"> <button>发送</button></p><script>var btn = document.querySelector('button');// 全局变量，定义剩下的秒数var time = 3;// 注册单击事件btn.addEventListener('click', function() {// 禁用按钮btn.disabled = true;// 开启定时器var timer = setInterval(function() {// 判断剩余秒数if (time == 0) {// 清除定时器和复原按钮clearInterval(timer);btn.disabled = false;btn.innerHTML = '发送';} else {btn.innerHTML = '还剩下' + time + '秒';time--;}}, 1000);});</script></pre><h2 id="8VBes"><span class="ne-text">location 对象</span></h2><p id="u061c71de" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="uc8152b11"><span class="ne-text"></span><a href="https://www.cnblogs.com/cang12138/p/7677239.html" data-href="https://www.cnblogs.com/cang12138/p/7677239.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/cang12138/p/7677239.html</span></a></li></ul><p id="e2075ea852fbd51db4333c83d85c9523" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363970-e7ae6f17-8fa0-4cda-bd5c-a486dbad0410.png" width="722" id="MQwpb" class="ne-image"></p><p id="f7ecca6db22c94e25e21f9028af8fc43" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364029-47b8981f-8ef1-4978-8760-2be8bc0c5e96.png" width="723" id="UFOqO" class="ne-image"></p><p id="25c715d613c17d0626a6317d0e406d8d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364086-8b3e0045-e245-4c0a-b484-4e038b829a6b.png" width="684" id="MJ42d" class="ne-image"></p><h3 id="2M3aW"><span class="ne-text">location 对象常用属性</span></h3><p id="85011982c4c2827ad3941f9fd94c779a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364152-c5c0aa45-eb47-49d3-81ce-2318a6bc8497.png" width="705" id="UD8ZA" class="ne-image"></p><h3 id="2mGXr"><span class="ne-text">location 对象常见方法</span></h3><p id="10d4f3fcc9195198740bd901b9a28ab0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364490-f3c87eef-a34f-4378-9b69-03ea18f2fb26.png" width="728" id="hTDRo" class="ne-image"></p><pre data-language="javascript" id="BwbbE" class="ne-codeblock language-javascript"><button>点击</button><script>var btn = document.querySelector('button');btn.addEventListener('click', function() {// 记录浏览历史，所以可以实现后退功能// location.assign('http://www.itcast.cn');// 不记录浏览历史，所以不可以实现后退功能// location.replace('http://www.itcast.cn');location.reload(true);})</script></pre><h3 id="B9Vt4"><span class="ne-text">Demo：5 秒钟自动跳转页面</span></h3><p id="0f4f867ac9741a98761fd02175a9b64a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616038766425-7b736d4a-8329-4912-879c-7eb5924745f5.png" width="399" id="ZGNKi" class="ne-image"></p><pre data-language="javascript" id="jvgIa" class="ne-codeblock language-javascript">var img = document.getElementsByTagName('img');<p>img[0].addEventListener(‘click’,function(){<br>console.log(‘运行到了这里 1’);<br>setTimeout(function(){<br>location.href = ‘<a href="https://www.wztlink1013.com&/#39;">https://www.wztlink1013.com&#39;</a>;<br>console.log(‘运行到了这里’);<br>},5000);<br>});</pre><h3 id="yyyVI"><span class="ne-text">Demo：获取 URL 参数</span></h3><div class="ne-quote"><p id="196f687b145b90010f886f2070baea0d" class="ne-p"><span class="ne-text">login.html</span></p></div><pre data-language="html" id="kFYC1" class="ne-codeblock language-html"><body></p><form action="index.html">用户名： <input type="text" name="uname"><input type="submit" value="登录"></form></body></pre><div class="ne-quote"><p id="a5a0e4e055a91abface6de685a421b2b" class="ne-p"><span class="ne-text">index.html</span></p></div><p id="7849bed1ce9e820cbfa79c3bedff2de0" class="ne-p"><span class="ne-text">收到login页面传来的参数后</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616039288488-d1884566-894d-4a15-a677-9227934a5eb9.png" width="170.5" id="ftUqi" class="ne-image"></p><pre data-language="html" id="GroTs" class="ne-codeblock language-html"><div></div>    <script>        console.log(location.search); // ?uname=wztlink1013        // 1.先去掉？  substr('起始的位置'，截取几个字符);        var params = location.search.substr(1); // uname=wztlink1013        console.log(params);        // 2. 利用=把字符串分割为数组 split('=');        var arr = params.split('=');        console.log(arr); // ["uname", "wztlink1013"]        var div = document.querySelector('div');        // 3.把数据写入div中        div.innerHTML = arr[1] + '欢迎您';</script></pre><h2 id="hB16a"><span class="ne-text">navigator对象</span></h2><p id="5d635830a7e29e9e05a508c2814d3885" class="ne-p"><span class="ne-text">navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户机发送服务器的 user-agent 头部的值。</span></p><p id="5f76ba34027cd602f6a90bf7d3f8a93e" class="ne-p"><span class="ne-text">下面前端代码可以判断用户那个终端打开页面，实现跳转，比如：</span></p><pre data-language="javascript" id="hrkdE" class="ne-codeblock language-javascript">if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {    window.location.href = "https://www.wztlink1013.com/m/index.html";    //手机页面 } else {    window.location.href = "https://www.wztlink1013.com/p/index.html";    //电脑页面 }</pre><p id="02a0bc9cc29aa62f4e980991386921e1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616072483887-50d05057-73f8-49b7-8761-8f68defe6194.png" width="960" id="lZii4" class="ne-image"></p><h2 id="vUGy8"><span class="ne-text">history对象</span></h2><p id="c9515b92dac24aeb44c22728cf1009ee" class="ne-p"><span class="ne-text">    window对象给我们提供了一个 history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。</span></p><p id="50db8e2b4cc06f0aca16245c29a0fbfe" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364555-790a838f-2446-45bd-886e-686c75286b2c.png" width="731" id="moiW0" class="ne-image"></p><h2 id="UCYb9"><span class="ne-text">screen对象</span></h2><table id="cBUJj" class="ne-table" style="width: 658px"><tbody><tr style="height: 33px"><td width="263" style="background-color: #555555"><p id="udc37d18e" class="ne-p" style="text-align: left"><span class="ne-text">属性</span></p></td><td width="395" style="background-color: #555555"><p id="ub8875a7e" class="ne-p" style="text-align: left"><span class="ne-text">说明</span></p></td></tr><tr style="height: 33px"><td width="263"><p id="ufb787a3c" class="ne-p"><a href="https://www.runoob.com/jsref/prop-screen-availheight.html" data-href="https://www.runoob.com/jsref/prop-screen-availheight.html" target="_blank" class="ne-link"><span class="ne-text">availHeight</span></a></p></td><td width="395"><p id="u29d77a4e" class="ne-p"><span class="ne-text">返回屏幕的高度（不包括Windows任务栏）</span></p></td></tr><tr style="height: 33px"><td width="263"><p id="u1c28a76c" class="ne-p"><a href="https://www.runoob.com/jsref/prop-screen-availwidth.html" data-href="https://www.runoob.com/jsref/prop-screen-availwidth.html" target="_blank" class="ne-link"><span class="ne-text">availWidth</span></a></p></td><td width="395"><p id="u284c540e" class="ne-p"><span class="ne-text">返回屏幕的宽度（不包括Windows任务栏）</span></p></td></tr><tr style="height: 33px"><td width="263"><p id="ub996e69c" class="ne-p"><a href="https://www.runoob.com/jsref/prop-screen-colordepth.html" data-href="https://www.runoob.com/jsref/prop-screen-colordepth.html" target="_blank" class="ne-link"><span class="ne-text">colorDepth</span></a></p></td><td width="395"><p id="u4b34713b" class="ne-p"><span class="ne-text">返回目标设备或缓冲器上的调色板的比特深度</span></p></td></tr><tr style="height: 33px"><td width="263"><p id="u6ef27334" class="ne-p"><a href="https://www.runoob.com/jsref/prop-screen-height.html" data-href="https://www.runoob.com/jsref/prop-screen-height.html" target="_blank" class="ne-link"><span class="ne-text">height</span></a></p></td><td width="395"><p id="ubfca94cc" class="ne-p"><span class="ne-text">返回屏幕的总高度</span></p></td></tr><tr style="height: 33px"><td width="263"><p id="uc7818a93" class="ne-p"><a href="https://www.runoob.com/jsref/prop-screen-pixeldepth.html" data-href="https://www.runoob.com/jsref/prop-screen-pixeldepth.html" target="_blank" class="ne-link"><span class="ne-text">pixelDepth</span></a></p></td><td width="395"><p id="u3d0c54da" class="ne-p"><span class="ne-text">返回屏幕的颜色分辨率（每象素的位数）</span></p></td></tr><tr style="height: 33px"><td width="263"><p id="ub44e530e" class="ne-p"><a href="https://www.runoob.com/jsref/prop-screen-width.html" data-href="https://www.runoob.com/jsref/prop-screen-width.html" target="_blank" class="ne-link"><span class="ne-text">width</span></a></p></td><td width="395"><p id="u390b7b4f" class="ne-p"><span class="ne-text">返回屏幕的总宽度</span></p></td></tr></tbody></table><p id="f60bdbd441a4acd43caeb5a354f70f3c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073065915-eee3a4aa-52a8-4200-9d15-9e66f5c4fba5.png" width="1920" id="ugF7E" class="ne-image"></p><p id="54ccc4cbab7357ca8c88c5dde6702538" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073033094-e0640f15-e1a2-4f9d-9937-aad687e2bfbe.png" width="310" id="PyKN9" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BOM各种长宽的总结</title>
      <link href="/blog/5_day05_webapis/"/>
      <url>/blog/5_day05_webapis/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="554d0"><strong><span class="ne-text">其他关于长宽</span></strong></h2><p id="ub3199948" class="ne-p"><br></p><h3 id="k8Yoi"><span class="ne-text">window.innerWidth和</span><span class="ne-text">innerHeight</span></h3><ul class="ne-ul"><li id="fffcee86f0b69d28fa052f3416ff42a4"><span class="ne-text" style="color: #4D4D4D; font-size: 16px">表示文档显示区域的宽高，不包括工具栏和地址栏等区域；</span></li></ul><p id="48c0d826e3cfdff268e862faa73354a4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617937380778-c1f24a67-c63e-49d1-9907-f7fe91880e9f.png" width="618" id="XJRfy" class="ne-image"></p><h3 id="YIozD"><span class="ne-text">window.pageYOffset和</span><span class="ne-text">pageXOffset</span></h3><p id="716976c49a06d30461e5c172d3687ca6" class="ne-p"><span class="ne-text">ie9往后才支持的“被卷去”的长度</span></p><p id="ab9bcc236105cfda1856fe6a98d1320d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617938014655-932453ea-63bc-4bc1-8388-63b41417892d.png" width="617" id="zy42z" class="ne-image"></p><p id="f18c4e1f1c5a9292cebbe576e2d9e7e0" class="ne-p"><span class="ne-text"></span></p><h3 id="UaaMt"><span class="ne-text">鼠标事件对象event</span></h3><p id="c2e01fa3a4c223b2894094ffbb203375" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361978-034f2af6-14fa-4ddb-bd8b-2eabe289eb59.png" width="703" id="nnFwt" class="ne-image"></p><p id="a0610de16ebdee3ca9844fb127be1ea0" class="ne-p"><br></p><h2 id="U6S0b"><span class="ne-text">元素偏移量offset</span></h2><h3 id="cIUmT"><span class="ne-text">offset 概述</span></h3><div class="ne-quote"><p id="36cee601812a5cae31f1bfdae78719c5" class="ne-p"><span class="ne-text">offset 翻译过来就是偏移量， 我们使用 offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等。</span></p></div><ul class="ne-ul"><li id="61296beadd25f4305dd958e50972ce7f"><span class="ne-text">获得元素距离带有定位父元素的位置</span></li><li id="c36fec9465ccf515f8f4b5181a220e44"><span class="ne-text">获得元素自身的大小（宽度高度）</span></li><li id="2aa12a4af1255a0c4f38a63c2e478ce7"><span class="ne-text">注意：返回的数值都不带单位</span></li></ul><p id="6b59ba834eebd043fecbbf9ffe97b10e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616067042341-17b54a01-de40-4ad5-8a54-ad61317d27ae.png" width="522" id="g51rZ" class="ne-image"></p><p id="9cc1a45f4a63450e88fe31bb0f9ed42a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616068060630-5d0eeb72-5a55-48c4-8e60-1e0f2cd4afed.png" width="960" id="vDTUe" class="ne-image"></p><h3 id="bSGRp"><span class="ne-text">offset 与 style 区别</span></h3><p id="6a55eaccfed38649cc21117e5188379d" class="ne-p"><span class="ne-text">【1】offset</span></p><ul class="ne-ul"><li id="19b80b40c0d93db5921d4e2a5dd57cbf"><span class="ne-text">offset 可以得到任意样式表中的样式值</span></li><li id="472fbc5f93fa8202921c835c0aef7e0d"><span class="ne-text">offset 系列获得的数值是没有单位的</span></li><li id="62831ab59bf214609f66206ec149bb0c"><strong><span class="ne-text">offsetWidth 包含padding+border+width</span></strong></li><li id="78961a0400789377e9c4aa8fd24fdbb9"><span class="ne-text">offsetWidth 等属性是只读属性，只能获取不能赋值</span></li></ul><div class="ne-quote"><p id="1523e9b0b35faa85b2afa8c48b8bc5e3" class="ne-p"><span class="ne-text">所以，我们想要获取元素大小位置，用offset更合适</span></p></div><p id="9a2fd986d8e6d296472c65bc1fac8027" class="ne-p"><span class="ne-text">【2】style</span></p><ul class="ne-ul"><li id="5057a864781691a453dd2f734536745c"><span class="ne-text">style 只能得到</span><strong><span class="ne-text">行内样式表中的样式值</span></strong></li><li id="9132c2eb2eec95a33ecef6f05ca8adad"><span class="ne-text">style.width 获得的是带有单位的字符串</span></li><li id="963ea56ee346a6837c51db20ec33bb1c"><span class="ne-text">style.width 获得不包含padding和border 的值</span></li><li id="fc17c23b46fd9e61e6d8867164683691"><span class="ne-text">style.width 是可读写属性，可以获取也可以赋值</span></li></ul><div class="ne-quote"><p id="cca2d9ac6e73fc7f9112699f811e3a05" class="ne-p"><span class="ne-text">所以，我们想要给元素更改值，则需要用style改变</span></p><p id="61dea57ac71828ab38f85fc6138b1f75" class="ne-p"><strong><span class="ne-text">因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes</span></strong></p></div><h3 id="Pb3tt"><span class="ne-text">Demo：获取鼠标在盒子内的坐标</span></h3><p id="7f574ec0cc308e9e438fb0bb00a3c234" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616069445575-c9a9b51d-665d-4f26-96bb-768a9415a230.png" width="960" id="OSAx3" class="ne-image"></p><p id="cb704cfbae779d2f31f6eaef4a4bf96d" class="ne-p"><br></p><pre data-language="javascript" id="CNqFs" class="ne-codeblock language-javascript">box.addEventListener('mousemove',function(e){<p>if(e.pageX &gt; (box_left + box.width)){<br>var ture_width = e.pageX - box_left +box_width;<br>} else {var ture_width = e.pageX - box_left;}<br>if(e.pageY &gt; (box_top + box_height)){<br>var ture_height = e.pageY - box_top + box_height;<br>}else {var ture_height = e.pageY - box_top;}<br>this.innerHTML = ‘x 坐标是’ + ture_width + ‘ y 坐标是’ + ture_height;<br>})</pre><h3 id="1tFb7"><span class="ne-text">Demo：模态框拖拽</span></h3><p id="7703a12f10c24691471bf77aa4c49085" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616210051320-8b04d6a8-efc0-4a78-a985-80fdc0a0c238.png" width="960" id="BpD78" class="ne-image"></p><p id="dea71cdd071adbfc45d6797c9b64e514" class="ne-p"><br></p><pre data-language="html" id="8zDvn" class="ne-codeblock language-html"><!DOCTYPE html></p><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title>    <style>        * {            padding: 0px;            margin: 0px;        }        a {            text-decoration: none;            color: #000000;        }        .login-header {            width: 100%;            text-align: center;            height: 30px;            line-height: 30px;            font-size: 24px;        }        .login-bg {            display: none;            width: 100%;            height: 100%;            position: fixed;            top: 0px;            left: 0px;            background: rgba(0, 0, 0, .3);        }        .login {            display: none;            width: 512px;            height: 280px;            position: fixed;            left: 50%;            top: 50%;            z-index: 9999;            border: #ebebeb solid 1px;            background-color: #ffffff;            box-shadow: 0px 0px 20px #ddd;            transform: translate(-50%, -50%);        }        .login-title {            width: 100%;            margin: 10px 0 0 0;            text-align: center;            line-height: 40px;            height: 40px;            font-size: 18px;            position: relative;            cursor: move;        }        .login-title span {            position: absolute;            width: 40px;            height: 40px;            font-size: 12px;            background: #ffffff;            border: #ebebeb solid 1px;            right: -20px;            top: -30px;            border-radius: 50%;        }        .login-input-content {            margin: 20px 0 0 0;        }        .login-input {            overflow: hidden;            margin: 0px 0px 20px 0px;        }        .login-input label {            float: left;            width: 90px;            padding-right: 10px;            text-align: right;            line-height: 35px;            height: 35px;            font-size: 14px;        }        .login-input input.list-input {            float: left;            line-height: 35px;            height: 35px;            width: 350px;            border: #ebebeb 1px solid;            text-indent: 5px;        }        .login-input input.button-login {            display: block;            border: 1px #ebebeb solid;            height: 35px;            width: 50%;            margin: 20px auto;        }    </style></head><body>    <div class="login-header"><a id="link" href="javascript:;">点击，弹出登录框</a></div>    <div id="loginBg" class="login-bg"></div>    <div id="login" class="login">        <div class="login-title" >登录会员            <span><a id="closeBtn" href="javascript:; " class="close-login">关闭</a></span>        </div>        <div class="login-input-content">            <div class="login-input">                <label>用户名：</label>                <input type="text" placeholder="请输入用户名" name="info[username]" id="username" class="list-input">            </div>            <div class="login-input">                <label>登录密码：</label>                <input type="password" placeholder="请输入登录密码" name="info[password]" id="password" class="list-input">            </div>            <div class="login-input">                <input type="button" class="button-login" value="登录会员"/>            </div>        </div>    </div>    <script>        var link = document.getElementById('link');        var loginBg = document.getElementById('loginBg');        var login = document.getElementById('login');        var closeBtn = document.getElementById('closeBtn');        link.addEventListener('click',function(){            loginBg.style.display = 'block';            login.style.display = 'block';        })        closeBtn.addEventListener('click',function(){            loginBg.style.display = 'none';            login.style.display = 'none';        })        login.addEventListener('mousedown', function(e){            var x = e.pageX - login.offsetLeft;            var y = e.pageY - login.offsetTop;            document.addEventListener('mousemove', move)<pre><code>        function move(e) &#123;            login.style.left = e.pageX - x + &#39;px&#39;;            login.style.top = e.pageY - y + &#39;px&#39;;        &#125;        document.addEventListener(&#39;mouseup&#39;, function() &#123;            document.removeEventListener(&#39;mousemove&#39;, move);        &#125;)    &#125;)&lt;/script&gt;</code></pre></body></html></pre><h2 id="7Q7rO"><span class="ne-text">元素可视区 client 系列</span></h2><h3 id="AU5zq"><span class="ne-text">client概述</span></h3><p id="a91bac5ac636ce9279f978baad74e250" class="ne-p"><span class="ne-text">client 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client</span></p><p id="161a8bbf651f3b800685c7d09893881a" class="ne-p"><span class="ne-text">系列的相关属性可以动态的得到该元素的边框大小、元素大小等。</span></p><p id="9a60f89df4ce3a5748ffe44c6c93c691" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070278053-25f4dbb3-2991-4ce4-b1ec-cb3a94f80c0c.png" width="515" id="u4HFg" class="ne-image"></p><p id="1e9256a55dabac26adc47632fd07593f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070286487-4d2a07f6-46b7-4af4-be5c-134ac01d6b48.png" width="286" id="n6sG4" class="ne-image"></p><p id="54195d8a856e36eb32657382a9ab3193" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070508648-c56b354b-77e7-4afb-9072-0385ac38782f.png" width="960" id="uEuaD" class="ne-image"></p><p id="abbed13e0bc0e9346de8b3b3b7bedffd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070554658-21dea2fb-5942-4f60-9205-71bc2a022a79.png" width="960" id="QhNXz" class="ne-image"></p><p id="cec95b197ba5e813d4a2367ac24f8a77" class="ne-p"><br></p><h3 id="Gn6hw"><span class="ne-text">淘宝 flexible.js 源码分析</span></h3><ul class="ne-ul"><li id="7227529bd0b0bf7a89cf0880c53e7ff8"><span class="ne-text">立即执行函数 (function(){})()  或者 (function(){}())</span></li><li id="022bd01f7149e6e34ebb9866225fc691"><span class="ne-text">主要作用： 创建一个独立的作用域。 避免了命名冲突问题</span></li><li id="87cbbe9eeda8bef197cc70b40c967214"><span class="ne-text">下面三种情况都会刷新页面都会触发 load 事件。</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="05d6a1e6b1d87666ce8b4b637d1c0024"><span class="ne-text">a标签的超链接</span></li><li id="c4ac24d03f554cc433d81923c4f6404e"><span class="ne-text">F5或者刷新按钮（强制刷新）</span></li><li id="1b0579a1cf9f7226ca0337a091665148"><span class="ne-text">前进后退按钮</span></li></ul></ul><div class="ne-quote"><p id="9d40d33a120d5ec57cde5b477a991f02" class="ne-p"><span class="ne-text">但是 火狐中，有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态；实际上是将整个页面都保存在了内存里。</span></p></div><p id="36c7cc356274b5fc59aa881db8f5d00f" class="ne-p"><span class="ne-text">所以此时后退按钮不能刷新页面。</span></p><p id="6bf724d20555e5f8d1e2811e9bba70ef" class="ne-p"><br></p><p id="269f37cea8b590146f3c8840bb360aa3" class="ne-p"><span class="ne-text">此时可以使用 pageshow事件来触发。，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow会在load事件触发后触发；根据事件对象中的persisted来判断是否是缓存中的页面触发的pageshow事件</span></p><p id="785180c496f22b98d41ef081092e5601" class="ne-p"><br></p><p id="fda309f83465cbabb7e3c8e1a11448d5" class="ne-p"><code class="ne-code"><span class="ne-text">注意这个事件给window添加。</span></code></p><pre data-language="javascript" id="otIEo" class="ne-codeblock language-javascript">(function flexible(window, document) {    // 获取的html 的根元素    var docEl = document.documentElement        // dpr 物理像素比    var dpr = window.devicePixelRatio || 1<pre><code>// adjust body font size  设置我们body 的字体大小function setBodyFontSize() &#123;    // 如果页面中有body 这个元素 就设置body的字体大小    if (document.body) &#123;        document.body.style.fontSize = (12 * dpr) + &#39;px&#39;    &#125; else &#123;        // 如果页面中没有body 这个元素，则等着 我们页面主要的DOM元素加载完毕再去设置body        // 的字体大小        document.addEventListener(&#39;DOMContentLoaded&#39;, setBodyFontSize)    &#125;&#125;setBodyFontSize();// set 1rem = viewWidth / 10    设置我们html 元素的文字大小function setRemUnit() &#123;    var rem = docEl.clientWidth / 10    docEl.style.fontSize = rem + &#39;px&#39;&#125;setRemUnit()// reset rem unit on page resize  当我们页面尺寸大小发生变化的时候，要重新设置下rem 的大小window.addEventListener(&#39;resize&#39;, setRemUnit)    // pageshow 是我们重新加载页面触发的事件window.addEventListener(&#39;pageshow&#39;, function(e) &#123;    // e.persisted 返回的是true 就是说如果这个页面是从缓存取过来的页面，也需要从新计算一下rem 的大小    if (e.persisted) &#123;        setRemUnit()    &#125;&#125;)// detect 0.5px supports  有些移动端的浏览器不支持0.5像素的写法if (dpr &gt;= 2) &#123;    var fakeBody = document.createElement(&#39;body&#39;)    var testElement = document.createElement(&#39;div&#39;)    testElement.style.border = &#39;.5px solid transparent&#39;    fakeBody.appendChild(testElement)    docEl.appendChild(fakeBody)    if (testElement.offsetHeight === 1) &#123;        docEl.classList.add(&#39;hairlines&#39;)    &#125;    docEl.removeChild(fakeBody)&#125;</code></pre><p>}(window, document))</pre><h2 id="PqA5S"><span class="ne-text">元素滚动 scroll 系列</span></h2><h3 id="uEzrT"><span class="ne-text">scroll 概述</span></h3><p id="638e3b34f6caa099a0edf7b5a65b0af1" class="ne-p"><span class="ne-text">scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。</span></p><p id="47ab09402ec4a49ea25b37f343438e9a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070606903-ad20b10d-b146-4d60-bcc8-b202127dbac2.png" width="528" id="Av8YH" class="ne-image"></p><p id="813d034c7681beaff60c2c89d34e352b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070615035-e5456585-8b3a-4c5a-8e1d-e4affd0e7fd2.png" width="210.5" id="fltiA" class="ne-image"></p><h3 id="sLsqC"><span class="ne-text">页面被卷去的头部</span></h3><p id="c0d8982276e0f7ca23cdc0ce56da1a37" class="ne-p"><span class="ne-text">如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 onscroll 事件。</span></p><h3 id="Dqr96"><span class="ne-text">页面被卷去的头部兼容性解决方案</span></h3><p id="b318cfaf793624daec91cc06ba25f643" class="ne-p"><span class="ne-text">需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法：</span></p><ol class="ne-ol"><li id="356f947a4302c52a189979f43eabf741"><span class="ne-text">声明了 DTD，使用 document.documentElement.scrollTop</span></li><li id="a1a223829ec3e48a0c6aba5b97e2868a"><span class="ne-text">未声明 DTD，使用   document.body.scrollTop</span></li><li id="92a572b59b8eeb2cce92afde520f3473"><span class="ne-text">新方法 window.pageYOffset 和 window.pageXOffset，IE9 开始支持</span></li><li id="c58b60ef3d06bf9dcd277f4d577ef68e"><span class="ne-text">微信里面浏览也会有相关兼容性的问题，所以需要兼容行解决</span></li></ol><pre data-language="javascript" id="cdk9B" class="ne-codeblock language-javascript">function getScroll() {<br>return {<br>left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft||0,<br>top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0<br>};<br>}<br>使用的时候 getScroll().left</pre><h2 id="FEDmA"><span class="ne-text">三大系列总结</span></h2><p id="86f5e62f6f9edd4094dd4b359c198a13" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070740695-1045516b-2b85-4697-874b-32fe2b1cbe5b.png" width="552.5" id="vDeiC" class="ne-image"></p><p id="ffde75e13e6d47892886298e95cf6928" class="ne-p"><span class="ne-text">他们主要用法：</span></p><ol class="ne-ol"><li id="8bb793eb49617b5d37e26b3da9dca410"><span class="ne-text">offset 系列 经常用于获得元素位置     offsetLeft  offsetTop</span></li><li id="518920d7f27dba5b0dae28fab3815575"><span class="ne-text">client 经常用于获取元素大小   clientWidth clientHeight</span></li><li id="e4d34e79eee5492714edb409bf794112"><span class="ne-text">scroll 经常用于获取滚动距离  scrollTop  scrollLeft</span></li><li id="438f9bd58d52a3ddffb608858e428e0d"><span class="ne-text">注意页面滚动的距离通过 window.pageXOffset   获得</span></li></ol><h2 id="r7BDm"></h2><h2 id="3Ynw6"></h2></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DOM节点操作</title>
      <link href="/blog/2_day02_webapis/"/>
      <url>/blog/2_day02_webapis/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="mk5K8"><span class="ne-text">节点概述</span></h3><p id="dc7f4e6b1cd6d40ca4a311ae5b67c390" class="ne-p"><span class="ne-text">网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。</span></p><p id="4d787dc172fdd79c5539a2cd6577c735" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358489-a0521202-b32d-46a9-9b8d-f0cfe9afc455.png" width="432" id="m41li" class="ne-image"></p><p id="c6ee72606a158be15bb6368a12996e6c" class="ne-p"><span class="ne-text">    一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</span></p><p id="de51f2d38fac0c9a1eac755aeb99bac5" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358548-9283575f-7aef-450d-bc6e-b9d3a4384cc2.png" width="666" id="u8PE0" class="ne-image"></p><div class="ne-quote"><p id="24bed889a829869f109e4f3e77a13507" class="ne-p"><span class="ne-text">节点层级：</span><span class="ne-text" style="background-color: transparent">利用 DOM 树可以把节点划分为不同的层级关系，常见的是</span><strong><span class="ne-text">父子兄层级关系</span></strong><span class="ne-text" style="background-color: transparent">。</span></p></div><h2 id="JLpsj"><span class="ne-text">父节点</span></h2><h3 id="AcNO7"><span class="ne-text">node.parentNode</span></h3><ul class="ne-ul"><li id="214d3250d71e594490fe6d85ed4fd06c"><span class="ne-text">返回某节点的父节点，最近的一个父节点</span></li><li id="19c44750b461e686d3a7b36c6c520389"><span class="ne-text">如果没有父节点，则返回null</span></li></ul><p id="3598457b7bfbb4f1400b4003bcb8d0fe" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616056309357-b2a256d0-2a4d-4983-80f9-1eed069c3890.png" width="960" id="RV3TK" class="ne-image"></p><h2 id="YKxQz"><span class="ne-text">子节点</span></h2><h3 id="xzVW4"><span class="ne-text">parentNode.childNodes</span></h3><ul class="ne-ul"><li id="d2468443d1f99250be50717ff123dd78"><span class="ne-text">返回指定节点的子节点的集合，会即时更新</span></li><li id="20988a9f7f831fe4b48859299f30b821"><span class="ne-text">会返回所有的节点（包含元素节点、文本节点等）</span></li></ul><p id="f695e5b6acc6dd337f9481e12d8c5f44" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616056553404-55b8fe19-9bea-413d-9cb1-6554380831af.png" width="960" id="V1IMU" class="ne-image"></p><h3 id="JUL3j"><span class="ne-text">parentNode.children</span></h3><ul class="ne-ul"><li id="cfd68b72ad47b9384c688dfb234a686e"><span class="ne-text">只读属性</span></li><li id="14d127abf548bffd5c4bf60c0d8f264e"><span class="ne-text">只返回元素节点</span></li><li id="9e055b1e452900d2c2f436fe73549e96"><span class="ne-text">非标准，但是各个浏览器都支持</span></li></ul><p id="02dbc621d526400a9fc369764443db25" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616056710609-4bb68282-b6ae-4240-b9be-a9faea530ab2.png" width="960" id="ETIGI" class="ne-image"></p><p id="7b0f909b7e33e289761ac8692ed8e3bf" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616057002507-4244db60-7bf0-4e95-b68b-acb4d4d62d8d.png" width="960" id="SeFkp" class="ne-image"></p><h3 id="8BZkY"><span class="ne-text">parent.firstChild</span></h3><p id="94055100bdfc122d67577e163d597c1e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616057242192-2bb01e66-de7d-4220-afc2-499adbdcc3de.png" width="960" id="AABqT" class="ne-image"></p><ul class="ne-ul"><li id="cc4b16e24523b5e81ed4ddf28ad1b2ca"><span class="ne-text">返回第一个子节点，找不到返回null，包含所有节点</span></li></ul><h3 id="7u8YN"><span class="ne-text">parent.lastChild</span></h3><ul class="ne-ul"><li id="b0bb21926aa0f08aafacdc611c0905e1"><span class="ne-text">返回最后一个子节点，找不到返回null，包含所有节点</span></li></ul><h3 id="ZVCAx"><span class="ne-text">parent.firstElementChild</span></h3><ul class="ne-ul"><li id="2546240e4abb5957d6d47ec52e05a2d0"><span class="ne-text">返回第一个子元素节点，找不到返回null</span></li><li id="d02e585bb29e669b962d666aa2e2d2c9"><span class="ne-text">IE9以上支持</span></li></ul><h3 id="VZX5Y"><span class="ne-text">parent.lastElementChild</span></h3><ul class="ne-ul"><li id="b5df47c0827866d5a2158d076685e62d"><span class="ne-text">返回最后一个子元素节点，找不到返回null</span></li><li id="9dc8087686e7a330c54e0b2751448eac"><span class="ne-text">IE9以上支持</span></li></ul><h3 id="8cKJW"><span class="ne-text">首末节点兼容方案</span></h3><div class="ne-quote"><p id="ad42fb7dbeabf149dbad3d2a82077ce5" class="ne-p"><span class="ne-text">实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何</span><span class="ne-text" style="background-color: #FADB14">获取第一个子元素节点或最后一个子元素节点</span><span class="ne-text">呢？</span></p></div><p id="515f8306e2c8718e01a2221f9466258e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616057537841-77a6605b-5d29-4cf2-b750-0cd916841cdd.png" width="960" id="zmR8s" class="ne-image"></p><h2 id="NWCvP"><span class="ne-text">兄弟节点</span></h2><p id="3e6d008f6fb317b408d07babc65f55af" class="ne-p"><strong><span class="ne-text">下一个兄弟节点</span></strong></p><p id="b94982616ed9363bc290bb1052cd75cf" class="ne-p"><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973538696.png" id="Fmrev" class="ne-image"></p><p id="8f8fe743b4bc1872fdc564c667ce2332" class="ne-p"><strong><span class="ne-text">上一个兄弟节点</span></strong></p><p id="d18faf12e39d18e226d625bc07f1bf1e" class="ne-p"><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973558511.png" id="iqUXH" class="ne-image"></p><pre data-language="javascript" id="Zk1wp" class="ne-codeblock language-javascript"><div>我是div</div><pre><code>&lt;span&gt;我是span&lt;/span&gt;&lt;script&gt;    var div = document.querySelector(&#39;div&#39;);    // 1.nextSibling 下一个兄弟节点 包含元素节点或者 文本节点等等    console.log(div.nextSibling);    console.log(div.previousSibling);    // 2. nextElementSibling 得到下一个兄弟元素节点    console.log(div.nextElementSibling);    console.log(div.previousElementSibling);&lt;/script&gt;&lt;/pre&gt;&lt;p id=&quot;2954658347162a9881591549390e610c&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;下一个兄弟元素节点（有兼容性问题）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p id=&quot;0e1a245336e0edf9e4950e49e0c9c9b0&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973610223.png&quot; id=&quot;ZByAF&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;p id=&quot;7afee902c6ad421a1412cf4081e5dfd7&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;上一个兄弟元素节点（有兼容性问题）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p id=&quot;e569f5d7ab198f09c62ddf90cd8b74a9&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973630150.png&quot; id=&quot;lHwA1&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;p id=&quot;4516a008fb10406165b70b2882c672c0&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973722805.png&quot; id=&quot;SByYv&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;p id=&quot;14a9fcb3460bf0f1e9ecaaa268bcb09e&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973799759.png&quot; id=&quot;GbWgS&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;pre data-language=&quot;javascript&quot; id=&quot;7mP9P&quot; class=&quot;ne-codeblock language-javascript&quot;&gt;function getNextElementSibling(element) &#123;  var el = element;  while (el = el.nextSibling) &#123;    if (el.nodeType === 1) &#123;        return el;    &#125;  &#125;  return null;&#125;&lt;/pre&gt;&lt;h2 id=&quot;W9ils&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;创建结点&lt;/span&gt;&lt;/h2&gt;&lt;h3 id=&quot;ha59o&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;document.createElement()&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;96c84d1efcad0c3e5dd844371a1dcb73&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;document.createElement(&#39;tagName&#39;)&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;b4f5eef18cc8513ff6b060ef837d78ab&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;动态创建元素节点&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;x1qgY&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;node.cloneNode()&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;2ddb4ee68a31ece5931b994700e347ed&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359854-90c1339a-ca41-47e5-86b1-189336c186d3.png&quot; width=&quot;726&quot; id=&quot;qNYYA&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;pre data-language=&quot;html&quot; id=&quot;3q3OE&quot; class=&quot;ne-codeblock language-html&quot;&gt;&lt;ul&gt;    &lt;li&gt;1111&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    var ul = document.querySelector(&#39;ul&#39;);    // 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容    // 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容    var lili = ul.children[0].cloneNode(true);    ul.appendChild(lili);&lt;/script&gt;&lt;/pre&gt;&lt;h3 id=&quot;O6pmN&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;Demo：动态生成表格&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;5f8dc010dd93f6a2a266cd688a4113c4&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359913-8e1af74d-0a30-4370-83ea-4974ad83d2b8.png&quot; width=&quot;718&quot; id=&quot;ykYr0&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;p id=&quot;8d005f91d480eadcff03e6605ddcec4f&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359980-7b2a19b1-47dd-41cb-8f9b-93d64873fb6f.png&quot; width=&quot;751&quot; id=&quot;SuO9z&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;pre data-language=&quot;html&quot; id=&quot;Lluj0&quot; class=&quot;ne-codeblock language-html&quot;&gt;&lt;script&gt;    // 1.先去准备好学生的数据    var datas = [&#123;        name: &#39;魏璎珞&#39;,        subject: &#39;JavaScript&#39;,        score: 100    &#125;, &#123;        name: &#39;弘历&#39;,        subject: &#39;JavaScript&#39;,        score: 98    &#125;, &#123;        name: &#39;傅恒&#39;,        subject: &#39;JavaScript&#39;,        score: 99    &#125;, &#123;        name: &#39;明玉&#39;,        subject: &#39;JavaScript&#39;,        score: 88    &#125;, &#123;        name: &#39;大猪蹄子&#39;,        subject: &#39;JavaScript&#39;,        score: 0    &#125;];    // 2. 往tbody 里面创建行： 有几个人（通过数组的长度）我们就创建几行    var tbody = document.querySelector(&#39;tbody&#39;);    // 遍历数组    for (var i = 0; i &lt; datas.length; i++) &#123;        // 1. 创建 tr行        var tr = document.createElement(&#39;tr&#39;);        tbody.appendChild(tr);        // 2. 行里面创建单元格td 单元格的数量取决于每个对象里面的属性个数        // 使用for in遍历学生对象        for (var k in datas[i]) &#123;            // 创建单元格            var td = document.createElement(&#39;td&#39;);            // 把对象里面的属性值 datas[i][k] 给 td            td.innerHTML = datas[i][k];            tr.appendChild(td);        &#125;        // 3. 创建有删除2个字的单元格        var td = document.createElement(&#39;td&#39;);        td.innerHTML = &#39;&lt;a href=&quot;javascript:;&quot;&gt;删除 &lt;/a&gt;&#39;;        tr.appendChild(td);    &#125;    // 4. 删除操作 开始    var as = document.querySelectorAll(&#39;a&#39;);    for (var i = 0; i &lt; as.length; i++) &#123;        as[i].onclick = function() &#123;            // 点击a 删除 当前a 所在的行(链接的爸爸的爸爸)  node.removeChild(child)            tbody.removeChild(this.parentNode.parentNode)        &#125;    &#125;&lt;/script&gt;&lt;/pre&gt;&lt;h3 id=&quot;6oHgk&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;创建元素的三种方式对比&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;2479c525a97b45574e75871c79bf64b3&quot; class=&quot;ne-p&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360041-a233aa10-7238-46f4-bb78-2438898c8950.png&quot; width=&quot;759&quot; id=&quot;s3h0H&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;pre data-language=&quot;html&quot; id=&quot;xU8oX&quot; class=&quot;ne-codeblock language-html&quot;&gt;&lt;script&gt;    // 三种创建元素方式区别    // 1. document.write() 创建元素  如果页面文档流加载完毕，再调用这句话会导致页面重绘     var btn = document.querySelector(&#39;button&#39;);     btn.onclick = function() &#123;         document.write(&#39;&lt;div&gt;123&lt;/div&gt;&#39;);     &#125;    // 2. innerHTML 创建元素    var inner = document.querySelector(&#39;.inner&#39;);     for (var i = 0; i &lt;= 100; i++) &#123;         inner.innerHTML += &#39;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#39;     &#125;    var arr = [];    for (var i = 0; i &lt;= 100; i++) &#123;        arr.push(&#39;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#39;);    &#125;    inner.innerHTML = arr.join(&#39;&#39;);    // 3. document.createElement() 创建元素    var create = document.querySelector(&#39;.create&#39;);    for (var i = 0; i &lt;= 100; i++) &#123;        var a = document.createElement(&#39;a&#39;);        create.appendChild(a);    &#125;&lt;/script&gt;&lt;/pre&gt;&lt;div class=&quot;ne-quote&quot;&gt;&lt;p id=&quot;66bb89d7710225bfbcb10f876f9b3ed4&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;innerTHML和createElement效率对比&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;p id=&quot;44edf8c2da4b84868603d0dcd99d1ab0&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;innerHTML字符串拼接方式（效率低）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre data-language=&quot;html&quot; id=&quot;QtcSJ&quot; class=&quot;ne-codeblock language-html&quot;&gt;&lt;script&gt;function fn() &#123;    var d1 = +new Date();    var str = &#39;&#39;;    for (var i = 0; i &lt; 1000; i++) &#123;        document.body.innerHTML += &#39;&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;&#39;;    &#125;    var d2 = +new Date();    console.log(d2 - d1);&#125;fn();</code></pre><p></script></pre><p id="2b823e413e8e01c50ad79dac0acf1a9d" class="ne-p"><strong><span class="ne-text">createElement 方式（效率一般）</span></strong></p><pre data-language="html" id="nkV46" class="ne-codeblock language-html"><script><br>function fn() {<br>var d1 = +new Date();<br>for (var i = 0; i < 1000; i++) {<br>var div = document.createElement('div');<br>div.style.width = '100px';<br>div.style.height = '2px';<br>div.style.border = '1px solid red';<br>document.body.appendChild(div);<br>}<br>var d2 = +new Date();<br>console.log(d2 - d1);<br>}<br>fn();<br></script></pre><p id="0166dfeb770e51b004795669737cf141" class="ne-p"><strong><span class="ne-text">innerHTML 数组方式（效率高）</span></strong></p><pre data-language="html" id="yeOgB" class="ne-codeblock language-html"><script><br>function fn() {<br>var d1 = +new Date();<br>var array = [];<br>for (var i = 0; i < 1000; i++) {<br>array.push('<div style="width:100px; height:2px; border:1px solid blue;"></div>');<br>}<br>document.body.innerHTML = array.join('');<br>var d2 = +new Date();<br>console.log(d2 - d1);<br>}<br>fn();<br></script></pre><h2 id="Xq4N9"><span class="ne-text">插入结点</span></h2><h3 id="QVxNQ"><span class="ne-text">node.appendChild()</span></h3><ul class="ne-ul"><li id="649946c80ab704b81055977fe71e029f"><span class="ne-text">node.appendChild(child)</span></li><li id="4f432e38d2e122cb48b2e2fec8e556d3"><span class="ne-text">添加到父节点的子节点列表末尾</span></li></ul><h3 id="PxnWx"><span class="ne-text">node.insertBefore()</span></h3><ul class="ne-ul"><li id="b13792234f4f581423280656bbe0e915"><span class="ne-text">node.insertBefore(child,指定元素)</span></li><li id="52a2ece9f61e782d5b10f54cd394899d"><span class="ne-text">将一个节点添加到父节点的指定子节点前面</span></li></ul><p id="217e22c13038952a26b6badb974d07f1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616058396292-0ab90d78-37b9-4851-96bf-2e2bf5fb13cd.png" width="960" id="TYlXP" class="ne-image"></p><h3 id="juCJS"><span class="ne-text">Demo：简单版发布留言</span></h3><p id="10ac85b13821f565506d3ba166fd4b81" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359458-b8cd80e8-0c64-4c8f-8d76-2cfcdbce3f48.png" width="337" id="fwxL4" class="ne-image"></p><p id="25c21382339a2bec5d7986e102f1f234" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359516-1b352ba3-c851-49d8-aeff-5af5668b1d71.png" width="727" id="Azxna" class="ne-image"></p><pre data-language="html" id="dtrC2" class="ne-codeblock language-html"><body></p><textarea name="" id=""></textarea><p><button>发布</button></p><ul></ul><script>// 1. 获取元素var btn = document.querySelector('button');var text = document.querySelector('textarea');var ul = document.querySelector('ul');// 2. 注册事件btn.onclick = function() {if (text.value == '') {alert('您没有输入内容');return false;} else {// console.log(text.value);// (1) 创建元素var li = document.createElement('li');// 先有 li 才能赋值li.innerHTML = text.value;// (2) 添加元素// ul.appendChild(li);ul.insertBefore(li, ul.children[0]);}}</script></body></pre><h2 id="4G5LG"><span class="ne-text">删除节点</span></h2><h3 id="dOGTN"><span class="ne-text">node.removeChild() </span></h3><ul class="ne-ul"><li id="32b7446bc5896ab43803da93d378e39c"><span class="ne-text">node.removeChild() 方法从 node节点中删除一个子节点，返回删除的节点。</span></li></ul><p id="a6d0a5c7e259c75180d2fd3d8ffaf67f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616060281051-79e7f85a-572a-4e31-b204-b5dbdaff1e60.png" width="960" id="eMnK9" class="ne-image"></p><h3 id="77XYl"><span class="ne-text">Demo：删除留言</span></h3><p id="bc2225f5b9f4ac124db30f4b695235c6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359732-302df5c2-5149-4e89-89dd-e99586f91651.png" width="361" id="FdDfh" class="ne-image"></p><p id="4e195b3ce00a4a21dc50d84ac9396486" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359795-1a54681c-6264-48c2-a670-28b1f41c4388.png" width="718" id="aRDNj" class="ne-image"></p><pre data-language="html" id="VthsM" class="ne-codeblock language-html"><textarea name="" id=""></textarea>    <button>发布</button>    <ul>    </ul>    <script>        // 1. 获取元素        var btn = document.querySelector('button');        var text = document.querySelector('textarea');        var ul = document.querySelector('ul');        // 2. 注册事件        btn.onclick = function() {            if (text.value == '') {                alert('您没有输入内容');                return false;            } else {                // console.log(text.value);                // (1) 创建元素                var li = document.createElement('li');                // 先有li 才能赋值                li.innerHTML = text.value + "<a href='javascript:;'>删除</a>";                // (2) 添加元素                // ul.appendChild(li);                ul.insertBefore(li, ul.children[0]);                // (3) 删除元素 删除的是当前链接的li  它的父亲                var as = document.querySelectorAll('a');                for (var i = 0; i < as.length; i++) {                    as[i].onclick = function() {                        // 删除的是 li 当前a所在的li  this.parentNode;                        ul.removeChild(this.parentNode);                    }                }            }        }    </script></pre><p id="da21939b8aebd1ca3f149d196b4790e4" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> DOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DOM元素操作</title>
      <link href="/blog/1_day01_webapis/"/>
      <url>/blog/1_day01_webapis/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="kXvnu"><span class="ne-text">API和Web API和SDK</span></h2><ul class="ne-ul"><li id="u558b1200"><span class="ne-text">文档：</span><a href="https://developer.mozilla.org/zh-CN/docs/Web/API" data-href="https://developer.mozilla.org/zh-CN/docs/Web/API" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/API</span></a></li></ul><p id="46a55321a1895c69fde7aeab23a2c28b" class="ne-p"><br></p><div data-type="color2" class="ne-alert"><p id="5291c3b97996b679982429fc3397629f" class="ne-p" style="text-indent: 2em"><span class="ne-text">API（Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，无需理解其内部工作机制细节，只需直接调用使用即可。</span></p><p id="ub0b15aa9" class="ne-p" style="text-indent: 2em"><span class="ne-text">Web API 是浏览器提供的一套操作浏览器功能和页面元素的 API ( BOM 和 DOM )。</span></p><p id="u84e7cb00" class="ne-p" style="text-indent: 2em"><a href="https://www.zhihu.com/question/21691705" data-href="https://www.zhihu.com/question/21691705" target="_blank" class="ne-link"><span class="ne-text">https://www.zhihu.com/question/21691705</span></a></p></div><p id="u40e389be" class="ne-p"><br></p><h2 id="93oSV"><span class="ne-text">DOM总结</span></h2><p id="d2dc6ed3d0cf7e566d27b3c1e4796553" class="ne-p"><span class="ne-text">关于dom操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。</span></p><p id="e36c44b913505a074d5c2745fd5745ac" class="ne-p"><span class="ne-text">【1】创建</span></p><p id="4c7cd54fd8ba33513a77991fcd6544b4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360222-db94e8d0-f9a7-459d-8a24-88b745237bd5.png" width="691" id="FDEjx" class="ne-image"></p><p id="9c3c4b00d6fd2ce9decc0d669bbf0f93" class="ne-p"><span class="ne-text">【2】增</span></p><p id="436b5b59f684285797cce52197a750d1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360287-480d224a-a047-4ef5-8bba-92845d85b573.png" width="720" id="ITVoj" class="ne-image"></p><p id="bb9372eb5deae8f74ce73ee55ec42aeb" class="ne-p"><span class="ne-text">【3】删</span></p><p id="87d68c0fd85fae7f741af7d4d6778d1a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360367-4e96254b-5fd8-4f7e-8fb3-29143718f08d.png" width="695" id="Y43N0" class="ne-image"></p><p id="4d144f96f196a9852cc6bd0e3ff55001" class="ne-p"><span class="ne-text">【4】改</span></p><p id="7a6028416e906114f423e37858dd2e3d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360436-7e94f916-24d1-4e97-84fe-6fc6ba6d68fb.png" width="731" id="Ex39g" class="ne-image"></p><p id="b062b8089a2b2862cea420f46547a800" class="ne-p"><span class="ne-text">【5】查</span></p><p id="8d43f07d6e7a91d895c47a6ad35de70d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360497-cfec4566-ac5b-46c6-995d-8db307167137.png" width="703" id="mmFdZ" class="ne-image"></p><p id="baa1abc359c4fffb9cbcdfa99aaf3ee7" class="ne-p"><span class="ne-text">【6】属性操作</span></p><p id="3f836afe6696cf03b355adb074be23f2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360564-6e2cf7dd-fa5e-48fe-bcdb-be69ea87065c.png" width="722" id="MIdFD" class="ne-image"></p><p id="f0172a463e96ea8908580ce1583d5829" class="ne-p"><span class="ne-text">【7】事件操作（重点）</span></p><h2 id="aSkft"><span class="ne-text">获取元素</span></h2><h3 id="y6ztq"><span class="ne-text">getElementById</span></h3><ul class="ne-ul"><li id="f1719c4402fcb59e9d3cf73ec34ba38a"><span class="ne-text">语法：document.getElementById(id)</span></li><li id="12217790a54ad508927771e6a7efdb6c"><span class="ne-text">作用：根据ID获取元素对象</span></li><li id="a23e203313e0d34ba7bf8c0bf1d839e6"><span class="ne-text">参数：id值，区分大小写的字符串</span></li><li id="3be95e2cc1b6817bda44d4fabb3d1d92"><span class="ne-text">返回值：元素对象 或 null</span></li></ul><p id="461243afee13281b53efe612e95b95d6" class="ne-p"><strong><span class="ne-text"></span></strong></p><pre data-language="javascript" id="o5DlG" class="ne-codeblock language-javascript">var test_id = document.getElementById('indexLogo');</pre><p id="294ffa847e4baf68230cb7b07bbe1024" class="ne-p"><br></p><p id="3cb570bd77d18b6f22da38d9472c4acc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616048539813-60fc22f6-0d07-482c-aaae-0227b1f55206.png" width="458" id="N8Ltb" class="ne-image"></p><h3 id="iE8k5"><span class="ne-text">getElementsByTagName</span></h3><ul class="ne-ul"><li id="569cbc6c9f38397aabc6b1f3c5f6fea3"><span class="ne-text">语法：document.getElementsByTagName('标签名') 或者 element.getElementsByTagName('标签名') </span></li><li id="a800fcae80700b9a1ba7a4cf1d64e137"><span class="ne-text">作用：根据标签名获取元素对象</span></li><li id="c257c843c80461ec8bc372fb600881b8"><span class="ne-text">参数：标签名</span></li><li id="a44919a3f9a2c3aae3b3ad67cadae8ec"><span class="ne-text">返回值：元素对象集合（伪数组，数组元素是元素对象）</span><strong><span class="ne-text"></span></strong></li></ul><pre data-language="javascript" id="d2AEC" class="ne-codeblock language-javascript">var test_tag = document.getElementsByTagName('p');</pre><p id="40778211121366a71fcf19e632a0d747" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616048909454-bdfb7dbc-18e4-4449-abc6-800e87b42380.png" width="960" id="t8bGK" class="ne-image"></p><ul class="ne-ul"><li id="b34498ba8e1e1389a1109099ce7aaa2b"><span class="ne-text">getElementsByTagName()获取到是动态集合，即：当页面增加了标签，这个集合中也就增加了元素。</span></li><li id="07d484efcc0dcac5a6d9a9b02fed9ab6"><span class="ne-text">由上面的图可以知道，得到的不是一个对象，而是一个对象集合，所以要操作具体的一个p就要遍历，然后再进行操作（抑或是对其当作节点再进行操作）</span></li></ul><h3 id="lOixS"><span class="ne-text">getElementsByClassName</span></h3><h3 id="nv6PV"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616049522946-8c892471-1b04-4b04-b56f-630420bdb654.png" width="960" id="Nlkk2" class="ne-image"></h3><h3 id="AIV4u"><span class="ne-text">querySelector</span></h3><p id="8f9179e82d91b48eb024cdac48bfb563" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616049685312-55929307-c68b-4e1d-b6b5-1845c0d5a878.png" width="960" id="LgQYU" class="ne-image"></p><h3 id="qVXpe"><span class="ne-text">querySelectorAll</span></h3><p id="e6c4ba0c3da0bccddf51c8a37952abfe" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616049810063-ee5595dc-89bb-47cc-aa9a-c9446ed97d6f.png" width="960" id="KPxZC" class="ne-image"></p><ul class="ne-ul"><li id="ec916636cb33d1b8bb0ef59f878a566b"><span class="ne-text">如果是选择器，需要加符号 </span><code class="ne-code"><span class="ne-text">querySelectorAll('#box1')</span></code><span class="ne-text"> </span><strong><span class="ne-text"></span></strong></li></ul><h3 id="49WPY"><span class="ne-text">获取body/html对象</span></h3><p id="782093db7de09b389fac5ebf8f94ccda" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616050005999-ac944be2-9612-41ac-89f7-9fa04c4d3912.png" width="960" id="PNy3x" class="ne-image"></p><p id="818568300e29c7f77a38996b4784f6e7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518355850-2e015c88-50b7-400e-9593-c7e21a9068b5.png" width="748" id="Z6YzO" class="ne-image"></p><h2 id="QPRCY"><span class="ne-text">操作元素内容/属性</span></h2><p id="231261464f3195f4bc5abf22621579ce" class="ne-p"><span class="ne-text">JavaScript的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的）</span></p><h4 id="NABhf" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518357274-e26496b9-3fdb-47de-85be-fd6aea949767.png" width="442" id="n2RiL" class="ne-image"></h4><h3 id="hufij"><span class="ne-text">innerText和innerHTML</span></h3><ul class="ne-ul"><li id="533564842a159c2f961d622684f8f626"><span class="ne-text">获取内容时的区别：innerText会去除空格和换行，而innerHTML会保留空格和换行</span></li><li id="c4044cc83ce8e36d708c42e5255f2e37"><span class="ne-text">设置内容时的区别：innerText不会识别html，而innerHTML会识别</span></li><li id="02a0603246a53e036ffbaacc4089267b"><span class="ne-text">小记：是属性，不是方法！要用赋值的形式，而不是带参数的形式</span></li></ul><p id="4f95198e0ef3a9d536ebc3577b7bd8b7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616053295394-7fe7d51d-3ce6-4f51-9898-9e0e62b207c4.png" width="960" id="JoltV" class="ne-image"></p><p id="2dcdbf74ff30faf3b96cdf4824622a6f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616053546675-78ea1659-1dee-4b43-aa1a-82aad00e1795.png" width="960" id="t99V1" class="ne-image"></p><h3 id="6Ju71"><span class="ne-text">改变元素属性操作</span></h3><h3 id="9e57k"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616053829361-6faff7b2-0d8f-41c6-b909-6b72ff3b5401.png" width="960" id="fZfug" class="ne-image"></h3><p id="600003b1cb57747b608f5712550f1236" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616054507713-8b717792-1d98-4477-a9e8-db7417b87f34.png" width="960" id="lu27B" class="ne-image"></p><h3 id="1fiqy"><span class="ne-text">element.style</span></h3><h3 id="ebUmt"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616053829361-6faff7b2-0d8f-41c6-b909-6b72ff3b5401.png" width="960" id="uXyKy" class="ne-image"></h3><ul class="ne-ul"><li id="e5f1f5c01ab77f9aa0bab0743b156bc7"><span class="ne-text">元素对象的style属性也是一个对象！</span></li><li id="c1c6acc991cf7cb26f48fc953fc73a6c"><span class="ne-text">元素对象.style.样式属性 = 值;</span></li><li id="4b0ab22a2c4e0de22a695a451e46a565"><span class="ne-text">其中样式属性的命名不再是中间有-的，而是驼峰命名，eg：backgroundColor</span></li><li id="f0e95dc00ab4260e2cd0822c77d61d1b"><span class="ne-text">js修改的style样式操作，产生的是行内样式，css权重较高</span></li></ul><h3 id="1tNkf"><span class="ne-text">element.className</span></h3><ul class="ne-ul"><li id="aaf7eadae2a32bd0e2669c62d7bd923d"><span class="ne-text">元素对象.className = 值;</span></li><li id="e3ea1781ca3cffb067c8621a4bc01551"><span class="ne-text">因为class是关键字，所有使用className，覆盖原先的类名</span></li></ul><p id="d4ad769ece313bfb45ebdf3a41e3f9b7" class="ne-p"><br></p><pre data-language="html" id="hNVNS" class="ne-codeblock language-html"><body><pre><code>&lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt;&lt;script&gt;    // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用    var test = document.querySelector(&#39;div&#39;);    test.onclick = function() &#123;        // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况        // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器        // this.className = &#39;change&#39;;        this.className = &#39;first change&#39;;    &#125;&lt;/script&gt;</code></pre></body></pre><h2 id="wqS45"><span class="ne-text">自定义元素属性</span></h2><h3 id="38TpP"><span class="ne-text">element.getAttribute</span></h3><ul class="ne-ul"><li id="7250277a59b030794fb03d75366e68d2"><span class="ne-text">和element.属性不同的是，获取的是自定义属性的值，而</span><span class="ne-text">element.属性获取的是内置的属性</span></li></ul><pre data-language="html" id="eDmY4" class="ne-codeblock language-html"><div id="demo" index="1" class="nav"></div>    <script>        var div = document.querySelector('div');        // 1. 获取元素的属性值        // (1) element.属性        console.log(div.id);        //(2) element.getAttribute('属性')  get得到获取 attribute 属性的意思 我们程序员自己添加的属性我们称为自定义属性 index        console.log(div.getAttribute('id'));        console.log(div.getAttribute('index'));    </script></pre><h3 id="Ju7l1"><span class="ne-text">element.setAttribute</span></h3><ul class="ne-ul"><li id="d59a6ca897a739414fbc4aa61081127e"><span class="ne-text">element.setAttribute('属性','值')；</span></li></ul><pre data-language="javascript" id="XzvCm" class="ne-codeblock language-javascript">// 2. 设置元素属性值// (1) element.属性= '值'div.id = 'test';div.className = 'navs';// (2) element.setAttribute('属性', '值');  主要针对于自定义属性div.setAttribute('index', 2);div.setAttribute('class', 'footer'); // class 特殊  这里面写的就是</pre><h3 id="Bw0TQ"><span class="ne-text">element.removeAttribute</span></h3><pre data-language="javascript" id="ZCtwf" class="ne-codeblock language-javascript">// class 不是className// 3 移除属性 removeAttribute(属性)    div.removeAttribute('index');</pre><h3 id="8H5MW"><span class="ne-text">Demo：tab栏</span></h3><p id="7d95c8cd54584a750b700f79681b518f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358239-8396b94f-cc87-4ff3-bc86-20c652a2fe8f.png" width="786" id="loWsi" class="ne-image"></p><p id="5bba20fb3e4554c5be1be14951844e58" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358314-a1d9f6be-a9c3-4693-8b11-eec0665df297.png" width="744" id="zrKHc" class="ne-image"></p><pre data-language="html" id="8HLO5" class="ne-codeblock language-html"><script>        // 获取元素        var tab_list = document.querySelector('.tab_list');        var lis = tab_list.querySelectorAll('li');        var items = document.querySelectorAll('.item');        // for循环，给选项卡绑定点击事件        for (var i = 0; i < lis.length; i++) {            // 开始给5个小li 设置索引号             lis[i].setAttribute('index', i);            lis[i].onclick = function() {                // 1. 上的模块选项卡，当前这一个底色会是红色，其余不变（排他思想）                // 干掉所有人 其余的li清除 class 这个类                for (var i = 0; i < lis.length; i++) {                    lis[i].className = '';                }                // 留下我自己                 this.className = 'current';                // 2. 下面的显示内容模块                var index = this.getAttribute('index');                console.log(index);                // 干掉所有人 让其余的item 这些div 隐藏                for (var i = 0; i < items.length; i++) {                    items[i].style.display = 'none';                }                // 留下我自己 让对应的item 显示出来                items[index].style.display = 'block';            }        }    </script></pre><h3 id="A5dLE"><span class="ne-text">element.dataset</span></h3><p id="52bd4c3c970ebe6427840f35f75fdd30" class="ne-p"><span class="ne-text">自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。</span></p><p id="31fafa53a2b0d3a98fc062f59ba54e0a" class="ne-p"><span class="ne-text">自定义属性获取是通过getAttribute(‘属性’) 获取。</span></p><p id="63a299636dc1440b67ea25d070e9cd83" class="ne-p"><span class="ne-text">但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。</span></p><p id="2244a4bc40652131415dc54d083183b6" class="ne-p"><span class="ne-text">H5给我们新增了自定义属性：</span></p><p id="45df4c9292145a8050e9f4e7eefe8cc4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358371-b2d8cb33-5750-4e13-be06-27c86768b244.png" width="705" id="lLVY2" class="ne-image"></p><p id="52e2425c30b46fe0f3e38e022835773f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358431-0a046321-c303-4333-9e0d-57875144f3e5.png" width="691" id="FSDEa" class="ne-image"></p><pre data-language="html" id="j8FVh" class="ne-codeblock language-html"><div getTime="20" data-index="2" data-list-name="andy"></div><script>  var div = document.querySelector('div');  // console.log(div.getTime);  console.log(div.getAttribute('getTime'));  div.setAttribute('data-time', 20);  console.log(div.getAttribute('data-index'));  console.log(div.getAttribute('data-list-name'));  // h5新增的获取自定义属性的方法 它只能获取data-开头的  // dataset 是一个集合里面存放了所有以data开头的自定义属性  console.log(div.dataset);  console.log(div.dataset.index);  console.log(div.dataset['index']);  // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法  console.log(div.dataset.listName);  console.log(div.dataset['listName']);</script></pre></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> DOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内置对象-全局属性-函数</title>
      <link href="/blog/fc3rdkwoum2b/"/>
      <url>/blog/fc3rdkwoum2b/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u261d7807" class="ne-p"><strong><span class="ne-text">前言：</span></strong></p><p id="u4d3428e8" class="ne-p"><span class="ne-text">【全文内容是基于以下文档内容所作的补充】</span></p><ul class="ne-ul"><li id="u2b79b1a0"><span class="ne-text">MDN：</span><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" class="ne-link"><span class="ne-text">JavaScript 标准内置对象</span></a></li><li id="ub7629a50"><span class="ne-text">W3school：</span><a href="https://www.w3school.com.cn/jsref/index.asp" data-href="https://www.w3school.com.cn/jsref/index.asp" target="_blank" class="ne-link"><span class="ne-text">JavaScript 和 HTML DOM 参考手册</span></a></li><li id="ub4e95964"><span class="ne-text">菜鸟教程：</span><a href="https://www.runoob.com/jsref/jsref-tutorial.html" data-href="https://www.runoob.com/jsref/jsref-tutorial.html" target="_blank" class="ne-link"><span class="ne-text">JavaScript 和 HTML DOM 参考手册</span></a></li></ul><p id="ub9304818" class="ne-p"><span class="ne-text"></span></p><p id="ue5cc3ce9" class="ne-p"><span class="ne-text">补充：数组、字符串两中对象，都是打印原始值：</span></p><ul class="ne-ul"><li id="u71c31306"><span class="ne-text">toString</span></li><li id="u2fee9a4c"><span class="ne-text">valueOf</span></li></ul><p id="udd66ad91" class="ne-p"><br></p><h2 id="FFg7P"><span class="ne-text">String</span></h2><table id="VULTc" class="ne-table" style="width: 580px"><tbody><tr style="height: 33px"><td width="205" style="background-color: #F5F5F5"><p id="u617eacbe" class="ne-p" style="text-align: left"><span class="ne-text">类型</span></p></td><td width="375" style="background-color: #F5F5F5"><p id="u7aaa95ae" class="ne-p"><span class="ne-text">API</span></p></td></tr><tr style="height: 33px"><td width="205"><p id="ub8860a2e" class="ne-p" style="text-align: left"><span class="ne-text">增、删、改</span></p></td><td width="375"><ul class="ne-ul"><li id="uceea0bfc"><span class="ne-text">replace()：修改指定字符串为新字符串</span></li><li id="uc6b2f2b2"><span class="ne-text">replaceAll()：所有的</span></li><li id="u749b6910"><span class="ne-text">slice()：和数组api一样</span></li><li id="uc10a88f1"><span class="ne-text">substr()：给起始索引截取指定个数</span></li><li id="u8b3d45d9"><span class="ne-text">substring()：[起始索引，结束索引)</span></li><li id="u82f1c337"><span class="ne-text">trim()：清楚两边空白</span></li><li id="u83eb35a6"><span class="ne-text">toLowerCase()：字符串转换为小写</span></li><li id="ue834212a"><span class="ne-text">toUpperCase()：字符串转换为大写</span></li><li id="uc927ccb9"><span class="ne-text">toLocaleLowerCase()：根据本地主机的语言环境把字符串转换为小写</span></li><li id="ue44112ac"><span class="ne-text">toLocaleUpperCase()：根据本地主机的语言环境把字符串转换为大写</span></li></ul></td></tr><tr style="height: 33px"><td width="205"><p id="ud3d7e531" class="ne-p" style="text-align: left"><span class="ne-text">查</span></p></td><td width="375"><ul class="ne-ul"><li id="u2d171914"><span class="ne-text">charAt：根据索引得到指定位置值</span></li><li id="ue1bff438"><span class="ne-text">charCodeAt：根据索引得到指定位置值Unicode码</span></li><li id="u8b35bee4"><span class="ne-text">indexOf()：查找子字符串的初次索引</span></li><li id="u5dedcd4a"><span class="ne-text">lastIndexOf()：从右往左</span></li><li id="u71a562bb"><span class="ne-text">includes()：是否包含子字符串</span></li><li id="ue1763914"><span class="ne-text">match()：查找正则规则子字符串</span></li><li id="u0d483084"><span class="ne-text">search()：查找指定字符串/正则的索引</span></li></ul></td></tr><tr style="height: 33px"><td width="205"><p id="u1b9296c1" class="ne-p" style="text-align: left"><span class="ne-text">和数组联系</span></p></td><td width="375"><ul class="ne-ul"><li id="u99f3459b"><span class="ne-text">split：根据指定字符切割数组</span></li></ul></td></tr><tr style="height: 33px"><td width="205"><p id="u9dc6f3f5" class="ne-p" style="text-align: left"><span class="ne-text">拷贝和拼接</span></p></td><td width="375"><ul class="ne-ul"><li id="ua930b6b7"><span class="ne-text">concat：和数组一样</span></li></ul></td></tr><tr style="height: 33px"><td width="205"><p id="u4678e961" class="ne-p" style="text-align: left"><span class="ne-text">其他</span></p></td><td width="375"><ul class="ne-ul"><li id="u4e3ede4b"><span class="ne-text">startsWith()：是否已子字符串开头</span></li><li id="uaf594236"><span class="ne-text">endsWith：是否以子字符串结尾</span></li><li id="u1c34259a"><span class="ne-text">fromCharCode()：Unicode码转换为字符</span></li><li id="u88b66f9e"><span class="ne-text">repeat：将字符串复制指定次数并返回，参数是次数</span></li></ul><div class="ne-quote"><p id="u2559d7fe" class="ne-p"><span class="ne-text">'hello'.repeat(2)  // "hellohello"</span></p></div></td></tr></tbody></table><h3 id="PScRQ"><span class="ne-text">反引号</span></h3><p id="udbabc879" class="ne-p"><span class="ne-text">ES6新增的创建字符串的方式，使用反引号定义</span></p><pre data-language="javascript" id="flccT" class="ne-codeblock language-javascript">let name = `zhangsan`;</pre><ul class="ne-ul"><li id="u6e263fc1"><span class="ne-text">模板字符串中可以解析变量</span></li></ul><pre data-language="javascript" id="JS3YA" class="ne-codeblock language-javascript">let name = '张三';<p>let sayHello = <code>hello,my name is $&#123;name&#125;</code>; // hello,my name is 张三</pre><ul class="ne-ul"><li id="uc4068474"><span class="ne-text">模板字符串中可以换行</span></li></ul><pre data-language="javascript" id="Cr1ZR" class="ne-codeblock language-javascript">let result = {<br>name: 'zhangsan',<br>age: 20,<br>sex: '男'<br>}<br>let html = ` <div><br><span>${result.name}</span><br>     <span>${result.age}</span><br><span>${result.sex}</span></p> </div> `;</pre><ul class="ne-ul"><li id="u2bc5cf99"><span class="ne-text">在模板字符串中可以调用函数</span></li></ul><pre data-language="javascript" id="rlhcn" class="ne-codeblock language-javascript">const sayHello = function () {     return '哈哈哈哈 追不到我吧 我就是这么强大'; };  let greet = `${sayHello()} 哈哈哈哈`; console.log(greet); // 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈</pre><h2 id="RQulP"><span class="ne-text">Array</span></h2><ul class="ne-ul"><li id="u39ac743e"><a href="https://www.runoob.com/jsref/jsref-obj-array.html" data-href="https://www.runoob.com/jsref/jsref-obj-array.html" target="_blank" class="ne-link"><span class="ne-text">https://www.runoob.com/jsref/jsref-obj-array.html</span></a></li></ul><table id="YyxzQ" class="ne-table" style="width: 580px"><tbody><tr style="height: 33px"><td width="205" style="background-color: #F5F5F5"><p id="ue39bf158" class="ne-p" style="text-align: left"><span class="ne-text">类型</span></p></td><td width="375" style="background-color: #F5F5F5"><p id="ub804ed71" class="ne-p"><span class="ne-text">API</span></p></td></tr><tr style="height: 33px"><td width="205"><p id="ua63777b7" class="ne-p" style="text-align: left"><span class="ne-text">增、删、改</span></p></td><td width="375"><ul class="ne-ul"><li id="ua151c249"><span class="ne-text">slice：操作完然后复制结果为一个新数组</span></li><li id="uae071f96"><span class="ne-text">splice：会改变原始数组，返回的删除元素数组</span></li></ul></td></tr><tr style="height: 33px"><td width="205"><p id="uecace477" class="ne-p" style="text-align: left"><span class="ne-text">查</span></p></td><td width="375"><ul class="ne-ul"><li id="u08bc2761"><span class="ne-text">includes：根据数组元素值查</span></li><li id="ub252024f"><span class="ne-text">indexOf：根据索引查</span></li><li id="u2c0a06ef"><span class="ne-text">lastIndexOf：根据索引查</span></li></ul></td></tr><tr style="height: 33px"><td width="205"><p id="u1c022b42" class="ne-p"><span class="ne-text">充当栈、队列</span></p></td><td width="375"><ul class="ne-ul"><li id="uf37d678d"><span class="ne-text">push：末尾添加元素，返回新长度</span></li><li id="u28f95f9c"><span class="ne-text">pop：删除最后一个元素并且返回该值</span></li><li id="uab4a9f75"><span class="ne-text">shift：删除第一个元素并且返回该值</span></li><li id="u0787b237"><span class="ne-text">unshift：开头添加元素，返回新长度</span></li></ul></td></tr><tr style="height: 33px"><td width="205"><p id="ud43d0a77" class="ne-p" style="text-align: left"><span class="ne-text">和字符串联系</span></p></td><td width="375"><ul class="ne-ul"><li id="u69790b3c"><span class="ne-text">join：通过指定字符串拼接，空参数则为逗号（类似valueOf和toString）</span></li></ul></td></tr><tr style="height: 33px"><td width="205"><p id="u8a07e430" class="ne-p" style="text-align: left"><span class="ne-text">迭代遍历有关</span></p></td><td width="375"><p id="u10558545" class="ne-p"><span class="ne-text">every、some、entries、filter、find、findIndex、forEach、keys</span></p><ul class="ne-ul"><li id="u3a814cdc"><span class="ne-text">find：可以传入参数来查找</span></li><li id="u2a14a33e"><span class="ne-text">map：相当于将y = x 变成y = x</span><sup><span class="ne-text">2</span></sup><span class="ne-text">，不改变原数组</span></li><li id="uf673912c"><span class="ne-text">reduce：把结果继续和序列的下一个元素做累积计算</span></li></ul><pre data-language="javascript" id="BUHAm" class="ne-codeblock language-javascript">var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) {    return x * 10 + y;}); // 13579</pre><ul class="ne-ul"><li id="uf9f49f80"><span class="ne-text">reduceRight</span></li></ul></td></tr><tr style="height: 33px"><td width="205"><p id="ud7b8e5a9" class="ne-p" style="text-align: left"><span class="ne-text">拷贝和拼接</span></p></td><td width="375"><ul class="ne-ul"><li id="u54065c1a"><span class="ne-text">concat：不改变原数组，arr1.concat(arr2, arr3)</span></li><li id="uad794bee"><span class="ne-text">扩展运算符</span></li></ul><pre data-language="javascript" id="nnz0b" class="ne-codeblock language-javascript">// 方法一  let ary1 = [1, 2, 3]; let ary2 = [3, 4, 5]; let ary3 = [...ary1, ...ary2]; // 方法二  ary1.push(...ary2);</pre><ul class="ne-ul"><li id="u1e00281c"><span class="ne-text">copyWithin：从数组的指定位置拷贝元素到数组的另一个指定位置中</span></li></ul></td></tr><tr style="height: 33px"><td width="205"><p id="u40e31ae7" class="ne-p" style="text-align: left"><span class="ne-text">排序</span></p></td><td width="375"><ul class="ne-ul"><li id="uecea2954"><span class="ne-text">sort：数字升序（sort((a,b)=>{return a-b})）</span></li><li id="u76b32c37"><span class="ne-text">reserve：逆置</span></li></ul></td></tr><tr style="height: 33px"><td width="205"><p id="u04b94af7" class="ne-p" style="text-align: left"><span class="ne-text">其他</span></p></td><td width="375"><ul class="ne-ul"><li id="u2a30c5c0"><span class="ne-text">fill：使用一个值来填充/替换数组元素，可以指定索引，通常用在DP问题的填充0</span></li><li id="u3257185f"><span class="ne-text">from：构造函数方法，将伪数组或可遍历对象转换为真正的数组（类数组转换为数组）</span></li></ul><div class="ne-quote"><p id="u4f76070f" class="ne-p"><span class="ne-text">伪数组、可遍历对象、Set</span></p></div><ul class="ne-ul"><li id="u455e6bce"><span class="ne-text">isArray</span></li></ul></td></tr></tbody></table><h3 id="B7bYV"><span class="ne-text">类数组与数组的区别与转换</span></h3><p id="u6772056e" class="ne-p"><a href="https://blog.csdn.net/qq_37635012/article/details/106195211" data-href="https://blog.csdn.net/qq_37635012/article/details/106195211" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/qq_37635012/article/details/106195211</span></a></p><h3 id="xdGXB"><span class="ne-text">扩展运算符（展开语法）</span></h3><p id="6b22497dcf2459ba4e94305295651863" class="ne-p"><span class="ne-text">扩展运算符可以将数组或者对象转为用逗号分隔的参数序列</span></p><pre data-language="javascript" id="mZCNP" class="ne-codeblock language-javascript">let ary = [1, 2, 3]; ...ary  // 1, 2, 3 console.log(...ary);    // 1 2 3,相当于下面的代码 console.log(1,2,3);</pre><p id="u66ffe4c2" class="ne-p"><strong><span class="ne-text" style="color: #E8323C">扩展运算符可以应用于合并数组</span></strong></p><pre data-language="javascript" id="rx0Ds" class="ne-codeblock language-javascript">// 方法一  let ary1 = [1, 2, 3]; let ary2 = [3, 4, 5]; let ary3 = [...ary1, ...ary2]; // 方法二  ary1.push(...ary2);</pre><p id="u3a23de2d" class="ne-p"><strong><span class="ne-text" style="color: #E8323C">将类数组或可遍历对象转换为真正的数组</span></strong></p><pre data-language="javascript" id="kXT0K" class="ne-codeblock language-javascript">let oDivs = document.getElementsByTagName('div'); oDivs = [...oDivs];</pre><h3 id="tBIF4"><span class="ne-text">Array构造函数</span></h3><ul class="ne-ul"><li id="u9f71d109"><span class="ne-text">Array构造函数：</span><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Array" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Array" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Array</span></a></li></ul><h3 id="D5FbK"><span class="ne-text">from</span></h3><p id="u48ce05e1" class="ne-p"><span class="ne-text">构造函数方法：Array.from()</span></p><p id="a55532828913cd79169f81b6626ea807" class="ne-p"><span class="ne-text">将伪数组或可遍历对象转换为真正的数组</span></p><pre data-language="javascript" id="0SCPz" class="ne-codeblock language-javascript">//定义一个集合let arrayLike = {    '0': 'a',    '1': 'b',    '2': 'c',    length: 3}; //转成数组let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']</pre><p id="5cfbba68dda39d45a09a16232e8d457d" class="ne-p"><span class="ne-text">方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组</span></p><pre data-language="javascript" id="4XlkA" class="ne-codeblock language-javascript">let arrayLike = {      "0": 1,     "1": 2,     "length": 2 } let newAry = Array.from(arrayLike, item => item *2)//[2,4]</pre><p id="1a11d080cac1316fae624d88ef6b98cd" class="ne-p"><span class="ne-text">注意：如果是对象，那么属性需要写对应的索引</span></p><h3 id="Z9Ogp"><span class="ne-text">find</span></h3><p id="d9da4319774215d055aa9f178498bcac" class="ne-p"><span class="ne-text">用于找出第一个符合条件的数组成员，如果没有找到返回undefined</span></p><pre data-language="javascript" id="kh6Nd" class="ne-codeblock language-javascript">let ary = [{     id: 1,     name: '张三' }, {      id: 2,     name: '李四' }]; //找数组里面符合条件的值，当数组中元素id等于2的查找出来，注意，只会匹配第一个 let target = ary.find((item, index) => item.id == 2);</pre><h3 id="QV1uF"><span class="ne-text">findIndex</span></h3><p id="926e377abb1d5d9bce32f14ef10cc0c8" class="ne-p"><span class="ne-text">用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1</span></p><pre data-language="javascript" id="vAI0k" class="ne-codeblock language-javascript">let ary = [1, 5, 10, 15];let index = ary.findIndex((value, index) => value > 9); console.log(index); // 2</pre><h2 id="aYG20"><span class="ne-text">Set</span></h2><p id="u45fbb6f7" class="ne-p"><a href="https://www.runoob.com/w3cnote/es6-map-set.html" data-href="https://www.runoob.com/w3cnote/es6-map-set.html" target="_blank" class="ne-link"><span class="ne-text">https://www.runoob.com/w3cnote/es6-map-set.html</span></a></p><h3 id="wPg0o"><span class="ne-text">构造函数</span></h3><p id="d69e2b330bbdf98ea073bb8d8682d0d6" class="ne-p"><span class="ne-text">ES6 提供了新的数据结构  Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</span></p><p id="5678d1e94c0c0e8e175c338c7c7d3f7a" class="ne-p"><span class="ne-text">Set本身是一个构造函数，用来生成  Set  数据结构</span></p><pre data-language="javascript" id="zVcyK" class="ne-codeblock language-javascript">const s = new Set();</pre><p id="4fb8c374014d58f0a33f107e2db03d10" class="ne-p"><span class="ne-text">Set函数可以接受一个数组作为参数，用来初始化。</span></p><pre data-language="javascript" id="0Dma7" class="ne-codeblock language-javascript">const set = new Set([1, 2, 3, 4, 4]);//{1, 2, 3, 4}</pre><h3 id="qoiWl"><span class="ne-text">实例方法</span></h3><ul class="ne-ul"><li id="0ab1d7020fd21bf92e6d626b0276a540"><span class="ne-text">add(value)：添加某个值，返回 Set 结构本身</span></li><li id="1c3ec2ddd240bd790c2e3847a5d53936"><span class="ne-text">delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</span></li><li id="e79974c89233f1c17df98e55353ec9c3"><span class="ne-text">has(value)：返回一个布尔值，表示该值是否为 Set 的成员</span></li><li id="061c1d0fef5be553c3322d0227757653"><span class="ne-text">clear()：清除所有成员，没有返回值</span></li></ul><pre data-language="javascript" id="YRkZU" class="ne-codeblock language-javascript">const s = new Set(); s.add(1).add(2).add(3); // 向 set 结构中添加值  s.delete(2)             // 删除 set 结构中的2值    s.has(1)                // 表示 set 结构中是否有1这个值 返回布尔值  s.clear()               // 清除 set 结构中的所有值 //注意：删除的是元素的值，不是代表的索引</pre><h3 id="dwQLf"><span class="ne-text">遍历</span></h3><p id="5d10e3fbc5f04d2ca41330e68eade34f" class="ne-p"><span class="ne-text">Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</span></p><pre data-language="javascript" id="3wwaR" class="ne-codeblock language-javascript">s.forEach(value => console.log(value))</pre><h2 id="XKyKc"><span class="ne-text">Map</span></h2><p id="u0b973f4e" class="ne-p"><a href="https://www.runoob.com/w3cnote/es6-map-set.html" data-href="https://www.runoob.com/w3cnote/es6-map-set.html" target="_blank" class="ne-link"><span class="ne-text">https://www.runoob.com/w3cnote/es6-map-set.html</span></a></p><h2 id="cC4mz"><span class="ne-text">其他</span></h2><h3 id="DHVnH"><span class="ne-text" style="color: rgb(49, 49, 48)">解构赋值</span></h3><ul class="ne-ul"><li id="ud57ba94c"><span class="ne-text">数组和对象可以赋值解构</span></li><li id="ubff8641c"><span class="ne-text">参考：</span><a href="https://zh.javascript.info/destructuring-assignment" data-href="https://zh.javascript.info/destructuring-assignment" target="_blank" class="ne-link"><span class="ne-text">https://zh.javascript.info/destructuring-assignment</span></a></li></ul><h3 id="KnCV1"><span class="ne-text">剩余参数</span></h3><ul class="ne-ul"><li id="u71820533"><span class="ne-text">剩余参数是以</span><strong><span class="ne-text">数组</span></strong><span class="ne-text">的形式存在的</span></li></ul><pre data-language="javascript" id="DpxSW" class="ne-codeblock language-javascript">function sum(...theArgs) {  return theArgs.reduce((previous, current) => {    return previous + current;  });}<p>console.log(sum(1, 2, 3));<br>// expected output: 6</p><p>console.log(sum(1, 2, 3, 4));<br>// expected output: 10</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>变量-数据类型-表达式-程序结构</title>
      <link href="/blog/uz1d072engtt/"/>
      <url>/blog/uz1d072engtt/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="V12Ex"><span class="ne-text">知识架构</span></h2><h3 id="JFtpp"><span class="ne-text">第一大类：ECMAScript</span></h3><ul class="ne-tl"><li checked="true" id="d551a5c8ab98987aa17710d202c57390"><span class="ne-text">基本语法</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="0b90f1143a9d10dc40afe1352552a5b8"><span class="ne-text">【补充】JavaScript语言介绍</span></li><li id="3f8caa983af060038ae3d710cfc2a384"><span class="ne-text">变量</span></li><li id="0d7b50b2f47e5e5726bdf01d81812eff"><span class="ne-text">基本数据类型</span></li><li id="79d37b38b3f9c3fd1f38bebef8e32cb5"><span class="ne-text">运算符和表达式</span></li><li id="4efe0b69d87a3c50df99b5fcf6751a56"><span class="ne-text">流程控制语句</span></li></ul></ul><ul class="ne-tl"><li checked="true" id="5ebb72df9e87bce090e80ece1a37c084"><span class="ne-text">函数</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="59deb06d09e8943aec1de189017638c9"><span class="ne-text">常规基础知识</span></li><li id="70e788886c2ba351d34659d18c39bdc3"><span class="ne-text">闭包</span></li><li id="5c6d5f9f292192cfc55cc04c0552a8e4"><span class="ne-text">JavaScript运行机制（单线程，异步任务机制……）</span></li></ul></ul><ul class="ne-tl"><li checked="true" id="cf0e032096503fbf4c0899a9babcf23b"><span class="ne-text">引用</span></li></ul><div class="ne-quote"><p id="c6714ac36f03c2a87054bd3b1b8002aa" class="ne-p"><span class="ne-text">文档学习：</span><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</span></a></p></div><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="82a4f6006679197c394f0008f9ac990c"><span class="ne-text">基本引用类型：Date、RegExp、原始包装、Global、Math等</span></li><li id="0a492c84bba6b2f20a398c4eaa93d9c9"><span class="ne-text">集合引用类型：Object、Array、Map、WeakMap、Set、WeakSet</span></li></ul></ul><ul class="ne-tl"><li checked="true" id="aa54bd01d46af609ef0662e4fa32ee9e"><span class="ne-text">面向对象</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="09e68ed930b6ed0c17a1cd92c7e7996f"><span class="ne-text">体系一：原型</span></li><li id="6756d813c1785e1cc8ad2737932055ff"><span class="ne-text">体系二：类【ES6后出来的】</span></li><li id="d84edf742157e2d39dbcf959223ed3f8"><span class="ne-text">关于对象的创建和内置方法</span></li></ul></ul><hr id="iOtSh" class="ne-hr"><ul class="ne-tl"><li id="c14d73398d63dd7645fe1568909392aa"><span class="ne-text">迭代器和生成器</span></li><li id="6a3b98d56fc851e8d60ec724f3e571ab"><span class="ne-text">代理和反射</span></li><li id="9015d8035768a1a6a386f59cdb0dd125"><span class="ne-text">canvas技术</span></li><li id="a67afb8f4abb51b5909903c20212d926"><span class="ne-text">表单脚本</span></li><li id="63e393c2063c2be490455928813b71ef"><span class="ne-text">JavaScript API</span></li><li id="97be63e8055aaa132c7132949fbc7c6b"><span class="ne-text">错误处理和调试</span></li><li id="ee5778e11414b5f0d6a3e23e2f1db42f"><span class="ne-text">处理XML</span></li><li id="7bf471ca409c5aa4f2eceaf149c921b9"><span class="ne-text">JSON技术</span></li><li id="1801c735ee820c3935425de5430da647"><span class="ne-text">网络请求和远程资源</span></li><li id="6593a2ba1d177849167e40252f26b097"><span class="ne-text">模块化</span></li><li id="abab32528b4c486569756b8eee3fa311"><span class="ne-text">工作者线程</span></li><li id="7092eb9802cd5d68950dbf7feddc0b1d"><span class="ne-text">最佳实践</span></li><li checked="true" id="008804e982826540a439bd6556fd273b"><span class="ne-text">严格模式</span></li></ul><h2 id="TbATG"><span class="ne-text">JavaScript编程语言</span></h2><h3 id="78f3f7ef"><span class="ne-text">解释型语言和编译型语言</span></h3><p id="69ffa4210daa4163c5bbc70cce50ba3e" class="ne-p"><br></p><p id="dfe8e5c763d02ef66ada79c293445101" class="ne-p"><span class="ne-text">计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能执行程序。程序语言翻译成机器语言的工具，被称为翻译器。</span></p><p id="baf5e8aabb77bc62e6171b03a3826398" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883945965-edfd63f6-b312-4daa-990e-aa7fb8d29640.png" width="307" id="lzaQj" class="ne-image"></p><ul class="ne-ul"><li id="efec4d96acc3487841fe1c20fe326675"><span class="ne-text">翻译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译的时间点不同</span></li><li id="0edde9d3ff6baac0b93441af50cc77b9"><span class="ne-text">编译器是在代码执行之前进行编译，生成中间代码文件</span></li><li id="b50497b629bf6d2b0b30059b8084d5f0"><span class="ne-text">解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候，也称之为解释器)</span></li></ul><div class="ne-quote"><p id="a90f8b7e8fa2b421e01306c42417af73" class="ne-p"><span class="ne-text">执行过程</span></p></div><p id="8091ab085a95f6a5b8e5af75a6cd1c9d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883933551-3185c915-4a31-4151-a6c6-9212e11d336c.png" width="412.5" id="Fnw0A" class="ne-image"></p><h3 id="0gbfN"><span class="ne-text">JavaScript 是什么</span></h3><ul class="ne-ul"><li id="b6e3ac0f6e2af3555e1378cb16e6b12f"><span class="ne-text">JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script == 脚本）</span></li><li id="74f0d8b65f96d7c5a6077f292280f75b"><span class="ne-text">脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行</span></li><li id="7b94a21c458ad335dba5acd13541c6b3"><span class="ne-text">现在也可以基于 Node.js 技术进行服务器端编程</span></li></ul><h3 id="xeNhG"><span class="ne-text">JavaScript的作用</span></h3><ul class="ne-ul"><li id="bbed77407276a35c0259baced5bd344c"><span class="ne-text">表单动态校验（密码强度检测）  （ JS 产生最初的目的 ）</span></li><li id="ace9e3fba9f20d8bab5385aae951bf5a"><span class="ne-text">网页特效</span></li><li id="cc0c97ac003fb1af899b9d45c7537186"><span class="ne-text">服务端开发(Node.js)</span></li><li id="78616ee8907d689ec18133f86ce622cd"><span class="ne-text">桌面程序(Electron)</span></li><li id="891ae8804cc06ed9a64f1ec98c95938f"><span class="ne-text">App(Cordova)</span></li><li id="341af114419bf832ccb4fbb8ddec5084"><span class="ne-text">控制硬件-物联网(Ruff)</span></li><li id="382a39ab9b42d32c40e55c5bf1140621"><span class="ne-text">游戏开发(cocos2d-js)</span></li></ul><h3 id="z0wpQ"><span class="ne-text">浏览器执行 JS 简介</span></h3><p id="0fb918279dbf616a0b59c4903bdb082d" class="ne-p"><strong><span class="ne-text">浏览器分成两部分：渲染引擎和 JS 引擎</span></strong></p><p id="0c8f394f9c32dd48710b81425ff64614" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883433929-789dc835-fd39-43fb-8212-9580ee9e69a6.png" width="419.5" id="sXxXn" class="ne-image"></p><pre data-language="plain" id="2Kf1e" class="ne-codeblock language-plain">浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。</pre><p id="b4855ebda6bdca6b06e92138ccb77b45" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883443893-9e920247-6cbf-4713-85cb-c76eeb34013c.png" width="408" id="KjTqV" class="ne-image"></p><h3 id="LJtqL"><span class="ne-text">JavaScript的组成</span></h3><p id="3fc8971ef42cf383049a55c071f80223" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883453712-2dfb6f14-cf77-4475-ad87-5826124bc43f.png" width="412.5" id="nDXwH" class="ne-image"></p><ol class="ne-ol"><li id="9d3fa69f2905f0015a2cb70aada359d8"><strong><span class="ne-text">ECMAScript</span></strong><span class="ne-text"><p></span><span class="ne-text">        ECMAScript 是由 ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。<br></span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883470657-6e9bb00b-781e-46d3-99e7-64afd35e3758.png" width="420.5" id="HPj6o" class="ne-image"><span class="ne-text"><br></span><span class="ne-text"> ECMAScript：规定了 JS 的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套 JS 语法工业标准。<br></span><span class="ne-text">更多参看 MDN: </span><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview" target="_blank" class="ne-link"><span class="ne-text">MDN 手册</span></a></li><li id="6211f9bd380f9eab462a26b6f6fa9604"><strong><span class="ne-text">DOM——文档对象模型</span></strong><span class="ne-text"><br></span><span class="ne-text"> </span><strong><span class="ne-text">文档对象模型</span></strong><span class="ne-text">（DocumentObject Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）</span></li><li id="b384e8b17b6138d481f89b860d6065e8"><strong><span class="ne-text">BOM——浏览器对象模型</span></strong><span class="ne-text"><br></span><span class="ne-text"> </span><strong><span class="ne-text">浏览器对象模型</span></strong><span class="ne-text">(Browser Object Model，简称 BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过 BOM 可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</span></li></ol><h3 id="JjAdV"><span class="ne-text">JavaScript 初体验</span></h3><pre data-language="plain" id="Poq1H" class="ne-codeblock language-plain">JS 有 3 种书写位置，分别为行内、内嵌和外部。</pre><ol class="ne-ol"><li id="78f6bbfb58c59aa8abab080ed39898ab"><span class="ne-text">行内式</span></li></ol><pre data-language="html" id="2IUIz" class="ne-codeblock language-html"><input type="button" value="点我试试" onclick="alert('Hello World')" /></pre><ul class="ne-ul"><li id="34d5805e3a07bd82c77a1df85aa1309a"><span class="ne-text">可以将单行或少量 JS 代码写在 HTML 标签的事件属性中（以 on 开头的属性），如：onclick</span></li><li id="8874d4b369aa059e1db1b044a80ce93f"><span class="ne-text">注意单双引号的使用：在 HTML 中我们推荐使用双引号, JS 中我们推荐使用单引号</span></li><li id="b25bb5c12408a6a0182cb6e6e40d58ca"><span class="ne-text">可读性差， 在 html 中编写 JS 大量代码时，不方便阅读；</span></li><li id="a0009b0de1446d5a08980c850592155f"><span class="ne-text">引号易错，引号多层嵌套匹配时，非常容易弄混；</span></li><li id="a5d132e73d0cac778a5df4a1c7438db6"><span class="ne-text">特殊情况下使用</span></li></ul><ol start="2" class="ne-ol"><li id="d39de46cc36c7d4acbde29a733cd5afa"><span class="ne-text">内嵌式</span></li></ol><pre data-language="html" id="t9OzL" class="ne-codeblock language-html"><script><br>alert('Hello World~!');<br></script></pre><ul class="ne-ul"><li id="1eef0139c3c66611a5dc64ecee65e408"><span class="ne-text">可以将多行 JS 代码写到 script 标签中</span></li><li id="7bc3fab3ac017fd3f92db43769324a0f"><span class="ne-text">内嵌 JS 是学习时常用的方式</span></li></ul><ol start="2" class="ne-ol"><li id="d3683d6b49fc8d7de2c00e52f53e920e"><span class="ne-text">外部 JS 文件</span></li></ol><pre data-language="html" id="5c2sa" class="ne-codeblock language-html"><script src="my.js"></script></pre><ul class="ne-ul"><li id="dd06ea51aa8637084a34b80f5c9ae421"><span class="ne-text">利于 HTML 页面代码结构化，把大段 JS 代码独立到 HTML 页面之外，既美观，也方便文件级别的复用</span></li><li id="6c254554bc97f0124b411198f49d4103"><span class="ne-text">引用外部 JS 文件的 script 标签中间不可以写代码</span></li><li id="b9d106462ae7ce66f0dba3faad071798"><span class="ne-text">适合于 JS 代码量比较大的情况</span></li></ul><h3 id="iKvnh"><span class="ne-text">JavaScript 输入输出</span></h3><div class="ne-quote"><p id="d363d14ccbb8e053f6a3c51281a2ff5a" class="ne-p"><span class="ne-text">调试有两种，一种是 debug，一种是 print 大法，js 输入输出依靠浏览器来“可视化”输入输出</span></p></div><ul class="ne-ul"><li id="383882d9eccf86bc61afeefeaa9cd5cd"><span class="ne-text">prompt：可以输入</span></li><li id="4c98042f3b685499ef75b89791e2c221"><span class="ne-text">alert：输出</span></li><li id="183ee8fe403073ea701643df72a362d8"><span class="ne-text">console.log()：输出</span></li></ul><h2 id="sbNCv"><span class="ne-text">变量</span></h2><p id="4059550aa0a45ab0242b2c21afc95148" class="ne-p"><span class="ne-text">JavaScript 里面的变量使用可谓是一言难尽，用</span><em><span class="ne-text">《JavaScript 高级程序设计》</span></em><span class="ne-text">书里面说的就是：</span></p><p id="77f86a927bdbd10032d1115e77736001" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617866042752-0faeefea-8db4-4432-b4ce-afe96f10375a.png" width="166" id="JljGP" class="ne-image"><span class="ne-text">，总结一下变量一些重点知识。</span></p><h3 id="VtQxt"><span class="ne-text">var 和 let 和 const</span></h3><p id="9fae286a19ede0132a5a1a12ac0f7401" class="ne-p"><strong><span class="ne-text">【1】var</span></strong></p><ul class="ne-ul"><li id="4b18ac66fd11eb63fce31132e08e6905"><span class="ne-text">在全局区域声明是全局变量</span></li><li id="4e7c5fcdfd99152eca107eed7dd2c013"><span class="ne-text">在</span><strong><span class="ne-text">函数里面</span></strong><span class="ne-text">用 var 声明变量的时候是局部变量，但是省略 var 的时候，就变成全局变量了（坑……），好在严格模式下如果在函数里面这样定义会报错</span></li></ul><p id="17bbb693bcc03ecc288ff17db9c2b30b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617867733497-db043164-d28e-48e8-8bd7-2a9b1d30203a.png" width="394.5" id="HzdsA" class="ne-image"></p><ul class="ne-ul"><li id="f638dd23fb3b1540a05cdda9e79b177e"><span class="ne-text">会变量提升，把所有变量声明都拉到函数作用域的顶部，所以在同一个域里面，var 定义的变量，先使用在定义也是可以的。</span></li><li id="dc244b9f34ceed5f0b4fcbf3b5281c0e"><span class="ne-text">可以多次定义赋值</span></li></ul><div class="ne-quote"><p id="de0c36e3edbdbee957ac99fcdfa808d6" class="ne-p"><span class="ne-text">var i = 0;</span></p><p id="860099dbb2710894d93098996226ca2c" class="ne-p"><span class="ne-text">var i = 0;</span></p></div><p id="ed71f4c945d18bad2442c40e1f802617" class="ne-p"><br></p><p id="e8254d958e99a0d08ff6ffaeffa7e111" class="ne-p"><strong><span class="ne-text">【2】let</span></strong></p><ul class="ne-ul"><li id="25474a0c4d77e48d0a4a46a7e38d27e7"><span class="ne-text">作用范围：块作用域</span></li><li id="a9afcf6c118af8e2fe38d77d6230ec3e"><span class="ne-text">会有冗余声明（不可以多次定义赋值）</span></li><li id="1fb550c75ddb693e76698978e23d9141"><span class="ne-text">不会变量提升，俗称“暂时性死区”</span></li></ul><p id="1c050cf0e9ccabc5362225957f0c686f" class="ne-p"><br></p><p id="37bbef0fa25eda71ada360f4d91b4231" class="ne-p"><strong><span class="ne-text">【3】const</span></strong></p><ul class="ne-ul"><li id="067ab39a534217f79f6adff89fa3f32e"><span class="ne-text">作用范围：块作用域</span></li><li id="33666ea26ba42487b84cef5e601af45c"><strong><span class="ne-text">声明变量必须同时初始化变量</span></strong></li><li id="8399546d375b0568936129626249f4d2"><span class="ne-text">尝试修改变量的值报错</span></li><li id="49f0d13a0b574d6cec237d487a23784f"><span class="ne-text">不允许重复声明</span></li><li id="ad16a32248fc0a94d1ce7f5a34ce295a"><span class="ne-text">但对对象操作就不一样了</span></li></ul><p id="0fb976da70fae316328a15fdcc8511cf" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617866749694-8c13df91-894d-41ba-a6bf-4545875594be.png" width="450" id="Tyu1F" class="ne-image"></p><h3 id="hadaa"><span class="ne-text">作用域链</span></h3><p id="9b06e3ef24f988cbf5ada73473af0ca6" class="ne-p" style="text-indent: 2em"><span class="ne-text">因为 var 可以多次声明这一个特点，就产生出了一个问题，在函数里面声明一个变量，在函数外也声明一个同名的变量，就会导致接下来的代码使用哪一个变量的情况。分析是哪个其实也好办，就是看调用的这个函数离哪个声明的变量最近，哪个最近取哪个。</span></p><p id="80a50768986d03c2f827454471ac74cd" class="ne-p"><br></p><p id="479e3709bd121f8ec83beb8b71dc79d6" class="ne-p"><strong><span class="ne-text">作用域链有其解决的办法，那就是利用作用域链，但是使用 let 和 const 更为方便</span></strong><span class="ne-text">。</span></p><p id="866735ea735d526fbf4227849f23cc2a" class="ne-p"><br></p><p id="3f19ead06d1fb42b98104cf2befdb5c8" class="ne-p"><span class="ne-text">比如：循环迭代过程中</span></p><p id="7fbe1e43dfcc7c2fb50235c53d85c645" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617867856859-e30d58a7-ff23-4c94-9690-fa18931b1274.png" width="465" id="R0mLn" class="ne-image"></p><h3 id="QYvRI"><span class="ne-text">预解析和代码执行</span></h3><p id="cef513c0880c7435eacf92f0c844c35a" class="ne-p"><span class="ne-text">浏览器的 js 解析器当中，会将 js 代码分两步执行，分别为，预解析和执行代码</span></p><ul class="ne-ul"><li id="d4260e8a8c85ebc367a453db9e9eccab"><span class="ne-text">预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义</span></li><li id="41fa0c517abcb568eeaf0e218d77268a"><span class="ne-text">代码执行： 从上到下执行 JS 语句</span></li></ul><h3 id="nhps9"><span class="ne-text">使用风格</span></h3><p id="68161edcd295ea2008aee78b61d6f1cc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617866793247-8f59e0d0-c674-4bbb-927d-c0def061ef4b.png" width="453" id="j8Cg3" class="ne-image"></p><p id="0772179df091db79a7fd6a8d5b8153c5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617866805218-d141595e-4964-4c77-8b8a-e0396af6ecc9.png" width="448" id="tYDkb" class="ne-image"></p><h2 id="jdb6i"><span class="ne-text">基本数据类型</span></h2><h3 id="9G5W7"><span class="ne-text">JavaScript 和 java 比较</span></h3><ul class="ne-ul"><li id="fbe394c40227f61e00368d911005a332"><span class="ne-text">JAVA 有八种基本数据类型（byte、short、int、long、float、double、string、boolean）</span></li><li id="16c9f191f6a14d855de7ff25c7e730fa"><span class="ne-text">JavaScript 有六种基本类型（值类型）（Number、String、Boolean、Undefined、Null、Symbol（es6））</span></li></ul><div class="ne-quote"><p id="9cb3393879567f489ae74c826a417b72" class="ne-p"><span class="ne-text">注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。</span></p></div><p id="b12277a330585c4536d2fcd824da6e10" class="ne-p"><strong><span class="ne-text">在 java 中除了以上八种，其他都是以对象 Object（或者说类的实例）存在的，JavaScript 也一样！</span></strong></p><p id="8b2e110078d65672bbe071aea12b0ed1" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="7bad046707bd8d3059e4b2141a38f8f1" class="ne-p"><span class="ne-text">【在 Java.lang 里面有上述八种包装类，在 JavaScript 里面也有相应的概念称之为——包装对象】</span></p><p id="591bbdaf066248259a5f8c8e1a425f19" class="ne-p"><br></p><h3 id="z9IHQ"><span class="ne-text">自动确定类型机制</span></h3><p id="f4e0edcd3e3d01abbabd141904c255ce" class="ne-p" style="text-indent: 2em"><span class="ne-text">JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定，这是和 Java 基本类型不同的一点。</span></p><pre data-language="javascript" id="GSjIl" class="ne-codeblock language-javascript">var age = 10; // 这是一个数字型<br>var forsome= '是的'; // 这是一个字符串</pre><p id="68f2c4303a2a1c7c967ae54726fa8a2b" class="ne-p" style="text-indent: 2em"><span class="ne-text">在代码运行时，变量的数据类型是由 </span><strong><span class="ne-text">JS 引擎</span></strong><span class="ne-text"> 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。</span><strong><span class="ne-text">JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型</span></strong></p><h3 id="e674dc88"><span class="ne-text">number</span></h3><p id="d48e633cddf085a01207a261b9c64ddf" class="ne-p"><span class="ne-text">JavaScript 数字类型既可以保存整数，也可以保存小数(浮点数）。</span></p><p id="41c98be8b4cf427f4c897f0ac3f3b02e" class="ne-p"><br></p><table id="ql3SS" class="ne-table" style="width: 611px"><tbody><tr style="height: 33px"><td width="305"><p id="5e45ec84827cfb9f97c75aaa08781710" class="ne-p"><span class="ne-text">Number.MAX_VALUE</span></p></td><td width="306"><p id="130e7f32aae07295c8a98efa9a3ce6aa" class="ne-p"><span class="ne-text">最大值</span></p></td></tr><tr style="height: 33px"><td width="305"><p id="547b64fb9d070428f592b37d63f975e8" class="ne-p"><span class="ne-text">Number.MIN_VALUE</span></p></td><td width="306"><p id="42f20137ee9e7a5dd3f5f41057fcba2f" class="ne-p"><span class="ne-text">最小值</span></p></td></tr><tr style="height: 33px"><td width="305"><p id="fe06105b5e515933087c9deb23103db7" class="ne-p"><span class="ne-text">Infinity </span></p></td><td width="306"><p id="5ba9e08ee4e145a5117ac331037ba95f" class="ne-p"><span class="ne-text">正无穷大</span></p></td></tr><tr style="height: 33px"><td width="305"><p id="u2b29095d" class="ne-p"><span class="ne-text" style="color: #404040">-Infinity</span></p></td><td width="306"><p id="d6ced9d7c04c424000c39e75d0418591" class="ne-p"><span class="ne-text">负无穷大</span></p></td></tr><tr style="height: 33px"><td width="305"><p id="uafd41328" class="ne-p"><span class="ne-text" style="color: #404040">NaN </span></p></td><td width="306"><p id="40671c008d6bc06d52333a8258445105" class="ne-p"><span class="ne-text">非数值</span></p></td></tr></tbody></table><p id="d54976bd9410ce84c367e96f4e3cfbbd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617862223224-4f56c586-004a-476a-b000-b6ab21d9d76f.png" width="267.5" id="QgHNv" class="ne-image"></p><p id="40c81a2051edce27690e3428ef83c87c" class="ne-p"><span class="ne-text">isNaN()：用来判断一个变量是否为非数字的类型，返回 true 或者 false</span></p><p id="4cde0d9e085d5d43e623f0d427bfbc35" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617862345109-761be59e-466e-4e76-ae90-de038b1eb668.png" width="164.5" id="FD7YB" class="ne-image"></p><h3 id="uY2n4"><span class="ne-text">string</span></h3><ul class="ne-ul"><li id="30b2c7953c7c86c2ad7b35b0e4550e93"><span class="ne-text">转义符：和 java 一样</span></li></ul><table id="VgS2L" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="ue9877b5d" class="ne-p"><span class="ne-text">转义符</span></p></td><td width="375"><p id="u6a61842a" class="ne-p"><span class="ne-text">解释说明</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u44aeffdc" class="ne-p"><span class="ne-text">\n</span></p></td><td width="375"><p id="ue5100e5b" class="ne-p"><span class="ne-text">换行符，n 是 newline 的意思</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u73f7d0d8" class="ne-p"><span class="ne-text">\ &lt;/span&gt;</p></td><td width="375"><p id="ue5964408" class="ne-p"><span class="ne-text">斜杠 &lt;/span&gt;</p></td></tr><tr style="height: 33px"><td width="375"><p id="udd88e141" class="ne-p"><span class="ne-text">‘</span></p></td><td width="375"><p id="u88cc2fc6" class="ne-p"><span class="ne-text">‘ 单引号</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uc84de0ce" class="ne-p"><span class="ne-text">“</span></p></td><td width="375"><p id="ubebb2834" class="ne-p"><span class="ne-text">”双引号</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ubb8ae444" class="ne-p"><span class="ne-text">\t</span></p></td><td width="375"><p id="u1588ec72" class="ne-p"><span class="ne-text">tab 缩进</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u93eb6780" class="ne-p"><span class="ne-text">\b</span></p></td><td width="375"><p id="u3dca8f38" class="ne-p"><span class="ne-text">空格 ，b 是 blank 的意思</span></p></td></tr></tbody></table><ul class="ne-ul"><li id="f287ae23e7879558a6cb42dc2d2d9734"><span class="ne-text">字符串长度：通过字符串的 length 属性可以获取整个字符串的长度。</span></li></ul><pre data-language="plain" id="84EV1" class="ne-codeblock language-plain">var strMsg = "一串文字";<br>alert(strMsg.length); // 显示 4</pre><p id="e9f93860f0d2d5b0c2a4e16aba58eedf" class="ne-p"><br></p><div data-type="danger" class="ne-alert"><p id="7f8553ababaf3f5d577b5c1dadb8bbf8" class="ne-p" style="text-indent: 2em"><span class="ne-text">Java 里面基本数据类型比如定义了一串字符，是没有相应长度 length 属性一说的，除非 new 一个字符的对象。JavaScript 里面也有相应的机制，称之为——</span><strong><span class="ne-text">“包装对象”</span></strong><span class="ne-text">，可以直接使用 length 属性，指的是与数值、字符串、布尔值分别相对应的 Number、String、Boolean 三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象，和 Java 里面一样。</span></p></div><p id="bec7a0d355bbd0182eb012c34cd33a09" class="ne-p"><br></p><ul class="ne-ul"><li id="ac62830550316362bcb30d4b5fe64be5"><span class="ne-text">字符串拼接：和 java 一样，用一个+号就好了</span></li></ul><h3 id="OHZAa"><span class="ne-text">boolean</span></h3><p id="65ae1349d5053d7a31285ed03b9cb765" class="ne-p"><span class="ne-text">布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。</span></p><p id="e84fd2e26d52a12322850dc605aab96d" class="ne-p"><span class="ne-text">布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</span></p><pre data-language="javascript" id="JzX7B" class="ne-codeblock language-javascript">console.log(true + 1); // 2<br>console.log(false + 1); // 1</pre><h3 id="NxgS8"><span class="ne-text">undefined</span></h3><p id="720ca5a45780160a3ac9c2afe4219a12" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617863116062-5457a96b-062e-4262-a093-ea6e30c005cb.png" width="506" id="lgGc7" class="ne-image"></p><h3 id="QbygZ"><span class="ne-text">null</span></h3><ul class="ne-ul"><li id="95fb32d119628744b0263c501eaad1cb"><span class="ne-text">参考教程：</span><a href="https://javascript.ruanyifeng.com/grammar/types.html#toc2" data-href="https://javascript.ruanyifeng.com/grammar/types.html#toc2" target="_blank" class="ne-link"><span class="ne-text">https://javascript.ruanyifeng.com/grammar/types.html#toc2</span></a><span class="ne-text">    </span></li></ul><h3 id="CaEwI"><span class="ne-text">symbol</span></h3><p id="u958c5524" class="ne-p"><a href="https://juejin.cn/post/7091170378243899429" data-href="https://juejin.cn/post/7091170378243899429" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/7091170378243899429</span></a></p><h3 id="R1UJS"><span class="ne-text">数据类型判断及转换</span></h3><h4 id="ZBxR7"><span class="ne-text">typeof、instanceof、constructor、Object.prototype.toString.call()</span></h4><p id="uf7d25ec1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1648801814160-1ac450e7-aee2-49e7-bae9-3dbd1b18fff0.webp" width="737" id="u5794e0ee" class="ne-image"></p><ul class="ne-ul"><li id="uc2463120"><a href="https://www.jianshu.com/p/6f3087a44d83" data-href="https://www.jianshu.com/p/6f3087a44d83" target="_blank" class="ne-link"><span class="ne-text">JS 类型判断 typeof、instanceof、constructor、Object.prototype.toString.call()</span></a></li></ul><h4 id="T5o9d"><span class="ne-text">转换</span></h4><p id="b1017f65214934b4aa69112b1dafbfb4" class="ne-p"><span class="ne-text">使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型</span></p><div class="ne-quote"><p id="8341bc266f56864d5ebbd96ad4fb6bb1" class="ne-p"><span class="ne-text">当参数为： ‘’、0、NaN、null、undefined，转换为 false，其他都转换称 true</span></p></div><h2 id="tw29Y"><span class="ne-text">运算符和表达式</span></h2><div class="ne-quote"><p id="f1bdac82f52feacbce16672c52a851a8" class="ne-p"><span class="ne-text">几乎和 java 里面一样，但是有一些不同</span></p></div><h3 id="Bzl1R"><span class="ne-text">基本</span></h3><ul class="ne-ul"><li id="f93a4d541ac032e85efecb51275eca2a"><span class="ne-text">+-*/%</span></li><li id="45ad3a1c4eba1e3e77045d304fc99c4e"><span class="ne-text">i++和++i 区别</span></li><li id="899c1722e0db3cd3873805589e5d266f"><span class="ne-text">==和===区别就是后者要求值和数据类型都相等，前者只要求值</span></li><li id="801757053c409d5c406e07cb3b1bfbbc"><span class="ne-text">&amp;&amp;与||或!非</span></li></ul><h3 id="rV4uB"><span class="ne-text">逻辑与和逻辑或</span></h3><ul class="ne-ul"><li id="1588e271a35e14b169128b20d4a32ba4"><span class="ne-text">逻辑与</span></li></ul><pre data-language="javascript" id="r46Lc" class="ne-codeblock language-javascript">console.log( 123 && 456 ); // 456<br>console.log( 0 && 456 ); // 0<br>console.log( 123 && 456&& 789 ); // 789</pre><ul class="ne-ul"><li id="b3aeea98c1513eda88ec374ed1c31653"><span class="ne-text">逻辑或</span></li></ul><pre data-language="javascript" id="GGKk8" class="ne-codeblock language-javascript">console.log( 123 || 456 ); // 123<br>console.log( 0 || 456 ); // 456<br>console.log( 123 || 456 || 789 ); // 123</pre><p id="9db1fe6b6fba817d6dfbe5503c9b3edb" class="ne-p"><br></p><p id="593d27c68a8418b9dba8cede19392a9b" class="ne-p"><br></p><h2 id="u2gBR"><span class="ne-text">程序三大基本结构</span></h2><h3 id="cD1tY"><span class="ne-text">顺序结构</span></h3><p id="0409ac153792ff51d807e66eb5bba5bd" class="ne-p"><span class="ne-text">浏览器引擎对 js 代码是从上往下依次执行的！所以 js 代码的位置，以及代码与代码相互依赖的关系顺序都要注意。</span></p><h3 id="9PsRD"><span class="ne-text">选择结构</span></h3><p id="e890f4dded7530d17f9b2b5a671b6f94" class="ne-p"><span class="ne-text">和 Java 一样，都有 if 语句</span></p><p id="ud11400b1" class="ne-p"><span class="ne-text"></span></p><hr id="gcMml" class="ne-hr"><p id="u0fd38d97" class="ne-p"><br></p><ul class="ne-ul"><li id="u56d34b10"><span class="ne-text">switch 语句</span></li></ul><p id="08be078adebdd1c379c79712eaf739bb" class="ne-p"><br></p><pre data-language="javascript" id="yCMyF" class="ne-codeblock language-javascript">switch( 表达式 ){<br>case value1:<br>// 表达式 等于 value1 时要执行的代码<br>break;<br>case value2:<br>// 表达式 等于 value2 时要执行的代码<br>break;<br>default:<br>// 表达式 不等于任何一个 value 时要执行的代码<br>}</pre><p id="ub696e44b" class="ne-p"><br></p><hr id="E4R8a" class="ne-hr"><p id="u4bd4c086" class="ne-p"><br></p><ul class="ne-ul"><li id="u8844da52"><span class="ne-text">条件赋值语句 = 赋值语句 + </span><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" target="_blank" class="ne-link"><span class="ne-text">条件（三元）运算符</span></a></li></ul><pre data-language="javascript" id="ucP1q" class="ne-codeblock language-javascript">// 如果 row 为 true 则 this.actFormOptions.modelObject.assign({}, toShowActFromData(row))<br>this.actFormOptions.model = row ? Object.assign({}, toShowActFromData(row)) : getColumnFormModel(actColumns, defaultActProp)</pre><p id="u95042bca" class="ne-p"><span class="ne-text"></span></p><p id="u79bdaa52" class="ne-p"><span class="ne-text"></span></p><h3 id="69bdc66b"><span class="ne-text">循环结构</span></h3><p id="9f5fc0154d98d39318addfb18498bc71" class="ne-p"><span class="ne-text">和 Java 一样都有，都有 for(){}、while(){}、do{}while()三种结构，以及 continue、break 两个关键字，用法完全一样，在 java 里面有增强的 for 循环一说，js 也有相应的增强的 for 循环。</span></p><p id="89634c6cfea76e555ffd8dd98c3f3086" class="ne-p" style="text-indent: 2em"><br></p><p id="40e828b6b1dc3dfe3413604062a126fa" class="ne-p"><span class="ne-text">for-in 语句</span></p><p id="452de57e58a327227019f0d17ff0183e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622620171596-8dc93211-66d7-4bff-aa7a-f0a1f25fef6b.png" width="536" id="hh3nm" class="ne-image"></p><p id="82f12f9c844211cf144655e575b28d97" class="ne-p"><span class="ne-text">for-of 语句</span></p><p id="aa3e67f4cc97321006824c1ec232217e" class="ne-p"><span class="ne-text">遍历可迭代对象的元素</span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shadowsocks/ByWave使用总结</title>
      <link href="/blog/qt0mw3de2tcn/"/>
      <url>/blog/qt0mw3de2tcn/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS定位</title>
      <link href="/blog/qfka5bkr6swg/"/>
      <url>/blog/qfka5bkr6swg/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="65gks"><span class="ne-text">CSS 布局的三种机制</span></h2><div class="ne-quote"><p id="724554c70ac42551b74ef2ad8d363e1b" class="ne-p"><span class="ne-text">网页布局的核心 —— 就是</span><strong><span class="ne-text">用 CSS 来摆放盒子位置</span></strong><span class="ne-text">。</span></p><p id="u7a88283e" class="ne-p"><span class="ne-text">CSS 提供了 </span><strong><span class="ne-text">3 种机制</span></strong><span class="ne-text">来设置盒子的摆放位置，分别是</span><strong><span class="ne-text">普通流</span></strong><span class="ne-text">、</span><strong><span class="ne-text">浮动</span></strong><span class="ne-text">和</span><strong><span class="ne-text">定位</span></strong></p></div><p id="edae316fcfc6158bd65d60d946024894" class="ne-p"><br></p><div class="ne-quote"><p id="fc10cf71c968792f8eb87c32b43e6f85" class="ne-p"><strong><span class="ne-text">【1】普通流</span></strong><span class="ne-text">（</span><strong><span class="ne-text">标准流</span></strong><span class="ne-text">）</span></p></div><p id="3f9dd38c6447fc6c09f3dd9500607afb" class="ne-p"><span class="ne-text">可以让盒子上下排列或者左右排列的</span></p><ul class="ne-ul"><li id="67c6f632b995ef4e73b5da3b8df402f4"><strong><span class="ne-text">块级元素</span></strong><span class="ne-text">会独占一行，</span><strong><span class="ne-text">从上向下</span></strong><span class="ne-text">顺序排列；</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="236edbcb61b399e70ad3194cb8d9a86b"><span class="ne-text">常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table</span></li></ul></ul><ul class="ne-ul"><li id="b00c5bdcfcc9cd9db53ec08d59915754"><strong><span class="ne-text">行内元素</span></strong><span class="ne-text">会按照顺序，</span><strong><span class="ne-text">从左到右</span></strong><span class="ne-text">顺序排列，碰到父元素边缘则自动换行；</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="d9242960895707a6b9b775a1a1ad63ec"><span class="ne-text">常用元素：span、a、i、em等</span></li></ul></ul><div class="ne-quote"><p id="4f6393051ded8ff63cd5fd82a39ec378" class="ne-p"><strong><span class="ne-text">【2】浮动</span></strong></p></div><ul class="ne-ul"><li id="262eb5b768fb1615537d8abababdd540"><span class="ne-text">让盒子从普通流中</span><strong><span class="ne-text">浮</span></strong><span class="ne-text">起来 —— </span><strong><span class="ne-text">让多个盒子(div)水平排列成一行</span></strong><span class="ne-text">。</span></li><li id="66d451cdcf0680dd5cc3a742f884026b"><span class="ne-text">可以让多个块级元素一行显示  或者 左右对齐盒子   浮动的盒子就是按照顺序左右排列</span></li></ul><div class="ne-quote"><p id="021ee711bb151487bf712b1151a748ca" class="ne-p"><strong><span class="ne-text">【3】定位</span></strong></p></div><ul class="ne-ul"><li id="cb03fe93167fc6d2ec6dca88dcdfa83b"><span class="ne-text">将盒子</span><strong><span class="ne-text">定</span></strong><span class="ne-text">在某一个</span><strong><span class="ne-text">位</span></strong><span class="ne-text">置  自由的漂浮在其他盒子的上面  —— CSS 离不开定位，特别是后面的 js 特效。</span></li><li id="27aec920a4f380f1ed132b42a2a94692"><span class="ne-text">定位最大的特点是有层叠的概念，就是可以让多个盒子 前后 叠压来显示。 但是每个盒子需要测量数值。</span></li></ul><div class="ne-quote"><p id="0f2e6d737c0e906ac7244974bc7863f6" class="ne-p"><strong><span class="ne-text">【结论】</span></strong></p><ul class="ne-ul"><li id="346e0171743956d8d8b703fd72d6dd99"><span class="ne-text">标准流在最底层</span></li><li id="177921ad9727a25b32380ebf22ae4b17"><span class="ne-text">浮动的盒子在中间层</span></li><li id="4c29b0f39bc0ecb42d635fd4ef44d211"><span class="ne-text">定位的盒子在最上层</span></li></ul></div><h2 id="d1Y7J"><span class="ne-text">定位详解</span></h2><p id="f1fa9f746a60f81ef735ba80db36f1c6" class="ne-p"><span class="ne-text">定位也是用来布局的，它有两部分组成：</span></p><div class="ne-quote"><p id="7ecc134c80772b1ce6c928226e3c90d2" class="ne-p"><code class="ne-code"><span class="ne-text" style="background-color: #FADB14">定位 = 定位模式 + 边偏移</span></code></p></div><p id="455389d2b88fdf8ad77ac3ada964412c" class="ne-p" style="text-align: center"><span class="ne-text" style="background-color: #FADB14"><p></span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552456483-b258a0b4-d5e2-43ab-af99-f6eef921bacb.png" width="301" id="tPuDD" class="ne-image"></p><h3 id="1K2Ri"><span class="ne-text">边偏移</span></h3><p id="fb261a241352e64819d572aaba30815c" class="ne-p"><span class="ne-text">简单说， 我们定位的盒子，是通过边偏移来移动位置的。</span></p><p id="1267830c67568ad54390c8d1384f4023" class="ne-p"><span class="ne-text">在 CSS 中，通过 </span><code class="ne-code"><span class="ne-text">top</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">bottom</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">left</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">right</span></code><span class="ne-text"> 属性定义元素的</span><strong><span class="ne-text">边偏移</span></strong><span class="ne-text">：（方位名词）</span></p><table id="kZb6M" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"><p id="uf0893d0e" class="ne-p"><span class="ne-text">边偏移属性</span></p></td><td width="250"><p id="u5b47e94c" class="ne-p" style="text-align: left"><span class="ne-text">示例</span></p></td><td width="250"><p id="u35c861a2" class="ne-p"><span class="ne-text">描述</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ueaaffd79" class="ne-p"><code class="ne-code"><span class="ne-text">top</span></code></p></td><td width="250"><p id="uf9b7c0f0" class="ne-p" style="text-align: left"><code class="ne-code"><span class="ne-text">top: 80px</span></code></p></td><td width="250"><p id="u3bfeb26f" class="ne-p"><strong><span class="ne-text">顶端</span></strong><span class="ne-text">偏移量，定义元素相对于其父元素</span><strong><span class="ne-text">上边线的距离</span></strong><span class="ne-text">。</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u0fae95fb" class="ne-p"><code class="ne-code"><span class="ne-text">bottom</span></code></p></td><td width="250"><p id="u366ababc" class="ne-p" style="text-align: left"><code class="ne-code"><span class="ne-text">bottom: 80px</span></code></p></td><td width="250"><p id="u41d2f3a2" class="ne-p"><strong><span class="ne-text">底部</span></strong><span class="ne-text">偏移量，定义元素相对于其父元素</span><strong><span class="ne-text">下边线的距离</span></strong><span class="ne-text">。</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u6fa5efd3" class="ne-p"><code class="ne-code"><span class="ne-text">left</span></code></p></td><td width="250"><p id="u321cec7e" class="ne-p" style="text-align: left"><code class="ne-code"><span class="ne-text">left: 80px</span></code></p></td><td width="250"><p id="u6b20a4a7" class="ne-p"><strong><span class="ne-text">左侧</span></strong><span class="ne-text">偏移量，定义元素相对于其父元素</span><strong><span class="ne-text">左边线的距离</span></strong><span class="ne-text">。</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ud83f9f2f" class="ne-p"><code class="ne-code"><span class="ne-text">right</span></code></p></td><td width="250"><p id="ube9a64bf" class="ne-p" style="text-align: left"><code class="ne-code"><span class="ne-text">right: 80px</span></code></p></td><td width="250"><p id="u7a671312" class="ne-p"><strong><span class="ne-text">右侧</span></strong><span class="ne-text">偏移量，定义元素相对于其父元素</span><strong><span class="ne-text">右边线的距离</span></strong></p></td></tr></tbody></table><p id="43af9b6612ed81f652b3287c153eb95b" class="ne-p"><span class="ne-text">定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。</span></p><h3 id="4A2UW"><span class="ne-text">static</span></h3><ul class="ne-ul"><li id="331e4f6a35ce0d54170a1ee05026bdad"><strong><span class="ne-text">静态定位</span></strong><span class="ne-text">是元素的默认定位方式，无定位的意思。它相当于 border 里面的 none， 不要定位的时候用。</span></li><li id="80ce23d3b66c7604285b97fe1b469aaa"><span class="ne-text">静态定位 按照标准流特性摆放位置，它没有边偏移。</span></li><li id="435fecf0c833a4e4cf3d3d29be4a3dfb"><span class="ne-text">静态定位在布局时我们几乎不用的</span></li></ul><h3 id="GFG3d"><span class="ne-text">relative</span></h3><ul class="ne-ul"><li id="dd42d137e5033eb61538e251049a13bb"><strong><span class="ne-text">相对定位</span></strong><span class="ne-text">是元素</span><strong><span class="ne-text" style="background-color: #FADB14">相对</span></strong><span class="ne-text" style="background-color: #FADB14">于它原来在标准流中的位置 </span><span class="ne-text">来说的。（自恋型）</span><strong><span class="ne-text"></span></strong></li></ul><p id="79bf9ba704f0110d328df135a7de910f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552470167-bd2f5289-4670-4b1f-9b22-1361f8cd58d0.png" width="365" id="hJGMp" class="ne-image"></p><p id="c1d344c57d750307207fec2a4c93df18" class="ne-p"><span class="ne-text">相对定位的特点：（务必记住）</span></p><ul class="ne-ul"><li id="c2a9d82d9882e894f0665b319ea45e4e"><span class="ne-text">相对于 </span><span class="ne-text" style="background-color: #FADB14">自己原来在标准流中位置</span><span class="ne-text">来移动的</span></li><li id="4bbc08ef0de456d9d40eba1b4743a2bc"><span class="ne-text" style="background-color: #FADB14">原来</span><strong><span class="ne-text" style="background-color: #FADB14">在标准流的区域继续占有</span></strong><span class="ne-text">，后面的盒子仍然以标准流的方式对待它。</span></li></ul><h3 id="HdfJM"><span class="ne-text">absolute</span></h3><div class="ne-quote"><p id="4e4c61a9eda6b0d988624646a72d60d4" class="ne-p"><strong><span class="ne-text">【1】绝对定位</span></strong><span class="ne-text">是元素以</span><span class="ne-text" style="background-color: #FADB14">带有定位的父级元素</span><span class="ne-text">来移动位置 （拼爹型）</span></p></div><ul class="ne-ul"><li id="9575cff1d09fecb62c7624a84da41ff5"><strong><span class="ne-text">完全脱标</span></strong><span class="ne-text">：完全不占位置，完全镂空</span></li><li id="8bf51dee24b5b51b7bc4fae1dfe74ef1"><strong><span class="ne-text">父元素没有定位：</span></strong><span class="ne-text">则</span><span class="ne-text" style="background-color: #FADB14">以</span><strong><span class="ne-text" style="background-color: #FADB14">浏览器</span></strong><span class="ne-text" style="background-color: #FADB14">为准定位</span><span class="ne-text">（Document 文档）。</span></li><li id="ee0b69474d539a5bef37523d4679b5c7"><strong><span class="ne-text">父元素要有定位：</span></strong><span class="ne-text">将元素依据</span><span class="ne-text" style="background-color: #FADB14">最近的已经定位（绝对、固定或相对定位）的父元素</span><span class="ne-text">（祖先）进行定位。</span></li><li id="c2033b627f9b53d96424c366617b842a"><span class="ne-text" style="background-color: #FADB14">绝对是以带有定位的父级元素来移动位置， 如果父级都没有定位，则以浏览器文档为准移动位置</span></li><li id="8107c669dc33a33cd93a0866117e5b7f"><span class="ne-text">不保留原来的位置，完全是脱标的。</span></li></ul><p id="e0bfb2f31e6e5a4a75328ded17f972d3" class="ne-p"><br></p><div class="ne-quote"><p id="8e05428a270afb4dbb178db748d114c5" class="ne-p"><span class="ne-text">【2】子级元素使用绝对定位时，父级元素就要用相对定位</span></p></div><p id="26f0f4debd399214965f47acd79bfa1b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552541033-59cb288a-ccb1-4ccb-aa4c-e4550e99edf0.png" width="617" id="Nzb9x" class="ne-image"></p><div class="ne-quote"><p id="b75da7bdce2e85eb000ecf30896d4fd9" class="ne-p"><strong><span class="ne-text">分析</span></strong></p></div><ul class="ne-ul"><li id="d618608aff39b7822f091431719bcedc"><strong><span class="ne-text">方向箭头</span></strong><span class="ne-text">叠加在其他图片上方，应该使用</span><strong><span class="ne-text">绝对定位</span></strong><span class="ne-text">，因为</span><strong><span class="ne-text">绝对定位完全脱标</span></strong><span class="ne-text">，完全不占位置。</span></li><li id="c076c7c69bba3cbf65c5ea9b70534bf2"><strong><span class="ne-text">父级盒子</span></strong><span class="ne-text">应该使用</span><strong><span class="ne-text">相对定位</span></strong><span class="ne-text">，因为</span><strong><span class="ne-text" style="background-color: #FADB14">相对定位不脱标</span></strong><span class="ne-text" style="background-color: #FADB14">，后续盒子仍然以标准流的方式对待它</span><span class="ne-text">。</span></li><li id="d054a418d38211b7819ce50c458f2fda"><span class="ne-text">如果父级盒子也使用</span><strong><span class="ne-text">绝对定位</span></strong><span class="ne-text">，会完全脱标，那么下方的</span><strong><span class="ne-text">广告盒子</span></strong><span class="ne-text">会上移，这显然不是我们想要的。</span></li></ul><h3 id="1ngvh"><span class="ne-text">fixed</span></h3><ul class="ne-ul"><li id="14e1df3d5ea13ae4e65b0ae6a7fae03f"><strong><span class="ne-text">固定定位</span></strong><span class="ne-text">是</span><strong><span class="ne-text">绝对定位</span></strong><span class="ne-text">的一种特殊形式： （认死理型） </span></li><li id="1cac66d1bd321be37c94d60cd6a334b2"><strong><span class="ne-text">完全脱标</span></strong><span class="ne-text"> —— 完全不占位置；</span></li><li id="39c0532981c4ce636b3bc5a6fa8cb6f4"><span class="ne-text">只认</span><strong><span class="ne-text">浏览器的可视窗口</span></strong><span class="ne-text"> —— </span><code class="ne-code"><span class="ne-text">浏览器可视窗口 + 边偏移属性</span></code><span class="ne-text"> 来设置元素的位置；</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="20e4fcadce41afb9b037c549d45d3c29"><span class="ne-text" style="background-color: #FADB14">跟父元素没有任何关系；单独使用的</span></li><li id="f35266c895be9f1023dd2e0e5f933c96"><span class="ne-text">不随滚动条滚动。</span></li></ul></ul><div class="ne-quote"><p id="23667b0e72a02c9503d0fc160e82c755" class="ne-p"><span class="ne-text">案例演练：固定定位案例。</span></p></div><p id="b552766fb43e413630fbfbb9c583338c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552558881-329f4f76-7ace-4fdd-840d-40a651c628ad.png" width="610.5" id="dVYeK" class="ne-image"></p><p id="5f3773a56e8eaff000ffb1fcf238c5fc" class="ne-p"><strong><span class="ne-text">提示</span></strong><span class="ne-text">：IE 6 等低版本浏览器不支持固定定位。</span></p><h3 id="t5NV1"><span class="ne-text">Demo：轮播图</span></h3><p id="fb46235baba689e57749b342fabae2d5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616243009664-321f94d9-d92b-4503-9ff3-beaf87f2413e.png" width="960" id="RvrWd" class="ne-image"></p><div class="ne-quote"><p id="ff1b950566f10e46a24f5c420e8b970a" class="ne-p"><span class="ne-text">圆角矩形设置 4 个角</span></p></div><ul class="ne-ul"><li id="6d73e870c448f85b869d03b19b93958e"><span class="ne-text">圆角矩形可以为 4 个角分别设置圆度， 但是是有顺序的</span></li></ul><pre data-language="css" id="SlFVQ" class="ne-codeblock language-css">border-top-left-radius:20px;<br>border-top-right-radius:20px;<br>border-bottom-right-radius:20px;<br>border-bottom-left-radius:20px;</pre><ul class="ne-ul"><li id="3009035cd1ebf3fad224902ec6fd7a0f"><span class="ne-text">如果 4 个角，数值相同</span></li></ul><pre data-language="css" id="N8KrX" class="ne-codeblock language-css">border-radius: 15px;</pre><ul class="ne-ul"><li id="ffd12c25f9293674bc08021abb0391a7"><span class="ne-text">里面数值不同，我们也可以按照简写的形式，</span><span class="ne-text">还是遵循的顺时针。</span></li></ul><pre data-language="css" id="Pp6ot" class="ne-codeblock language-css">border-radius: 左上角 右上角 右下角 左下角;</pre><pre data-language="html" id="rj5qh" class="ne-codeblock language-html"><!DOCTYPE html></p><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title>    <style>        * {            padding: 0;            margin: 0;        }        li {            list-style: none;        }        .box {            width: 400px;            height: 300px;            background-color: tan;            position: relative;            margin: 0 auto;        }        .row_left {            position: absolute;            width: 20px;            height: 30px;            top: 50%;            left: 0;            margin-top: -15px;            border: 1px darkgoldenrod solid;            line-height: 30px;            border-top-right-radius:30px;            border-bottom-right-radius:30px;            text-align: left;        }        .row_right {            position: absolute;            width: 20px;            height: 30px;            top: 50%;            right: 0;            margin-top: -15px;            border: 1px darkgoldenrod solid;            line-height: 30px;            border-top-left-radius:30px;            border-bottom-left-radius:30px;            text-align: right;        }        .bottom_dots {            position: absolute;            width: 110px;            height: 22px;            bottom: 10px;            left: 50%;            margin-left: -50px;            border: springgreen 1px solid;            border-radius: 10px;        }        .row_left:hover,        .row_right:hover {            background-color: yellowgreen;        }<pre><code>    .bottom_dots li &#123;        float: left;        width: 20px;        height: 20px;        border-radius: 50%;        border: steelblue solid 1px;    &#125;    .bottom_dots .current &#123;        background-color: tomato;    &#125;&lt;/style&gt;</code></pre></head><body>    <div class="box">        <div class="row_left"><</div>        <div class="row_right">></div>        <ul class="bottom_dots">            <li></li>            <li class="current"></li>            <li></li>            <li></li>            <li></li>        </ul>    </div></body></html></pre><h3 id="YIsso"><span class="ne-text">Demo：网站右下角快捷功能</span></h3><ul class="ne-ul"><li id="cd3a0fa344613d8115a8f7296762ebb8"><strong><span class="ne-text">注意</span></strong><span class="ne-text">：不要同时使用 </span><code class="ne-code"><span class="ne-text">left</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">right</span></code><span class="ne-text"> 和边偏移属性。</span><strong><span class="ne-text"></span></strong></li><li id="9521ffcacff82408c09e4f640086213e"><strong><span class="ne-text">固定定位</span></strong><span class="ne-text">的应用场景：</span><strong><span class="ne-text">固定在浏览器可视窗口某个位置的布局</span></strong><span class="ne-text">；</span></li><li id="b35f8fc0ee97f3e5aa6ba71c095a8e99"><span class="ne-text">在使用固定和绝对定位时，如果盒子中没有内容，需要指定宽度，下面的例子又宽度</span></li></ul><p id="68d1de6a9c23d84ce731913b5c206789" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616239742720-28510068-3322-4b73-ad28-8a345ba5f8c6.png" width="960" id="pTRHC" class="ne-image"></p><h2 id="gHroO"><span class="ne-text">定位的相关问题</span></h2><h3 id="VmeQ1"><span class="ne-text">绝对定位的盒子居中</span></h3><div class="ne-quote"><p id="04b3a9f11f4b6bf0df3b853a3d5fdba7" class="ne-p"><strong><span class="ne-text" style="background-color: #FADB14">注意</span></strong><span class="ne-text" style="background-color: #FADB14">：</span><strong><span class="ne-text" style="background-color: #FADB14">绝对定位/固定定位的盒子</span></strong><span class="ne-text" style="background-color: #FADB14">不能通过设置 </span><code class="ne-code"><span class="ne-text" style="background-color: #FADB14">margin: auto</span></code><span class="ne-text" style="background-color: #FADB14"> 设置</span><strong><span class="ne-text" style="background-color: #FADB14">水平居中</span></strong><span class="ne-text" style="background-color: #FADB14">。</span></p></div><p id="2733432ec4c32d5473b9fa84161e3135" class="ne-p"><span class="ne-text">在使用</span><strong><span class="ne-text">绝对定位</span></strong><span class="ne-text">时要想实现水平居中，可以按照下面的方法：</span></p><ol class="ne-ol"><li id="8c06e18365b09613746b656e3013218c"><code class="ne-code"><span class="ne-text">left: 50%;</span></code><span class="ne-text">：让</span><strong><span class="ne-text">盒子的左侧</span></strong><span class="ne-text">移动到</span><strong><span class="ne-text">父级元素的水平中心位置</span></strong><span class="ne-text">；</span></li><li id="5639daa73293066eb95f618cd5596eb2"><code class="ne-code"><span class="ne-text">margin-left: -100px;</span></code><span class="ne-text">：让盒子</span><strong><span class="ne-text">向左</span></strong><span class="ne-text">移动</span><strong><span class="ne-text">自身宽度的一半</span></strong><span class="ne-text">。</span></li></ol><p id="0d83f3805ed7919c00bef9a3f04c9a68" class="ne-p"><span class="ne-text">整体居中如下设置</span></p><p id="e5be7eaec3cb956b3e7bdb2960681d11" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616240730926-4415dd36-b842-4cc8-b0a2-49345b503a43.png" width="1920" id="U8COT" class="ne-image"></p><p id="dff5bbe7cdeb1d6ecfe6f49808ad8930" class="ne-p"><br></p><h3 id="lTMxE"><span class="ne-text">z-index</span></h3><ul class="ne-ul"><li id="cf5426f76cd1774030b9f8350f9d6a36"><span class="ne-text">在使用</span><strong><span class="ne-text">定位</span></strong><span class="ne-text">布局时，可能会</span><strong><span class="ne-text">出现盒子重叠的情况</span></strong><span class="ne-text">。</span></li><li id="b7474ae292e77bb67aa37b46fb54550c"><span class="ne-text">加了定位的盒子，默认</span><strong><span class="ne-text">后来者居上</span></strong><span class="ne-text">， 后面的盒子会压住前面的盒子。</span></li><li id="98b244a4b7393536e332be065c6bfdb9"><span class="ne-text">应用 </span><code class="ne-code"><span class="ne-text">z-index</span></code><span class="ne-text"> 层叠等级属性可以</span><strong><span class="ne-text">调整盒子的堆叠顺序</span></strong><span class="ne-text">。如下图所示：</span></li></ul><p id="25cd43f3aa4d88c6b4b97cbb30e93f1e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552609219-135cc13d-9a4e-411e-bac1-3b3fcad55d5e.png" width="622.5" id="FpYQs" class="ne-image"></p><div class="ne-quote"><p id="063262891111d21d460e4da48a13cd72" class="ne-p"><code class="ne-code"><span class="ne-text">z-index</span></code><span class="ne-text"> 的特性如下：</span></p></div><ul class="ne-ul"><li id="5c1828638f0025f7546bc78b74336c22"><strong><span class="ne-text">属性值</span></strong><span class="ne-text">：</span><strong><span class="ne-text">正整数</span></strong><span class="ne-text">、</span><strong><span class="ne-text">负整数</span></strong><span class="ne-text">或 </span><strong><span class="ne-text">0</span></strong><span class="ne-text">，默认值是 0，</span><span class="ne-text" style="background-color: #FADB14">数值越大，盒子越靠上</span><span class="ne-text">；</span></li><li id="12acdffa2fed8e2fe09f2ff82ece7ca5"><span class="ne-text">如果</span><strong><span class="ne-text">属性值相同</span></strong><span class="ne-text">，则按照书写顺序，</span><strong><span class="ne-text">后来居上</span></strong><span class="ne-text">；</span></li><li id="10e253e2f66239d776cd64004a570b71"><strong><span class="ne-text">数字后面不能加单位</span></strong><span class="ne-text">。</span></li><li id="e1cf084fa0cdb11f0ab8e4e4952a17a0"><strong><span class="ne-text">注意</span></strong><span class="ne-text">：</span><code class="ne-code"><span class="ne-text">z-index</span></code><span class="ne-text"> 只能应用于</span><strong><span class="ne-text">相对定位</span></strong><span class="ne-text">、</span><strong><span class="ne-text">绝对定位</span></strong><span class="ne-text">和</span><strong><span class="ne-text">固定定位</span></strong><span class="ne-text">的元素，其他</span><strong><span class="ne-text">标准流</span></strong><span class="ne-text">、</span><strong><span class="ne-text">浮动</span></strong><span class="ne-text">和</span><strong><span class="ne-text">静态定位</span></strong><span class="ne-text">无效。</span></li></ul><h3 id="tElMM"><span class="ne-text">定位改变display属性</span></h3><p id="47a3b713314689865e3381fc8c0676d6" class="ne-p"><span class="ne-text">前面我们讲过，display是显示模式，可以改变显示模式有以下方式:</span></p><ul class="ne-ul"><li id="c61fb1545c072579bf87260f723645cf"><span class="ne-text">可以用inline-block  转换为行内块</span></li><li id="ab2a8ea79335be9dd1072c8217d1bbaa"><span class="ne-text">可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）</span></li><li id="98ae6ec17d21e910e10651e39347feab"><span class="ne-text">绝对定位和固定定位也和浮动类似， 默认转换的特性转换为行内块。</span></li></ul><p id="d8b740389eae7cb20a3e57c5d26aab4c" class="ne-p"><span class="ne-text">所以说， 一个行内的盒子，如果加了</span><strong><span class="ne-text">浮动</span></strong><span class="ne-text">、</span><strong><span class="ne-text">固定定位</span></strong><span class="ne-text">和</span><strong><span class="ne-text">绝对定位</span></strong><span class="ne-text">，不用转换，就可以给这个盒子直接设置宽度和高度等。</span></p><div class="ne-quote"><p id="a6f42af6bd0cf0a011eb36f1b069f922" class="ne-p"><strong><span class="ne-text">同时注意：</span></strong></p></div><p id="aafbd03eda2dfa99dcc0735091d3e864" class="ne-p"><span class="ne-text">浮动元素、绝对定位(固定定位）元素的都不会触发外边距合并的问题。 （我们以前是用padding border overflow解决的）</span></p><p id="7f815c6a0925a73b63dae3d21a5817ab" class="ne-p"><span class="ne-text">也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。</span></p><p id="f6b3a849d3b4e348a77a602292c88baa" class="ne-p"><br></p><p id="9cfb767413c757141c9c6f05ba097f84" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 布局 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS浮动</title>
      <link href="/blog/vgixv5vex3i8/"/>
      <url>/blog/vgixv5vex3i8/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="Pnpum"><span class="ne-text">浮动详解</span></h2><h3 id="YjyYs"><span class="ne-text">为什么需要浮动</span></h3><ul class="ne-ul"><li id="7fe98f969121ab3da7e79bf3bc0f5d3b"><span class="ne-text">多个盒子(div)水平排列成一行</span></li><li id="f450cb6b8b07c6696515dbffa535ba73"><span class="ne-text">实现盒子的左右对齐</span></li><li id="6718aa183014881ad0069ba82f5c092d"><span class="ne-text">行内块（inline-block）</span><span class="ne-text">它可以实现多个元素一行显示，但是中间会有空白缝隙，不能满足以上第一个问题。</span></li><li id="3d3fe32ff4a5c1b956bb07a704f2b33e"><span class="ne-text">行内块（inline-block）不能实现以上第二个问题，盒子左右对齐</span></li></ul><h3 id="IEEfh"><span class="ne-text">浮动特点</span></h3><div class="ne-quote"><p id="0fde6a0492814b5705a53b8c6914a860" class="ne-p"><strong><span class="ne-text">概念</span></strong><span class="ne-text">：元素的浮动是指</span><strong><span class="ne-text">设置了浮动属性的元素</span></strong><span class="ne-text">会</span></p></div><ul class="ne-ul"><li id="55f5b825ae004b7e42be440ff72fd7c4"><span class="ne-text">脱离标准普通流的控制</span></li><li id="367f43a10c3797faf9c708191edb1381"><span class="ne-text">移动到指定位置</span></li></ul><div class="ne-quote"><p id="84682cd9897038d8c192d9e247f3ac76" class="ne-p"><span class="ne-text">作用</span></p></div><ul class="ne-ul"><li id="38fbcead580fd692865b133eee5ca680"><strong><span class="ne-text" style="color: #F5222D">让多个盒子(div)水平排列成一行</span></strong><span class="ne-text">，使得浮动成为布局的重要手段。</span></li><li id="6de5316c386b3f6df7edddc747732d3c"><span class="ne-text">可以实现盒子的左右对齐等等..</span></li><li id="2bc6e1d004f79b9031044b3cd1727675"><span class="ne-text">浮动最早是用来</span><strong><span class="ne-text">控制图片</span></strong><span class="ne-text">，实现</span><strong><span class="ne-text">文字环绕图片的效果</span></strong><span class="ne-text">。</span></li></ul><div class="ne-quote"><p id="f83501794e2e93a82b5306c3bfadd752" class="ne-p"><span class="ne-text">语法</span></p></div><pre data-language="css" id="UuSPJ" class="ne-codeblock language-css">选择器 { float: 属性值; }</pre><table id="prf6J" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u7cd09a85" class="ne-p"><span class="ne-text">属性值</span></p></td><td width="375"><p id="u8b7181df" class="ne-p"><span class="ne-text">描述</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u6efbd0a2" class="ne-p"><strong><span class="ne-text">none</span></strong></p></td><td width="375"><p id="uc645375d" class="ne-p"><span class="ne-text">元素不浮动（</span><strong><span class="ne-text">默认值</span></strong><span class="ne-text">）</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u9cf8251f" class="ne-p"><strong><span class="ne-text">left</span></strong></p></td><td width="375"><p id="ufac7de07" class="ne-p"><span class="ne-text">元素向</span><strong><span class="ne-text">左</span></strong><span class="ne-text">浮动</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u1f133063" class="ne-p"><strong><span class="ne-text">right</span></strong></p></td><td width="375"><p id="u7e1b66ed" class="ne-p"><span class="ne-text">元素向</span><strong><span class="ne-text">右</span></strong><span class="ne-text">浮动</span></p></td></tr></tbody></table><div class="ne-quote"><p id="0f39c1fdfa4940bad68a51e9c2393f29" class="ne-p"><span class="ne-text">特点1：浮</span></p></div><ul class="ne-ul"><li id="2a2949829b327623764c499f92b30d62"><span class="ne-text">浮动——浮</span><sub><span class="ne-text">浮</span></sub><span class="ne-text">浮~~~漂浮在普通流的上面。  脱离标准流。 俗称 “脱标”</span></li><li id="3dd3592c9477cb4b17ac7d41c0929e4d"><code class="ne-code"><span class="ne-text">float</span></code><span class="ne-text"> 属性会</span><span class="ne-text" style="background-color: #FADB14">让盒子漂浮在标准流的上面</span><span class="ne-text">，所以第二个标准流的盒子跑到浮动盒子的底下了。</span></li></ul><p id="0b5b0c88f34f52519f53f1e69faaeba7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616233538999-0a7d098b-a897-491c-b25c-36f34eb7b193.png" width="960" id="g1rEz" class="ne-image"></p><ul class="ne-ul"><li id="b9e590f2bc293d29382d423fb2b3f8b5"><span class="ne-text">上图问题1处出现文字被撑开的情况，似乎和预想的有一丢丢的不尽如意，原因是对于文本和行内元素来说依然是占用空间的</span></li></ul><div class="ne-quote"><p id="8c20acd9f9ab93e0aa9d4e7ea93c9c9c" class="ne-p"><span class="ne-text">特点2：漏</span></p></div><ul class="ne-ul"><li id="fd36b579359bbe2926e6b3a549b84fe8"><span class="ne-text">浮动——漏</span><sub><span class="ne-text">漏</span></sub><span class="ne-text">漏~  浮动的盒子，把自己原来的位置漏给下面标准流的盒子，就是不占有原来位置，是脱离标准流的，我们俗称 “脱标”。</span></li></ul><div class="ne-quote"><p id="431f97ac0f0723691f3a342fa5a42d05" class="ne-p"><span class="ne-text">特点3：特</span></p></div><ul class="ne-ul"><li id="f9b94d5d9bf202de9a747e893cda496f"><span class="ne-text">浮动——特性  float属性</span><span class="ne-text" style="background-color: #FADB14">会改变元素display属性</span><span class="ne-text">。</span></li><li id="82472b2355811e914bc07a76fc445270"><span class="ne-text">任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 生成的块级框和我们前面的行内块极其相似，所以出现了上面浮里面的例子当中父元素里面的文字被撑开的情况</span></li></ul><p id="b08b4725742ce3a26387b33231ee6d8a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616234017630-4391a0b4-6214-42ba-a1f2-cd44c1a99f94.png" width="960" id="xv7E0" class="ne-image"></p><ul class="ne-ul"><li id="2a115c14676bfc7e332ecebcce2c60bc"><strong><span class="ne-text">浮动的元素互相贴靠一起的，但是如果父级宽度装不下这些浮动的盒子， </span></strong><strong><span class="ne-text" style="background-color: #FADB14">多出的盒子会另起一行对齐</span></strong></li></ul><h3 id="RuL9h"><span class="ne-text">Demo：</span><span class="ne-text">浮动+标准流的布局</span></h3><div class="ne-quote"><p id="4ef971344694c0c7aba13859866c208a" class="ne-p"><span class="ne-text">浮动和标准流的父盒子搭配</span></p></div><p id="bf973f234adc970e1fc93111a591375b" class="ne-p"><span class="ne-text">我们知道，</span><span class="ne-text" style="color: #F5222D">浮动是脱标的，会影响下面的标准流元素，此时，我们需要给浮动的元素添加一个标准流的父亲，这样，最大化的减小了对其他标准流的影响。</span><strong><span class="ne-text"></span></strong></p><p id="e0f64ac51914923bab3cc58c492974ad" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616236830103-21860906-bc1f-48a8-8fb1-a5011f02a551.png" width="960" id="dIXWA" class="ne-image"></p><h2 id="wQdZz"><span class="ne-text">浮动的相关问题</span></h2><h3 id="IM9H6"><span class="ne-text">浮动元素与父盒子的关系</span></h3><ul class="ne-ul"><li id="4b46306c53c4ceedf33ae623d4b68bac"><span class="ne-text">子盒子的浮动参照父盒子对齐</span></li><li id="14156dcbcedc089b2ca10dbdda908395"><span class="ne-text">不会与父盒子的边框重叠，也不会超过父盒子的内边距</span></li></ul><p id="6a9f60c0d5cef8b6617cfa7a54fc6d38" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616237499108-fe82abe6-42c1-4f37-ad68-d45c3f78cd11.png" width="960" id="ilWC3" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616237548311-79fb762c-6f7d-45c0-b316-14a12ba92098.png" width="960" id="vhwGB" class="ne-image"></p><h3 id="9GPll"><span class="ne-text">浮动元素与兄弟盒子的关系</span></h3><p id="2db6f72e32f7cbd488ae7c9b91224da0" class="ne-p"><span class="ne-text">在一个父级盒子中，如果</span><strong><span class="ne-text">前一个兄弟盒子</span></strong><span class="ne-text">是：</span></p><ul class="ne-ul"><li id="fc323f18b46c5cccacd0a074b5744147"><strong><span class="ne-text">浮动</span></strong><span class="ne-text">的，那么</span><strong><span class="ne-text">当前盒子</span></strong><span class="ne-text">会与前一个盒子的顶部对齐；</span></li><li id="2f3e4959d009695be5dfd7d34a3702ac"><strong><span class="ne-text">普通流</span></strong><span class="ne-text">的，那么</span><strong><span class="ne-text">当前盒子</span></strong><span class="ne-text">会显示在前一个兄弟盒子的下方。</span></li></ul><ul class="ne-ul"><li id="a4ccf5f65ce1b09d20fe82716c312743"><span class="ne-text">浮动只会影响当前的或者是后面的标准流盒子，不会影响前面的标准流。</span></li></ul><p id="5d3acedd395a92571db9f70946806e50" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1611549557830-9fdd5350-af70-4793-8dba-cc3c06214b72.jpg" width="486" id="g7jBt" class="ne-image"></p><ul class="ne-ul"><li id="b2c8cf509911ffbf403e3708153b1d99"><strong><span class="ne-text">如果一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动。防止引起问题</span></strong></li></ul><h3 id="vDgC2"><span class="ne-text">为什么要清除浮动</span></h3><ul class="ne-ul"><li id="76265c07e0eb08052994d26955f82330"><span class="ne-text">因为父级盒子很多情况下，不方便给高度，但是子盒子浮动就不占有位置，最后父级盒子高度为0，就影响了下面的标准流盒子</span></li></ul><p id="3c65b916d269495dc3549c4506a2e21f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616238120449-097b5efe-31ea-43f9-b393-4e64e9836530.png" width="960" id="YeDHm" class="ne-image"></p><p id="bdc86e98cfb6b0c1d2ed01a6df31ded3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616238209810-a8b31f63-37b3-4289-a691-e52ab55f8203.png" width="960" id="CKrnI" class="ne-image"></p><ul class="ne-ul"><li id="babd04fd874137e57cc04b4d0600404d"><span class="ne-text">总结：由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，准确地说，并不是清除浮动，而是</span><strong><span class="ne-text">清除浮动后造成的影响</span></strong></li><li id="dd0def44fdbaa9b594f8a6d5574dc18d"><strong><span class="ne-text">所以还是最好利用一个标准流为父盒子，里面套数个浮动盒子最为好用</span></strong></li></ul><div class="ne-quote"><p id="428b625cbbb7ce77cd124a42a92bb8e3" class="ne-p"><strong><span class="ne-text">清除浮动本质：</span></strong></p><p id="u68725ad3" class="ne-p"><strong><span class="ne-text" style="background-color: #FADB14">清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题</span></strong><strong><span class="ne-text">。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了</span></strong></p></div><h3 id="W1MTH"><span class="ne-text">清除浮动的方法</span></h3><ul class="ne-ul"><li id="d312522c5925acc97d1f46b9facb0946"><span class="ne-text">clear属性用于清除浮动</span></li></ul><table id="9Apov" class="ne-table" style="width: 634px"><tbody><tr style="height: 33px"><td width="317"><p id="uf8b0a08f" class="ne-p"><span class="ne-text">属性值</span></p></td><td width="317"><p id="ue63a6de6" class="ne-p"><span class="ne-text">描述</span></p></td></tr><tr style="height: 33px"><td width="317"><p id="u6ac652ed" class="ne-p"><span class="ne-text">left</span></p></td><td width="317"><p id="u3462895a" class="ne-p"><span class="ne-text">不允许左侧有浮动元素（清除左侧浮动的影响）</span></p></td></tr><tr style="height: 33px"><td width="317"><p id="u1ecadbf6" class="ne-p"><span class="ne-text">right</span></p></td><td width="317"><p id="u1c4e7b2a" class="ne-p"><span class="ne-text">不允许右侧有浮动元素（清除右侧浮动的影响）</span></p></td></tr><tr style="height: 33px"><td width="317"><p id="u2040bf3a" class="ne-p"><span class="ne-text">both</span></p></td><td width="317"><p id="u173b26f5" class="ne-p"><span class="ne-text">同时清除左右两侧浮动的影响</span></p></td></tr></tbody></table><p id="6e9bce7e97d5d22debeadd67f3b5ef31" class="ne-p"><br></p><h4 id="enI7K"><span class="ne-text">clear:both</span></h4><p id="4ac5f6d0397e3560e92eb56786fabde1" class="ne-p"><span class="ne-text">是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 </span><code class="ne-code"><span class="ne-text"><div style=”clear:both”></div></span></code><span class="ne-text">，或则其他标签br等亦可。</span></p><ul class="ne-ul"><li id="106bb9b7a67e28ed03cb38b3020a3871"><span class="ne-text">优点： 通俗易懂，书写方便</span></li><li id="884ed29906ba71b0f119e4557c4f950e"><span class="ne-text">缺点： 添加许多无意义的标签，结构化较差。</span></li></ul><h4 id="c6y3n"><span class="ne-text">overflow: hidden;</span></h4><p id="f1a1c620ee8153583146af43159f338e" class="ne-p"><span class="ne-text">可以给父级添加： overflow为 hidden| auto| scroll  都可以实现。</span></p><ul class="ne-ul"><li id="1bcb0c5138d96d02cf1ad23e840b6fa7"><span class="ne-text">优点：  代码简洁</span></li><li id="49fab35d4a352416b4472fd7a36d9c70"><span class="ne-text">缺点：  内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</span></li></ul><h4 id="xMs3g"><span class="ne-text">使用after伪元素清除浮动</span></h4><div class="ne-quote"><p id="92ad997409a0ef9eef1c88f3e51d1e06" class="ne-p"><strong><span class="ne-text">:after 方式为空元素额外标签法的升级版，好处是不用单独加标签了</span></strong></p></div><pre data-language="css" id="4Uw7k" class="ne-codeblock language-css">.clearfix:after {<p>content: “”;<br>display: block;<br>height: 0;<br>clear: both;<br>visibility: hidden;<br>}<br>.clearfix {<br><em>zoom: 1;<br>} /</em> IE6、7 专有 */</pre><ul class="ne-ul"><li id="21f9c49158fd67d535e786fbd21e2d26"><span class="ne-text">优点： 符合闭合浮动思想 结构语义化正确</span></li><li id="da3589ab0eda11f91f3179bd17fb4d12"><span class="ne-text">缺点： 由于 IE6-7 不支持:after，使用 zoom:1 触发 hasLayout。</span></li><li id="c8b058f2ab76d9e4821939a59b60a7e0"><span class="ne-text">代表网站： 百度、淘宝网、网易等</span></li></ul><h4 id="ys7kP"><span class="ne-text">使用双伪元素清除浮动</span></h4><pre data-language="css" id="qvhzW" class="ne-codeblock language-css">.clearfix:before,.clearfix:after {<br>content:"";<br>display:table;<br>}<br>.clearfix:after {<br>clear:both;<br>}<br>.clearfix {<br>*zoom:1;<br>}</pre><ul class="ne-ul"><li id="1b4bfabffd301eb9633b9611a32e5d74"><span class="ne-text">优点： 代码更简洁</span></li><li id="eb4353557a6e2a844a063e0806623d7b"><span class="ne-text">缺点： 由于 IE6-7 不支持:after，使用 zoom:1 触发 hasLayout。</span></li><li id="2e20a92d3c148e2ee11f2c2e38867241"><span class="ne-text">代表网站： 小米、腾讯等</span></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 布局 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS盒模型</title>
      <link href="/blog/dnp4byvzqz87/"/>
      <url>/blog/dnp4byvzqz87/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="JCTid"><span class="ne-text">border</span></h2><p id="u2bf34599" class="ne-p"><br></p><h3 id="ezq6V"><span class="ne-text">border综合</span></h3><table id="TcCkm" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u101cc3bd" class="ne-p"><span class="ne-text">属性</span></p></td><td width="375"><p id="u4029e0c8" class="ne-p" style="text-align: center"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u4fe48a3d" class="ne-p"><span class="ne-text">border-width</span></p></td><td width="375"><p id="u7bdc8c95" class="ne-p" style="text-align: center"><span class="ne-text">定义边框粗细，单位是px</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ud4c1097e" class="ne-p"><span class="ne-text">border-style</span></p></td><td width="375"><p id="u018efb90" class="ne-p" style="text-align: center"><span class="ne-text">边框的样式</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u6703b7cf" class="ne-p"><span class="ne-text">border-color</span></p></td><td width="375"><p id="u71adaaa7" class="ne-p" style="text-align: center"><span class="ne-text">边框颜色</span></p></td></tr></tbody></table><div class="ne-quote"><p id="77e5ef6b8df66c1afb69f75e276d2551" class="ne-p"><span class="ne-text">【1】border-style</span></p></div><ul class="ne-ul"><li id="518d3853e6641a846ed6bb2e890daf98"><span class="ne-text">none：没有边框即忽略所有边框的宽度（默认值）</span></li><li id="0f9cb37cd35a4c063bf9c92f75872f1c"><span class="ne-text">solid：边框为单实线(最为常用的)</span></li><li id="711a5f1e83c36fdb4ffa67f310a4dfca"><span class="ne-text">dashed：边框为虚线</span></li><li id="850cde88a66e84b4994d70d53dd731ce"><span class="ne-text">dotted：边框为点线</span></li></ul><div class="ne-quote"><p id="81757a593425d2684863b55da9916c40" class="ne-p"><span class="ne-text">【2】综合设置：</span><span class="ne-text">盒子边框写法总结表</span></p></div><pre data-language="css" id="O9BYj" class="ne-codeblock language-css">border: 1px solid red;  </pre><p id="55836517b1ec9c8f1dc4c9daa01ad8f4" class="ne-p"><br></p><div class="ne-quote"><p id="f44af2eeb9a0e528aa9699feac1673a7" class="ne-p"><span class="ne-text">【3】很多情况下，我们不需要指定4个边框，我们是可以单独给4个边框分别指定的。</span></p></div><table id="5BX0r" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"><p id="u74e184bb" class="ne-p" style="text-align: left"><span class="ne-text">上边框</span></p></td><td width="187"><p id="u310b3604" class="ne-p" style="text-align: left"><span class="ne-text">下边框</span></p></td><td width="187"><p id="uf00d2c41" class="ne-p" style="text-align: left"><span class="ne-text">左边框</span></p></td><td width="187"><p id="ue30f51ec" class="ne-p" style="text-align: left"><span class="ne-text">右边框</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u199ec862" class="ne-p" style="text-align: left"><span class="ne-text">border-top-style:样式;</span></p></td><td width="187"><p id="u59c60a04" class="ne-p" style="text-align: left"><span class="ne-text">border-bottom-style:样式;</span></p></td><td width="187"><p id="u830c29ab" class="ne-p" style="text-align: left"><span class="ne-text">border-left-style:样式;</span></p></td><td width="187"><p id="u969dc48a" class="ne-p" style="text-align: left"><span class="ne-text">border-right-style:样式;</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u3b3796e2" class="ne-p" style="text-align: left"><span class="ne-text">border-top-width:宽度;</span></p></td><td width="187"><p id="u3083998c" class="ne-p" style="text-align: left"><span class="ne-text">border- bottom-width:宽度;</span></p></td><td width="187"><p id="u3ea29bd3" class="ne-p" style="text-align: left"><span class="ne-text">border-left-width:宽度;</span></p></td><td width="187"><p id="ub06ef4f8" class="ne-p" style="text-align: left"><span class="ne-text">border-right-width:宽度;</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u2f7ccc78" class="ne-p" style="text-align: left"><span class="ne-text">border-top-color:颜色;</span></p></td><td width="187"><p id="u14320fe2" class="ne-p" style="text-align: left"><span class="ne-text">border- bottom-color:颜色;</span></p></td><td width="187"><p id="u43281b90" class="ne-p" style="text-align: left"><span class="ne-text">border-left-color:颜色;</span></p></td><td width="187"><p id="u78a1b7a6" class="ne-p" style="text-align: left"><span class="ne-text">border-right-color:颜色;</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u917e4d22" class="ne-p" style="text-align: left"><span class="ne-text">border-top:宽度 样式 颜色;</span></p></td><td width="187"><p id="uc16e7248" class="ne-p" style="text-align: left"><span class="ne-text">border-bottom:宽度 样式 颜色;</span></p></td><td width="187"><p id="udc3f48b3" class="ne-p" style="text-align: left"><span class="ne-text">border-left:宽度 样式 颜色;</span></p></td><td width="187"><p id="u450cf750" class="ne-p" style="text-align: left"><span class="ne-text">border-right:宽度 样式 颜色;</span></p></td></tr></tbody></table><div class="ne-quote"><p id="d2c77a59b154c7ef703ba9baf0083383" class="ne-p"><span class="ne-text">表格的细线边框</span></p></div><ul class="ne-ul"><li id="2d1f0514add2a1b8fe04f31199288037"><span class="ne-text">通过表格的</span><code class="ne-code"><span class="ne-text">cellspacing="0"</span></code><span class="ne-text">,将单元格与单元格之间的距离设置为0，</span></li><li id="ad3f32e503f612a47f765e2860d27665"><span class="ne-text">但是两个单元格之间的边框会出现重叠，从而使边框变粗</span></li><li id="3912787b161a6b732d2de0db14ea4b56"><span class="ne-text">通过css属性：</span></li></ul><pre data-language="plain" id="le9zD" class="ne-codeblock language-plain">table{ border-collapse:collapse; }</pre><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="a53e896a4ffe982c42b62f7b7e7ce43c"><span class="ne-text">collapse 单词是合并的意思</span></li><li id="d7af81c6fc39f80b5d7ff5a6aa786601"><span class="ne-text">border-collapse:collapse; 表示相邻边框合并在一起。</span></li></ul></ul><pre data-language="css" id="0Q7mX" class="ne-codeblock language-css"><style><pre><code>table &#123;    width: 500px;    height: 300px;    border: 1px solid red;&#125;td &#123;    border: 1px solid red;    text-align: center;&#125;table, td &#123;    border-collapse: collapse;  /*合并相邻边框*/&#125;</code></pre><p></style></pre><p id="0ac9af404a9aab9aa70853735c45405b" class="ne-p"><br></p><h3 id="blzJF"><span class="ne-text">border-radius</span></h3><ul class="ne-ul"><li id="68a5cefee0330a38ec118af3bff46b79"><span class="ne-text">语法：</span></li></ul><pre data-language="css" id="7WnKx" class="ne-codeblock language-css">border-radius:length;</pre><ul class="ne-ul"><li id="924ad8023f83a51f7a394e7d0e3430c8"><span class="ne-text">其中每一个值可以为 数值或百分比的形式。</span></li><li id="4f052032249c4047a5860e6fe54b3d46"><span class="ne-text">让一个正方形（让这个盒子 width 和 height 相等）变成圆圈</span></li></ul><pre data-language="css" id="MOzrM" class="ne-codeblock language-css">border-radius: 50%;</pre><p id="92d09cd9977b517db7be31d0d68f7677" class="ne-p"><br></p><ul class="ne-ul"><li id="780851b513ce546b9047c529c3619f14"><span class="ne-text">百分比会是表示高度和宽度的一半的情况</span></li></ul><p id="9a6be9e92e67fe84d4d9f0e9d64e10d7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616160100879-1ec56967-ea20-4bd2-8327-519c75d1367f.png" width="960" id="Pc3pC" class="ne-image"></p><h3 id="o20No"><span class="ne-text">box-shadow</span></h3><ul class="ne-ul"><li id="a36ff41dece00cdb0f0019a2f74a4a36"><span class="ne-text">语法:</span></li></ul><pre data-language="css" id="BrDPd" class="ne-codeblock language-css">box-shadow:水平阴影 垂直阴影 模糊距离（虚实） 阴影尺寸（影子大小） 阴影颜色 内/外阴影；</pre><p id="115db4e91ea3aa39630df3308b34e537" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549557136-9945210f-61eb-44df-af61-5eb070818e6f.png" width="862" id="K53lY" class="ne-image"></p><ul class="ne-ul"><li id="1b6420b10dad52b7033b959e96a8c4f1"><span class="ne-text">前两个属性是必须写的。其余的可以省略。</span></li><li id="acf5393b844c9b136af59fd17c26b566"><span class="ne-text">外阴影 (outset) 是默认的 但是不能写 想要内阴影可以写 inset</span></li></ul><p id="c8182447720f3d1d977f98bbb2a7f816" class="ne-p"><br></p><h2 id="kTQ9J"><span class="ne-text">padding</span></h2><div class="ne-quote"><p id="7344ed2f44175c1d046f5f86bc4ffb55" class="ne-p"><span class="ne-text">内边距：</span><span class="ne-text" style="background-color: transparent">padding 属性用于设置内边距。 </span><strong><span class="ne-text">是指 边框与内容之间的距离。</span></strong></p></div><h3 id="UWMMQ"><span class="ne-text">padding 综合</span></h3><table id="xWw9k" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u7dc644cd" class="ne-p"><span class="ne-text">属性</span></p></td><td width="375"><p id="u2800f0e1" class="ne-p" style="text-align: left"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u993e2695" class="ne-p"><span class="ne-text">padding-left</span></p></td><td width="375"><p id="u74d3359c" class="ne-p" style="text-align: left"><span class="ne-text">左内边距</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u59b59b31" class="ne-p"><span class="ne-text">padding-right</span></p></td><td width="375"><p id="u1239baab" class="ne-p" style="text-align: left"><span class="ne-text">右内边距</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u9cbc149f" class="ne-p"><span class="ne-text">padding-top</span></p></td><td width="375"><p id="uf647fefe" class="ne-p" style="text-align: left"><span class="ne-text">上内边距</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u382b8957" class="ne-p"><span class="ne-text">padding-bottom</span></p></td><td width="375"><p id="u7e3035d5" class="ne-p" style="text-align: left"><span class="ne-text">下内边距</span></p></td></tr></tbody></table><p id="15448386d88a9f8c4cba0b0730e63010" class="ne-p"><span class="ne-text">当我们给盒子指定 padding 值之后， 发生了 2 件事情：</span></p><ol class="ne-ol"><li id="14f6e1056fc92cf53290828decec0659"><span class="ne-text">内容和边框 有了距离，添加了内边距。</span></li><li id="db0171fb34e72ff3d223679c911447c0"><span class="ne-text">盒子会变大了。</span></li></ol><p id="410353c73f30cdbc4270274bdb21f6e5" class="ne-p"><strong><span class="ne-text">注意： 后面跟几个数值表示的意思是不一样的。</span></strong></p><p id="66497da65a5cd86b01d3c8c566e47050" class="ne-p"><span class="ne-text">我们分开写有点麻烦，我们可以不可以简写呢？</span></p><table id="g1A1w" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u69c72838" class="ne-p"><span class="ne-text">值的个数</span></p></td><td width="375"><p id="uf590e907" class="ne-p"><span class="ne-text">表达意思</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uebdbf0a2" class="ne-p"><span class="ne-text">1 个值</span></p></td><td width="375"><p id="uaca4eb31" class="ne-p"><span class="ne-text">padding：上下左右内边距;</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u2104276e" class="ne-p"><span class="ne-text">2 个值</span></p></td><td width="375"><p id="uc9eb3fe0" class="ne-p"><span class="ne-text">padding: 上下内边距 左右内边距 ；</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uf5afd962" class="ne-p"><span class="ne-text">3 个值</span></p></td><td width="375"><p id="u6a6e6140" class="ne-p"><span class="ne-text">padding：上内边距 左右内边距 下内边距；</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u96bf2ac5" class="ne-p"><span class="ne-text">4 个值</span></p></td><td width="375"><p id="ub6f785eb" class="ne-p"><span class="ne-text">padding: 上内边距 右内边距 下内边距 左内边距 ；</span></p></td></tr></tbody></table><p id="ef5eade0247ea0263135b9e7fc0f188b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552112041-a7ed9154-18bb-478e-867f-92e7837719ea.png" width="204.5" id="zFwzo" class="ne-image"><strong><span class="ne-text"></span></strong></p><p id="580eb2e4f8cb735ad88dd2efe2107633" class="ne-p"><br></p><h3 id="6HsEI"><span class="ne-text">内盒尺寸计算（元素实际大小）</span></h3><p id="162d50e36bf780d8e71a111bcd850fe8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552122666-74470517-33eb-4212-b483-430e2bbd0ee5.png" width="173.5" id="c2yvz" class="ne-image"></p><ul class="ne-ul"><li id="c09e8d80bebc732aed586709735996e1"><span class="ne-text">宽度：Element Height = content height + padding + border （Height 为内容高度）</span></li><li id="c0767eddda0221523668f7d53c7bdae8"><span class="ne-text">高度：Element Width = content width + padding + border （Width 为内容宽度）</span></li><li id="d7c2ea6a331bc5caecd54dc4a4b8c9e3"><span class="ne-text">盒子的实际的大小 = 内容的宽度和高度 + 内边距 + 边框</span></li></ul><h3 id="EX92l"><span class="ne-text">内边距撑大盒子的解决方案</span></h3><div class="ne-quote"><p id="04df78ba9bc7d8c663522632bc30bb00" class="ne-p"><span class="ne-text">问题：</span><span class="ne-text">会撑大原来的盒子</span></p></div><p id="259f7baa08cca490803c3baa7029fe7b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552148703-03f4e9a2-62c0-4ef6-bcc9-daca7a48972f.png" width="350" id="HK0PO" class="ne-image"></p><p id="d5a90ce1bb855d20073ff41e2bc2c131" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552164629-96bb4847-362e-4c50-ad11-9bf86c3cd22e.png" width="353" id="RI9BY" class="ne-image"></p><div class="ne-quote"><p id="7e81d58b9af23f2bb4975d3f84ccd067" class="ne-p"><span class="ne-text">解决方案【1】：通过给设置了宽高的盒子，减去相应的内边距的值，维持盒子原有的大小</span></p></div><p id="32ba22cc2c7f2701ad958c938f13cb32" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552179527-c1060669-e26e-4c16-b0eb-0fa78c03b45b.png" width="393" id="ZRlkd" class="ne-image"></p><p id="7219cf1fbf5f6cba8df42cc64dd9b33c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552188919-c9493a98-9f8f-4ba4-942c-83d9fd2a033f.png" width="397" id="Xomtj" class="ne-image"></p><p id="79c394fd265eb212d6c98aa8873f2967" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552197848-242d4e3f-1cdd-4f31-b86b-e42b549e2094.png" width="397" id="ZzyzG" class="ne-image"></p><p id="722c3478a0ed1bba8fac82be535e3a84" class="ne-p"><span class="ne-text">关于根据下列代码计算 盒子宽高下列说法正确的是（）</span></p><pre data-language="css" id="U5DsE" class="ne-codeblock language-css">div {<br>width: 200px;<br>height: 200px;<br>border: 1px solid #000000;<br>border-top: 5px solid blue;<br>padding: 50px;<br>padding-left: 100px;<br>}</pre><ul class="ne-ul"><li id="504bc166451eeaadebb0469bc7b8862d"><span class="ne-text"> (A) 宽度为 200px 高度为 200px</span></li><li id="9c7f2da53ca8da36f17381752bce84c9"><span class="ne-text"> (B) 宽度为 352px 高度为 306px</span></li><li id="8d1b80a2536a6024e3b530b42056a6b3"><span class="ne-text"> (C) 宽度为 302px 高度为 307px</span></li><li id="e0f36ef537b95e19b2cb552195d8bfe7"><span class="ne-text"> (D) 宽度为 302px 高度为 252px</span></li></ul><p id="73e574d35139f8ec2d08dd2dce5c3efd" class="ne-p"><span class="ne-text">w 200 + 150 + 2 = 352</span></p><p id="6064c109d8ff412bec6d77199d1ddf50" class="ne-p"><span class="ne-text">h 200 + 100 + 6 = 306</span></p><p id="6a6a1806ec47d55c8b4d767974bc841d" class="ne-p"><br></p><div class="ne-quote"><p id="4e9a3e9d6adf48267faaa699bf36c3fe" class="ne-p"><span class="ne-text">解决方案【2】：设置 box-sizing 属性</span></p></div><pre data-language="css" id="53xZZ" class="ne-codeblock language-css">-moz-box-sizing: border-box; /<em>Firefox3.5+</em>/<br>-webkit-box-sizing: border-box; /<em>Safari3.2+</em>/<br>-o-box-sizing: border-box; /<em>Opera9.6</em>/<br>-ms-box-sizing: border-box; /<em>IE8</em>/<br>box-sizing: border-box; /<em>W3C 标准(IE9+，Safari5.1+,Chrome10.0+,Opera10.6+都符合 box-sizing 的 w3c 标准语法)</em>/</pre><p id="8ae3be472fc28a03cf5761fe64146f58" class="ne-p"><span class="ne-text" style="color: #121212">注意：box-sizing 属性是 CSS3 的属性，IE 低版本不支持，注意兼容性</span></p><p id="05121a1c196c4949e8fbc16f489374e1" class="ne-p"><span class="ne-text" style="color: #121212">参考：</span></p><ul class="ne-ul"><li id="6c64f2b92b3db6da9e28112b0c7b5e99"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing" data-href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing</span></a></li><li id="c3eeb96cbccff5c7f4f910639dc47f26"><a href="https://www.zhihu.com/question/31031251" data-href="https://www.zhihu.com/question/31031251" target="_blank" class="ne-link"><span class="ne-text">https://www.zhihu.com/question/31031251</span></a></li></ul><h3 id="nknxQ"><span class="ne-text">内边距不影响盒子大小情况</span></h3><div class="ne-quote"><p id="48bfcda97c1090abc231bddaefdc9ba7" class="ne-p"><span class="ne-text">如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定 padding， 则不会撑开盒子。</span></p></div><h2 id="p28ou"><span class="ne-text">margin</span></h2><p id="b9cd49468404bed5db521d4cd4a9a4ab" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552211186-1bc52b3c-f2d9-418b-99d8-582718465af1.png" width="475" id="V78Gu" class="ne-image"></p><p id="f82da73851a2f0d52d0c51aa2b4d5c82" class="ne-p"><span class="ne-text">margin 属性用于设置外边距。 margin 就是控制</span><strong><span class="ne-text">盒子和盒子之间的距离</span></strong></p><h3 id="wTOej"><span class="ne-text">padding 综合</span></h3><table id="n1CCn" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u844cb1e6" class="ne-p"><span class="ne-text">属性</span></p></td><td width="375"><p id="ua1522471" class="ne-p" style="text-align: left"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uc4fe543a" class="ne-p"><span class="ne-text">margin-left</span></p></td><td width="375"><p id="u7d0bfc42" class="ne-p" style="text-align: left"><span class="ne-text">左外边距</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ud9867846" class="ne-p"><span class="ne-text">margin-right</span></p></td><td width="375"><p id="uc1faecae" class="ne-p" style="text-align: left"><span class="ne-text">右外边距</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u3a6793c4" class="ne-p"><span class="ne-text">margin-top</span></p></td><td width="375"><p id="udf32b5cf" class="ne-p" style="text-align: left"><span class="ne-text">上外边距</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uff664e70" class="ne-p"><span class="ne-text">margin-bottom</span></p></td><td width="375"><p id="u3c77c338" class="ne-p" style="text-align: left"><span class="ne-text">下外边距</span></p></td></tr></tbody></table><p id="ffd339cb8367066aebcbff07969e5c70" class="ne-p"><span class="ne-text">margin 值的简写 （复合写法）代表意思 跟 padding 完全相同。</span></p><h2 id="xn3UG"><span class="ne-text">display</span></h2><h3 id="iskUR"><span class="ne-text">什么是标签显示模式</span></h3><ul class="ne-ul"><li id="89a08160615f7bc0de3f74b3bcb1c9cf"><span class="ne-text">什么是标签的显示模式？<br></span><span class="ne-text">标签以什么方式进行显示，比如 div 自己占一行， 比如 span 一行可以放很多个</span></li><li id="bf1f63ef35d5e7105cceaedaa8156536"><span class="ne-text">作用：<br></span><span class="ne-text">我们网页的标签非常多，再不同地方会用到不同类型的标签，以便更好的完成我们的网页。</span></li><li id="19c249a9f17bcd78f1a0ccbec3dab83c"><span class="ne-text">标签的类型(分类)<br></span><span class="ne-text">HTML 标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。</span></li></ul><h3 id="hK2nl"><span class="ne-text">块级元素(block-level)</span></h3><ul class="ne-ul"><li id="4b4928e7812cbb7c0c4c783aed635ed9"><span class="ne-text">例：</span></li></ul><pre data-language="plain" id="2AgRF" class="ne-codeblock language-plain">常见的块元素有<h1>~<h6>、<p>、<div>、<ul>、<ol>、<li>等，其中<div>标签是最典型的块元素。</pre><p id="3deaf2bc621f3577cbb913e0e1b27e50" class="ne-p"><br></p><ul class="ne-ul"><li id="4757984c4fb871c7d983bbd9af426d43"><span class="ne-text">块级元素的特点</span></li></ul><p id="59a0c9463618efc8d1990b4b74625e32" class="ne-p"><span class="ne-text">（1）比较霸道，自己独占一行</span></p><p id="4f5e01ecc1283dfadd396f9991d07089" class="ne-p"><span class="ne-text">（2）</span><span class="ne-text" style="background-color: #FADB14">高度，宽度、外边距以及内边距都可以控制</span><span class="ne-text">。</span></p><p id="373e8b457225bb93a4f89e1dee82f015" class="ne-p"><span class="ne-text">（3）宽度默认是容器（父级宽度）的 100%</span></p><p id="b61df844563bb3d409e2197924f7c4ae" class="ne-p"><span class="ne-text">（4）是一个容器及盒子，里面可以放行内或者块级元素。</span></p><ul class="ne-ul"><li id="f733edd36ff4994b4e0955b53072d743"><span class="ne-text">只有 文字才 能组成段落 因此 p 里面不能放块级元素，特别是 p 不能放 div</span></li><li id="d26fc0f5797995c7774c891ab4f6f2c2"><span class="ne-text">同理还有这些标签 h1,h2,h3,h4,h5,h6,dt，他们都是</span><span class="ne-text" style="background-color: #FADB14">文字类块级标签，里面不能放其他块级元素</span><span class="ne-text">。</span></li></ul><h3 id="Ut6nc"><span class="ne-text">行内元素(inline-level)</span></h3><ul class="ne-ul"><li id="5052735a7226bc4b97ea6084eadcba86"><span class="ne-text">例：</span></li></ul><pre data-language="plain" id="EObb1" class="ne-codeblock language-plain">常见的行内元素有<a>、<strong>、<b>、<em>、<i>、<del>、<s>、<ins>、<u>、<span>等，其中<span>标签最典型的行内元素。有的地方也成内联元素</pre><p id="438b5e985d85d249c9951bbd9ddb476e" class="ne-p"><br></p><ul class="ne-ul"><li id="5f0d2d02d21d01dc8213bbcb58211dd2"><span class="ne-text">行内元素的特点：</span></li></ul><p id="e42a2507e5459cae465a2838b2a3ea35" class="ne-p"><span class="ne-text">（1）相邻行内元素在一行上，一行可以显示多个。</span></p><p id="cc921f9e60be9f4bb13e88dfe7c89da4" class="ne-p"><span class="ne-text">（2）</span><span class="ne-text" style="background-color: #FADB14">高、宽直接设置是无效的</span><span class="ne-text">。</span></p><p id="a5a74e19eff289c7aeda8eaf8cbb8a18" class="ne-p"><span class="ne-text">（3）默认宽度就是它本身内容的宽度。</span></p><p id="c16ec105df6030002c0101359e231e5c" class="ne-p"><span class="ne-text">（4）</span><strong><span class="ne-text">行内元素只能容纳文本或则其他行内元素。</span></strong></p><ul class="ne-ul"><li id="4d6821870d1e2e4cf1ebc19120c2dd2a"><span class="ne-text">链接里面不能再放链接。</span></li><li id="e45d011ab4da6d7f498edebeff3a548a"><span class="ne-text">特殊情况 a 里面可以放块级元素，但是给 a 转换一下块级模式最安全。</span></li></ul><h3 id="IDdRF"><span class="ne-text">行内块元素（inline-block）</span></h3><ul class="ne-ul"><li id="39a6f44be52adfdc1d518bf15b74fe1b"><span class="ne-text">例：</span></li></ul><pre data-language="plain" id="WihsT" class="ne-codeblock language-plain">在行内元素中有几个特殊的标签——<img />、<input />、<td>，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。</pre><p id="0dd916847200e446ef2e7492e2cdc4e2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611551937533-f958d872-1942-4aee-8533-8671afa1dc82.png" width="608.5" id="BC5Jb" class="ne-image"></p><ul class="ne-ul"><li id="1f1ef48461f9100a9ba646144ca191ea"><span class="ne-text">行内块元素的特点：<br></span><span class="ne-text">（1）和相邻行内元素（行内块）在一行上,但是</span><span class="ne-text" style="background-color: #FADB14">之间会有空白缝隙</span><span class="ne-text">。一行可以显示多个<br></span><span class="ne-text">（2）默认宽度就是它本身内容的宽度。<br></span><span class="ne-text">（3）</span><span class="ne-text" style="background-color: #FADB14">高度，行高、外边距以及内边距都可以控制</span><span class="ne-text">。</span></li></ul><h3 id="rK5xE"><span class="ne-text">display</span></h3><ul class="ne-ul"><li id="89f5af16d988948efc7fbe26a970a48b"><span class="ne-text">块转行内：display:inline;</span></li><li id="6dc33ba7cfc639f381667ff870c5d372"><span class="ne-text">行内转块：display:block;</span></li><li id="e9c6980a124fa80fedc36d9d69eec2b9"><span class="ne-text">块、行内元素转换为行内块： display: inline-block;</span></li></ul><p id="8c84626698c91d68e38edb269b092476" class="ne-p"><span class="ne-text">此阶段，我们只需关心这三个，其他的是我们后面的工作。</span></p><h2 id="AOfov"><span class="ne-text">盒模型的相关问题</span></h2><h3 id="Nb3xh"><span class="ne-text">块级盒子水平居中</span></h3><ul class="ne-ul"><li id="437cd4cffd0f54b1a9dc6dc31cdd24f0"><span class="ne-text">一个块级盒子实现水平居中必须：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="3cb4ea77bd5869bd3fe08cbfe7ebbc33"><span class="ne-text">盒子</span><span class="ne-text" style="background-color: #FADB14">必须指定了宽度</span><span class="ne-text">（width）</span></li><li id="d6a40ea3ecc6204f5521ef90715cc5b5"><span class="ne-text">然后就给</span><strong><span class="ne-text">左右的外边距都设置为 auto</span></strong><span class="ne-text">，</span></li></ul></ul><p id="9786810a09167ebbff13ca70a9ca8e59" class="ne-p"><span class="ne-text">实际工作中常用这种方式进行网页布局，示例代码如下：</span></p><pre data-language="css" id="bjF7q" class="ne-codeblock language-css">.header{ width:960px; margin:0 auto;}</pre><p id="5d37638b52a8e8a18251e14c0ac1eae2" class="ne-p"><span class="ne-text">常见的写法，以下下三种都可以。</span></p><ul class="ne-ul"><li id="6d1848e42521eb6ebc2eab3b4267e11c"><span class="ne-text">margin-left: auto; margin-right: auto;</span></li><li id="9a5cd3c22438f4b405ca11cb209a9208"><span class="ne-text">margin: auto;</span></li><li id="eac29aeef9a15c2278a78eb80edff1a2"><span class="ne-text">margin: 0 auto;</span></li></ul><h3 id="nTwFa"><span class="ne-text">文字居中和盒子居中区别</span></h3><ol class="ne-ol"><li id="e910db0b669314404b209b4fe6440052"><span class="ne-text">盒子内的文字水平居中是 text-align: center, </span><span class="ne-text" style="background-color: #FADB14">而且还可以让行内元素和行内块居中对齐</span></li><li id="2f6322dbcdb8f57a23a777aa93a99679"><span class="ne-text">块级盒子水平居中左右 margin 改为 auto</span></li></ol><pre data-language="css" id="5O7o7" class="ne-codeblock language-css">text-align: center; /_ 文字 行内元素 行内块元素水平居中 <em>/<br>margin: 10px auto; /</em> 块级盒子水平居中 左右 margin 改为 auto 就阔以了 上下 margin 都可以 <em>/</pre><h3 id="8k8xB"><span class="ne-text">插入图片和背景图片区别</span></h3><ol class="ne-ol"><li id="2ce52b32ba2d31381d85168d74dd4211"><span class="ne-text">插入图片 我们用的最多 比如产品展示类 移动位置只能靠盒模型 padding margin</span></li><li id="9b91d6d8add70ec135e2bf2db9c283a1"><span class="ne-text">背景图片我们一般用于小图标背景 或者 超大背景图片 背景图片 只能通过 background-position</span></li></ol><pre data-language="css" id="6Oxgq" class="ne-codeblock language-css">img {<br> width: 200px;/</em> 插入图片更改大小 width 和 height <em>/<br>height: 210px;<br>margin-top: 30px; /</em> 插入图片更改位置 可以用 margin 或 padding 盒模型 <em>/<br>margin-left: 50px; /</em> 插入当图片也是一个盒子 <em>/<br>}<br>div {<br>width: 400px;<br>height: 400px;<br>border: 1px solid purple;<br>background: #fff url(images/sun.jpg) no-repeat;<br>background-position: 30px 50px; /</em> 背景图片更改位置 我用 background-position <em>/<br>}</pre><h3 id="Pdv2Q"><span class="ne-text">清除元素的默认内外边距</span></h3><p id="8a6590d752c05cc7a7063f8d49a81435" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552224242-7158d827-f872-4872-9c9d-598c846d74b9.png" width="537.5" id="mX9H5" class="ne-image"></p><p id="5ac4d743cebf72c649c0e1819516cb21" class="ne-p"><span class="ne-text">为了更灵活方便地控制网页中的元素，制作网页时，我们需要将元素的默认内外边距清除</span></p><p id="1c6943b223f9cbe41c41d6adbb93468c" class="ne-p"><span class="ne-text">代码：</span></p><pre data-language="css" id="ZLzAW" class="ne-codeblock language-css"></em> {<br>padding:0; /_ 清除内边距 <em>/<br>margin:0; /</em> 清除外边距 */<br>}</pre><p id="e7dfa241672cc4fb19f03d10d4abe302" class="ne-p"><br></p><ul class="ne-ul"><li id="99cbbfb0a8392e760a978ce3ebe48d89"><span class="ne-text">行内元素为了照顾兼容性， 尽量只设置左右内外边距， 不要设置上下内外边距。</span></li></ul><h3 id="RaoY5"><span class="ne-text">margin 塌陷问题</span></h3><p id="dd543c9f345ee1ece37c051df01fd992" class="ne-p"><span class="ne-text">使用 margin 定义块元素的</span><strong><span class="ne-text">垂直外边距</span></strong><span class="ne-text">时，可能会出现外边距的合并。</span></p><div class="ne-quote"><p id="1ad377dbaaf5dd90e43f08508e95d40d" class="ne-p"><span class="ne-text">相邻块元素垂直外边距的合并</span></p></div><ul class="ne-ul"><li id="f630addbe363d41abaeab18b3930ee1e"><span class="ne-text">当上下相邻的两个块元素相遇时，如果上面的元素有下外边距 margin-bottom</span></li><li id="ef6249e101ed2779e4f79840e2cd6f01"><span class="ne-text">下面的元素有上外边距 margin-top，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和</span></li><li id="8b41c378b72995e706e74bd145bffa25"><strong><span class="ne-text">取两个值中的较大者</span></strong><span class="ne-text">这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。</span></li></ul><p id="85633555814b639522d9b43aff72daec" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549556832-735ecd9b-2e20-4413-a635-cedc3692442f.png" width="504" id="Xh86G" class="ne-image"></p><p id="efc378e9313574719b1994f3041394e7" class="ne-p"><strong><span class="ne-text">解决方案：</span></strong><strong><span class="ne-text" style="background-color: #FADB14">尽量给只给一个盒子添加 margin 值</span></strong><span class="ne-text">。</span></p><div class="ne-quote"><p id="3ac2d8bb3f362ecf7af03d75e490cc23" class="ne-p"><span class="ne-text">嵌套块元素垂直外边距的合并（塌陷）</span></p></div><ul class="ne-ul"><li id="f48f3c54537f3f88fe0d67192d22abc1"><span class="ne-text">对于两个嵌套关系的块元素，如果父元素没有上内边距及边框</span></li><li id="185b5033f3dde26a0b853e77c2b298c1"><span class="ne-text">父元素的上外边距会与子元素的上外边距发生合并</span></li><li id="83b8eb018eaac93605fa6bdbc55bedc9"><span class="ne-text">合并后的外边距为两者中的较大者</span></li></ul><p id="fd2ab7cac791d6551ec60aed341b41cf" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549556894-4dc0bcd3-d5ed-467c-b725-bf4477a4e93c.png" width="504" id="IGgQt" class="ne-image"></p><p id="346586f3289b9f6716d564a6c29f0e83" class="ne-p"><strong><span class="ne-text">解决方案：</span></strong></p><ol class="ne-ol"><li id="facd0aef5c5b8e5b9ac705cd34cde1d0"><span class="ne-text">可以为父元素定义上边框。</span></li><li id="38fe1d73e2aacba786ce75234290ecda"><span class="ne-text">可以为父元素定义上内边距</span></li><li id="39585dd00016953d196179ffb4c437a9"><span class="ne-text">可以为父元素添加 overflow:hidden。</span></li></ol><p id="804de09e7be716252fae4ea7171adfe6" class="ne-p"><span class="ne-text">还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。</span></p><h3 id="JJYX2"><span class="ne-text">盒子模型布局稳定性</span></h3><ul class="ne-ul"><li id="4d65dcd3d034a343d8b98ed58060c363"><span class="ne-text">根据稳定性来分：按照 优先使用 宽度 （width） 其次 使用内边距（padding） 再次 外边距（margin）。</span></li><li id="e6a870579c41773a05091c7976d17d06"><span class="ne-text">margin 会有外边距合并 还有 ie6 下面 margin 加倍的 bug（讨厌）所以最后使用。</span></li><li id="486a6af44f14fba2f4bf8a3786d8e078"><span class="ne-text">padding 会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。</span></li><li id="e16ea833830f425a6e2b4f1865de948e"><span class="ne-text">width 没有问题，经常使用宽度剩余法 高度剩余法来做。</span></li></ul><h3 id="163a7388"><span class="ne-text">line-height 的问题</span></h3><div class="ne-quote"><p id="a34d352388a29dfcf6de65f88ea9b1f9" class="ne-p"><span class="ne-text">【1】行高测量</span></p></div><p id="2c03a2b7fd64293043ff6cefd146d65a" class="ne-p"><span class="ne-text">行高的测量方法：</span></p><p id="19c3a75b19a867666a11b6e5f5b1cd12" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555568-b660d3a6-0153-453f-ae22-fc831f79d659.png" width="407" id="x9gll" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555629-ba0bce7a-f7b1-49ff-89aa-c14496ccbcb6.png" width="408" id="nxHkv" class="ne-image"></p><div class="ne-quote"><p id="58b8fc7eaabe988fa6e371e7650d7107" class="ne-p"><span class="ne-text">【2】单行文本垂直居中</span></p></div><p id="51b9b25a2edc37518f00345a3313b06b" class="ne-p"><span class="ne-text">行高我们利用最多的一个地方是： 可以让单行文本在盒子中垂直居中对齐。</span></p><div class="ne-quote"><p id="af89ce2b5d40945c3346d2a91c7c0650" class="ne-p"><strong><span class="ne-text">文字的行高等于盒子的高度。</span></strong></p></div><p id="3e4bc506a9085bf4cd60a09c7f9f7e4a" class="ne-p"><span class="ne-text">这里情况些许复杂，开始学习，我们可以先从简单地方入手学会。</span></p><p id="554d2c5826a2d89b9c5e397e4c7e70e1" class="ne-p"><span class="ne-text">行高 = 上距离 + 内容高度 + 下距离</span></p><p id="643f7cdf1a6f02f27ba698ac5668282f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555695-02bf584b-9ece-45fe-a081-52aaf565d20d.png" width="700" id="MtmuD" class="ne-image"></p><p id="3bc01b831d7f26166eade37c44905689" class="ne-p"><span class="ne-text">上距离和下距离总是相等的，因此文字看上去是垂直居中的。</span></p><p id="1bc83f7189819f709e9da1ea6669d02f" class="ne-p"><strong><span class="ne-text">行高和高度的三种关系</span></strong></p><ul class="ne-ul"><li id="53b38d91456bf8df5fc2fce675fbc288"><span class="ne-text">如果 行高 等 高度 文字会 垂直居中</span></li><li id="43ef6b9886ad131cf6aaef4737bd1f22"><span class="ne-text">如果行高 大于 高度 文字会 偏下</span></li><li id="e179c187a8654a8d4b1f5f5fbe7a8a1e"><span class="ne-text">如果行高小于高度 文字会 偏上</span></li></ul><h3 id="RmwDf"></h3></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 布局 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS字体和背景</title>
      <link href="/blog/sideak09lpko/"/>
      <url>/blog/sideak09lpko/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="WU1xa"><span class="ne-text">字体相关</span></h2><p id="ua093e460" class="ne-p"><br></p><h3 id="stiE1"><span class="ne-text">font-size</span></h3><ul class="ne-ul"><li id="8e43b3eea7f7b798e48bf1af27414841"><span class="ne-text">作用：<p></span><span class="ne-text">font-size 属性用于设置字号</span></li></ul><pre data-language="css" id="5RxOE" class="ne-codeblock language-css">p {<br> font-size:20px;<br>}</pre><ul class="ne-ul"><li id="8bfa902392b2aeb8bfd1d8dd40e6609b"><span class="ne-text">单位：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="f4bf7008ed8b5bdd6fba01bd2d0577a2"><span class="ne-text">可以使用相对长度单位，也可以使用绝对长度单位。</span></li><li id="60e0817b239ec2884c905d56656f1943"><span class="ne-text">相对长度单位比较常用，推荐使用像素单位 px，绝对长度单位使用较少。</span></li></ul></ul><p id="bd06cb1ec6cf54e3d7abaa019cb4cbf4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549554219-97b92fc6-0b55-4946-a903-080b2dfa44fa.png" width="637" id="qV5gw" class="ne-image"></p><p id="2c356f6322f61c7102e3f88cc2042fb1" class="ne-p"><strong><span class="ne-text">注意：</span></strong></p><ul class="ne-ul"><li id="fe97b200a8a2c2c6bb4e4d2bcbd9d1b3"><span class="ne-text">我们文字大小以后，基本就用 px 了，其他单位很少使用</span></li><li id="3acdedf95108e28d574be4b287a13c3f"><span class="ne-text">谷歌浏览器默认的文字大小为 16px</span></li><li id="4bf467144a558303f4f85d9752995bbf"><span class="ne-text">但是不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。一般给 body 指定整个页面文字的大小</span></li></ul><h3 id="rROy7"><span class="ne-text">font-family</span></h3><pre data-language="plain" id="gyiM3" class="ne-codeblock language-plain">p{ font-family:"微软雅黑";}</pre><ul class="ne-ul"><li id="5868d62378de2747bdad9788cabc69f0"><span class="ne-text">网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑</span></li><li id="ac0ad11168330a61c5aa46e9401f05d7"><span class="ne-text">可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体， 如果都没有，则以我们电脑默认的字体为准。</span></li></ul><pre data-language="plain" id="MPzOP" class="ne-codeblock language-plain">p{font-family: Arial,"Microsoft Yahei", "微软雅黑";}</pre><div class="ne-quote"><p id="eb83b2f69b375ac6aef1e35b90ff08a2" class="ne-p"><span class="ne-text">常用技巧：</span></p><ol class="ne-ol"><li id="65ef063464b28f62823807c841a87ae4"><span class="ne-text">各种字体之间必须使用英文状态下的逗号隔开。</span></li><li id="39b6fcc3fbd63f03375f97c46f995679"><span class="ne-text">中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。</span></li><li id="cc68a00775015182ea05ef5f335dbb66"><span class="ne-text">如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如 font-family: “Times New Roman”;。</span></li><li id="4c8ba9e7209d79bf037a46f0f51fc89a"><span class="ne-text">尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。</span></li></ol></div><h3 id="TB5BW"></h3><div class="ne-quote"><p id="c6bb0d2aa68fcc325598c9cd38d411f1" class="ne-p"><span class="ne-text">CSS Unicode 字体</span></p></div><ul class="ne-ul"><li id="a3b079f90095249452216ebdabf85f20"><span class="ne-text">为什么使用 Unicode 字体</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="5b6654582a3ee45dd48601b766e9e6db"><span class="ne-text">在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。</span></li><li id="ac28e35bd8581d2bd5554b7db6acdd99"><span class="ne-text">xp 系统不支持 类似微软雅黑的中文。</span></li></ul></ul><ul class="ne-ul"><li id="1d62cc4a8dc3b5f3eb00ced601a57f73"><span class="ne-text">解决方案一： 你可以使用英文来替代。 比如</span><code class="ne-code"><span class="ne-text">font-family:"Microsoft Yahei"</span></code><span class="ne-text">。</span></li><li id="58f562c7e9a2e05fa6ed03132a12574b"><span class="ne-text">解决方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的，记住！是在 CSS 里面</span></li></ul><pre data-language="css" id="bB9gT" class="ne-codeblock language-css">font-family: "\5FAE\8F6F\96C5\9ED1"; 表示设置字体为“微软雅黑”。</pre><table id="UQOeB" class="ne-table" style="width: 634px"><tbody><tr style="height: 33px"><td width="211"><p id="ucf6e2cb8" class="ne-p"><span class="ne-text">字体名称</span></p></td><td width="211"><p id="u7afdb783" class="ne-p"><span class="ne-text">英文名称</span></p></td><td width="212"><p id="ueea774a4" class="ne-p"><span class="ne-text">Unicode 编码</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="u9cd417cf" class="ne-p"><span class="ne-text">宋体</span></p></td><td width="211"><p id="u98a3c135" class="ne-p"><span class="ne-text">SimSun</span></p></td><td width="212"><p id="u368ae8f1" class="ne-p"><span class="ne-text">\5B8B\4F53</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="u191f50ce" class="ne-p"><span class="ne-text">新宋体</span></p></td><td width="211"><p id="u7540a81a" class="ne-p"><span class="ne-text">NSimSun</span></p></td><td width="212"><p id="uca11cf31" class="ne-p"><span class="ne-text">\65B0\5B8B\4F53</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="u8c31e834" class="ne-p"><span class="ne-text">黑体</span></p></td><td width="211"><p id="ueace5b20" class="ne-p"><span class="ne-text">SimHei</span></p></td><td width="212"><p id="u57d5de2c" class="ne-p"><span class="ne-text">\9ED1\4F53</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="uf119efbd" class="ne-p"><span class="ne-text">微软雅黑</span></p></td><td width="211"><p id="udd05be5c" class="ne-p"><span class="ne-text">Microsoft YaHei</span></p></td><td width="212"><p id="u1f8e18fd" class="ne-p"><span class="ne-text">\5FAE\8F6F\96C5\9ED1</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="u6f7b0e30" class="ne-p"><span class="ne-text">楷体_GB2312</span></p></td><td width="211"><p id="u140ceb6e" class="ne-p"><span class="ne-text">KaiTi_GB2312</span></p></td><td width="212"><p id="ud52232b6" class="ne-p"><span class="ne-text">\6977\4F53_GB2312</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="u5ecea98b" class="ne-p"><span class="ne-text">隶书</span></p></td><td width="211"><p id="u8b3a52f2" class="ne-p"><span class="ne-text">LiSu</span></p></td><td width="212"><p id="ufdf09f77" class="ne-p"><span class="ne-text">\96B6\4E66</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="ud46ec35b" class="ne-p"><span class="ne-text">幼园</span></p></td><td width="211"><p id="ufa48359a" class="ne-p"><span class="ne-text">YouYuan</span></p></td><td width="212"><p id="uc3a4f246" class="ne-p"><span class="ne-text">\5E7C\5706</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="u5b2a7daf" class="ne-p"><span class="ne-text">华文细黑</span></p></td><td width="211"><p id="u6cf9b908" class="ne-p"><span class="ne-text">STXihei</span></p></td><td width="212"><p id="u07b704ac" class="ne-p"><span class="ne-text">\534E\6587\7EC6\9ED1</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="u5741e7f8" class="ne-p"><span class="ne-text">细明体</span></p></td><td width="211"><p id="u66743664" class="ne-p"><span class="ne-text">MingLiU</span></p></td><td width="212"><p id="u71cec40e" class="ne-p"><span class="ne-text">\7EC6\660E\4F53</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="u431c6120" class="ne-p"><span class="ne-text">新细明体</span></p></td><td width="211"><p id="u36208940" class="ne-p"><span class="ne-text">PMingLiU</span></p></td><td width="212"><p id="u6bf8af56" class="ne-p"><span class="ne-text">\65B0\7EC6\660E\4F53</span></p></td></tr></tbody></table><p id="a46319f729dd5fd84480af2537acb64c" class="ne-p"><span class="ne-text">为了照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体</span></p><h3 id="hcJS6"><span class="ne-text">font-weight</span></h3><ul class="ne-ul"><li id="1cf7778ea7e35c4c0fabb72769f19a73"><span class="ne-text">在 html 中使用 b 和 strong 标签是文本加粗。</span></li><li id="73706be18f2409ee0534999843c78595"><span class="ne-text">可以使用 CSS 来实现，但是 CSS 是没有语义的。</span></li></ul><table id="uQDCQ" class="ne-table" style="width: 634px"><tbody><tr style="height: 33px"><td width="317"><p id="u36e05a7b" class="ne-p"><span class="ne-text">属性值</span></p></td><td width="317"><p id="u337f7186" class="ne-p" style="text-align: left"><span class="ne-text">描述</span></p></td></tr><tr style="height: 33px"><td width="317"><p id="u9bfc89b7" class="ne-p"><span class="ne-text">normal</span></p></td><td width="317"><p id="ua5f78f53" class="ne-p" style="text-align: left"><span class="ne-text">默认值（不加粗的）</span></p></td></tr><tr style="height: 33px"><td width="317"><p id="u5f3eb217" class="ne-p"><span class="ne-text">bold</span></p></td><td width="317"><p id="u1269b5e6" class="ne-p" style="text-align: left"><span class="ne-text">定义粗体（加粗的）</span></p></td></tr><tr style="height: 33px"><td width="317"><p id="ud0f7c24b" class="ne-p"><span class="ne-text">100<del>900</span></p></td><td width="317"><p id="u8ba9bbaa" class="ne-p" style="text-align: left"><span class="ne-text">400 等同于 normal，而 700 等同于 bold </span></p></td></tr></tbody></table><p id="18d7995e48948e1ccd3b2b7b41b15603" class="ne-p"><br></p><h3 id="psESq"><span class="ne-text">font-style</span></h3><ul class="ne-ul"><li id="c323f4844af6ba3ea71ac61ec503eb17"><span class="ne-text">在 html 中字体倾斜用 i 和 em 标签，</span></li><li id="9b0a13eab7d5582cb8e0745e3d32862c"><span class="ne-text">可以使用 CSS 来实现，但是 CSS 是没有语义的</span></li></ul><p id="3f462c871bb5608bd3e3de9860f8a52e" class="ne-p"><span class="ne-text">font-style 属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下：</span></p><table id="WhXxP" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="udc3ef5f1" class="ne-p"><span class="ne-text">属性</span></p></td><td width="375"><p id="u72f1bd92" class="ne-p" style="text-align: left"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u69aafc66" class="ne-p"><span class="ne-text">normal</span></p></td><td width="375"><p id="uf96287ca" class="ne-p" style="text-align: left"><span class="ne-text">默认值，浏览器会显示标准的字体样式 font-style: normal;</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u5e8582d3" class="ne-p"><span class="ne-text">italic</span></p></td><td width="375"><p id="u60cd0133" class="ne-p" style="text-align: left"><span class="ne-text">浏览器会显示斜体的字体样式。</span></p></td></tr></tbody></table><p id="4da476ca833af4498080dd5a7fce0e0c" class="ne-p"><br></p><h3 id="PcpGh"><span class="ne-text">font 综合设置</span></h3><ul class="ne-ul"><li id="34c5903b2de0ee158f7ce2d512b7a39b"><span class="ne-text">基本语法格式如下：</span></li></ul><pre data-language="css" id="Eio85" class="ne-codeblock language-css">选择器 {<br>font: font-style font-weight font-size/line-height font-family;<br>}</pre><ul class="ne-ul"><li id="f72b059c56b8dfe0e2f3f73428678421"><span class="ne-text">使用 font 属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以</span><strong><span class="ne-text">空格</span></strong><span class="ne-text">隔开。</span></li><li id="07fa0204254ed683cae615d30feca2bb"><span class="ne-text">其中不需要设置的属性可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用。</span></li></ul><h3 id="ngzBC"><span class="ne-text">color</span></h3><ul class="ne-ul"><li id="059578d93fd28a83241f555b5b2bda11"><span class="ne-text">作用：color 属性用于</span><span class="ne-text" style="background-color: #FADB14">定义文本的颜色</span><span class="ne-text">，</span></li><li id="085bbd251f449a8805330557aa351a18"><span class="ne-text">一般选用十六进制的</span></li><li id="43c49596b43bde17e0587ed25994aa56"><span class="ne-text">其取值方式有如下 3 种：</span></li></ul><table id="sYGFx" class="ne-table" style="width: 568px"><tbody><tr style="height: 33px"><td width="284"><p id="u7046a06f" class="ne-p" style="text-align: left"><span class="ne-text">表示表示</span></p></td><td width="284"><p id="ud5955bb3" class="ne-p" style="text-align: left"><span class="ne-text">属性值</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="u56c1d57c" class="ne-p" style="text-align: left"><span class="ne-text">预定义的颜色值</span></p></td><td width="284"><p id="uf3402dda" class="ne-p" style="text-align: left"><span class="ne-text">red，green，blue，还有我们的御用色 pink</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="u1697ed52" class="ne-p" style="text-align: left"><span class="ne-text">十六进制</span></p></td><td width="284"><p id="u762f5640" class="ne-p" style="text-align: left"><span class="ne-text">#FF0000，#FF6600，#29D794</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="u33cb846c" class="ne-p" style="text-align: left"><span class="ne-text">RGB 代码</span></p></td><td width="284"><p id="u4e97f8d7" class="ne-p" style="text-align: left"><span class="ne-text">rgb(255,0,0)或 rgb(100%,0%,0%)</span></p></td></tr></tbody></table><h3 id="zHk1x"><span class="ne-text">text-align</span></h3><ul class="ne-ul"><li id="8f5826a4c479bb4f7edc8eaecf54db0c"><span class="ne-text">文本水平对齐方式：text-align 属性用于设置文本内容的水平对齐，相当于 html 中的 align 对齐属性</span></li><li id="d97698018ce0b800138714770c2beb91"><span class="ne-text">其可用属性值如下：</span></li></ul><table id="CM1ef" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u54a9c299" class="ne-p"><span class="ne-text">属性</span></p></td><td width="375"><p id="uc438d3b8" class="ne-p" style="text-align: center"><span class="ne-text">解释</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u2faf7c1d" class="ne-p"><span class="ne-text">left</span></p></td><td width="375"><p id="u69b6cf5d" class="ne-p" style="text-align: center"><span class="ne-text">左对齐（默认值）</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u28295ba4" class="ne-p"><span class="ne-text">right</span></p></td><td width="375"><p id="u67a9311a" class="ne-p" style="text-align: center"><span class="ne-text">右对齐</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u7201017c" class="ne-p"><span class="ne-text">center</span></p></td><td width="375"><p id="u0ccc7a27" class="ne-p" style="text-align: center"><span class="ne-text">居中对齐</span></p></td></tr></tbody></table><ul class="ne-ul"><li id="7420a6a71abdab22492ee6119eb94584"><span class="ne-text">注意：<br></span><span class="ne-text">是让盒子里面的内容水平居中， 而不是让盒子居中对齐</span></li></ul><h3 id="80aPj"><span class="ne-text">TODO: line-height</span></h3><ul class="ne-ul"><li id="f8abec0cd94b9e7e61de78d98a139763"><span class="ne-text">行间距：line-height 属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。</span></li><li id="239976a5b6452d80c8bd3ebe142f4958"><span class="ne-text">单位：line-height 常用的属性值单位有三种，分别为像素 px，相对值 em 和百分比%，实际工作中使用最多的是像素 px</span></li></ul><pre data-language="plain" id="orIdc" class="ne-codeblock language-plain">一般情况下，行距比字号大 7.8 像素左右就可以了。<br>line-height: 24px;</pre><h3 id="gITg7"><span class="ne-text">text-indent</span></h3><ul class="ne-ul"><li id="ce1e703598265ce3ecc212147c55087c"><span class="ne-text">作用：text-indent 属性用于设置首行文本的缩进，</span></li><li id="39d76db4ee50f2b57926f2c2ed34c1ba"><span class="ne-text">其属性值可为不同单位的数值、em 字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值,</span></li><li id="363d39e17b84fbfde77093413c6f3c0d"><span class="ne-text">建议使用 em 作为设置单位，</span><strong><span class="ne-text">1em 就是一个字的宽度 如果是汉字的段落， 1em 就是一个汉字的宽度</span></strong></li></ul><pre data-language="css" id="NNuAQ" class="ne-codeblock language-css">p {<br>/<em>行间距</em>/<br>line-height: 25px;<br>/<em>首行缩进 2 个字 em 1 个 em 就是 1 个字的大小</em>/<br>text-indent: 2em;<br> }</pre><h3 id="SCoxC"><span class="ne-text">text-decoration</span></h3><ul class="ne-ul"><li id="f7cf032e274e467fac30577bc24ef0c3"><span class="ne-text">text-decoration 通常我们用于给链接修改装饰效果</span></li></ul><table id="rkvxe" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="ube459a65" class="ne-p"><span class="ne-text">值</span></p></td><td width="375"><p id="u2bcb4e37" class="ne-p"><span class="ne-text">描述</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u5464b817" class="ne-p"><span class="ne-text">none</span></p></td><td width="375"><p id="u467b833c" class="ne-p"><span class="ne-text">默认。定义标准的文本。 取消下划线（最常用）</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u7bb3c8cb" class="ne-p"><span class="ne-text">underline</span></p></td><td width="375"><p id="u43b1baa6" class="ne-p"><span class="ne-text">定义文本下的一条线。下划线 也是我们链接自带的（常用）</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u1330d5eb" class="ne-p"><span class="ne-text">overline</span></p></td><td width="375"><p id="u48f0c42d" class="ne-p"><span class="ne-text">定义文本上的一条线。（不用）</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ub1992c55" class="ne-p"><span class="ne-text">line-through</span></p></td><td width="375"><p id="ub35bb2db" class="ne-p"><span class="ne-text">定义穿过文本下的一条线。（不常用）</span></p></td></tr></tbody></table><p id="fee0cf74a4f0b39a790d3cf20cf9ce37" class="ne-p"><br></p><h2 id="mhb00"><span class="ne-text">背景相关</span></h2><h3 id="kZ6AP"><span class="ne-text">background-color</span></h3><ul class="ne-ul"><li id="9f8ec23b1a989c1ff41e8daf52dd8d1a"><span class="ne-text">background-color: 颜色值;</span></li><li id="f29ca935a52510bc930afbafe808ace8"><span class="ne-text">默认的值是 transparent   透明的</span></li></ul><h3 id="knP1Y"><span class="ne-text">background-image</span></h3><ul class="ne-ul"><li id="2fccad699df5122aa563c1fdd0afb97e"><span class="ne-text">background-image : url(images/demo.png);</span></li><li id="d728a04db20c8f3e1e4c1f0e16649751"><span class="ne-text">背景图片后面的地址，url 不要加引号。</span></li></ul><pre data-language="css" id="bJVjP" class="ne-codeblock language-css">background-image : none | url (url)</pre><table id="LuvYR" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u3fd3515c" class="ne-p"><span class="ne-text">参数</span></p></td><td width="375"><p id="ue87ae9cd" class="ne-p" style="text-align: center"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u9fcc575f" class="ne-p"><span class="ne-text">none</span></p></td><td width="375"><p id="uf66eb0fb" class="ne-p" style="text-align: center"><span class="ne-text">无背景图（默认的）</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u6fbf4a5d" class="ne-p"><span class="ne-text">url</span></p></td><td width="375"><p id="uddc1f659" class="ne-p" style="text-align: center"><span class="ne-text">使用绝对或相对地址指定背景图像</span></p></td></tr></tbody></table><p id="0a5011efb1d57bc6cd5c29975df1dd16" class="ne-p"><br></p><h3 id="VdPjT"><span class="ne-text">background-repeat</span></h3><ul class="ne-ul"><li id="bb9d397c7f4e3366ff713dcf858efe2b"><span class="ne-text">语法：</span></li></ul><pre data-language="css" id="t0ycl" class="ne-codeblock language-css">background-repeat : repeat | no-repeat | repeat-x | repeat-y</pre><table id="XNa51" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u4b8d4c02" class="ne-p"><span class="ne-text">参数</span></p></td><td width="375"><p id="u082b9d44" class="ne-p" style="text-align: center"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u4f0b70f8" class="ne-p"><span class="ne-text">repeat</span></p></td><td width="375"><p id="uf08131b8" class="ne-p" style="text-align: center"><span class="ne-text">背景图像在纵向和横向上平铺（默认的）</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u11e204da" class="ne-p"><span class="ne-text">no-repeat</span></p></td><td width="375"><p id="u25c70515" class="ne-p" style="text-align: center"><span class="ne-text">背景图像不平铺</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u1efa323b" class="ne-p"><span class="ne-text">repeat-x</span></p></td><td width="375"><p id="ub7636bc6" class="ne-p" style="text-align: center"><span class="ne-text">背景图像在横向上平铺</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u06ff26ce" class="ne-p"><span class="ne-text">repeat-y</span></p></td><td width="375"><p id="u451b353e" class="ne-p" style="text-align: center"><span class="ne-text">背景图像在纵向平铺</span></p></td></tr></tbody></table><h3 id="maWIg"><span class="ne-text">background-position</span></h3><ul class="ne-ul"><li id="cd4f25d2ca7a9b98807393b7582106de"><span class="ne-text">语法：</span></li></ul><pre data-language="css" id="NlaRU" class="ne-codeblock language-css">background-position : length || length<br>background-position : position || position</pre><ul class="ne-ul"><li id="944f0ffcab9c21fb077b6ac07e5f50b4"><span class="ne-text">参数解释</span></li></ul><table id="wKMRs" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u16aeb696" class="ne-p"><span class="ne-text">参数</span></p></td><td width="375"><p id="u6bfb5a48" class="ne-p" style="text-align: center"><span class="ne-text">值</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u6f7a4e9f" class="ne-p"><span class="ne-text">length</span></p></td><td width="375"><p id="ud6a2f4dc" class="ne-p" style="text-align: center"><span class="ne-text">百分数 | 由浮点数字和单位标识符组成的长度值</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u682d50cf" class="ne-p"><span class="ne-text">position</span></p></td><td width="375"><p id="u28e44348" class="ne-p" style="text-align: center"><span class="ne-text">top | center | bottom | left | center | right 方位名词</span></p></td></tr></tbody></table><p id="cdd7dfc8797842cfa0b6e1ca1f60b7ee" class="ne-p"><br></p><ul class="ne-ul"><li id="eb4538599e63d4221bed5057ae516cf2"><span class="ne-text">必须先指定 background-image 属性</span></li><li id="6ec962b18a0eb4c67c5f9c0f74470f08"><span class="ne-text">position 后面是 x 坐标和 y 坐标。 可以使用方位名词或者 精确单位。</span></li><li id="16eb9a84c4cf05516a300ad858051391"><span class="ne-text">如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如 left top 和 top left 效果一致</span></li><li id="c11f599edbac51ec6d4818f2ff124784"><span class="ne-text">如果只指定了一个方位名词，另一个值默认居中对齐。</span></li><li id="bfad8a29d772f8aa9e0724375d400844"><span class="ne-text">如果 position 后面是精确坐标， 那么第一个，肯定是 x 第二的一定是 y</span></li><li id="8430d1c9203e531bbee190d951a161ce"><span class="ne-text">如果只指定一个数值,那该数值一定是 x 坐标，另一个默认垂直居中</span></li><li id="6330bd3aabd30ec5525f9169dcbe96c8"><span class="ne-text">如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是 x 坐标，第二个值是 y 坐标</span></li><li id="089f1d235d246a97cad4da7b403dc0b9"><strong><span class="ne-text">实际工作用的最多的，就是背景图片居中对齐了。</span></strong></li></ul><h3 id="WcAYx"><span class="ne-text">background-attachment</span></h3><ul class="ne-ul"><li id="3215b38962dd6157e3269b26cb66a02a"><span class="ne-text">背景附着就是解释背景是滚动的还是固定的</span></li><li id="683bd0554e204723f4ad10c6bda06b2a"><span class="ne-text">语法：</span></li></ul><pre data-language="css" id="QOgbl" class="ne-codeblock language-css">background-attachment : scroll | fixed</pre><table id="O1Ml4" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u04ec1eeb" class="ne-p"><span class="ne-text">参数</span></p></td><td width="375"><p id="u27cd12ce" class="ne-p" style="text-align: center"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u5d59f1fb" class="ne-p"><span class="ne-text">scroll</span></p></td><td width="375"><p id="u57d9a984" class="ne-p" style="text-align: center"><span class="ne-text">背景图像是随对象内容滚动</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uedb2a723" class="ne-p"><span class="ne-text">fixed</span></p></td><td width="375"><p id="u1f85d788" class="ne-p" style="text-align: center"><span class="ne-text">背景图像固定</span></p></td></tr></tbody></table><h3 id="1D8b9"><span class="ne-text">background-size</span></h3><div class="ne-quote"><p id="4bca5d850aec85fc6407cffcb8478047" class="ne-p"><span class="ne-text">background-size 属性规定背景图像的尺寸</span></p></div><ul class="ne-ul"><li id="fcf1c81b4928af3b262fd2df0f9861ab"><span class="ne-text">两个参数：分别是长度和宽度</span></li><li id="d30026ded0e900d31e22fb76dd154b08"><span class="ne-text">一个参数：就是宽度，高度跟着宽度等比拉伸</span></li><li id="b39544135268299b015c4182b651d462"><strong><span class="ne-text">也可以是百分比，相对父盒子</span></strong></li><li id="9dbed52c124ad259c3c504b05fd55727"><span class="ne-text">cover：类似按着右下角光标，把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。</span></li><li id="58b0a8cbb55fa54b2010b423455029a2"><span class="ne-text">contain：把图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域</span></li></ul><h3 id="Z6U90"><span class="ne-text">背景简写</span></h3><ul class="ne-ul"><li id="b00a2ace8788e67fb85f42bf1f53e816"><span class="ne-text">background：属性的值的书写顺序官方</span><span class="ne-text" style="background-color: #FADB14">并没有强制标准</span><span class="ne-text">的。</span></li><li id="3f72d20b2c0454a04afde43924d6e188"><span class="ne-text">background: 背景</span><span class="ne-text" style="color: #F5222D">颜色</span><span class="ne-text"> 背景</span><span class="ne-text" style="color: #F5222D">图片地址</span><span class="ne-text"> 背景</span><span class="ne-text" style="background-color: transparent; color: #F5222D">平铺</span><span class="ne-text"> 背景</span><span class="ne-text" style="color: #F5222D">滚动</span><span class="ne-text"> 背景</span><span class="ne-text" style="color: #F5222D">位置</span><span class="ne-text">;</span></li><li id="bef72971c1c3b01818f649ac15c9eb1d"><span class="ne-text">语法：</span></li></ul><pre data-language="css" id="ekhTV" class="ne-codeblock language-css">background: blue url(image.jpg) repeat-y scroll center top ;</pre><p id="738c50709a978b35759842a1bb3b1d7e" class="ne-p"><br></p><h3 id="zSOq3"><span class="ne-text">背景透明(CSS3)</span></h3><ul class="ne-ul"><li id="1d94db94af3eaac4c290c401d74ac8b5"><span class="ne-text">语法：</span></li></ul><pre data-language="css" id="8GnN2" class="ne-codeblock language-css">background: rgba(0, 0, 0, 0);</pre><ul class="ne-ul"><li id="914da85d55c7e7d3299bdc60ea3ff4cb"><span class="ne-text">最后一个参数是 alpha 透明度 取值范围 0</del>1 之间</span></li><li id="50115bc31d1c1cdf7c4becb7ae4307f7"><span class="ne-text">我们习惯把 0.3 的 0 省略掉 这样写 background: rgba(0, 0, 0, .3);</span></li><li id="ec156db933637e0d0a37c74da3bb4f1b"><span class="ne-text">注意： 背景半透明是指盒子背景半透明， 盒子里面的内容不受影响</span></li><li id="3d2dbe3de60b5a9ea2e6fb4d3cf6265b"><span class="ne-text">因为是 CSS3 ，所以 低于 ie9 的版本是不支持的。</span></li></ul><p id="62d74c5b709174b23bc31c244acba0a9" class="ne-p"><br></p><p id="374da716b00bcaa399985b4d9756ed1c" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML5总结</title>
      <link href="/blog/vxz6aq7m0szt/"/>
      <url>/blog/vxz6aq7m0szt/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="ZkzlO"><span class="ne-text">HTML5</span></h2><div data-type="info" class="ne-alert"><p id="5f2311a63014ef8aea05ee4a4b4a1ddc" class="ne-p"><span class="ne-text">新版本的 HTML 语言，定义了新的标签、特性和属性</span></p></div><h3 id="8MvVB"><span class="ne-text">常用文档</span></h3><div class="ne-quote"><p id="f82a9e7df8b21eef78cf9ab241036a96" class="ne-p"><span class="ne-text">W3C :  </span><a href="http://www.w3school.com.cn/" data-href="http://www.w3school.com.cn/" target="_blank" class="ne-link"><span class="ne-text">http://www.w3school.com.cn/</span></a></p><p id="a9693ce5572587f78832ec6c5caea27e" class="ne-p"><span class="ne-text">MDN: </span><a href="https://developer.mozilla.org/zh-CN/" data-href="https://developer.mozilla.org/zh-CN/" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/</span></a></p><p id="6e87e3fb9d2d879b4e89b41f01e346a0" class="ne-p"><span class="ne-text">菜鸟：</span><a href="https://www.runoob.com/" data-href="https://www.runoob.com/" target="_blank" class="ne-link"><span class="ne-text">https://www.runoob.com/</span></a></p></div><h3 id="SAKcC"><span class="ne-text">扩展的内容</span></h3><ul class="ne-ul"><li id="2576dd5e70338b5ab236655dd7140dd0"><span class="ne-text">语义化标签</span></li><li id="cc85e1a4dfedecc807b62ad17cb3e3fe"><span class="ne-text">本地存储</span></li><li id="b1fad9da0de12a43a6e61f0fb8a01426"><span class="ne-text">兼容特性</span></li><li id="a80caa2dac765fbc4feb7e5720dfd1cf"><span class="ne-text">2D、3D</span></li><li id="56c7a854bf7023b5175df6b51925509a"><span class="ne-text">动画、过渡</span></li><li id="70cdba570bd2326cc35ba111550bad66"><span class="ne-text">CSS3 特性</span></li><li id="3b740b119c3124f163867dc45e2c3b55"><span class="ne-text">性能与集成</span></li></ul><h2 id="B8GzM"><span class="ne-text">HTML5文档结构/语义化标签</span></h2><p id="fd03a18ba6e17c41c78082ab3295e7ad" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616663386514-c6d53c70-d47f-4e40-b6f8-4a0f0596489b.png" width="334.5" id="lgs5S" class="ne-image"></p><ul class="ne-ul"><li id="f45bbd7e39f254637aaa60fc3ef0dc05"><a href="https://www.jianshu.com/p/c41b88217834" data-href="https://www.jianshu.com/p/c41b88217834" target="_blank" class="ne-link"><span class="ne-text">https://www.jianshu.com/p/c41b88217834</span></a></li><li id="06dd8082656e33ab385b9b4e4f82068e"><a href="https://juejin.cn/post/6844903544995184653" data-href="https://juejin.cn/post/6844903544995184653" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6844903544995184653</span></a></li></ul><h2 id="8aB2g"><span class="ne-text"><!DOCTYPE></span></h2><ul class="ne-ul"><li id="d1e82340b404562616c95978ef587888"><span class="ne-text">html5的文档类型声明：声明位于文档中的最前面的位置，处于  标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。</span></li><li id="e06797b56fd2a8025d6c5b6741dff4fb"><span class="ne-text" style="background-color: transparent">一些老网站可能用的还是老版本的文档类型比如 XHTML之类的，但是我们学的是HTML5,而且HTML5的文档类型兼容很好(向下兼容的原则)</span></li></ul><h2 id="uWDQh"><span class="ne-text">charset</span></h2><ul class="ne-ul"><li id="03f8547414a772599060d12b5e0b16b2"><span class="ne-text">html5文档编码格式的指定</span></li></ul><pre data-language="html" id="98GpN" class="ne-codeblock language-html"><meta charset="UTF-8" /></pre><div class="ne-quote"><p id="520f6765beab0b82f6020b9f64bbdc62" class="ne-p"><span class="ne-text">字符集(Character set)是多个字符的集合。</span></p><p id="f44de8225c3ae022a5888e8700666f7d" class="ne-p"><span class="ne-text">计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</span></p></div><p id="f1615e0cc70e5b86af5393e9cc72be40" class="ne-p"><span class="ne-text">utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。</span></p><ul class="ne-ul"><li id="f7cbd6b361453e85e7e2420b1daec0bb"><span class="ne-text">gb2312 简单中文  包括6763个汉字</span></li><li id="6f945bfea92cb04029853be612934b35"><span class="ne-text">BIG5   繁体中文 港澳台等用</span></li><li id="7943dadd5c0b456f85a054c440a84e93"><span class="ne-text">GBK包含全部中文字符    是GB2312的扩展，加入对繁体字的支持，兼容GB2312</span></li><li id="e91d1cc50d349f88823aad50d6aaf115"><span class="ne-text">UTF-8则基本包含全世界所有国家需要用到的字符</span></li></ul><h2 id="uKwWB"><span class="ne-text">多媒体音频标签</span></h2><ol class="ne-ol"><li id="df329d3ea76bedef62cea5aafe922c6a"><span class="ne-text">多媒体标签有两个，分别是</span></li></ol><ul class="ne-ul"><li id="ba194af62a61a209391e330173faa070"><span class="ne-text">音频  -- </span><code class="ne-code"><span class="ne-text">audio</span></code></li><li id="996462f3326a9f962b8f3db13378cb1d"><span class="ne-text">视频  -- </span><code class="ne-code"><span class="ne-text">video</span></code></li></ul><ol start="2" class="ne-ol"><li id="924aa3218a69542dff9e67d340cf5758"><code class="ne-code"><span class="ne-text">audio</span></code><span class="ne-text"> 标签说明</span></li></ol><ul class="ne-ul"><li id="0c70170019bc3e0fba044da599125975"><span class="ne-text">可以在不使用标签的情况下，也能够原生的支持音频格式文件的播放，</span></li><li id="a083cd1beac4d4a4d753746bab961cd4"><span class="ne-text">但是：播放格式是有限的</span></li></ul><ol start="3" class="ne-ol"><li id="37114ce1b72c417f46901f8ed7a9c9ea"><span class="ne-text">audio 支持的音频格式</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="fa4749fc93a863b2fd24daf66577991b"><span class="ne-text">audio 目前支持三种格式</span></li></ul></ul><ol start="4" class="ne-ol"><li id="cddae4aa81f1abe4eecc459b90949b24"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560874331-7786480d-ad33-403e-976d-73e235a0f3ec.png" width="589.5" id="RY5qn" class="ne-image"></li><li id="69c380758e7954808541f645e8961074"><span class="ne-text">audio 的参数</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560883989-c202ee16-7e45-4c86-ac47-3e3ba07fc2a7.png" width="601.5" id="jl5Sy" class="ne-image"></li></ol><p id="d09cbaad74a33137afc660c975ff3051" class="ne-p"><span class="ne-text">5、audio 代码演示</span></p><pre data-language="css" id="HoAi8" class="ne-codeblock language-css"><body>  <!-- 注意：在 chrome 浏览器中已经禁用了 autoplay 属性 -->  <!-- <audio src="./media/snow.mp3" controls autoplay></audio> -->  <!--     因为不同浏览器支持不同的格式，所以我们采取的方案是这个音频准备多个文件   -->  <audio controls>    <source src="./media/snow.mp3" type="audio/mpeg" />  </audio></body></pre><h2 id="gfSCR"><span class="ne-text">多媒体视频标签</span></h2><ol class="ne-ol"><li id="06e83d4275eec88014e5e02c639395b1"><span class="ne-text">video 视频标签</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="9952ba70d653f33fde3ba24ec195918b"><span class="ne-text">目前支持三种格式</span></li></ul></ul><ol start="2" class="ne-ol"><li id="815508b07e5037fb06d4750cd6b78da3"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560894436-db88d851-871b-4758-9b78-9b9892711139.png" width="605.5" id="LTerj" class="ne-image"></li><li id="864d706f7cf4dd51f52d4fd976647bbb"><span class="ne-text">语法格式</span></li></ol><pre data-language="html" id="kw48s" class="ne-codeblock language-html"><video src="./media/video.mp4" controls="controls"></video></pre><ol class="ne-ol"><li id="3db938a7697face04ccb25872a80d2d7"><span class="ne-text">video 参数</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560905874-4a6cc88d-8941-4f8c-9c89-05ce01e229fb.png" width="596.5" id="cVVsr" class="ne-image"></li><li id="ad0e24959eca689b28d12891f6d26705"><span class="ne-text">video 代码演示</span></li></ol><pre data-language="html" id="hRhBq" class="ne-codeblock language-html"><body>  <!-- <video src="./media/video.mp4" controls="controls"></video> -->  <!-- 谷歌浏览器禁用了自动播放功能，如果想自动播放，需要添加 muted 属性 -->  <video controls="controls" autoplay muted loop poster="./media/pig.jpg">    <source src="./media/video.mp4" type="video/mp4">    <source src="./media/video.ogg" type="video/ogg">  </video></body></pre><ol class="ne-ol"><li id="98177e61ec71e15abae90eb7144ef5ac"><span class="ne-text">多媒体标签总结</span></li></ol><ul class="ne-ul"><li id="82e44acec12dbcd2169ae9ec80c5cab2"><span class="ne-text">音频标签与视频标签使用基本一致</span></li><li id="db1a6c5b6b0f06a9084137509f4e0fa3"><span class="ne-text">多媒体标签在不同浏览器下情况不同，存在兼容性问题</span></li><li id="a4aa2e20bab7877979128818300defc8"><span class="ne-text">谷歌浏览器把音频和视频标签的自动播放都禁止了</span></li><li id="9d3b339ecaead5270fa379ca944773da"><span class="ne-text">谷歌浏览器中视频添加 muted 标签可以自己播放</span></li><li id="7807befe0e4644cde46c9c80ddeab9d8"><span class="ne-text">注意：重点记住使用方法以及自动播放即可，其他属性可以在使用时查找对应的手册</span></li></ul><h2 id="cMw9Z"><span class="ne-text">新增 input 标签</span></h2><p id="7663543d9a186a67902e6d945bd05595" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560920848-b6218b7e-57ed-4da9-889e-ff00dd8df1c2.png" width="629.5" id="QfnGy" class="ne-image"></p><h2 id="1y9CZ"><span class="ne-text">新增表单属性</span></h2><p id="b4f19541ffe4082aabd9018ed884fd9f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560931257-0c5b2693-9baf-4129-a502-e22ebc14c89e.png" width="608.5" id="xEk6J" class="ne-image"></p><p id="u44ad0119" class="ne-p"><br></p><p id="u0ac21576" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML总结</title>
      <link href="/blog/vtwy70ohpnm5/"/>
      <url>/blog/vtwy70ohpnm5/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="dZG9R"><span class="ne-text">常用文档</span></h2><div class="ne-quote"><p id="1730efa97c814edb0a0af9fdccb1ef56" class="ne-p"><span class="ne-text">W3C :  </span><a href="http://www.w3school.com.cn/" data-href="http://www.w3school.com.cn/" target="_blank" class="ne-link"><span class="ne-text">http://www.w3school.com.cn/</span></a></p><p id="c7fd9ef80bcede5c3555529ab9b94c34" class="ne-p"><span class="ne-text">MDN: </span><a href="https://developer.mozilla.org/zh-CN/" data-href="https://developer.mozilla.org/zh-CN/" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/</span></a></p><p id="5551e70a0ba88ded407ba5e50b0ff279" class="ne-p"><span class="ne-text">菜鸟：</span><a href="https://www.runoob.com/" data-href="https://www.runoob.com/" target="_blank" class="ne-link"><span class="ne-text">https://www.runoob.com/</span></a></p></div><h2 id="npsjj"><span class="ne-text">排版标签</span></h2><ul class="ne-ul"><li id="c58d1d14e822228e7de7b1d387eae4f4"><span class="ne-text">h：标题</span></li><li id="752fbd6a7f0db71d8bfb5b4c3e66a76b"><span class="ne-text">p：段落</span></li><li id="1af4dad3c9a5482c5a72883184a3a2b3"><span class="ne-text">hr（单）：横线</span></li><li id="dbe599382da964f3c9db2ced9aa8415e"><span class="ne-text">br（单）：换行</span></li><li id="90f1a7203b674a62fea092312c140167"><span class="ne-text" style="color: #4D4D4D; font-size: 16px">blockquote：引用</span></li><li id="325664d03a52915e3e258062f8c56445"><span class="ne-text" style="color: #4D4D4D; font-size: 16px">pre：预定义格式</span></li></ul><div class="ne-quote"><p id="4d51bedc413f950d477424f0b2269688" class="ne-p"><span class="ne-text">标签可定义预格式化的文本。 被包围在   标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。</span></p></div><span id="rahiB"></span><h2 id="L1PLV"><span class="ne-text">文本格式化标签</span></h2><p id="f3ba3ad02b77de7e36371f91b1fbaabd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611547659083-2c64e035-b906-47c8-84e1-67b8e747e361.png" width="1054" id="hTJyy" class="ne-image"></p><ul class="ne-ul"><li id="746680bbb7293cd90ce0fceeec3c3525"><span class="ne-text" style="background-color: transparent">b 只是加粗strong除了可以加粗还有 强调的意思，语义更强烈。</span></li></ul><h2 id="Y1Z3u"><span class="ne-text">img（单）</span></h2><p id="6e01155f3183ccbbdaa0d5d8c4f66f9d" class="ne-p"><br></p><p id="bd0f3775697bd11cff7298215468fcc1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611547659339-b5fd80fe-ed24-42d9-8d70-ab9fe086449d.png" width="997" id="qWbBI" class="ne-image"></p><p id="84ef3e55c8d1099d653b4d7948d4b6cb" class="ne-p"><span class="ne-text">border 后面我们会用css来做，这里童鞋们就记住这个border 单词就好了</span></p><p id="3b087b4c5380b9c94d71bc1692f72147" class="ne-p"><strong><span class="ne-text">注意: </span></strong></p><ol class="ne-ol"><li id="807e1815b792378ebf4e94283a6cfe9d"><span class="ne-text">标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。</span></li><li id="3dbcc6d607d712dbdb7a1f933b09bba6"><span class="ne-text">属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</span></li><li id="d678fc804f07a24a329d9ebe62e7ea31"><span class="ne-text">任何标签的属性都有默认值，省略该属性则取默认值。</span></li><li id="0ec5f1ec9e03bff327e8b0f37543ed41"><span class="ne-text">采取  键值对 的格式   key="value"  的格式</span></li></ol><p id="4cbe163524078f64efdeebf5a77ca286" class="ne-p"><span class="ne-text">比如:</span></p><span id="Vc37C"></span><p id="81d7149d5163ab07286a2b1718d2baeb" class="ne-p"><span class="ne-text">此处有练习题</span></p><p id="26cbd0574b9aa0697630dfbada743c3b" class="ne-p"><strong><span class="ne-text">重点掌握点：</span></strong></p><ul class="ne-ul"><li id="b71ea9f48e0abe185409c6b1a4cea80e"><span class="ne-text"> 请说出 图像标签那个属性是必须要写的？  img  src 图片的路径</span></li><li id="187463f93b61742b415d079a095f8ab0"><span class="ne-text"> 请说出 图像标签中 alt 和  title 属性区别？ alt 图片显示不出，文字就显示     title 鼠标经过图片的时候显示文字</span></li></ul><h2 id="TUVIZ"><span class="ne-text">a</span><strong><span class="ne-text"></span></strong></h2><ul class="ne-ul"><li id="a2430543e546b23873a407f4ad76810b"><span class="ne-text"> href：必须要的属性</span></li><li id="f6895ebac9686e774eccd98fda26e5d9"><span class="ne-text">target=“_blank”：新窗口打开</span></li></ul><h2 id="BatH6"><span class="ne-text">div和span</span></h2><div class="ne-quote"><p id="b5f6582587884fb813bd7d87a00187cb" class="ne-p"><span class="ne-text">标准流布局</span></p></div><ul class="ne-ul"><li id="d05d1232aa861b2108b327fc365ff3ac"><span class="ne-text">div标签  用来布局的，但是现在一行只能放一个div</span></li><li id="30faeb721117edf86fdd11764dd9a41a"><span class="ne-text">span标签  用来布局的，一行上可以放好多个span</span></li></ul><h2 id="Qo35Y"><span class="ne-text">base</span></h2><ul class="ne-ul"><li id="d637d8e76b5fd773f91aee5dbe978807"><span class="ne-text">base 可以设置整体链接的打开状态</span></li></ul><div class="ne-quote"><p id="c3fc3eb4ba3d36bb11cd68128ca18905" class="ne-p"><span class="ne-text">最常用的就是<base target="_blank" /></span></p></div><p id="ff81843c907c80bb4f282f7c083c2d6b" class="ne-p"><br></p><h2 id="8aB2g"></h2><h2 id="NS3GL"><span class="ne-text">lang</span></h2><pre data-language="html" id="scifT" class="ne-codeblock language-html"><html lang="en">  指定html 语言种类</pre><p id="b26c08b7b08fb95b641b20636fe462ae" class="ne-p"><span class="ne-text">最常见的2个：</span></p><ol class="ne-ol"><li id="f523c33a93dd7d077235040184061708"><code class="ne-code"><span class="ne-text">en</span></code><span class="ne-text">定义语言为英语</span></li><li id="a907681bcc17b7516a48453fcb7511ae"><code class="ne-code"><span class="ne-text">zh-CN</span></code><span class="ne-text">定义语言为中文</span></li></ol><ul class="ne-ul"><li id="053e4f69d6d72ee5d5f0c8311db4c9fe"><span class="ne-text">指定该html标签 内容 所用的语言为中文</span><strong><span class="ne-text"></span></strong></li><li id="227d29a54a59530daa63f6cfb61656bd"><span class="ne-text">简单来说，可能对于程序来说没有太大的作用，但是它可以告诉浏览器，搜索引擎，一些处理Html的程序对页面语言内容来做一些对应的处理或者事情。</span></li></ul><p id="fd03547ee12ad4e8c25dfe5910c52e51" class="ne-p"><br></p><h2 id="5ecVw"><span class="ne-text">table</span></h2><h3 id="bryeo"><span class="ne-text">解释</span></h3><ul class="ne-ul"><li id="cbeb125d54f702ed33e5ca74573a7a6e"><span class="ne-text">展示数据</span></li><li id="902d55a49f6e5c2cf66f2c0395154328"><span class="ne-text">让数据显示整齐规范</span></li><li id="2d57b152aafdf627d23586b4c0d89bcb"><span class="ne-text">表格属性需要注意的</span></li></ul><p id="9f56becae2aece13e944d1c664bee8a6" class="ne-p"><span class="ne-text">平时开发的我们这三个参数border、cellpadding、cellspacing为0，但在HTML5里面，后两者属性设置无效，利用 </span><code class="ne-code"><span class="ne-text">border-collapse: collapse;</span></code><span class="ne-text"> 来设置，将th和td设置为0</span></p><ul class="ne-ul"><li id="408fe9d1ca157a3567bf96ec624990f5"><span class="ne-text">浏览器会默认包裹tbody标签</span></li><li id="eaffcbabbd2c9d5a9620ac8ec141ff59"><span class="ne-text">HTML5里面用thead,tbody,tfoot来标注内容，更加清晰</span><strong><span class="ne-text"></span></strong></li></ul><h3 id="SqIni"><span class="ne-text">合并单元格</span></h3><p id="38dbbade10b863bc300718edf1b0617c" class="ne-p"><span class="ne-text">合并单元格是我们比较常用的一个操作，但是不会合并的很复杂。</span></p><div class="ne-quote"><p id="b7b96409b556c1ee73d7520552b21dbc" class="ne-p"><span class="ne-text">【1】合并单元格2种方式</span></p></div><ul class="ne-ul"><li id="dba3f0910488b3618d3d54ec5a86238e"><span class="ne-text">跨行合并：rowspan="合并单元格的个数"</span></li><li id="23d45b8f12e5ce98dd35acbf74c34da3"><span class="ne-text">跨列合并：colspan="合并单元格的个数"</span></li></ul><div class="ne-quote"><p id="ed00c86c77879b70ba1296d0adbe0c13" class="ne-p"><span class="ne-text">【2】合并单元格顺序</span></p><p id="de0116a248a291ee6cf56bddd657fbe4" class="ne-p"><strong><span class="ne-text">合并的顺序我们按照   先上 后下     先左  后右 的顺序 </span></strong></p></div><p id="1adbbc617356d92cbee58f233e655b01" class="ne-p"><span class="ne-text">跟我们以前学习汉字的书写顺序完全一致。</span></p><div class="ne-quote"><p id="02773556afb0793cbeaf3e3a2184ee47" class="ne-p"><span class="ne-text">【3】合并单元格三步曲</span></p></div><ol class="ne-ol"><li id="53edf24679a27257a723e79b4d0b8f59"><span class="ne-text">先确定是跨行还是跨列合并</span></li><li id="ea62ad1c10c1ffe956c908ce110fdd40"><span class="ne-text">根据 先上 后下   先左  后右的原则找到目标单元格    然后写上 合并方式 还有 要合并的单元格数量  比如 ：    </span></li><li id="2944a1964138c244395cd912cd745714"><span class="ne-text">删除多余的单元格 单元格</span></li></ol><h2 id="5Qiin"><span class="ne-text">ul、ol、dl</span></h2><h3 id="6xC2e"><span class="ne-text">去掉列表默认的样式</span></h3><p id="d9586db6059b7cb2e4a0304ae1d8345c" class="ne-p"><span class="ne-text">无序和有序列表前面默认的列表样式，在不同浏览器显示效果不一样，而且也比较难看，所以，我们一般上来就直接去掉这些列表样式就行了。 代码如下</span></p><pre data-language="css" id="K7d70" class="ne-codeblock language-css">li { list-style: none; }</pre><h2 id="x6Hv6"><span class="ne-text">form</span></h2><ul class="ne-ul"><li id="d802bced65eba0ac604c6187eeed57dd"><span class="ne-text">表单目的是为了收集用户信息。</span></li></ul><p id="946ad7e8a5abf5dea27b2a08e4102e93" class="ne-p"><span class="ne-text">在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。</span></p><div class="ne-quote"><p id="3aa180518e9978d41bb13185f25f3800" class="ne-p"><span class="ne-text">在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。</span></p></div><ul class="ne-ul"><li id="d5a6e453dc3fd2c8ee80bd3b2faa5c03"><strong><span class="ne-text">表单控件： </span></strong><span class="ne-text">包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。</span></li><li id="a5f481fa212c0bbf7d2b8aff6909641e"><strong><span class="ne-text">提示信息：</span></strong><span class="ne-text">一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。</span></li><li id="ca3b62ad328c68dacf5717898c4cff35"><strong><span class="ne-text">表单域：</span></strong><span class="ne-text">他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。</span></li></ul><h3 id="J30BE"><span class="ne-text">input</span></h3><ul class="ne-ul"><li id="708bc00409b6951e0568439e6bd50401"><span class="ne-text">常用属性：</span></li></ul><p id="25ae6c09845c71d5cbd3a42106a1cdb4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611547661035-9721cb68-5232-4cbf-8bf5-01b447ed3f3f.png" width="950" id="BiEER" class="ne-image"></p><ul class="ne-ul"><li id="96409159c52168dd7cd21522f33888a1"><span class="ne-text">value 默认的文本值。 有些表单想刚打开页面就默认显示几个文字，就可以通过这个value 来设置。</span></li></ul><div class="ne-quote"><p id="9098761dcdcaabbae8752cbaf8f4be43" class="ne-p"><span class="ne-text">name属性后面的值，是我们自己定义的。</span></p></div><ul class="ne-ul"><li id="777a432e08a3d84e5fe34e4425adedab"><span class="ne-text">name表单的名字， 这样，后台可以通过这个name属性找到这个表单。  页面中的表单很多，name主要作用就是用于区别不同的表单。</span></li><li id="1fd92e9f3054a9cf22591a76647bf148"><span class="ne-text">radio  如果是一组，我们必须给他们命名相同的名字 name   这样就可以在同一个组里面多个选其中的一个</span></li><li id="343bee6cc19ef0c8eef0782dadada843"><span class="ne-text">name属性，我们现在用的较少， 但是，当我们学ajax 和后台的时候，是必须的。</span></li></ul><div class="ne-quote"><p id="ea9fcc433044658e950fdb2c12740e7d" class="ne-p"><span class="ne-text">checked属性</span></p></div><ul class="ne-ul"><li id="8638fed527ec64aef863070db5d678f9"><span class="ne-text">默认选中状态。  较常见于 单选按钮和复选按钮。</span></li></ul><h3 id="pFWQV"><span class="ne-text">label</span></h3><ul class="ne-ul"><li id="fb5c6b55f8d543ae80f4b986ea41e043"><span class="ne-text">用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点。</span></li></ul><div class="ne-quote"><p id="23c3bac617d30e9e6221c498a9e6c2cc" class="ne-p"><span class="ne-text">两种绑定方式</span></p></div><ol class="ne-ol"><li id="0fc90e67592232b4cbad70745cdb1a01"><span class="ne-text">第一种用法就是用label直接包括input表单。</span></li></ol><pre data-language="html" id="FW339" class="ne-codeblock language-html"><label> 用户名： <input type="radio" name="usename" value="请输入用户名">   </label></pre><p id="a984427ff266427f18b1550a1c94a4ca" class="ne-p"><span class="ne-text">适合单个表单选择</span></p><ol start="2" class="ne-ol"><li id="dc0782022e14c21fdb00507407349e69"><span class="ne-text">第二种用法 for 属性规定 label 与哪个表单元素绑定。</span></li></ol><pre data-language="html" id="VLjqx" class="ne-codeblock language-html"><label for="sex">男</label><p><input type="radio" name="sex"  id="sex"></pre><h3 id="f8rp2"><span class="ne-text">textarea</span></h3><h3 id="dlEQf"><span class="ne-text">select</span></h3><h3 id="BEna6"></h3><ul class="ne-ul"><li id="0a912ce9277e7ec729177ab905ddefe0"><span class="ne-text"><select> 中至少包含一对 option</span></li><li id="9dc2fd4c252850af4c10619c11c7e093"><span class="ne-text">在 option 中定义 selected =” selected “时，当前项即为默认选中项。</span></li><li id="9cb5a3582e1366a7c3c844fadefb794e"><span class="ne-text">但是我们实际开发会用的比较少</span></li></ul><h3 id="UQL8F"><span class="ne-text">form 表单域</span></h3><ul class="ne-ul"><li id="26b0190ce393a5aaf96962fc3e3100b1"><span class="ne-text">收集的用户信息怎么传递给服务器：通过 form 表单域</span></li><li id="b1f7fce94a087e1c39f04441c803038a"><span class="ne-text">目的：在 HTML 中，form 标签被用于定义表单域，以实现用户信息的收集和传递，form 中的所有内容都会被提交给服务器。</span></li></ul><pre data-language="html" id="mA7pL" class="ne-codeblock language-html"><form action="url地址" method="提交方式" name="表单名称"><br>各种表单控件</p></form></pre><p id="227c848e2a3bb1e297ee457d25dd613e" class="ne-p"><br></p><ul class="ne-ul"><li id="5ac1d849d58aca6b7d530170ad76a674"><span class="ne-text">每一个form至少含有一个submit类型的input标签（点击submit提交到form中的action地址当中），然后接收的html页面（服务端）利用类似以下的代码进行处理url得到前者页面所传过来的参数，以便在服务端进行利用</span></li></ul><pre data-language="javascript" id="wd4BA" class="ne-codeblock language-javascript"><script>    console.log(location.search); // ?uname=andy    // 1.先去掉？  substr('起始的位置'，截取几个字符);    var params = location.search.substr(1); // uname=andy    console.log(params);    // 2. 利用=把字符串分割为数组 split('=');    var arr = params.split('=');    console.log(arr); // ["uname", "ANDY"]    var div = document.querySelector('div');    // 3.把数据写入div中    div.innerHTML = arr[1] + '欢迎您';</script></pre><ul class="ne-ul"><li id="c18037fa2f630dadad819c600904f594"><strong><span class="ne-text">常用属性</span></strong></li></ul><table id="e9gFW" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"><p id="u512bd0ef" class="ne-p"><span class="ne-text">属性</span></p></td><td width="250"><p id="u56ca4cef" class="ne-p" style="text-align: left"><span class="ne-text">属性值</span></p></td><td width="250"><p id="u86a41f61" class="ne-p"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ud5e906c8" class="ne-p"><span class="ne-text">action</span></p></td><td width="250"><p id="u6e241977" class="ne-p" style="text-align: left"><span class="ne-text">url地址</span></p></td><td width="250"><p id="u06e58014" class="ne-p"><span class="ne-text">用于指定接收并处理表单数据的服务器程序的url地址。</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u2c885830" class="ne-p"><span class="ne-text">method</span></p></td><td width="250"><p id="u56055c02" class="ne-p" style="text-align: left"><span class="ne-text">get/post</span></p></td><td width="250"><p id="uc97156b6" class="ne-p"><span class="ne-text">用于设置表单数据的提交方式，其取值为get或post。</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u58721498" class="ne-p"><span class="ne-text">name</span></p></td><td width="250"><p id="u8a30ce77" class="ne-p" style="text-align: left"><span class="ne-text">名称</span></p></td><td width="250"><p id="u11fb0c64" class="ne-p"><span class="ne-text">用于指定表单的名称，以区分同一个页面中的多个表单。</span></p></td></tr></tbody></table><ul class="ne-ul"><li id="a344cbcf320b7302fdd8fb26c704b41b"><span class="ne-text">每个表单都应该有自己表单域。我们现在做页面，不写看不到效果，但是 如果后面学 ajax 后台交互的时候，必须需要 form表单域。</span></li></ul><p id="1325c33cdd78fe0615dea69075fcc3cf" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>674. 最长连续递增序列🔖数组🔖双指针</title>
      <link href="/blog/guaorh/"/>
      <url>/blog/guaorh/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u8ff4bb64"><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" data-href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/</span></a></li></ul><h3 id="Iw90w"><span class="ne-text">思路</span></h3><p id="ue0607f29" class="ne-p"><span class="ne-text">双指针顺移思想</span></p><p id="uff2fb206" class="ne-p"><span class="ne-text"></span></p><h3 id="AGl80"><span class="ne-text">ts实现</span></h3><pre data-language="typescript" id="qPw2F" class="ne-codeblock language-typescript">function findLengthOfLCIS(nums: number[]): number {<dl><dt>if (nums.length === 1) return 1<br>let head: number = 0<br>let next: number = 1<br>let result: number = 1<br>while (next !== nums.length) {<br>nums[next - 1] &lt; nums[next]<br>? (result = result &lt;= next - head + 1 ? next - head + 1 : result)</dt><dd>(head = next)<br>next++<br>}<br>return result<br>}</pre><p id="u882f6202" class="ne-p"><span class="ne-text"></span></p><h3 id="OB9D2"><span class="ne-text">之前 java 代码实现</span></h3><pre data-language="java" id="iKLT0" class="ne-codeblock language-java">package com.wztlink1013.problems.leetcode.editor.cn;</dd></dl><p>// P674.最长连续递增序列<br>// P674.longest-continuous-increasing-subsequence<br>//给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。<br>//<br>// 连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那<br>//么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。<br>//<br>//<br>//<br>// 示例 1：<br>//<br>//<br>//输入：nums = [1,3,5,4,7]<br>//输出：3<br>//解释：最长连续递增序列是 [1,3,5], 长度为 3。<br>//尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。<br>//<br>//<br>// 示例 2：<br>//<br>//<br>//输入：nums = [2,2,2,2,2]<br>//输出：1<br>//解释：最长连续递增序列是 [2], 长度为 1。<br>//<br>//<br>//<br>//<br>// 提示：<br>//<br>//<br>// 0 &lt;= nums.length &lt;= 104<br>// -109 &lt;= nums[i] &lt;= 109<br>//<br>// Related Topics 数组<br>// 👍 147 👎 0</p><p>public class P674LongestContinuousIncreasingSubsequence{<br>public static void main(String[] args) {<br>Solution solution = new P674LongestContinuousIncreasingSubsequence().new Solution();<br>int [] nums = {1,3,5,7};<br>int result = solution.findLengthOfLCIS(nums);<br>System.out.println(result);<br>}</p><p>//leetcode submit region begin(Prohibit modification and deletion)<br>class Solution {<br>public int findLengthOfLCIS(int[] nums) {<br>if (nums.length == 0) { return 0; }<br>int result = 1;<br>int count = 1;<br>for (int i=0; i&lt;nums.length-1; i++) {<br>if (nums[i] &lt; nums[i+1] ) {<br>count++;<br>if (result &lt; count) {result = count;}<br>} else {<br>if (result &lt; count) {result = count;}<br>count = 1;<br>}<br>}<br>return result;<br>}<br>}<br>//leetcode submit region end(Prohibit modification and deletion)</p><p>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《软件工程导论》知识总结</title>
      <link href="/blog/sc6tzq/"/>
      <url>/blog/sc6tzq/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue801d3a7" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623288164521-ad52e1f8-1a29-4976-ac2b-c45d7d5aa773.png" width="234.98956298828125" id="uca9222ff" class="ne-image"></p><p id="u0f5fa5c3" class="ne-p"><span class="ne-text"></span></p><p id="udeb4604d" class="ne-p"><span class="ne-text">前言：大三课程所学总结，同时日后以此为蓝本在实际开发中规范化开发。</span></p><p id="ud6be1287" class="ne-p"><br></p><h2 id="Sg2gh"><span class="ne-text">一、传统方法学</span></h2><ul class="ne-ul"><li id="u064198b3"><strong><span class="ne-text">问题定义</span></strong></li><li id="u573f5f0a"><strong><span class="ne-text">可行性研究</span></strong></li></ul><p id="u629ba7d2" class="ne-p"><br></p><ul class="ne-ul"><li id="u933d2d62"><strong><span class="ne-text">需求分析</span></strong></li><li id="u6e6fc06e"><strong><span class="ne-text">总体设计</span></strong></li><li id="uf627370b"><strong><span class="ne-text">详细设计</span></strong></li></ul><p id="ua85c12d8" class="ne-p"><br></p><ul class="ne-ul"><li id="u37f64c7c"><strong><span class="ne-text">编码和单元测试</span></strong></li><li id="u74245b96"><strong><span class="ne-text">综合测试</span></strong></li></ul><p id="u32145c4e" class="ne-p"><br></p><ul class="ne-ul"><li id="u34d5e06c"><strong><span class="ne-text">软件维护</span></strong></li></ul><p id="uecdbfe88" class="ne-p"><strong><span class="ne-text"></span></strong></p><h3 id="kWUyN"><span class="ne-text">可行性研究</span></h3><div class="ne-quote"><p id="da256ec317c21c67463ce9e72c02676b" class="ne-p"><span class="ne-text">在了解问题定义之后，将其模型抽离出来，然后对其进行可行性分析，探索若干种解法，对每种解法仔细研究其可行性，从下面几种方面来考虑</span></p></div><ol class="ne-ol"><li id="4491145eb22ea1f1f9851e794718f1b1"><span class="ne-text">技术可行性：能否用现又技术实现？</span></li><li id="0ef89cd6a88e622374fd1c9abd33be3a"><span class="ne-text">经济可行性：软件带来的经济效益能否大于软件的开发成本？</span></li><li id="91bc3d6b87ac18c66962c6db7181155b"><span class="ne-text">操作可行性：在用户组织之间是否具有操作可行性？</span></li></ol><p id="e7c5762d2b7f53f3c02815b1ac02dab5" class="ne-p"><br></p><p id="f56b388d47cc5e1383c0f819c95ff2c2" class="ne-p"><span class="ne-text">必要时还有从法律和社会效益来研究其可行性。</span></p><p id="f736b9b4886d5b30b7f847a004cfaba2" class="ne-p"><br></p><div class="ne-quote"><p id="2cb44a84ff8d9e6512b497e6ea8830e9" class="ne-p"><span class="ne-text">系统流程图</span></p><p id="990dc056d60a8294a724cf6ac2e0b26f" class="ne-p"><span class="ne-text">数据流图</span></p></div><p id="e2724457d877628cb99acab2eec04da4" class="ne-p"><br></p><div class="ne-quote"><p id="1b361a0060ba18cfae16ab07acc28938" class="ne-p"><span class="ne-text">成本/效益分析</span></p></div><p id="220af99ca5b90b67c97cb898bdde6493" class="ne-p"><span class="ne-text">成本估计的几种方法</span></p><ul class="ne-ul"><li id="a1ce0c0a61613b6dd566b39061c6f943"><span class="ne-text">代码行技术：根据每行代码的平均成本乘以行数就是大概的成本</span></li><li id="87615407e2f1fb8079c9c57e73739125"><span class="ne-text">任务分解技术：将整个声明周期划分不同阶段，估计每个不同阶段所花费的成本，一般都是各阶段的人数诚意平均工资再加这般</span></li><li id="1e278915a7b91d80f4b4e32795487753"><span class="ne-text">自动估计成本：根据程序来估计，一般要用到大量数据，才能保证这个估计有效（大数据时代应该很吃香，可以利用所搜集的大量数据来进行建模）</span></li></ul><p id="1775f6dde2a55974718d34e86bf586a6" class="ne-p"><br></p><p id="476b681e81fd2f67fd8a382cc00391f3" class="ne-p"><span class="ne-text">成本/效益分析的方法</span></p><ul class="ne-ul"><li id="f67bec3f08ba880aa864bca1291f02c2"><span class="ne-text">货币的时间价值：这里面有年利率的概念，就是过n年之后，你手中的钱在n年之后会提升</span></li></ul><p id="4ee18602917afb986f4f491c367652b7" class="ne-p"><span class="ne-text">F=P（1+n）^n        （P元钱在n年后的价值）</span></p><ul class="ne-ul"><li id="d87da5223a3b61714341639756dc6289"><span class="ne-text">投资回收期：你所赚的钱等于你所投资的资金所花费的时间越短越好</span></li><li id="db66717e9cac0948bd3732fbb7550a5c"><span class="ne-text">纯收入：整个生命周期内，赚的钱减去你投资的钱</span></li></ul><h3 id="i74Hr"><span class="ne-text">需求分析</span></h3><div class="ne-quote"><p id="abe209f676db33b9d9a619b6e9aa6f90" class="ne-p"><span class="ne-text">与用户沟通获取需求的方法</span></p></div><ul class="ne-ul"><li id="c81898b947638b817b40a1ee6b31997d"><span class="ne-text">访谈</span></li><li id="50482d1eb38d4982069107892aa38382"><span class="ne-text">面向数据流自顶向下求精</span></li><li id="504a63ce936b7c766f2e360d8ee1f67b"><span class="ne-text">简易的应用规格说明技术</span></li><li id="9e77c616f4921079c2ecd3b0197a433b"><span class="ne-text">快速建立软件模型</span></li></ul><p id="a129032def9a21df6ec1816fb63c7536" class="ne-p"><br></p><div class="ne-quote"><p id="a6976eabc8b5a57c244dc94c31ae467a" class="ne-p"><span class="ne-text">根据结构化分析准则，需求分析过程应该建立三种模型，它们分别是？以及他们所用到的工具？</span></p></div><ul class="ne-ul"><li id="d5810c7e4c99fe3c690286d15258a271"><span class="ne-text">数据模型——E-R图：就是数据库里面学到的实体-联系图</span></li><li id="ecff7d5e5389025a0c7de4166b323828"><span class="ne-text">功能模型——数据流图：描述数据在系统中的转换的逻辑过程</span></li><li id="44e373a12ce96cd1e6e9dc964b52ecf9"><span class="ne-text">行为模型——状态转换图：作为外部事件结果的系统行为</span></li></ul><p id="4ad53d3f9e7fbcad84af4ead365a4254" class="ne-p"><br></p><div class="ne-quote"><p id="5ed1424a182263377220cfe0104f5a84" class="ne-p"><span class="ne-text">其他的工具还有</span></p></div><ul class="ne-ul"><li id="bfdc0d510e292081cae0537b845462d4"><span class="ne-text">层次方框图（树形结构）</span></li><li id="06f3050dcb6c971fcf9177f4fd71c9c9"><span class="ne-text">Warnier图{大括号包裹）</span></li><li id="6720079fe34f229e69a211ed8f6977e8"><span class="ne-text">IPO图（方框-箭头；表格形式）</span></li></ul><p id="c8bac408ac7e8d987d6ac2b9f87e67a1" class="ne-p"><br></p><h3 id="XMDx8"><span class="ne-text">形式化说明技术</span></h3><div class="ne-quote"><p id="4f81173a2f49c4af9bc074d2c65331b6" class="ne-p"><span class="ne-text">软件工程所使用的方法可划分为下面三种</span></p></div><ul class="ne-ul"><li id="aa3a4b4b22f9df9f52a75fd4b5787b49"><span class="ne-text">非形式化方法：用自然语言描述就是典型的非形式化方法</span></li><li id="282495a0dd8355d5495c0db509344ccd"><span class="ne-text">半形式化方法：利用E-R图描述就是半形式化方法</span></li><li id="462d34af07b4f5e183190104e896ee18"><span class="ne-text">形式化方法：用到数学的技术，也就是说，如果一种方法用到坚实的数学基础，那么他就是形式化方法</span></li></ul><p id="0278630d09af9b8e39ae0eacf316e038" class="ne-p"><br></p><h3 id="IECRF"><span class="ne-text">总体设计</span></h3><div class="ne-quote"><p id="c095e1f290f3a6bd1331e12b689974b1" class="ne-p"><span class="ne-text">总体设计又称之为概要设计、初步设计</span></p></div><p id="f9ffad5ade83523a7e15cdf9fc65a51c" class="ne-p"><br></p><div class="ne-quote"><p id="3cb7fa8506228a3b8e172579417623a5" class="ne-p"><span class="ne-text">由哪两阶段组成呢？</span></p></div><ul class="ne-ul"><li id="d6bb60278de18caf92d0d38d880517e3"><span class="ne-text">系统设计阶段：确定系统的具体实现方案</span></li><li id="9f284ffd2d8474dffec7ced586f34e58"><span class="ne-text">结构设计阶段：确定软件结构</span></li></ul><p id="2cbeb585f58b1631c245e39292eb3612" class="ne-p"><br></p><div class="ne-quote"><p id="81d32fbaac962fc58818774d3fdf63d7" class="ne-p"><span class="ne-text">设计原理</span></p></div><p id="33600484e6ffb5faea327d78d9c85c16" class="ne-p"><strong><span class="ne-text">模块</span></strong><span class="ne-text">是由边界元素限定的相邻程序元素（数据说明，可执行的语句）的序列，而且有一个总体标识符代表它</span></p><p id="58244961575f89e6b5f1ed76b954aa59" class="ne-p"><br></p><p id="a22ea39919ca56b42645b301fc737f9b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608815946283-167d2edb-f25b-45de-ade4-6041bddf45c2.png" width="347" id="LdPtL" class="ne-image"></p><p id="aa02840ac5fcd121ad83406d7093cab2" class="ne-p"><br></p><p id="ecf87b630b701c6cb6656f8779ea3bfc" class="ne-p"><br></p><p id="9105c9d8f9cb15172cb19cc4903aefb5" class="ne-p"><span class="ne-text">模块之间的</span><strong><span class="ne-text">独立程度</span></strong><span class="ne-text">有两个标准来度量，分别是：</span></p><p id="5b4f0e2d137cd16a71cbcce9a0321030" class="ne-p"><br></p><p id="f88789e8c34c9ebbd8db4b66488ee0f5" class="ne-p"><span class="ne-text">耦合：度量</span><strong><span class="ne-text">模块间</span></strong><span class="ne-text">的互相依赖程度</span></p><p id="6e2424863e29b1c1adf1d771db288b8d" class="ne-p"><br></p><p id="f7122c2837080727dd4bd2bb54054327" class="ne-p"><span class="ne-text">内聚：度量</span><strong><span class="ne-text">模块内部元素间</span></strong><span class="ne-text">的结合程度</span></p><p id="760f6c8b5cd58d68df12050c14aeaf8a" class="ne-p"><br></p><p id="e852b73d15289a8fc8fcd3824c3f8bd0" class="ne-p"><strong><span class="ne-text">尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合</span></strong></p><p id="b04f602a43611d629c8ffd9a6f20f0a3" class="ne-p"><br></p><p id="f6bdd7d8c49ec62f7bb77db48f63f55b" class="ne-p"><span class="ne-text">7种内聚优劣评分：功能内聚（10分）偶然内聚（0分）</span></p><p id="12859f61a93111253568308a59c23924" class="ne-p"><br></p><p id="bcba68641f66e8a8fad0ce7c1aae5e58" class="ne-p"><br></p><div class="ne-quote"><p id="0a164888fc073692c379e2f485f972d0" class="ne-p"><span class="ne-text">描绘软件结构的图形工具</span></p></div><ul class="ne-ul"><li id="cf54a5d7bfc71c75141f3081e5952a5e"><span class="ne-text">层次图（树状）和HIPO图（带编号的层次图）</span></li><li id="9c69e26cd9190ae3fff35df02c5e1a06"><span class="ne-text">结构图</span></li></ul><p id="462482eb0d23638902d6e635ccdbd5ac" class="ne-p"><br></p><div class="ne-quote"><p id="0455dfb17ed7f2cc85a0be9dcb6c65dd" class="ne-p"><span class="ne-text">面向数据流的设计方法</span></p></div><p id="fec262227f248cb37fc0c92964752881" class="ne-p"><span class="ne-text">概念：面向数据流的设计方法就是把信息流映射成软件结构，同时信息流的结构决定了映射的方法</span></p><ul class="ne-ul"><li id="f4370e4bd0d5beba8545faf6c09b9ab3"><span class="ne-text">变换流</span></li><li id="cb85574b913dd2d3e35009f0141d0098"><span class="ne-text">事务流</span></li><li id="e147a27045b2a8b3a5c09febdeda30a3"><span class="ne-text">设计过程</span></li></ul><p id="9a483d7fc338d13110695847ddf5ccc6" class="ne-p"><br></p><h3 id="DbbUV"><span class="ne-text">详细设计</span></h3><div class="ne-quote"><p id="443d467214e52b2b1c698b72d8659de2" class="ne-p"><span class="ne-text">结构程序设计</span></p></div><p id="1fe118dce6b49fb0cddd673ba252f346" class="ne-p"><span class="ne-text">只用3种控制结构就能实现任何单入口单出口的程序，这三种结构分别是顺序结构、选择结构、循环结构</span></p><p id="f763b9eb74869fad77139fab87bf7fb6" class="ne-p"><br></p><div class="ne-quote"><p id="bfd7aaf9bd228397f640fd8a3022f1a8" class="ne-p"><span class="ne-text">人机界面设计的设计问题有：</span></p></div><ul class="ne-ul"><li id="9ced93a1317b97f85376e9c449904fc2"><span class="ne-text">系统响应时间</span></li><li id="a3d9dcb8fa2155170cd8b6eecb47c11f"><span class="ne-text">用户帮助实施</span></li><li id="e7b3ce822219911bc89cc0fef1644ed8"><span class="ne-text">出错信息处理</span></li><li id="3d0c3d8df2b1eb6650b2006fdfff5a5c"><span class="ne-text">命令交互</span></li></ul><p id="e4555c640ff81385e9791a398d81dfa8" class="ne-p"><br></p><div class="ne-quote"><p id="c02606096e3a4ac9ead29edffbf0a34c" class="ne-p"><span class="ne-text">人机界面设计的设计指南：</span></p></div><ul class="ne-ul"><li id="a1bd29ae07ab96fab323785d20c5bc67"><span class="ne-text">一般交互指南</span></li><li id="de06e4d07e2ace5bacb4fca1d03b0e9d"><span class="ne-text">信息显示指南</span></li><li id="19a9595dd58f8d9b71367ea2ae38b752"><span class="ne-text">数据输入指南</span></li></ul><p id="9071298852c9231623309cd766a7109e" class="ne-p"><br></p><div class="ne-quote"><p id="30fb3c25eb3a86cbc11061b3230db105" class="ne-p"><span class="ne-text">过程设计的工具【重要】</span></p></div><ol class="ne-ol"><li id="b025b96e652e9bf3a6aaccd0ce217480"><span class="ne-text">程序流程图</span></li><li id="5ef4caaceb7524873bbe5fa273100774"><span class="ne-text">盒图（N-S图）</span></li><li id="c41e532c02b61ed188a0e90289f32928"><span class="ne-text">PAD图</span></li><li id="2879ff7ca86a0d5993f8aad5de8b0a19"><span class="ne-text">判定表</span></li><li id="53e72a38aaadb5e6796a71d4250677eb"><span class="ne-text">判定树</span></li><li id="b4537a54d484d6e6f06b17bd781635cf"><span class="ne-text">过程设计语言</span></li></ol><p id="837fcba8267b78744a3425b4876abf79" class="ne-p"><br></p><div class="ne-quote"><p id="f0c4583917dcbdd1b1e498760cbea0a3" class="ne-p"><span class="ne-text">面向数据结构的设计方法</span></p></div><p id="aad5708860dabaed2e66051c5e502278" class="ne-p"><strong><span class="ne-text">两个最著名的方法为：Jackson方法和Warnier方法</span></strong></p><p id="81bdd1af3843b105d53d661dd93f0921" class="ne-p"><br></p><div class="ne-quote"><p id="2eeafbb284efe2526ff2f088288915dc" class="ne-p"><span class="ne-text">Jackson方法</span></p></div><p id="de6c848630baecfc322c9ae676e817ef" class="ne-p"><span class="ne-text">只有顺序、选择、重复三种结构</span></p><p id="8fa8c35706c506788ea92fd019f18f3a" class="ne-p"><br></p><p id="ff05530cb6b0944032a3318da99c61b9" class="ne-p"><span class="ne-text">要会用伪代码表示</span></p><p id="ede4aaecbb95bdab786cea0c294e455a" class="ne-p"><br></p><div class="ne-quote"><p id="2a8f8ba9267e31fb85ac50d19e5d395b" class="ne-p"><span class="ne-text">程序复杂程度的定量度量有McCabe方法和Halstead方法，只介绍前者</span></p></div><ol class="ne-ol"><li id="b83ce80d9e0e4d850d28f5342ab0b5af"><span class="ne-text">流图（给出伪代码画流图）</span></li><li id="33daebeb3ded5c6b1dc06e20ef95602e"><span class="ne-text">计算环形复杂度的方法</span></li></ol><h3 id="bZDiQ"><span class="ne-text">实现</span></h3><p id="ud66084d2" class="ne-p"><span class="ne-text">实现 = 编码 + 调试</span></p><p id="u6361cd37" class="ne-p"><br></p><p id="u9921e41a" class="ne-p"><span class="ne-text">实际过程中，调试所花费的时间远大于编码的时间</span></p><h3 id="s1Bnl"><span class="ne-text">维护</span></h3><hr id="WKC4w" class="ne-hr"><p id="u28c37437" class="ne-p"><br></p><h2 id="ebErT"><span class="ne-text">二、面向对象方法学</span></h2><p id="973562448df5e3b289545e92949add7c" class="ne-p"><br></p><p id="98d76573c00e18bed3152076eca61ff1" class="ne-p"><span class="ne-text">由三部分组成：分析，设计，实现</span></p><p id="u361bafd9" class="ne-p"><br></p><h2 id="nBd4i"><span class="ne-text">三、软件项目管理</span></h2><p id="11788720156d1924889182831224b54a" class="ne-p"><br></p><p id="7d4a8b3d1acc1ca0f23cfb44f4f8f668" class="ne-p" style="text-indent: 2em"><span class="ne-text">本章节探讨的是实际</span><strong><span class="ne-text">软件项目管理</span></strong><span class="ne-text">的相关工作，软件项目管理是软件项目一经启动就开始实施的一系列工作，其首先需要探讨的就是软件项目的相关估算，具体的有</span><strong><span class="ne-text">软件规模的估算、工作量的估算</span></strong><span class="ne-text">和</span><strong><span class="ne-text">完成项目估算</span></strong><span class="ne-text">，由上述的估算再对其进行制定一套完整的</span><strong><span class="ne-text">进度计划方案</span></strong><span class="ne-text">和</span><strong><span class="ne-text">人员组织方案</span></strong><span class="ne-text">，在整个项目过程中，还需要动态的</span><strong><span class="ne-text">软件配置管理</span></strong><span class="ne-text">，最后还介绍了</span><strong><span class="ne-text">软件质量的保证</span></strong><span class="ne-text">和</span><strong><span class="ne-text">软件能力成熟度模型</span></strong><span class="ne-text">这两个软件完成收尾的相关概念。</span></p><p id="ua95ab332" class="ne-p"><br></p><p id="uf6e13592" class="ne-p" style="text-indent: 2em"><span class="ne-text">作者想要解决软件危机相关问题，具体而言就印证“后人哀之而不鉴之，亦是后人而复哀后人也”这句古话，所以一套系统的软件项目管理出来了。</span></p><p id="4ac9099fefb47413fb631ebb746249fe" class="ne-p"><br></p><h3 id="FhYVU"><span class="ne-text">估算工作</span></h3><p id="dcb4c6036ec315e999b7a26b7d081a80" class="ne-p"><strong><span class="ne-text">估算软件规模</span></strong><span class="ne-text">有两种方法：代码行估算和功能点估算</span></p><p id="c6fd79aa347b5f525d17a0fe5a310686" class="ne-p" style="text-indent: 2em"><span class="ne-text">代码行技术就是利用代码的行数来进行估算的，会根据几个有经验的工作者利用一个公式来进行估算（最小可能的规模+最大可能的规模+最可能的规模）/6，得到的结果有两种，第一种是规模小的时候，单位行，第二种是规模大的时候，单位是千行。</span></p><p id="bb218ba9a4af03e7895ad913e7f1b505" class="ne-p" style="text-indent: 2em"><span class="ne-text">功能点技术就比较复杂了，它涉及到五个相关信息域特征的概念，分别是输入项数，输出项数，查询项数，主文件数，外部接口项数，再利用一系列步骤公式得到这个软件的功能点估算，最后得到的是功能点数FP。</span></p><p id="9291bc14cf0a3023f7c41a7bb1b0a87a" class="ne-p" style="text-indent: 2em"><span class="ne-text">具体可以参考：</span><a href="https://wiki.mbalib.com/wiki/%E5%8A%9F%E8%83%BD%E7%82%B9%E4%BC%B0%E7%AE%97%E6%B3%95" data-href="https://wiki.mbalib.com/wiki/%E5%8A%9F%E8%83%BD%E7%82%B9%E4%BC%B0%E7%AE%97%E6%B3%95" target="_blank" class="ne-link"><span class="ne-text">功能点估算法 | MBA智库</span></a></p><p id="27a02b83c7c038ac03a549a49a114ae6" class="ne-p"><strong><span class="ne-text">估算工作量</span></strong><span class="ne-text">有三种方法</span></p><p id="b30bb9c6aa59761a4c3ac94a95118e6c" class="ne-p" style="text-indent: 2em"><span class="ne-text">构造的函数模型的有静态单变量模型、动态多变量模型、COCOMO2模型这三种模型，得到的结果单位是人月（pm）。     </span></p><p id="cd402b4625b2321063e188b743e6c109" class="ne-p" style="text-indent: 2em"><span class="ne-text">静态单变量是基于上一个估算软件规模得出的代码行/功能点结果这一个变量函数，有一些相应的前人总结的公式</span></p><p id="f904977abee7508fbf5daa2232d161c8" class="ne-p" style="text-indent: 2em"><span class="ne-text">多变量模型，顾名思义，多个变量不止一个变量，有项目持续时间，特殊技术因子，生产率参数，也有相应的函数，可以去查查。</span></p><p id="1a033da3ccb58b79378792b75c9c643f" class="ne-p" style="text-indent: 2em"><span class="ne-text">COCOMO2模型 略、</span></p><p id="bd97fa8750217c45735f37b01d6d38cf" class="ne-p"><strong><span class="ne-text">估算开发时间</span></strong></p><p id="ff704fb3f91505dfb86d4220d8be62b5" class="ne-p" style="text-indent: 2em"><span class="ne-text">利用上一步骤得到的所估算的工作量，有一系列模型将工作量的值带进去就会得到相应的开发时间值。书中介绍了Walston_Felix、原始的COCOMO模型、COCOMO2模型、Putnam模型。</span></p><hr id="UiY8s" class="ne-hr"><h3 id="antpi"><span class="ne-text">制定进度计划表/图</span></h3><p id="fbffa6431b00ef3f008b9c92cccb0901" class="ne-p" style="text-indent: 2em"><span class="ne-text">得到开发时间，然后就是根据人员人员数量的资源来自定计划，有两种可视化方法：</span></p><p id="a8a8cca474ca2a750020a9d9595f5b7e" class="ne-p" style="text-indent: 2em"><span class="ne-text">第一种就是</span><strong><span class="ne-text">Gantt图</span></strong><span class="ne-text">：典型的异于流水作业的一种方法，动态调配人员来完成工作</span></p><p id="8a678f2ae91dc2521139b950aff125f2" class="ne-p" style="text-indent: 2em"><span class="ne-text">第二种就是</span><strong><span class="ne-text">工程网络</span></strong><span class="ne-text">：用箭头和圆圈来表示整个项目流程，优于Gantt图的就是能够实际根据实际项目中的潜力任务来跟踪观察，具体说就是有些任务可能在实际过程中，用原先指定的时间或人员不一定能高效完成，逾期或是提前很久完成等等这种情况。</span></p><p id="66ebe5fc24301b3cd8a4865483c6bb54" class="ne-p" style="text-indent: 2em"><span class="ne-text">工程网络功能可以估算工程的进度，在工程网络里面加上一些时间数字，可以灵活地查看并计算工程的计划时间。</span></p><p id="66839487d9df2505cbc30bc1d9ebc2d9" class="ne-p" style="text-indent: 2em"><span class="ne-text">工程网络还可以计算出机动时间。</span></p><p id="99f725f16a892be5dfbf5ffb4463f611" class="ne-p" style="text-indent: 2em"><span class="ne-text">其实在实际过程中，这两种方法都是并用的。</span></p><hr id="Z5TGx" class="ne-hr"><h3 id="uXQqO"><span class="ne-text">人员组织</span></h3><p id="u2901f8b4" class="ne-p"><span class="ne-text">人员组织在所经历的阶段中，经过多次变革，书中介绍有，最初的民主制程序员组👉主程序员</span></p><p id="52bb8c3b5ff106c6af3409409567c823" class="ne-p"><span class="ne-text">组👉现代程序员组</span></p><p id="75444e66e94cc38829277c056c2b460b" class="ne-p" style="text-indent: 2em"><span class="ne-text">只介绍现代程序员组，其实这个在历史中也分两种，第一种是根据职能不同分成两个组长，这种方式不能根治这过程中的软件危机，不详细讲述，第二种就是现在常说的项目经理管理下调配的，项目经理管多个组长，各个组长管理下面的多个程序员，并且，在组长与组长之间可以进行该层的交流，程序员层也一样，但是项目经理就是在该项目中的天花板了，没人管得了……</span></p><hr id="9JKVX" class="ne-hr"><h3 id="cTc7h"><span class="ne-text">软件配置管理、质量保证、能力成熟度模型</span></h3><p id="97b9eb0ea70dcea85baa6783d3b9c090" class="ne-p" style="text-indent: 2em"><span class="ne-text">这三个就是项目管理过程中一些概念之类的，其中软件配置管理讲究动态二字，因为随着时间抑或是用户需求的推移，软件配置势必会改变，这时候就需要即时更新相应配置</span></p><p id="04943293cbad84bafed42068304ddd16" class="ne-p" style="text-indent: 2em"><span class="ne-text">后两者是对软件完成的收尾相关工作了。</span></p><p id="uea81367b" class="ne-p"><br></p><p id="8ca165ef34fd3139501918978b84a812" class="ne-p"><br></p><p id="53bd320562154be3fa996c5b0f326ccd" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理知识点回顾</title>
      <link href="/blog/pnf49g/"/>
      <url>/blog/pnf49g/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><p id="8ad03590f73c34d275dfefb0c8e25d8a" class="ne-p"><span class="ne-text">利用一些基本的问题简单回顾一下这学期学的计组的基本知识点。</span></p></div><h2 id="MTQew"><span class="ne-text">概论</span></h2><div class="ne-quote"><p id="31d14279500463f7b782d82a1e4c75ea" class="ne-p" style="text-align: left"><span class="ne-text">电子数字计算机和电子模拟计算机的区别是什么？</span></p></div><p id="80f953469f71f4acc35b6630fa82d40f" class="ne-p" style="text-align: left"><span class="ne-text">电子数字计算机处理的信息是</span><strong><span class="ne-text">离散</span></strong><span class="ne-text">的，运算过程是离散的</span></p><p id="u0e03442d" class="ne-p" style="text-align: left"><span class="ne-text"></span></p><p id="443d32daf3b1bddb7c83d1b6d9425fac" class="ne-p" style="text-align: left"><span class="ne-text">电子模拟计算机处理的信号时</span><strong><span class="ne-text">连续</span></strong><span class="ne-text">的，运算过程是连续的</span></p><div class="ne-quote"><p id="edf4419af9927be6045773d9ca7a81e3" class="ne-p"><span class="ne-text">冯诺依曼计算机的特点是什么？其中最主要的一点是什么？</span></p></div><ol class="ne-ol"><li id="e2c29bb8a0409b4fe70c80a62181f253"><span class="ne-text">计算机由运算器、控制器、存储器、输入系统、输出系统</span><strong><span class="ne-text">五大部件</span></strong><span class="ne-text">组成（注意中央处理器是运算器和控制器的合称）</span></li><li id="374b9714d18be902ffd47d5abe513b94"><span class="ne-text">计算机内部由</span><strong><span class="ne-text">二进制编码</span></strong><span class="ne-text">指令和数据</span></li><li id="28b1ea0a9b7fab2e68dd14e628fc90e7"><span class="ne-text">将编好的数据和程序</span><strong><span class="ne-text">先放</span></strong><span class="ne-text">入存储器中，然后</span><strong><span class="ne-text">再启动</span></strong><span class="ne-text">计算机工作</span></li></ol><p id="c563b5321c8c4f9c9fe197d941f31d8c" class="ne-p"><br></p><p id="c6543040bbeda2deb8a0af5bcedbfad5" class="ne-p"><span class="ne-text">其中最主要的一点是第三点最主要！</span></p><h2 id="qiJfo"><span class="ne-text">数据的机器层次表示</span></h2><div class="ne-quote"><p id="9ce13ff84e9d3693974d273aad1b3f55" class="ne-p"><span class="ne-text">机器数的原码+反码+补码表示</span></p></div><p id="879c1e9515c98cc016b56c7e4493ca39" class="ne-p"><span class="ne-text">定点小数表示：阶码：小数点位数；尾数：在小数那里编码即可</span></p><p id="5da2b7534817403b242f7d9195016ef7" class="ne-p"><br></p><p id="86633fcf0244c9dd6ce3495f9cca8ddb" class="ne-p"><span class="ne-text">真值就是加正负所表现出来的</span></p><p id="357642719f8c68765b7df7a5421d34bf" class="ne-p"><br></p><div class="ne-quote"><p id="31eb1926fc3ea63fbb02fc712d0e54cb" class="ne-p"><span class="ne-text">给定计算机字长位数，知道各种情况下表示数值的范围</span></p></div><p id="c4ad836da807b205d6a6bb9b8594cda6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608863188017-8f6c8d66-710e-4880-8559-af59c6e37609.png" width="657.5" id="eaL0T" class="ne-image"></p><h2 id="YkVpK"><span class="ne-text">数值的机器运算</span></h2><div class="ne-quote"><p id="70123f476bc78a3897b756f6f2fd43d6" class="ne-p"><span class="ne-text">定点加减运算+判断结果是否溢出</span></p></div><ol class="ne-ol"><li id="b0920e9899d1e1bc286b45928ce10e93"><span class="ne-text">先写出两个数的补码（减法运算转换为加法运算即可）</span></li><li id="1777aeedda9391f96f2c10deb07df8f0"><span class="ne-text">然后进行二进制加法运算（遵循0+0=0，1+0=1，0+1=1，1+1=10向高位进位）</span></li><li id="87f1fdc8d85cb9d95fec626a2efa745f"><span class="ne-text">判断是否溢出【00：结果为正无溢出；01：正溢；10：负溢；11结果为负无溢出】</span></li><li id="122017f46b9bf7758f2a588f69ed49f8"><span class="ne-text">将[X+Y]补转换为[X+Y]真值</span></li></ol><div class="ne-quote"><p id="2ef8f2b15fa3f9a073b674d99b970ba2" class="ne-p"><span class="ne-text">定点乘法运算：原码一位乘法运算+补码一位乘法运算</span></p></div><p id="0905019b3ac25e330eb8feef29036281" class="ne-p"><span class="ne-text">原码一位乘法运算：</span></p><ol class="ne-ol"><li id="d4d3ac15c729c249277feca190144110"><span class="ne-text">先写出X和Y的绝对值|X|和|Y|</span></li><li id="f8b036cbfdbaf1be9896cee854b5d763"><span class="ne-text">让00.0……和|X|相加同时判断|Y|的最后一位（如果为1加|X|如果是0加0）</span></li><li id="1cc1be5ff7baa72b2b507ba296e33772"><span class="ne-text">加完之后右移一位，再判断，加了再判断，啥时候那个分隔符分没了，就好了……………</span></li><li id="0d20e618c0a38ecdb5808ea9b029ab8f"><span class="ne-text">最后判断真值符号</span></li></ol><p id="77b252cc036615a7948c6810cc3b4447" class="ne-p"><span class="ne-text">我写的个啥………………逃</span></p><p id="a12331a3fab11218e635d2837ea8382a" class="ne-p"><br></p><p id="c6e155cc91fa478a383e70393598fedb" class="ne-p"><span class="ne-text">补码一位乘法运算：</span></p><ol class="ne-ol"><li id="7188fa67760f6d1f9b9c2d8260604f68"><span class="ne-text">写出[X]补[-X]补[Y]补</span></li><li id="6470ab89f1179721d5f9a8d15771b337"><span class="ne-text">在[Y]补码尾巴后面加一个0，判断最后两位，（00加0；10加</span><span class="ne-text">[-X]补；01加</span><span class="ne-text">[X]补；11加0</span><span class="ne-text">）</span></li><li id="3bde37c7e803f097305188c472459c36"><span class="ne-text">让00.000……加上上面判断的加上某某</span></li><li id="9454f72239a79d3729dc6db38c4a7fbe"><span class="ne-text">又一直这样下去下去……</span></li><li id="eb2cb9a8e55705a195ed5c9a731b2e7e"><span class="ne-text">把补码换成原码即可……</span></li></ol><p id="0106ebfe35adb04961dfb580e8437c6c" class="ne-p"><span class="ne-text">…………逃🤣</span></p><h2 id="1GunN"><span class="ne-text">指令系统</span></h2><div class="ne-quote"><p id="f5ed26763e16575fce31eb067819e736" class="ne-p" style="text-align: left"><span class="ne-text">什么叫主程序和子程序？调用子程序还可以采用哪几种方法保存返回地址？画出图说明调用子程序的过程。</span></p></div><p id="204a01cee0bd9b479833edc5cf5f7815" class="ne-p"><span class="ne-text">主程序：</span><strong><span class="ne-text">通常</span></strong><span class="ne-text">的程序</span></p><p id="241dd345798400ab5c67846097f12a7d" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="7bb09abafb177f3d2e953ac0efee5ef0" class="ne-p"><span class="ne-text">子程序：可以被反复调用、</span><strong><span class="ne-text">公用</span></strong><span class="ne-text">的程序，只要知道其</span><strong><span class="ne-text">入口地址</span></strong><span class="ne-text">，就可以调用之，其就是我们编程常写的函数</span></p><p id="b7675f618d31c01265ce25e12799f835" class="ne-p"><br></p><p id="e619bbac62c03e91eec987482d66157d" class="ne-p"><span class="ne-text">保存返回地址的方法：</span></p><ul class="ne-ul"><li id="42c608e25ee0488f2036f9314d9bdb36"><span class="ne-text">子程序的第一个</span><strong><span class="ne-text">子单元</span></strong><span class="ne-text">存放返回地址，然后从第二个字单元开始执行子程序</span></li><li id="37347f7860837462c02c24acf3f3acf8"><strong><span class="ne-text">寄存器</span></strong><span class="ne-text">存放</span></li><li id="5143570db311f33bc33658bf07a5c836"><strong><span class="ne-text">堆栈</span></strong><span class="ne-text">保存</span></li></ul><p id="d7f843db66f7e3d41f618eff3dc0cd8e" class="ne-p"><br></p><p id="e75a14f7160c60c7b700722a62349832" class="ne-p"><span class="ne-text">以堆栈保存返回地址的方法来说明调用子程序的过程：</span></p><p id="31405bd4340cb931a268ad1d7c5a4891" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608774330112-3e8bf3df-1091-4476-aa72-e9757e36a3e6.png" width="121" id="DF2GZ" class="ne-image"></p><div class="ne-quote"><p id="0bc9ae1fd9a06faefeef0492f7a546e9" class="ne-p"><span class="ne-text">如果某计算机调用子程序保存返回地址是上个问题的第一种方式，有这么几个问题：</span></p><ol class="ne-ol"><li id="fc1c868b1d3d81dd3fbd1bee778f62fd"><span class="ne-text">为这种方法设计一条从子程序转到主程序的返回指令</span></li><li id="0f2527e29c21f249548270f9a9ae0e96"><span class="ne-text">怎么在主程序和子程序之间进行传参</span></li><li id="36da0b43e2c23abb4b0e983e8f2c0c64"><span class="ne-text">可否用于子程序嵌套</span></li><li id="e7c2acec70b8fa57e42bdb4ca00a1de3"><span class="ne-text">可否用于子程序的递归</span></li><li id="4456529a4550141fcc599297b99334ef"><span class="ne-text">如果将该种方式改为第三种方式（堆栈方式），可否完成4</span></li></ol></div><ol class="ne-ol"><li id="2e1a3644ca845a6843fa8ee430780c81"><span class="ne-text">使用间接寻址方式</span></li></ol><p id="5b9e53296660beb156de5733c5da00b8" class="ne-p"><br></p><table id="2LYD7" class="ne-table" style="width: 912px"><tbody><tr style="height: 33px"><td width="304"><p id="816d21bd9c047ae4c49e5e033acac4a3" class="ne-p"><span class="ne-text">JMP</span></p></td><td width="304"><p id="b2e6b668ff1b9a9aa2c080e617e79de4_p_0" class="ne-p"><span class="ne-text">@</span></p></td><td width="304"><p id="a6e5e54fbd1a6a759ab4854adf387653_p_0" class="ne-p"><span class="ne-text">子程序首地址</span></p></td></tr></tbody></table><p id="19c173f676918d5da2d46703e15279e8" class="ne-p"><br></p><ol start="2" class="ne-ol"><li id="54263ce76ba764aeed91a9dfd54179d9"><span class="ne-text">可以利用寄存器或主存单元进行主、子程序间的参数传递</span></li><li id="b39dfb2b472800cb73eaef4a900e063c"><span class="ne-text">可以。返回的地址都放在子程序的第一个单元</span></li><li id="d3c8d5784ace5ed7c57897a1f8813c8f"><span class="ne-text">不可以。会破坏其内部结构</span></li><li id="5f702ef8ca222ad8cc0785dfca37759e"><span class="ne-text">可以。因为堆栈具有后进先出功能</span></li></ol><p id="c3d1751a96104ce576139282d838ca49" class="ne-p"><br></p><h2 id="SfjVG"><span class="ne-text">存储系统和结构</span></h2><div class="ne-quote"><p id="852ba6465f7286d6d69e3e2a10645446" class="ne-p"><span class="ne-text">如何区别存储器和寄存器？两者是一回事说法对吗？</span></p></div><p id="5fa952249ec83ac207a68223fd81fa3b" class="ne-p"><span class="ne-text">两者不是一回事。</span></p><p id="1c4e1d918a0b5dd1d5cd044b77043aa2" class="ne-p"><br></p><p id="fa47cd5ab7e43727a8671f6dcf693692" class="ne-p"><span class="ne-text">存储器是在</span><strong><span class="ne-text">CPU</span></strong><span class="ne-text">外边，用来存放数据和程序的，访问存储器的</span><strong><span class="ne-text">速度</span></strong><span class="ne-text">较慢；</span></p><p id="964d621dbb3f7a14565847f8787e0a0e" class="ne-p"><br></p><p id="a9b67f5dc531f3d148c75330767a08b3" class="ne-p"><span class="ne-text">寄存器数据CPU的一部分，访问寄存器的速度很快。</span></p><p id="cfb35d68ff524d04f1d7e765fac7a3c3" class="ne-p"><strong><span class="ne-text"></span></strong></p><div class="ne-quote"><p id="970947708aa151c237982f1afa409466" class="ne-p"><span class="ne-text">存储器的主要功能是什么？为什么把存储系统分成若干个不同层次？主要有那些层次？</span></p></div><p id="5caee85a402367e1707bf7235206b371" class="ne-p"><span class="ne-text">存储器的主要功能：存储数据和程序</span></p><p id="3f22f2a92b8fa4d7aef6ca88fd3143e7" class="ne-p"><br></p><p id="693872a58a506ecd748a075f12a33320" class="ne-p"><span class="ne-text">存储系统是有几个</span><strong><span class="ne-text">容量、速度、价格</span></strong><span class="ne-text">不同的存储器用硬件、软件、软硬件相结合起来的系统。分成若干个不同层次是因为考虑到不同存储器的价格因素、存储速度、存储容量三个因素。</span></p><p id="938a3900f42a61a964c49b0b8249e88d" class="ne-p"><br></p><ol class="ne-ol"><li id="dfc059d62bf5c064acdf25c194e89fbf"><span class="ne-text">高速缓存</span></li><li id="0d30099b072f94de5275190001870ce1"><span class="ne-text">主存</span></li><li id="f3fd3872a2030a914118032cb8879955"><span class="ne-text">辅存</span></li></ol><p id="0d36a4aa9c21de3a1f06c05887169957" class="ne-p"><br></p><p id="f9cff4010943d46fc8f00055d1ba95ef" class="ne-p"><span class="ne-text">其中12又称之为Cache-主存存储层次，23又称之为主存-辅存存储层次。</span></p><p id="6db556996c11f57a93040fa86544ce8a" class="ne-p"><br></p><div class="ne-quote"><p id="da18244217f0e6449790e6b1e28ee017" class="ne-p"><span class="ne-text">动态RAM为什么要刷新？一般有几种刷新方式？各有什么优缺点？</span></p></div><p id="54f00e02a63ab155c031bab9ada01c49" class="ne-p"><strong><span class="ne-text">为了维持DRAM的记忆单元的存储信息</span></strong></p><ul class="ne-ul"><li id="51369c4ec0bf4fbc746761810e0194b2"><strong><span class="ne-text">集中式</span></strong><span class="ne-text">刷新</span></li></ul><p id="f6a95914f2cfa71fd460e179cc771d20" class="ne-p"><span class="ne-text">优点：</span><strong><span class="ne-text">读写操作</span></strong><span class="ne-text">不受刷新工作的影响，</span><strong><span class="ne-text">存取速度</span></strong><span class="ne-text">高</span></p><p id="2f52e97ee9aa2445d61a8f62e81e1a40" class="ne-p"><br></p><p id="4c9f9dba696547423f74fd21d535cea1" class="ne-p"><span class="ne-text">缺点：存储容量越大，死区越长</span></p><ul class="ne-ul"><li id="7e617547b2ede92904e6e2dde8d1d3e7"><strong><span class="ne-text">分散式</span></strong><span class="ne-text">刷新</span></li></ul><p id="138316dc28b0c6e1e058fb29f04b1645" class="ne-p"><span class="ne-text">优点：没有死区</span></p><p id="218df8daebc9aa27392a1275a2eb4d13" class="ne-p"><br></p><p id="3b066343f56c3d85c5daa4e7af6741ee" class="ne-p"><span class="ne-text">缺点：加长了系统的</span><strong><span class="ne-text">存取周期</span></strong><span class="ne-text">，降低了整机的速度，并且刷新过于频繁，没有充分利用允许的最大刷新间隔</span></p><ul class="ne-ul"><li id="e35570a707be389e1f302033802d59c4"><strong><span class="ne-text">异步式</span></strong><span class="ne-text">刷新</span></li></ul><p id="a79792d9af9ffb369cd0cdcc59e0077d" class="ne-p"><span class="ne-text">异步式虽然有死区，但是比几种方式的</span><strong><span class="ne-text">死区小</span></strong><span class="ne-text">得多，而且</span><strong><span class="ne-text">减少了刷新次数</span></strong><span class="ne-text">，是比较实用的一种刷新方式。</span></p><p id="9e71039ca057d47c358f523ef0fd073a" class="ne-p"><br></p><h2 id="ITNcC"><span class="ne-text">中央处理器</span></h2><hr id="pj8gk" class="ne-hr"><div class="ne-quote"><p id="bcea3ec07206330004e2e3789c35ce09" class="ne-p"><span class="ne-text">控制器有哪几种控制方式？各有何特点？</span></p></div><ul class="ne-ul"><li id="069dd81db3936611fadcb15177e7d127"><strong><span class="ne-text">同步</span></strong><span class="ne-text">控制方式</span></li></ul><p id="fa54d530d058750d622b4c3f37d24d21" class="ne-p"><span class="ne-text">该控制方式各项操作都由统一的</span><strong><span class="ne-text">时序信号</span></strong><span class="ne-text">完成，并且在每个及其周期中产生统一的</span><strong><span class="ne-text">节拍电位和工作脉冲</span></strong><span class="ne-text">。这种方式设计简单，但是对于许多</span><strong><span class="ne-text">单指令</span></strong><span class="ne-text">来说，有太多的</span><strong><span class="ne-text">空闲时间</span></strong><span class="ne-text">，造成时间浪费，影响指令执行速度。</span></p><p id="07a4c5c2f6d132046518ad852d64ee7b" class="ne-p"><br></p><ul class="ne-ul"><li id="bbf515908cf3b84af7a41726dd1cfd1a"><strong><span class="ne-text">异步</span></strong><span class="ne-text">控制方式</span></li></ul><p id="d42c82b6ae1e7c98d3963038b6a1d464" class="ne-p"><span class="ne-text">该控制方式的各项操作都</span><strong><span class="ne-text">不由统一的时序信号</span></strong><span class="ne-text">完成，而是由指令本身或部件的具体情况决定，因此这种控制方式的效率高，时间能够合理利用，但是该控制方式也比较复杂。</span></p><p id="8a31a2411880accf26ba0334f49c72d0" class="ne-p"><br></p><ul class="ne-ul"><li id="54addc15f4395432239c5e127c4d33ec"><strong><span class="ne-text">联合</span></strong><span class="ne-text">控制方式</span></li></ul><p id="320df0179f596617b456951d7fc84d82" class="ne-p"><span class="ne-text">是由上面的同步控制方式和异步控制方式相结合的方式。</span></p><hr id="ZCrzr" class="ne-hr"><div class="ne-quote"><p id="89a2449ce0c4197c43b444f796c1a242" class="ne-p"><span class="ne-text">什么是三级时序系统？</span></p></div><p id="49334fc101fddb224f33914c5dd9c5d8" class="ne-p"><span class="ne-text">三级时序系统是指</span><strong><span class="ne-text">机器周期</span></strong><span class="ne-text">、</span><strong><span class="ne-text">节拍</span></strong><span class="ne-text">、</span><strong><span class="ne-text">工作脉冲</span></strong></p><p id="875d1d3a314a7947327aaaea9fccc003" class="ne-p"><br></p><p id="f051d98d24e8baf2b6ded9588bdae088" class="ne-p"><span class="ne-text">具体所属关系是：每个指令周期划分若干个机器周期，每个机器周期划分若干个节拍，每个节拍划分1个或几个工作脉冲。</span></p><hr id="HdIYa" class="ne-hr"><div class="ne-quote"><p id="545a4d1e85ebc11216d7299cf1133dfe" class="ne-p"><span class="ne-text">控制器有哪些基本功能？可分为哪几类？分类的依据是什么？</span></p></div><p id="cce468c294e11bad12e47b9429c69724" class="ne-p"><span class="ne-text">基本功能：</span></p><ul class="ne-ul"><li id="e3d0f91ef261179e42dfe616ba162512"><span class="ne-text">从主存中</span><strong><span class="ne-text">取出一条指令</span></strong><span class="ne-text">，并指出下一跳指令在主存中的位置</span></li><li id="917bd76d7485df150900a43755bf4ba2"><span class="ne-text">对指令进行</span><strong><span class="ne-text">译码或是测试</span></strong><span class="ne-text">，产生相应的操作控制信号，以便启动规定的工作</span></li><li id="a8fc5203632cb27284271c21f2fa09f0"><span class="ne-text">指挥并控制</span><strong><span class="ne-text">CPU</span></strong><span class="ne-text">，主存和输入输出设备之间的</span><strong><span class="ne-text">数据流动</span></strong></li></ul><p id="bed058693632f901f735bc5da78143b9" class="ne-p"><span class="ne-text">分类：</span></p><ul class="ne-ul"><li id="c539818b0a659b32407bb6ce0137f27a"><strong><span class="ne-text">组合逻辑</span></strong><span class="ne-text">型</span></li><li id="a9e8c918340cda1890553998780dbf20"><strong><span class="ne-text">存储逻辑</span></strong><span class="ne-text">型</span></li><li id="358a09680fbf3e00fdd45e35532b7ab5"><span class="ne-text">组合逻辑和存储逻辑</span><strong><span class="ne-text">结合</span></strong><span class="ne-text">型</span></li></ul><p id="22bfbaa2cbc6d8e4ff6d944cf683fa37" class="ne-p"><span class="ne-text">分类的依据：</span></p><p id="b95bdd01da2c3f224d79acd9d2575986" class="ne-p"><span class="ne-text">在于控制器的核心——</span><strong><span class="ne-text">微操作信号发生器的实现方法不同</span></strong><span class="ne-text">。</span></p><hr id="AaWg1" class="ne-hr"><div class="ne-quote"><p id="17f72232f2b1d5d97e0b1b9129cc987f" class="ne-p"><span class="ne-text">中央处理器有哪些功能？它是由那些基本部件构成的？</span></p></div><p id="e829c3e1520460b7e850f1288194b22f" class="ne-p"><span class="ne-text">构成：</span></p><ul class="ne-ul"><li id="cdac7027e772b3f3feb39658f4a7d544"><span class="ne-text">控制器</span></li><li id="bd2c6cf87849f07ef7000902847f1d0f"><span class="ne-text">运算器</span></li></ul><p id="4bdc50e6020643b565ed4bed5e3eee70" class="ne-p"><span class="ne-text">功能：</span></p><p id="a83025c5146a2600186b1edf659481d4" class="ne-p"><span class="ne-text">对数据流和指令流在时间上和空间上进行正确的控制。当然，对于冯诺依曼结构的计算机而言，数据流是基于指令流的操作而驱动的。</span></p><hr id="wZckO" class="ne-hr"><div class="ne-quote"><p id="b484dd2533aee804ce4b287497a435e9" class="ne-p"><span class="ne-text">中央处理器有哪几个主要寄存器？说说他们的结构和功能？</span></p></div><p id="77ba3dd412afabc7e9e503fc88442709" class="ne-p"><span class="ne-text">寄存器的功能就是用来存放程序运行过程中的中间结果、最终结果以及控制、状态信息的。</span></p><ul class="ne-ul"><li id="e13f8067776706b09322783c9c0827d3"><span class="ne-text">通用寄存器</span></li></ul><p id="c48ace8dd6a28c243eae640aff6c0130" class="ne-p"><span class="ne-text">用来存放原始数据和运算结果，有的还可以作为变址寄存器、计数器、地址指针等</span></p><ul class="ne-ul"><li id="2e7e0367e7370abbed35ebf62171d1bf"><span class="ne-text">专用寄存器</span></li></ul><p id="138e2900bb45f1c63a9789a37eab3c6a" class="ne-p"><span class="ne-text">是用来完成某些特定功能的寄存器：程序计数器（PC）、指令寄存器（IR）、存储器地址寄存器（MAR）、存储器数据寄存器（MDR）、程序状态字寄存器（PSWR）等</span></p><p id="669386b2f97c3ec049c32cc82ef9fb5a" class="ne-p"><br></p><div class="ne-quote"><p id="c4523aba7842fae72ae515c3f02e563e" class="ne-p"><span class="ne-text">以单指令为例，简要说明下列部件在计算机的取值周期和执行周期的作用。</span></p></div><ul class="ne-ul"><li id="1e201c5462e561a5857105d079538b16"><span class="ne-text">程序计数器（PC）：存放指令地址</span></li><li id="64ccffe53e1a34cb1afcf5ba6d7065ef"><span class="ne-text">指令寄存器（IR）：存放当前指令</span></li><li id="1fd6998aba727f19794915a8f481c016"><span class="ne-text">存储器地址寄存器（MAR）：进行算术逻辑运算</span></li><li id="d08be2ebbadaf994c98d0614e4089b5c"><span class="ne-text">存储器数据寄存器（MDR）：存放写入或读出的数据/指令</span></li><li id="c0a63d3a0b6ef0ddecda83aca430f580"><span class="ne-text">程序状态字寄存器（PSWR）：存放写入或读出的数据/指令的地址</span></li></ul><hr id="pnGgF" class="ne-hr"><div class="ne-quote"><p id="3c8ab0d3ddc3cd6174c3324ec8e0255d" class="ne-p"><span class="ne-text">什么是指令周期？什么是CPU周期？他们之间有什么关系？</span></p></div><p id="eea0bee762845c5dda2546a1ab1cda0b" class="ne-p"><span class="ne-text">指令周期：指</span><strong><span class="ne-text">取指令</span></strong><span class="ne-text">、</span><strong><span class="ne-text">分析指令</span></strong><span class="ne-text">到</span><strong><span class="ne-text">执行指令</span></strong><span class="ne-text">所花费的所有时间</span></p><p id="2a66bfbbbb1d05b8957fa4ab4c013bbf" class="ne-p"><br></p><p id="dcd2fcd80d5598b99b9470ecc5855f99" class="ne-p"><span class="ne-text">CPU周期：也叫</span><strong><span class="ne-text">机器周期</span></strong><span class="ne-text">，是指完成一个基本操作所花费的时间</span></p><p id="17bed01c4b7b0d346941e5a5450d04d8" class="ne-p"><span class="ne-text">一个指令周期划分为多个CPU周期</span></p><hr id="yXu0E" class="ne-hr"><h2 id="K6voT"><span class="ne-text">【总线+外部设备】nothing</span></h2><h2 id="dmz3A"><span class="ne-text">输入输出系统</span></h2><hr id="AFwJf" class="ne-hr"><div class="ne-quote"><p id="2d329cb51b5a202823a61a48ed8448fd" class="ne-p"><span class="ne-text">什么是计机的输入输出系统？输入输出设备有哪些编址方式？有什么特点？</span></p></div><p id="edefd57ab69af8470668ff2a424356a1" class="ne-p"><span class="ne-text">输入输出系统：包括输入输出</span><strong><span class="ne-text">接口</span></strong><span class="ne-text">和输入输出信息</span><strong><span class="ne-text">传送</span></strong><span class="ne-text">控制方式，是计算机系统中最具有</span><strong><span class="ne-text">多样性</span></strong><span class="ne-text">和</span><strong><span class="ne-text">复杂性</span></strong><span class="ne-text">的部分。</span></p><p id="f9fc8ac6291156b3f05b224fd32bf2ed" class="ne-p"><br></p><p id="ab87944d3ce6f7a51fefd1953f5351d9" class="ne-p"><span class="ne-text">编址方式：</span></p><ul class="ne-ul"><li id="2707ef199b4f1e9984f5b26de524424b"><strong><span class="ne-text">独立编址</span></strong></li></ul><p id="fabc1c5bddd0b669a0124171c4db4f1a" class="ne-p"><span class="ne-text">优点：指令易于区分，译码简单，主存空间不会减少</span></p><p id="d563ec5ff4b439085cb9ab1601704308" class="ne-p"><br></p><p id="0cc8b5d976bbc529e4debeb63ec9d40b" class="ne-p"><span class="ne-text">缺点：增加了控制线I/ORead和I/OWrite信号</span></p><ul class="ne-ul"><li id="27da5029a93cb3f29a4b7ddd5149a335"><strong><span class="ne-text">统一编址</span></strong></li></ul><p id="db0394b2e9cbdd8e060cbcef65b95726" class="ne-p"><span class="ne-text">优点：总线结构简单，全部访存类指令都可用于控制外设，可直接对外设寄存器进行各种运算</span></p><p id="c9ec0f4c81c14859d4f616d21c82d21a" class="ne-p"><br></p><p id="d0d4cb0e5308de9987cc3b8cf6f2cc15" class="ne-p"><span class="ne-text">缺点：占用主存一部分地址，缩小了可用的主存空间</span></p><hr id="muQ6M" class="ne-hr"><div class="ne-quote"><p id="b22a986de3efd0a5b8efa407e847f202" class="ne-p"><span class="ne-text">什么是I/O接口？I/O接口有哪些特点和功能？接口有哪些类型？</span></p></div><p id="98a2cf08c7c301f2ab0aba9ea1fd7cd0" class="ne-p"><span class="ne-text">主机和外设之间的交接界面</span></p><p id="83a9756d9dc7e015d8768506f919ec9b" class="ne-p"><br></p><p id="4333b6c723d94f845b3a5614e3095f64" class="ne-p"><span class="ne-text">特点：</span></p><p id="b712a5be993fb88c5d4d62baea0b6f6f" class="ne-p"><span class="ne-text">实现信息交换</span></p><p id="544d1cc53d23366b107405a2ea8f7bb0" class="ne-p"><br></p><p id="0cc25be04a53a0c916aac101aba94675" class="ne-p"><span class="ne-text">功能：</span></p><ul class="ne-ul"><li id="5c723efbc9ebbf5520e009a67bc22003"><span class="ne-text">实现主机和外设的通信联络控制</span></li><li id="b6fea9d4ef882ec6551e95c5b93c35cc"><span class="ne-text">进行地址译码和设备选择</span></li><li id="4720e6750b9905bf1076f2a89350bad0"><span class="ne-text">实现数据缓冲</span></li><li id="1af433d251035ab2181cbd62799cc149"><span class="ne-text">完成数据格式的变换</span></li><li id="d3b797cf76b8bb289949ce0cf39c04f7"><span class="ne-text">传递控制命令和状态信息</span></li></ul><p id="48b588f728fe021b99967853961b8497" class="ne-p"><span class="ne-text">类型：</span></p><ul class="ne-ul"><li id="21882bf923e3234f90da98bf2614405e"><span class="ne-text">串行接口</span></li><li id="8175ce14a9e0743c683ef38001d276a7"><span class="ne-text">并行接口</span></li></ul><p id="4a6b52ff999522ae3c33345921945361" class="ne-p"><br></p><hr id="trvup" class="ne-hr"><p id="77cc6dc8295348d4c2f8d497aa36ea99" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608728980150-18e3d2ee-cc80-4187-b38c-14c78554e979.png" width="589" id="xIuDJ" class="ne-image"></p><p id="ee38f7a51426771d7c16bea8a84cea26" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729028676-c983dd94-3689-431d-bf54-76bbb5b01f75.png" width="394" id="auSQX" class="ne-image"></p><p id="617d7abbbc2b6c009ce7716456731744" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729049887-aee5cd74-e49d-44d1-88b2-bcdc511ff3c3.png" width="484" id="jcRjZ" class="ne-image"></p><p id="306325c19a7a2f3a0d213b5f5e4fee4f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729065956-47dc5b50-caaa-44a1-a54e-8e3f5ae2192a.png" width="343.5" id="mPHNN" class="ne-image"></p><p id="399fce97c541358e15ec13808166372b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729081886-f27d6175-e541-4379-b158-0093a23b693d.png" width="461" id="oRfmo" class="ne-image"></p><p id="6bfd4491ff863d27832ff22b4c2c8283" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729097801-61fd270b-1608-48ab-b1fa-a951febba5d6.png" width="453.5" id="yeoZf" class="ne-image"></p><p id="f4b79ef71832f8c5a407ba8be18261a4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729108461-95f5d6e5-efd6-4acf-a2c7-fb72f6052d25.png" width="448.5" id="cRak4" class="ne-image"></p><p id="8896d7b3ea160b9a6486690e87021da2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729131667-e6955db4-4b2c-4efb-ad1f-3acf8ccc5e48.png" width="487" id="Y7pz1" class="ne-image"></p><p id="449b7cd92863b968e08149ab77db3031" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729144873-1a207e20-98d9-4e44-b40e-c1a81a54b667.png" width="484" id="VOGan" class="ne-image"></p><p id="cf52e2046f0c6701e6ccd82a088c7b2a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729157489-b3899992-00d9-405b-8f02-9619f08d9960.png" width="469" id="evibg" class="ne-image"></p><p id="65832d59e9fafe63982b5add438c52ac" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729176250-7499ab5f-2a40-4514-92f3-afc46c739936.png" width="502.5" id="MLKi5" class="ne-image"></p><p id="0234382e72464867bc7bd05cba0e3ce4" class="ne-p"><br></p><p id="120b5003507e6a34cb6f0c259cd54f7f" class="ne-p"><br></p><p id="2011e3c76f08a21c0746f4bc94d537a7" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VuePress初体验</title>
      <link href="/blog/czl3oc/"/>
      <url>/blog/czl3oc/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="ozvnV"><span class="ne-text">安装Yarn</span></h2><div class="ne-quote"><p id="9f230f3078dda28f9190829db7cf14f5" class="ne-p"><span class="ne-text">Yarn 是为了弥补 npm 的一些缺陷而生的</span></p></div><p id="18f7bf9e434b2aa7bf34c07f048c0400" class="ne-p"><span class="ne-text">具体参考：</span><a href="https://zhuanlan.zhihu.com/p/27449990" data-href="https://zhuanlan.zhihu.com/p/27449990" target="_blank" class="ne-link"><span class="ne-text">https://zhuanlan.zhihu.com/p/27449990</span></a></p><h3 id="sUZiq"><span class="ne-text">引导式安装</span></h3><p id="308b0baf1ce6d0c44024f8c422ab9c07" class="ne-p"><a href="https://classic.yarnpkg.com/zh-Hans/docs/install#windows-stable" data-href="https://classic.yarnpkg.com/zh-Hans/docs/install#windows-stable" target="_blank" class="ne-link"><span class="ne-text">下载地址</span></a></p><p id="e9f75a338ae8719f5690c2481f765c56" class="ne-p"><span class="ne-text">使用Windows版的下载安装即可</span></p><p id="4f0292a57b73306d20fdb988adeb8053" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608540352757-ed3ef592-f042-4262-9378-42aa9d053fcd.png" width="216.5" id="cUHeI" class="ne-image"></p><h3 id="HmpLs"><span class="ne-text">bash安装</span></h3><p id="45d24035c8269d64a7dec4fd942e155f" class="ne-p"><span class="ne-text">在bash里面不能显示，在bash里面下载</span></p><p id="f0590a47339cb2f102ce3a00b82f4f8e" class="ne-p"><code class="ne-code"><span class="ne-text">npm install -g yarn</span></code><span class="ne-text"> 即可</span></p><h2 id="BAmwf"><span class="ne-text">将 VuePress 安装为本地依赖</span></h2><h3 id="hTgJ6"><span class="ne-text">yarn init</span></h3><p id="2138ae8db26c8146a6b1ba44f50470ed" class="ne-p"><span class="ne-text">yarn init 出错</span></p><pre data-language="bash" id="ndRuV" class="ne-codeblock language-bash">error An unexpected error occurred: "Can't answer a question unless a user TTY". info If you think t</pre><p id="a5a86f73bd4bb824ef123a24a7d72df7" class="ne-p"><br></p><p id="c930e64598c0fab55a88f896ba724116" class="ne-p"><strong><span class="ne-text">使用cmd或者power shell不要使用bash</span></strong></p><p id="254831a44128efb65c0596eafc3d2e1e" class="ne-p"><br></p><h3 id="y9C7f"><span class="ne-text">yarn add -D vuepress</span></h3><p id="d5bd5357c4ae3e4a21e8e621cc185459" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541125538-3124ff43-0574-4bfd-a290-908621b54644.png" width="960" id="wwNV3" class="ne-image"></p><h3 id="CfmJf"><span class="ne-text">创建一篇文章</span></h3><p id="57df215360093e1966f8fc3f2b635a57" class="ne-p"><span class="ne-text">在bash创建，在powershell里面创建会报错</span></p><pre data-language="bash" id="NEG00" class="ne-codeblock language-bash">mkdir docs && echo '# Hello VuePress' > docs/README.md</pre><p id="616f3cc2b927ab5cce32e0b7c3e04b61" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541380531-3ad1565f-0eef-4dac-bebf-64d1a131d7f3.png" width="580" id="RwhmG" class="ne-image"></p><h3 id="7N75d"><span class="ne-text">添加脚本</span></h3><pre data-language="json" id="N7wL8" class="ne-codeblock language-json">{<p>“name”: “my-site”,<br>“version”: “1.0.0”,<br>“main”: “index.js”,<br>“license”: “MIT”,<br>“devDependencies”: {<br>“vuepress”: “^1.7.1”<br>},<br>“scripts”: {<br>“docs:dev”: “vuepress dev docs”,<br>“docs:build”: “vuepress build docs”<br>}<br>}</p><p></pre><h3 id="D36sT"><span class="ne-text">运行</span></h3><p id="f29d4b5825726ddeecc7b678467b47c8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541418296-b53b29dc-f6a9-480f-b65d-009a21c0d013.png" width="475.5" id="YrVlg" class="ne-image"></p><p id="0657fe2ea1293fafb661fb2b837f9bbf" class="ne-p"><span class="ne-text">端口访问：</span><a href="http://localhost:8080/" data-href="http://localhost:8080/" target="_blank" class="ne-link"><span class="ne-text">http://localhost:8080/</span></a></p><p id="b08fb81c68f3ededd960aa218a6dc28d" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]低谷</title>
      <link href="/essay/vpzzbr/"/>
      <url>/essay/vpzzbr/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><blockquote class="ne-quote"><p class="ne-p" style="text-align: left"><span class="ne-text">不要害怕低谷，这是上天给你的升级时间</span></p><p class="ne-p" style="text-align: left"><span class="ne-text">有个好玩的现象，我这里的畅销书，绝大多数是在作者低谷的时候写出来的。比如创业失败、被公司裁员、或者身体不好在家休息等等。</span></p><p class="ne-p" style="text-align: left"><span class="ne-text"></span></p><p class="ne-p" style="text-align: left"><span class="ne-text">为什么呢？因为事业上升时，人被事情推着走，每天忙忙碌碌，没有一块时间思考和复盘。</span></p><p class="ne-p" style="text-align: left"><span class="ne-text">进入低谷后，时间充足，可以好好整理思想了，把以前的经验体系化，于是一本畅销书横空出世。更重要的是，这本书已成为他的视野催化剂，走向人生的第二巅峰。</span></p><p class="ne-p" style="text-align: left"><span class="ne-text"></span></p><p class="ne-p" style="text-align: left"><span class="ne-text">低谷不可怕，可怕的是一蹶不振啊。</span></p><p class="ne-p" style="text-align: left"><span class="ne-text"></span></p><p class="ne-p" style="text-align: left"><strong><span class="ne-text">转载自：写书哥（同微博）</span></strong></p></blockquote></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS的高级使用技巧</title>
      <link href="/blog/rpd10b/"/>
      <url>/blog/rpd10b/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建“文本三巨头”环境</title>
      <link href="/blog/yhxiep/"/>
      <url>/blog/yhxiep/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="MX2J5"><span class="ne-text">Vim</span></h2><h3 id="UeIzT"><span class="ne-text">Vim下载安装</span></h3><ul class="ne-ul"><li id="u37b51cda"><span class="ne-text"></span><a href="https://www.vim.org/download.php" data-href="https://www.vim.org/download.php" target="_blank" class="ne-link"><span class="ne-text">下载地址</span></a></li></ul><p id="fd7db94422d09137b510c85a8f048e85" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357192619-ac3d093e-c4e4-49fa-9a3b-8ead607b2160.png" width="959.5" id="RDX6X" class="ne-image"></p><p id="2449b5f125868070febf7be6f42fcab4" class="ne-p"><span class="ne-text">下载完之后next安装即可</span></p><h3 id="LeFv1"><span class="ne-text">Vim环境变量配置</span></h3><p id="2d8a275cd1370075d6c93754c5bfe8a4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357482468-e6a53bc3-991d-4eda-aa2e-c5643b9617b0.png" width="301" id="PYvNp" class="ne-image"></p><p id="098d2d74bb7ca4f594cdacaa29a6ded2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357463679-c00baef1-4e21-4405-8e79-f65afabe0370.png" width="488" id="RNNXe" class="ne-image"></p><h3 id="YO0FX"><span class="ne-text">测试</span></h3><p id="5f1be856ce1788c351c271daabb249dc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357601712-bc8f6f5b-6038-4358-8699-a7201ce8223e.png" width="734" id="yrzYQ" class="ne-image"></p><p id="67778d17505fe26067423a65e21cc36a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357572830-fd4043b2-f02a-4c32-b9e7-677c4918ec19.png" width="721" id="gVyaq" class="ne-image"></p><p id="8b603cfeea4571802722e72d2bb3ba71" class="ne-p"><br></p><h2 id="6BZUj"><span class="ne-text">zsh</span></h2><h3 id="5elC9"><span class="ne-text">安装Linux子系统</span></h3><p id="1287f4331cd3cf96803fad048a9fdaeb" class="ne-p"><span class="ne-text">查看之前写的文章：</span><a href="https://www.wztlink1013.com/blog/xnh83z/" data-href="https://www.wztlink1013.com/blog/xnh83z/" target="_blank" class="ne-link"><span class="ne-text">搭建Windows子系统Linux - 尼采般地抒情</span></a></p><h3 id="GSwqQ"><span class="ne-text">安装ConEmu</span></h3><p id="2269ccbd077f3fb5114a7175f53939eb" class="ne-p"><a href="https://www.fosshub.com/ConEmu.html" data-href="https://www.fosshub.com/ConEmu.html" target="_blank" class="ne-link"><span class="ne-text">https://www.fosshub.com/ConEmu.html</span></a></p><p id="bfab0f338cb60686ecb2f0ae6f3878f9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358847174-3a3b7ba1-45e8-4951-a943-debd2a09de43.png" width="952" id="JLc7g" class="ne-image"></p><p id="2ebcb0025b41d5882e1342b644cbb602" class="ne-p"><span class="ne-text">设置如下：</span></p><p id="824e1177a6f2cef5e494d9af45775d2b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358926353-c172728f-978e-47f7-9ec5-34472219ccdb.png" width="571.5" id="jMLUr" class="ne-image"></p><p id="32d37a369121314e27dda5bbebc813c3" class="ne-p"><span class="ne-text">确定后会进入以下界面</span></p><p id="0152db9904699107b9ad4429273bc13c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358964494-c12c30a4-4b04-4463-b3d6-3c5fc21b607f.png" width="485" id="aXzWd" class="ne-image"></p><h3 id="x8iJh"><span class="ne-text">安装并配置zsh</span></h3><p id="aeb676b2c219ea91b35677d9de82d04c" class="ne-p"><span class="ne-text">进入页面 </span><code class="ne-code"><span class="ne-text">sudo apt-get install -y zsh</span></code><span class="ne-text"> ，输入密码：</span></p><p id="e43bdbe7ea45caf308a48dc8a305c670" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608359167583-80d5f5fd-77e6-417d-ac0c-279dbfb55776.png" width="480" id="tPJV7" class="ne-image"></p><p id="2e682f65e859273cd4350c083d006f4e" class="ne-p"><span class="ne-text">安装成功界面如下：</span></p><p id="7edf269ca8eba2bd4c536a050301f018" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608360612991-863a5a2e-77a2-4bd7-b1b9-4ef6a79dcb86.png" width="954" id="CG6aU" class="ne-image"></p><h3 id="3aliR"><span class="ne-text">安装oh-my-zsh</span></h3><p id="e102b11293393af801ac79b473c4b0c4" class="ne-p"><span class="ne-text">sh -c "$(curl -fsSL </span><a href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)%22" data-href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)%22" target="_blank" class="ne-link"><span class="ne-text">https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"</span></a></p><p id="bbbdc71fc02899370ca618bc6bbd7e92" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608360763102-d6886d61-c954-4c15-adfc-ca42c0daf337.png" width="954" id="rLLx0" class="ne-image"></p><p id="d41909239673e72a3b22acf5d4e178b4" class="ne-p"><span class="ne-text">上述文件夹在这里： </span><code class="ne-code"><span class="ne-text">C:\Users\wztli\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\home\wztlink1013</span></code></p><h2 id="R79BF"><span class="ne-text">tmux</span></h2><h3 id="G5qPr"><span class="ne-text">安装运行</span></h3><p id="c06eec7d1d903a65c9492f40534fda91" class="ne-p"><span class="ne-text">Ubuntu系统命令行界面输入： </span><code class="ne-code"><span class="ne-text">sudo apt install tmux</span></code></p><p id="cde2dbaf7bb9d5d1a7e0454459c73752" class="ne-p"><br></p><p id="618b9ad9be8a1fd257d9b1a1215c079a" class="ne-p"><span class="ne-text">在Ubuntu系统输入并执行"tmux"命令，会进入tmux窗口</span></p><h2 id="kMBv5"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="6cb9d18d408a2264bfbcc4b6dcc20f16"><a href="https://www.jianshu.com/p/5f7b83ca3952" data-href="https://www.jianshu.com/p/5f7b83ca3952" target="_blank" class="ne-link"><span class="ne-text">https://www.jianshu.com/p/5f7b83ca3952</span></a></li><li id="e7ee5cc06385fadf6576551109990cf8"><a href="https://post.smzdm.com/p/a5k6e033/" data-href="https://post.smzdm.com/p/a5k6e033/" target="_blank" class="ne-link"><span class="ne-text">https://post.smzdm.com/p/a5k6e033/</span></a></li><li id="d4c1f36e4129f6867e6453ee35ef630d"><a href="https://blog.csdn.net/qq_2300688967/article/details/81774297" data-href="https://blog.csdn.net/qq_2300688967/article/details/81774297" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/qq_2300688967/article/details/81774297</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>150.逆波兰表达式求值🔖栈</title>
      <link href="/blog/ewoap5/"/>
      <url>/blog/ewoap5/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="vi7Gj"><span class="ne-text">问题分析</span></h2><p id="eb6bae56e307e499aa83c1b2931e1693" class="ne-p"><span class="ne-text">对所给字符串进行遍历，遇到数字字符就压入栈stack内，遇到+-*/符号就pop处栈的两个元素，进行该字符运算处理</span></p><p id="u854f3b3d" class="ne-p"><span class="ne-text"></span></p><h2 id="gnNEL"><span class="ne-text">代码实现</span></h2><pre data-language="java" id="sx7ex" class="ne-codeblock language-java">package com.wztlink1013.problems.leetcode.editor.cn;<p>// P150.逆波兰表达式求值<br>// P150.evaluate-reverse-polish-notation<br>//根据 逆波兰表示法，求表达式的值。<br>//<br>// 有效的运算符包括 +, -, <em>, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>//<br>//<br>//<br>// 说明：<br>//<br>//<br>// 整数除法只保留整数部分。<br>// 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。<br>//<br>//<br>//<br>//<br>// 示例 1：<br>//<br>// 输入: [“2”, “1”, “+”, “3”, “</em>“]<br>//输出: 9<br>//解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) _ 3) = 9<br>//<br>//<br>// 示例 2：<br>//<br>// 输入: [“4”, “13”, “5”, “/“, “+”]<br>//输出: 6<br>//解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6<br>//<br>//<br>// 示例 3：<br>//<br>// 输入: [“10”, “6”, “9”, “3”, “+”, “-11”, “<em>“, “/“, “</em>“, “17”, “+”, “5”, “+”]<br>//输出: 22<br>//解释:<br>//该算式转化为常见的中缀算术表达式为：<br>// ((10 _ (6 / ((9 + 3) _ -11))) + 17) + 5<br>//= ((10 _ (6 / (12 _ -11))) + 17) + 5<br>//= ((10 _ (6 / -132)) + 17) + 5<br>//= ((10 _ 0) + 17) + 5<br>//= (0 + 17) + 5<br>//= 17 + 5<br>//= 22<br>//<br>//<br>//<br>// 逆波兰表达式：<br>//<br>// 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。<br>//<br>//<br>// 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) _ ( 3 + 4 ) 。<br>// 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) _ ) 。<br>//<br>//<br>// 逆波兰表达式主要有以下两个优点：<br>//<br>//<br>// 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + _ 也可以依据次序计算出正确结果。<br>// 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。<br>//<br>// Related Topics 栈<br>// 👍 213 👎 0</p><p>import java.util.Stack;</p><p>public class P150EvaluateReversePolishNotation{<br>public static void main(String[] args) {<br>Solution solution = new P150EvaluateReversePolishNotation().new Solution();<br>String[] tokens_1 = {“10”, “6”, “9”, “3”, “+”, “-11”, “<em>“, “/“, “</em>“, “17”, “+”, “5”, “+”};<br>int temp = solution.evalRPN(tokens_1);<br>System.out.println(temp);</p><pre><code>&#125;</code></pre><p>//leetcode submit region begin(Prohibit modification and deletion)<br>class Solution {<br>public int evalRPN(String[] tokens) {<br>Stack<String> stack = new Stack&lt;&gt;();</p><pre><code>    String temp = &quot;0&quot;;    stack.push(temp);    for (String token : tokens) &#123;        int sum = 0;        if (token.equals(&quot;+&quot;)) &#123;            sum += Integer.parseInt(stack.pop()) + Integer.parseInt(stack.pop());            String str = String.valueOf(sum);            stack.push(str);        &#125; else if (token.equals(&quot;-&quot;)) &#123;            int i = Integer.parseInt(stack.pop());            int j = Integer.parseInt(stack.pop());            sum += j-i;            String str = String.valueOf(sum);            stack.push(str);        &#125; else if (token.equals(&quot;*&quot;)) &#123;            sum += Integer.parseInt(stack.pop()) * Integer.parseInt(stack.pop());            String str = String.valueOf(sum);            stack.push(str);        &#125; else if (token.equals(&quot;/&quot;)) &#123;            int i = Integer.parseInt(stack.pop());            int j = Integer.parseInt(stack.pop());            sum += j / i;            String str = String.valueOf(sum);            stack.push(str);        &#125; else &#123;            stack.push(token);        &#125;    &#125;    int result = Integer.parseInt(stack.pop());    return result;&#125;</code></pre><p>}<br>//leetcode submit region end(Prohibit modification and deletion)</p><p>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo-部署出错at formatNunjucksError</title>
      <link href="/blog/gw1d4z/"/>
      <url>/blog/gw1d4z/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="ZHzbx"><span class="ne-text">报错信息</span></h2><p id="5938fb2fe1d4c56c4604990ca6c24af9" class="ne-p"><span class="ne-text">GitHub Actions 流程中 hexo g 出现错误，具体错误在“Vue笔记”中那篇文章中，有个地方用到了大括号嵌套的情况。</span></p><p id="u1514b961" class="ne-p"><span class="ne-text"></span></p><pre data-language="bash" id="aWgBi" class="ne-codeblock language-bash">    =====             Context Dump Ends            =====<pre><code>at formatNunjucksError (/home/runner/work/website/website/node_modules/hexo/lib/extend/tag.js:102:13)at Promise.fromCallback.catch.err (/home/runner/work/website/website/node_modules/hexo/lib/extend/tag.js:124:34)at tryCatcher (/home/runner/work/website/website/node_modules/bluebird/js/release/util.js:16:23)at Promise._settlePromiseFromHandler (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:547:31)at Promise._settlePromise (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:604:18)at Promise._settlePromise0 (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:649:10)at Promise._settlePromises (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:725:18)at _drainQueueStep (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:93:12)at _drainQueue (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:86:9)at Async._drainQueues (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:102:5)at Immediate.Async.drainQueues [as _onImmediate] (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:15:14)at runCallback (timers.js:705:18)at tryOnImmediate (timers.js:676:5)at processImmediate (timers.js:658:5)</code></pre><p>Error: Process completed with exit code 2.</pre><h2 id="jey7n"><span class="ne-text">问题分析与解决</span></h2><p id="f32587a18e5fbb9076f47fa248dea0ba" class="ne-p"><span class="ne-text">上述代码中第二行其实已经说的很明确 </span><code class="ne-code"><span class="ne-text"> at formatNunjucksError</span></code></p><p id="ca6c3ba87a6e808b7ce9caba49cbcd21" class="ne-p"><span class="ne-text">但是 hexo 中，渲染过程中用到的是 Nunjucks，在</span><span class="ne-text">Nunjucks 中双大括号被视为语法，所以报错。</span></p><p id="5c64b985804966a5f0cae8668252b7a6" class="ne-p"><br></p><h2 id="dGlTA"><span class="ne-text">小记</span></h2><p id="4ff02731522488c525e38c80355b3636" class="ne-p"><a href="https://www.wztlink1013.com/blog/pxpix4/" data-href="https://www.wztlink1013.com/blog/pxpix4/" target="_blank" class="ne-link"><span class="ne-text">https://www.wztlink1013.com/blog/pxpix4/</span></a></p><p id="e15627319cbf9b3a8521b96cc8107302" class="ne-p"><br></p><p id="0518438c34866821cedf6125a3d3856d" class="ne-p"><span class="ne-text">其实之前遇到过类似的问题……写的博客还是要经常回顾……</span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub多人协作功能Pull requests</title>
      <link href="/blog/iwvugw/"/>
      <url>/blog/iwvugw/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u31601118" class="ne-p"><br></p><h2 id="DCg0L"><span class="ne-text">给出一个初始场景</span></h2><p id="c0439f998a7d6e947c75a146c50f3ffd" class="ne-p"><span class="ne-text">小吴和小王同时开发一个项目project，该项目托管到GitHub上，假定该项目托管到小吴的GitHub上，小王要想同时开发这个</span><span class="ne-text">project</span><span class="ne-text">，就必须要fork小吴的这个</span><span class="ne-text">project，最后两个人GitHub仓库是这个样子的：</span></p><p id="eb9de5372fb93217c68d508889e9e4cd" class="ne-p"><span class="ne-text"></span></p><p id="c2f46a89e5d15d8ef53e3f6b2f2d4ab5" class="ne-p"><span class="ne-text">小吴：xiaowu/</span><span class="ne-text">project</span></p><p id="8aa249bbe683024034e0992fb6055a79" class="ne-p"><span class="ne-text">小王：xiaowang/</span><span class="ne-text">project</span></p><p id="8bda843a6ff64345456ade47213f08bf" class="ne-p"><span class="ne-text"></span></p><p id="24ceaa9af6e310aa231a9b483c5769b2" class="ne-p"><span class="ne-text">（需要明确一点，小吴小王各自的</span><span class="ne-text">project</span><span class="ne-text">仓库现在就相当各做各的事情了）</span></p><h2 id="1qeg2"><span class="ne-text">具体工作场景</span></h2><p id="9b038e2df868654b1a890dbd8d750bef" class="ne-p"><span class="ne-text">小王的仓库xiaowang/</span><span class="ne-text">project</span><span class="ne-text">改了代码，想要push合并到小吴的仓库</span><span class="ne-text">xiaowu/</span><span class="ne-text">project</span><span class="ne-text">中，这里分两种情况。</span></p><h3 id="DiWJ5"><span class="ne-text">第一种情况</span></h3><p id="4e893ad2c787d4a3a779a7168168092b" class="ne-p"><strong><span class="ne-text">小王在从fork小吴仓库到现在这段期间，小吴没有对</span></strong><strong><span class="ne-text">xiaowu/</span></strong><strong><span class="ne-text">project做任何改动</span></strong></p><div class="ne-quote"><p id="b9e9e81e49a159a584b0bde3013e3f5d" class="ne-p"><span class="ne-text">处理方法：直接Pull request</span></p><p id="0325da8c1804938cc8da4cbe8fae3cc8" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606915274704-123b219d-d7fe-4816-88c4-91ba11b5c466.png" width="958.5" id="e0K97" class="ne-image"></p><p id="0abe218755ef480a82419c4db86fc31f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606915405152-c1e60a93-99fb-42d5-a7a5-87c564fe53d4.png" width="960" id="Of4D4" class="ne-image"></p><p id="445cb52a29ae02f428d83bfdf1d0cdcb" class="ne-p"><span class="ne-text">可以看到1区域显示Able to merge，表明这个Pull request对于双方是没有矛盾的</span></p></div><h3 id="32QPC"><span class="ne-text">第二种情况</span></h3><p id="ec75d99a8dfa37cfc3805c5048f48b3b" class="ne-p"><strong><span class="ne-text">小王在从fork小吴仓库到现在这段期间，小吴又在</span></strong><strong><span class="ne-text">xiaowu/</span></strong><strong><span class="ne-text">project里面做了改动，就相当于小王fork过后，两个人都对各自的仓库更新了，然后小王想将自己的改动推送到小吴那里</span></strong></p><div class="ne-quote"><p id="0d2cf68d0594a424347363bcc59db400" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916524143-c5076532-2497-4923-986f-d442122e6de7.png" width="960" id="YBom8" class="ne-image"></p><p id="03ab732358a386ad99e80c772e5cceeb" class="ne-p"><strong><span class="ne-text">可以发现1处并没有那么顺利，因为产生了冲突，但是2处仍然可以新建一个request请求，先点击2</span></strong></p><p id="c6e5b226b1eefb56ff6a05488526e174" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916762342-e5215ae5-cf61-43ac-9051-f73c40de1fb1.png" width="595.5" id="F7o57" class="ne-image"></p><p id="fdf5506797d72d1ab6bb3df9f3f8e95b" class="ne-p"><strong><span class="ne-text">点击之后会这样👇</span></strong></p><p id="c229297191fc31dd9b02969a7f402804" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916826669-b406d584-50a7-49d5-9044-166bba4bc75f.png" width="642" id="D3ARz" class="ne-image"></p><p id="d5443136a0d145e87ab8b46faa73fac5" class="ne-p"><span class="ne-text">1处显示矛盾的文件（就是小吴和小王在各自的仓库都进行了更改）</span></p><p id="688d507347aaf61e5509b5ecaba3555d" class="ne-p"><span class="ne-text">我们点击2处</span></p><p id="eccad7ee02b8b3e852fabd0bdeb5418c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916998671-6b369cf8-f6dc-4ad3-ba0b-d2f7006b7804.png" width="960" id="nRTI1" class="ne-image"></p><p id="d467d8ba7db152777274f22d363c75fe" class="ne-p"><span class="ne-text">接下来解决这个问题并且点击Mark as resolved按钮就可以了</span></p><p id="cab9aefe14bc6edf1c5ffb77a5e5fb47" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917076365-e79652f9-3c56-4259-87d4-b6e979af277d.png" width="960" id="UNqSw" class="ne-image"></p><p id="74945fa4679aefd2686ac145b8c4e922" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917146702-bc316303-78f2-4746-94fa-72e4cda90dd0.png" width="960" id="jhbAg" class="ne-image"></p><p id="3ad2005353acf4f79465f5e62d5f949e" class="ne-p"><span class="ne-text">最后就会出现下面的图，接下来，小吴在他的GitHub上同意接受这个请求就可以了。（或者小王有权限小王自己接受也可以）</span></p><p id="1b6480392b24d94385471138665d6163" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917264180-37c25758-4db9-44f8-a3f6-0ca725d6c0fd.png" width="717.5" id="Z5Awy" class="ne-image"></p></div><p id="fa17e72108ac106d6ff944862bb4d411" class="ne-p"><br></p><p id="f10c012a34060aec773c9785b4f20443" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>224.基本计算器🔖栈</title>
      <link href="/blog/ckr31m/"/>
      <url>/blog/ckr31m/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="qBwwM"><span class="ne-text">问题思路</span></h2><p id="08d50083874be74117e6e22e45bdce8f" class="ne-p"><span class="ne-text">用栈来作为临时存取非括号的求和数。对字符串进行逐个遍历，然后对遇到的每个字符串进行判断</span></p><ul class="ne-ul"><li id="b5cdec04cd257aa592ef59810a4af372"><span class="ne-text">数字：将其求和到sum当中</span></li><li id="d1177edf6ed8225eddd2b90fba55cbc4"><span class="ne-text">（：将上述sum和符号压入栈内</span></li><li id="196c7a9b829fde933e3b4af76d924a5c"><span class="ne-text">）：将栈内的元素取出与现有sum求和</span></li><li id="1166e7c68cdc0bd4ed851db695c47b66"><span class="ne-text">+：直接走</span></li><li id="4ba40d6ea839a7bfbfd7dc6b53927f06"><span class="ne-text">-：直接走不过给下一个计算数提前加负号</span></li></ul><p id="ueba54000" class="ne-p"><span class="ne-text"></span></p><h2 id="UGPHv"><span class="ne-text">代码实现</span></h2><pre data-language="java" id="lAUyp" class="ne-codeblock language-java">package com.wztlink1013.problems.leetcode.editor.cn;<p>// P224.基本计算器<br>//实现一个基本的计算器来计算一个简单的字符串表达式的值。<br>//<br>// 字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格 。<br>//<br>// 示例 1:<br>//<br>// 输入: “1 + 1”<br>//输出: 2<br>//<br>//<br>// 示例 2:<br>//<br>// 输入: “ 2-1 + 2 “<br>//输出: 3<br>//<br>// 示例 3:<br>//<br>// 输入: “(1+(4+5+2)-3)+(6+8)”<br>//输出: 23<br>//<br>// 说明：<br>//<br>//<br>// 你可以假设所给定的表达式都是有效的。<br>// 请不要使用内置的库函数 eval。<br>//<br>// Related Topics 栈 数学<br>// 👍 309 👎 0</p><p>import java.util.Stack;</p><p>public class P224BasicCalculator{<br>public static void main(String[] args) {<br>Solution solution = new P224BasicCalculator().new Solution();<br>int key_1 = solution.calculate(“7896979”);<br>int key_2 = solution.calculate(“(23-2)-33+1111”);<br>System.out.println(key_1);<br>System.out.println(key_2);<br>}</p><p>//leetcode submit region begin(Prohibit modification and deletion)<br>class Solution {<br>public int calculate(String s) {<br>Stack<Integer> stack_1 = new Stack<Integer>();<br>int sum = 0;<br>int sign = 1;<br>int num = 0;</p><pre><code>    for (int i=0;i&lt;s.length();i++) &#123;        char ch = s.charAt(i);        if (Character.isDigit(ch)) &#123;            num = 10 * num + (int) (ch - &#39;0&#39;);        &#125; else if (ch == &#39;+&#39;) &#123;            num = num * sign;            sum = sum + num;            sign = 1;            num = 0;        &#125; else if (ch == &#39;-&#39;) &#123;            num = num * sign;            sum = sum + num;            sign = -1;            num = 0;        &#125; else if (ch == &#39;(&#39;) &#123;            stack_1.push(sum);            stack_1.push(sign);            sum = 0;            num = 0;            sign = 1;        &#125; else if (ch == &#39;)&#39;) &#123;            num = num * sign;            sum = sum + num;            sum = stack_1.pop() * sum;            sum = sum + stack_1.pop();            num = 0;            sign = 1;        &#125;    &#125;    sum = sum + sign * num;    return sum;&#125;&#125;</code></pre><p>//leetcode submit region end(Prohibit modification and deletion)</p><p>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sdnu-dboj-Student-Movie</title>
      <link href="/blog/zhdy1x/"/>
      <url>/blog/zhdy1x/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><p id="766f80ed9b16d637ca1bb196c489ffe8" class="ne-p"><span class="ne-text">题目入口：</span><a href="http://db.itoi.sd.cn/problem/set" data-href="http://db.itoi.sd.cn/problem/set" target="_blank" class="ne-link"><span class="ne-text">http://db.itoi.sd.cn/problem/set</span></a></p></div><h2 id="oszRU"><span class="ne-text">成绩管理相关题目</span></h2><h3 id="6sRD6"><span class="ne-text">Student表</span></h3><p id="5ccc5406745fb4adea6deee908cf8c88" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600849205116-d4263820-8bbb-4d01-b97b-a0363f4498e7.png" width="361" id="i6Mtq" class="ne-image"></p><h3 id="vpVPK"><span class="ne-text">Course表</span></h3><p id="5b3d9be708bed51611532df4586b3c55" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600849217512-41be815b-8bc4-4b6a-82c2-cbb4d335c9b9.png" width="316" id="TH7Ie" class="ne-image"></p><h3 id="EbonT"><span class="ne-text">SC表</span></h3><p id="fb17afe17cd270a297f15766c0b9a636" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600849229639-8d5cd91f-d87e-49e9-a1cd-9c563b64723f.png" width="246" id="FFiKd" class="ne-image"></p><p id="717d0a9d202baca2ab2288e4f84ab294" class="ne-p"><br></p><h3 id="Gs1JS"><span class="ne-text">初始化SQL语句</span></h3><pre data-language="sql" id="bPwcN" class="ne-codeblock language-sql">SET NAMES utf8mb4;<p>SET FOREIGN_KEY_CHECKS = 0;</p><p>/<em>学生表</em>/<br>CREATE TABLE Student<br>(<br>Sno INT(9) PRIMARY KEY,<br>Sname VARCHAR(10),<br>Ssex CHAR(2),<br>Sage TINYINT(3),<br>Sdept VARCHAR(20)<br>);<br>INSERT INTO Student<br>VALUES (201215121, ‘李勇’, ‘男’, 20, ‘CS’),<br>(201215122, ‘刘晨’, ‘女’, 19, ‘CS’),<br>(201215123, ‘王敏’, ‘女’, 18, ‘MA’),<br>(201215125, ‘张立’, ‘男’, 19, ‘IS’),<br>(201215133, ‘张三’, ‘男’, 21, ‘TE’),<br>(201215137, ‘赵四’, ‘男’, 23, ‘TE’),<br>(201215139, ‘田二’, ‘女’, 24, ‘CS’),<br>(201215140, ‘李四’, ‘男’, 21, ‘CS’),<br>(201215141, ‘郑五’, ‘女’, 22, ‘IS’);</p><p>/<em>课程表</em>/<br>CREATE TABLE Course<br>(<br>Cno INT(4) PRIMARY KEY,<br>Cname VARCHAR(40),<br>Cpno INT(4),<br>Ccredit TINYINT(3),<br>FOREIGN KEY (Cpno) REFERENCES Course (Cno)<br>);<br>INSERT INTO Course<br>VALUES (1, ‘数据库’, 5, 4),<br>(2, ‘数学’, NULL, 2),<br>(3, ‘信息系统’, 1, 4),<br>(4, ‘操作系统’, 6, 3),<br>(5, ‘数据结构’, 7, 4),<br>(6, ‘数据处理’, NULL, 2),<br>(7, ‘PASCAL 语言’, 6, 4);</p><p>/<em>选课表</em>/<br>CREATE TABLE SC<br>(<br>Sno INT(9),<br>Cno INT(4),<br>Grade SMALLINT(3),<br>PRIMARY KEY (Sno, Cno),<br>/_ 主码由两个属性构成，必须作为表级完整性进行定义_/<br>FOREIGN KEY (Sno) REFERENCES Student (Sno),<br>/_ 表级完整性约束条件，Sno 是外码，被参照表是 Student <em>/<br>FOREIGN KEY (Cno) REFERENCES Course (Cno)<br>/</em> 表级完整性约束条件， Cno 是外码，被参照表是 Course_/<br>);<br>INSERT INTO SC<br>VALUES (201215121, 1, 92),<br>(201215121, 2, 85),<br>(201215121, 3, 88),<br>(201215122, 2, 90),<br>(201215122, 3, 80),<br>(201215122, 6, 59),<br>(201215123, 1, 84),<br>(201215125, 1, 60),<br>(201215125, 3, 90),<br>(201215133, 4, 87),<br>(201215137, 2, 79),<br>(201215139, 2, 80),<br>(201215140, 2, 81);</p><p>SET FOREIGN<em>KEY_CHECKS = 1;</pre><h3 id="HrV7x"><span class="ne-text">问题代码</span></h3><pre data-language="sql" id="njGZD" class="ne-codeblock language-sql">0<br>select Sno, Sname<br>from Student<br>1<br>select Sname, Sno, Sdept<br>from Student<br>2<br>select Sname, Sno, Sdept<br>from Student<br>3<br>select distinct Sno<br>from SC<br>4<br>select distinct Sname<br>from Student<br>where Sdept='CS'<br>5<br>select Sname, Sage<br>from Student<br>where Sage<20<br>6<br>select Sno<br>from SC<br>where Grade<60<br>7<br>select Sname, Sdept, Sage<br>from Student<br>where Sage>=20 and Sage<=23<br>8<br>select Sname, Sdept, Sage<br>from Student<br>where Sage<20 or Sage>23<br>9<br>select Sname, Ssex<br>from Student<br>where Sdept='CS' or Sdept='MA' or Sdept='IS'<br>10<br>select Sname, Ssex<br>from Student<br>where Sdept not in ('CS', 'MA', 'IS')<br>11<br>select Sname, Sno, Ssex<br>from Student<br>where Sname like '刘</em>‘<br>12<br>select Sname, Sno<br>from Student<br>where Sname like ‘<em>立’<br>13<br>select Sname, Sno, Ssex<br>from Student<br>where Sname not like ‘刘</em>‘<br>14<br>select Sno, Cno<br>from SC<br>where Grade is not null<br>15<br>select Sname<br>from Student<br>where Sdept=’CS’ and Sage&lt;20<br>16<br>select Sno, Grade<br>from SC<br>where Cno=’3’<br>order by Grade desc<br>17<br>select *<br>from Student<br>order by Sdept asc, Sage desc<br>18<br>select count(Sno) as ‘COUNT’<br>from Student<br>19<br>select count(Sno) as COUNT<br>from (<br>select Sno<br>from SC<br>group by sno) as test<br>20<br>select avg(Grade) as AVG<br>from SC<br>where Cno=’1’<br>21<br>select max(Grade) as MAX<br>from SC<br>where Cno=’1’<br>22<br>select SUM(Ccredit) as SUM<br>from Course, SC<br>where Course.Cno=SC.Cno<br>and Sno=’201215121’<br>23<br>select Cno, count(Grade) as COUNT<br>from SC<br>group by Cno<br>24<br>select Sno<br>from(<br>select Sno, count(Grade) as COUNT<br>from SC<br>group by Sno<br>)as test<br>where COUNT&gt;2<br>25<br>select Sno, AVG(Grade) as AVG<br>from SC<br>group by Sno<br>having AVG(Grade)&gt;=88<br>26<br>select Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade<br>from Student inner join SC<br>on Student.Sno=SC.Sno<br>27<br>SELECT x.Cno, y.Cpno<br>FROM Course x, Course y<br>WHERE x.Cpno = y.Cno<br>28<br>select Student.Sno, Student.Sname<br>from Student, SC<br>where Student.Sno=SC.Sno<br>and SC.Cno=’2’<br>and SC.Grade&gt;80<br>29<br>select test.Sno, test.Sname, Course.Cname, test.Grade<br>from Course join<br>(select SC.Sno, SC.Cno, Student.Sname, SC.Grade<br>from Student join SC<br>on Student.Sno=SC.Sno)as test<br>on Course.Cno=test.Cno</pre><h2 id="6Emyc"><span class="ne-text">Movie 相关题目</span></h2><pre data-language="sql" id="5DJOc" class="ne-codeblock language-sql">30<br>select title<br>from movie<br>where director='Steven Spielberg'<br>31<br>select year<br>from movie<br>where mID in (<br>select mID<br>from rating<br>where stars='4' or stars='5'<br>)<br>order by year asc<br>32<br>select title<br>from movie<br>where mID not in (<br>select mID<br>from rating)<br>33<br>select name<br>from reviewer<br>where rID in (<br>select rID<br>from rating<br>where ratingDate is null)<br>34<br>select reviewer.name, test.title, test.stars, test.ratingDate<br>from reviewer join (<br>select movie.title, rating.rID, rating.stars, rating.ratingDate<br>from movie join rating<br>on movie.mID=rating.mID<br>) as test<br>on reviewer.rID=test.rID<br>order by reviewer.name, test.title, test.stars<br>35</p><p>37<br>select movie.title, rating_2.stars_avg as stars<br>from movie join (<br>select mID, AVG(stars) as stars_avg<br>from rating<br>group by mID) as rating_2<br>on movie.mID=rating_2.mID<br>order by stars desc, title<br>38<br>select name<br>from reviewer<br>where rID in(<br>select rID<br>from rating<br>group by rID<br>having COUNT(rID)&gt;=3)<br>39<br>select name<br>from reviewer<br>where rID in (<br>select distinct rID<br>from rating<br>where mID in (<br>select mID<br>from movie<br>where title=’Gone with the Wind’))<br>40<br>select temp.name as name, movie.title as title, temp.stars as stars<br>from movie join (<br>select rating.stars, reviewer.name, rating.mID<br>from rating join reviewer<br>on rating.rID=reviewer.rID) as temp<br>on movie.mID=temp.mID<br>where movie.director=temp.name</p><p></pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>509. 斐波那契数🔖递归</title>
      <link href="/blog/pmd7dz/"/>
      <url>/blog/pmd7dz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u81e6a0fb"><a href="https://leetcode-cn.com/problems/fibonacci-number/" data-href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/fibonacci-number/</span></a></li></ul><p id="u42c17be2" class="ne-p"><span class="ne-text"></span></p><h3 id="vDIhF"><span class="ne-text">ts实现</span></h3><pre data-language="typescript" id="xxRCR" class="ne-codeblock language-typescript">function fib(n: number): number {<p>if (n &lt;= 1) return n<br>return fib(n - 1) + fib(n - 2)<br>}</pre><h3 id="WHTdQ"><span class="ne-text">java 实现</span></h3><pre data-language="java" id="rmYIh" class="ne-codeblock language-java">class Solution {<br>// TODO: for 循环实现<br>public int fib(int N) {<br>if (N <= 1) return N;<br>int first = 0;<br>int second = 1;<br>for (int i = 0; i < N - 1; i++) {<br>int sum = first + second;<br>first = second;<br>second = sum;<br>}<br>return second;<br>}<br>// // TODO: 递归实现 O(2^n)<br>// public int fib1(int n) {<br>// if (n <= 1) return n;<br>// return fib1(n - 1) + fib1(n - 2);<br>// }<br>// // TODO: 首尾实现<br>// public int fib3(int n) {<br>// if (n <= 1) return n;<br>// int first = 0;<br>// int second = 1;<br>// while (n-- > 1) {<br>// second += first;<br>// first = second - first;<br>// }<br>// return second;<br>// }<br>}</pre><h3 id="Qk196"><span class="ne-text">C++实现</span></h3><pre data-language="java" id="Zt1Em" class="ne-codeblock language-java">// 递归：O(2^n)<br>public static int fib1(int n) {<br>if (n <= 1) return n;<br>return fib1(n - 1) + fib1(n - 2);<br>}</p><p>// for 循环：O(n)<br>public static int fib2(int n) {<br>if (n &lt;= 1) return n;<br>int first = 0;<br>int second = 1;<br>for (int i = 0; i &lt; n - 1; i++) {<br>int sum = first + second;<br>first = second;<br>second = sum;<br>}<br>return second;<br>}<br>// 首尾法<br>public static int fib3(int n) {<br>if (n &lt;= 1) return n;</p><pre><code>int first = 0;int second = 1;while (n-- &gt; 1) &#123;    second += first;    first = second - first;&#125;return second;</code></pre><p>}<br>// 特征方程解法：O（1）<br>public static int fib4(int n) {<br>double c = Math.sqrt(5);<br>return (int) (Math.pow((1+c) / 2, n) - Math.pow((1-c) / 2, c));<br>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>486. 预测赢家🔖数组</title>
      <link href="/blog/srvbwz/"/>
      <url>/blog/srvbwz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u65f8b50c"><a href="https://leetcode-cn.com/problems/predict-the-winner/" data-href="https://leetcode-cn.com/problems/predict-the-winner/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/predict-the-winner/</span></a></li></ul><p id="ueb9322bf" class="ne-p"><span class="ne-text"></span></p><p id="ud43caea7" class="ne-p"><span class="ne-text"></span></p><h3 id="eJk9K"><span class="ne-text">思路</span></h3><p id="u94ddd270" class="ne-p"><span class="ne-text">贪心策略不行，如果玩家每次都选相对自己当下可选择的最大值，这样的贪心策略有错误，比如这个例子：</span></p><div class="ne-quote"><p id="uc8fe1ddc" class="ne-p"><span class="ne-text">输入：nums = [1,5,233,7]</span></p><p id="u21848967" class="ne-p"><span class="ne-text">输出：true</span></p><p id="u2b002e03" class="ne-p"><span class="ne-text">解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。</span></p><p id="u77e974fa" class="ne-p"><span class="ne-text">最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 true，表示玩家 1 可以成为赢家。</span></p></div><p id="u6b4f21c1" class="ne-p"><br></p><p id="u923b8044" class="ne-p"><span class="ne-text"></span></p><h3 id="275rS"><span class="ne-text">java实现</span></h3><pre data-language="java" id="FiCRc" class="ne-codeblock language-java">class Solution {<pre><code>public boolean PredictTheWinner(int[] nums) &#123;    return total(nums, 0, nums.length - 1, 1) &gt;= 0;&#125;public int total(int[] nums, int start, int end, int turn) &#123;    if (start == end) &#123;        return nums[start] * turn;    &#125;    int scoreStart = nums[start] * turn + total(nums, start + 1, end, -turn);    int scoreEnd = nums[end] * turn + total(nums, start, end - 1, -turn);    return Math.max(scoreStart * turn, scoreEnd * turn) * turn;</code></pre><p>// if(turn == 1){<br>// return Math.max(scoreStart ,scoreEnd );<br>// }else{<br>// return Math.min(scoreStart ,scoreEnd );<br>// }<br>}<br>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>876. 链表的中间结点🔖链表</title>
      <link href="/blog/serpsb/"/>
      <url>/blog/serpsb/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ub5d113e8" class="ne-p"><br></p><h2 id="XRQoL"><span class="ne-text">876. 链表的中间结点</span></h2><ul class="ne-ul"><li id="u1161591c"><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" data-href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/middle-of-the-linked-list/</span></a></li></ul><h3 id="ADYbv"><span class="ne-text">问题描述</span></h3><p id="f851f8caacea66d5f47930ef13cbcc66" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195941092-8cd11b96-c174-425e-ab68-a7015110092e.png" width="358.5" id="QJds4" class="ne-image"></p><h3 id="wGOtu"><span class="ne-text">问题分析</span></h3><h3 id="DKSwG"><span class="ne-text">代码实现</span></h3><h4 id="VgC44"><span class="ne-text">js</span></h4><pre data-language="javascript" id="zCMOu" class="ne-codeblock language-javascript">/**<ul><li><p>Definition for singly-linked list.</p></li><li><p>function ListNode(val, next) {</p></li><li><pre><code>this.val = (val===undefined ? 0 : val)</code></pre></li><li><pre><code>this.next = (next===undefined ? null : next)</code></pre></li><li><p>}<br>*/<br>/**</p></li><li><p>@param {ListNode} head</p></li><li><p>@return {ListNode}<br>*/<br>var middleNode = function(head) {<br>let count = 0<br>let temp = head<br>while(temp) {<br>count++<br>temp = temp.next<br>}<br>for(let i = 0; i &lt; (count-1)/2; i++) {<br>head = head.next<br>}<br>return head<br>};</pre><h4 id="Oopql"><span class="ne-text">java</span></h4><pre data-language="java" id="QIrJP" class="ne-codeblock language-java">class Solution {<br>public ListNode middleNode(ListNode head) {<br>if (head.next == null) return head;<br>if (head.next.next == null) return head.next;</p><pre><code>    ListNode slow = head.next;    ListNode fast = head.next.next;    while (fast != null &amp;&amp; fast.next != null) &#123;        slow = slow.next;        fast = fast.next.next;        if (fast == null) return slow;    &#125;    return slow;&#125;</code></pre><p>}</pre><p id="8be157d580e196b77db4a526b3f96cad" class="ne-p"><br></p></div></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📎线结构：链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>83. 删除排序链表中的重复元素🔖链表</title>
      <link href="/blog/lg67md/"/>
      <url>/blog/lg67md/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ucbb649c6" class="ne-p"><br></p><pre data-language="java" id="b4Q7V" class="ne-codeblock language-java">/**<ul><li>public class ListNode {</li><li><pre><code>int val;</code></pre></li><li><pre><code>ListNode next;</code></pre></li><li><pre><code>ListNode(int x) &#123; val = x; &#125;</code></pre></li><li>}<br>*/</pre><h2 id="FAX8v"><span class="ne-text">83. 删除排序链表中的重复元素</span></h2><h3 id="DLj48"><span class="ne-text">问题描述</span></h3><p id="da0c5698221c6ef0a11fab5a5ebff8c0" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195897467-fdb33dfe-a1c0-4963-b76a-2c978f565801.png" width="363.5" id="jCb28" class="ne-image"></p><h3 id="UVrd5"><span class="ne-text">问题分析</span></h3><h3 id="mBIcW"><span class="ne-text">代码实现</span></h3><pre data-language="java" id="C8Ged" class="ne-codeblock language-java">class Solution {<br>public ListNode deleteDuplicates(ListNode head) {<br>// TODO: 快慢指针<br>if (head == null) return head;<br>ListNode slow = head;<br>ListNode fast = head.next;<br>while (fast != null){<br>if (slow.val != fast.val) {<br>slow.next = fast;<br>slow = fast;<br>}<br>fast = fast.next;<br>}<br>slow.next = null;<br>return head;<br>}<br>}<br>// TODO: 单指针下一步<br>//class Solution {<br>// public ListNode deleteDuplicates(ListNode head) {<br>// ListNode cur = head;<br>// while(cur != null && cur.next != null) {<br>// if(cur.val == cur.next.val) {<br>// cur.next = cur.next.next;<br>// } else {<br>// cur = cur.next;<br>// }<br>// }<br>// return head;<br>// }<br>//}</pre></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>203. 移除链表元素🔖链表</title>
      <link href="/blog/kgpm3x/"/>
      <url>/blog/kgpm3x/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uae85bd2a" class="ne-p"><br></p><pre data-language="java" id="b4Q7V" class="ne-codeblock language-java">/**<ul><li>public class ListNode {</li><li><pre><code>int val;</code></pre></li><li><pre><code>ListNode next;</code></pre></li><li><pre><code>ListNode(int x) &#123; val = x; &#125;</code></pre></li><li>}<br>*/</pre><h2 id="yi7xQ"><span class="ne-text">203. 移除链表元素</span></h2><h3 id="79mCM"><span class="ne-text">问题描述</span></h3><p id="d189c77098b09ec66d33802808106857" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195857807-2e8c8296-2d79-4e36-b304-f02c4dee52b3.png" width="364.5" id="GxO4N" class="ne-image"></p><h3 id="Yuuw5"><span class="ne-text">问题分析</span></h3><h3 id="qdcwo"><span class="ne-text">代码实现</span></h3><pre data-language="java" id="86HBJ" class="ne-codeblock language-java">class Solution {<br>public ListNode removeElements(ListNode head, int val) {<br>// 将整个链表想象成 head+子链表<br>if (head == null)<br>return null;<br>// 先处理子链表<br>head.next = removeElements(head.next, val);<br>// 再处理头结点<br>return head.val == val ? head.next : head;<br>}<br>}</pre></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>141. 环形链表🔖链表</title>
      <link href="/blog/fgkbg2/"/>
      <url>/blog/fgkbg2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="b41a17e84cfb91784f84ec5285c0a15f" class="ne-p"><br></p><pre data-language="java" id="b4Q7V" class="ne-codeblock language-java">/**<ul><li><p>public class ListNode {</p></li><li><pre><code>int val;</code></pre></li><li><pre><code>ListNode next;</code></pre></li><li><pre><code>ListNode(int x) &#123; val = x; &#125;</code></pre></li><li><p>}<br>*/</pre><h2 id="eU0Hv"><span class="ne-text">141. 环形链表</span></h2><h3 id="6qsAy"><span class="ne-text">问题描述</span></h3><p id="b845617b08d4e230e723d0fe77c421fb" class="ne-p"><span class="ne-text">给定一个链表，判断链表中是否有环。</span></p><p id="d5d83d8d177c68c1286e4bc279c70a22" class="ne-p"><br></p><p id="a94910678403385c503aa30e56d9059b" class="ne-p"><span class="ne-text">如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</span></p><p id="308bdb2ec7045fea75ded39be10410f1" class="ne-p"><br></p><p id="40ab708608e25dd3b797e9ecbdf80c94" class="ne-p"><span class="ne-text">如果链表中存在环，则返回 true 。 否则，返回 false 。</span></p><p id="e8ad61232c56c5940b39c44eaebc65f0" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195777983-5574f7c4-135c-45c2-aef2-6118e954bf68.png" width="363" id="ydSqs" class="ne-image"></p><h3 id="kppHk"><span class="ne-text">问题思路</span></h3><h3 id="sl3wo"><span class="ne-text">代码实现</span></h3><pre data-language="java" id="AAOpu" class="ne-codeblock language-java">public class Solution {<br>public boolean hasCycle(ListNode head) {<br>if (head == null || head.next == null) return false;</p><pre><code>    // TODO: 快慢指针    ListNode slow = head;    ListNode fast = head.next;    while (fast != null &amp;&amp; fast.next != null) &#123;        slow = slow.next;        fast = fast.next.next;        if (slow == fast) return true; //如果能相遇则表示有环    &#125;    return false; //不能相遇则没有环&#125;</code></pre><p>}</pre></div></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>.gitignore文件使用总结</title>
      <link href="/blog/hgxgvd/"/>
      <url>/blog/hgxgvd/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="f47a11490e029063f14371f0d1d2180c" class="ne-p"><span class="ne-text">在Git项目将要提交到github仓库的时候，有些时候我们想要将指定文件不push，例如含有敏感信息类似token的文件，或者.class、.xml、等文件</span></p></div><p id="u8267b8e4" class="ne-p"><span class="ne-text"></span></p><h2 id="hzRD2"><span class="ne-text">忽略指定文件的push的三种方式</span></h2><ul class="ne-ul"><li id="d5936771af41aa4bac653963e539c1fe"><span class="ne-text">方式一：在Git项目中定义.gitignore文件</span></li><li id="4aec825d2a0be427f6b76228fc2c7da6"><span class="ne-text">方式二：在Git项目的设置中指定排除文件</span></li></ul><ul start="3" class="ne-ul"><li id="46dcbf7e45127090c3c6416767235663"><span class="ne-text">方式三：定义Git全局的 .gitignore 文件</span></li></ul><p id="a80d535ea7c8b5af3cc4eadf87f77f32" class="ne-p"><br></p><h2 id="1DegL"><span class="ne-text">语法规则</span></h2><pre data-language="plain" id="DVqoS" class="ne-codeblock">#               表示此为注释,将被Git忽略<p><em>.a 表示忽略所有 .a 结尾的文件<br>!lib.a 表示但 lib.a 除外<br>/TODO 表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO<br>build/ 表示忽略 build/目录下的所有文件，过滤整个 build 文件夹；<br>doc/</em>.txt 表示会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</p><p>bin/: 表示忽略当前路径下的 bin 文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件<br>/bin: 表示忽略根目录下的 bin 文件<br>/<em>.c: 表示忽略 cat.c，不忽略 build/cat.c<br>debug/</em>.obj: 表示忽略 debug/io.obj，不忽略 debug/common/io.obj 和 tools/debug/io.obj<br><strong>/foo: 表示忽略/foo,a/foo,a/b/foo 等<br>a/</strong>/b: 表示忽略 a/b, a/x/b,a/x/y/b 等<br>!/bin/run.sh 表示不忽略 bin 目录下的 run.sh 文件<br>*.log: 表示忽略所有 .log 文件<br>config.php: 表示忽略当前路径的 config.php 文件</p><p>/mtk/ 表示过滤整个文件夹<br>*.zip 表示过滤所有.zip 文件<br>/mtk/do.c 表示过滤某个具体文件</p><p>被过滤掉的文件就不会出现在 git 仓库中（gitlab 或 github）了，当然本地库中还有，只是 push 的时候不会上传。</p><p>需要注意的是，gitignore 还可以指定要将哪些文件添加到版本管理中，如下：<br>!*.zip<br>!/mtk/one.txt</p><p>唯一的区别就是规则开头多了一个感叹号，Git 会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？<br>想象一个场景：假如我们只需要管理/mtk/目录中的 one.txt 文件，这个目录中的其他文件都不需要管理，那么.gitignore 规则应写为：：<br>/mtk/*<br>!/mtk/one.txt</p><p>假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了 one.txt 以外的所有文件都写出来！<br>注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt 文件虽然加了!过滤规则，也不会生效！</p><hr><p>还有一些规则如下：<br>fd1/*<br>说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；</p><p>/fd1/*<br>说明：忽略根目录下的 /fd1/ 目录的全部内容；</p><p>/_<br>!.gitignore<br>!/fw/<br>/fw/_<br>!/fw/bin/<br>!/fw/sf/<br>说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对 bin/的父目录使用!规则，使其不被排除。</pre><h2 id="IOM5w"><span class="ne-text">参考文章</span></h2><ul class="ne-ul"><li id="f99cb5013fe93dcc5133f5bb13981dec"><span class="ne-text">文章主要参考：</span><a href="https://www.cnblogs.com/kevingrace/p/5690241.html" data-href="https://www.cnblogs.com/kevingrace/p/5690241.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/kevingrace/p/5690241.html</span></a></li></ul><p id="4ba6965444eace451678908c1920bb80" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《围城》有感</title>
      <link href="/essay/obs0vr/"/>
      <url>/essay/obs0vr/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B16%2C2%2C4%5D%2C%5B16%2C2%2C4%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="b789d1efa36e0abe5cbc7219e396bb93" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">持续记录读这本书的所思所感所悟</p><p data-lake-id="e6d3db6f4a85e94337bad3b88d22725f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">“城外的人想进来，城内的人想出去”</p></blockquote><p data-lake-id="d2d63d2879ad44fc90806f08c5559399" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote class="lake-alert lake-alert-success" style="margin: 0px; padding: 10px; border: 1px solid rgb(194, 210, 181); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(237, 249, 232);"><p data-lake-id="475e81f65b57fe0952d55508c9f5e73a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">这真的是一种人生态度，每次用这句话对一系列问题进行思考的时候，我总喜欢在后面加上一句“活在当下，知足常乐”。</p></blockquote><p data-lake-id="c3431d7780d27281483e678fe0f92a0e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="896e462daba6f696bec087a38b0461d1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">还是坐在教室里面的一些遐想…</p><p data-lake-id="68e89188f89f7353eb813d5240c982a7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c673b7452f6cb01ec12f8001f9a6f195" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">我很难去想象一个没有选择权利的人会怎么样度过这么一生。这是一个极端，也是一个愿以安于现状的人的一种解脱，</p><p data-lake-id="23fd8e2c160a48ce0e49c66115936356" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="e4032a9a58f27c8b7bb6fe8242c556ba" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ad977d0940dfcd72ed2bc5ac3344b050" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">还没看完，下次再写吧</p><p data-lake-id="553d4176d279bdd2a9d9181e9021915a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="dc6f25a0946b8911145587b844fd196d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">最大的围城，或许就是知识分子之间的吧，就像是一个圈子，这个圈子吧所谓的知识分子划分出来，而这个圈子里面的人或许又如井底的青蛙一样，甚至也不想出去呢~</p><p data-lake-id="c68c97a423a94c11987939de4db0c582" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="50fe0a7ca3a1acae3a25df290ab1f143" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">滑稽的人呀，一切都貌似在追求一些虚无缥缈般地事物一样，易碎​<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">fragile</code>​ ……</p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算方法课小记</title>
      <link href="/essay/sdzqr3/"/>
      <url>/essay/sdzqr3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-traditional" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%5D%2C%5B0%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="d9e332cce85f1f3ef7298d122d15d531" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>上计算方法课的那个老师，我严重怀疑他有山东口音，他讲话，一开始简直听不清，可能是我还不习惯山东话的缘故吧~可就是在那样的课堂里面，在那些个周里面，我真的是潜移默化般地学到了</span>许多到许多……</p><p data-lake-id="d73afa25b0d28b77dfdf79ec77f2dc0e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">大三上学期选了一门计算方法这门课，当时选的人不太多，四十几个吧，当时都是说这门课太难了，需要用到许多之前学习的高数、线代、概率统计等知识，我选这门课，一是自己比较喜欢数学，想着今后应该不做科研了，与数学不出意外应该是不会再相见了，还想再最后学习一下自己最喜欢的科目，也算是一种情怀吧~哈哈，在一个原因就是，这门课四个学分，四个学分！！</p><p data-lake-id="02e23851902c918bbdaca021544d8345" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="7e97f63a8153e16390c1108753032f9c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">老师经常和我们说，算法就是解决实际问题，以前我们学的立刻当中，结果就是是与不是，但是这门课里面，没有对错，他经常让我们看到一个问题，不要立马去看树上的解答，他说书很局限思维，起初我不以为意，渐渐地，我发现了这位老师说的的确对，我记得有一次课是讲求积分，我一直觉得我高数学的还行，老师让我们尽自己所想，想出所有的解决方案，来解决求一个正态分布表这么个简单的问题，老师一再强调让我们不要有正确答案的想法，有解决方案即可，那次我记得那个问题同学们给出的解决方案有许许多多，插值、拟合、泰勒多项式展开、幂级数展开、求面积，多点函数值……</p><p data-lake-id="9b0bb4b85f2dec12205f63aaabae9573" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="092d046e3d698127add0c41ce2a3402f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">其实从那个时候，我对算法这个事物有了进一步的认识，就像这位常年带学校ACM队的老师所说，算法就是解决实际问题，没有什么对错，只有精度，优化，算法亦是如此，其实那个时候，我对算法设计与分析那门课程里面谈及的各种算法问题，各种算法思想，也有了更加一步的上帝视角来观望。</p><p data-lake-id="05929eda00ae5919fd815a662cd85fa9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="9253fa293a725c65c3d84a578fabd5d7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">算法就是解决实际问题，手上敲的代码亦是如此。</p><p data-lake-id="0cf6fc779ba8f66fde6e7988564ec396" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="20752f0dd67268309d23274c50751265" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">他和我们说，我们现在在学校里面学的这些知识出去是用不到的，那为什么还学呢？</p><p data-lake-id="8c49eea7ba0e2a94e20d5aa7979e7ac7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c99f3d7c69c95bae89f8e779587cb237" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">能力。他的这个回答，和我的回答一样，身处在这个技术迭代极快的情况下，更何况是计算机行业，我们要学的实在太多了，但是又如老师所言，但那些底层次的知识，那些思想，是我们这些学习者要学习的，我想老师想表达的更是一种万变不离其中的意味吧。</p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博客与前端历程</title>
      <link href="/essay/sgyoz3/"/>
      <url>/essay/sgyoz3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-traditional" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B20%2C0%2C19%5D%2C%5B20%2C0%2C19%5D%5D%2C%22active%22%3Atrue%7D"><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="cba2c4e2b71701941bfa0c1b20ed801e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">大三上学期，学习计算机网络的应用层那里，我才知道我常写的原来叫博客……</p></blockquote><h2 data-lake-id="92adbbfe4a5aa6608e7cd089ecbd6deb" id="ibOL9" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">学习就要做笔记</h2><p data-lake-id="a14d6fdcaceee344552fd9572dd3fb7a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">大二上学期期末那会，当时复习操作系统那会在想，为什么我现在想不起来我大一的C语言的一些知识呢？学过的知识过了许久没有记录，没有可以供自己想起的那般线索，还有什么意义呢？于是，那时我就想着在网上弄一个电子笔记吧。</p><p data-lake-id="dedaa9ddca9d558738bd76d7dd060118" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="502c32f5f32c55fee52806f91995cf56" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">于是，我认识了Onenote，Onenote很灵活，以至于太过灵活，不太适合发布文章，用了一段时间，想了想我还是想以发布文章的角色来做笔记</p><p data-lake-id="a9712a7039eaf3d3c9344da5a5317081" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="1bc7ac352eda9f3034b820e0fdf38b84" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">于是期末那段时间我就平时在网上搜适合我做电子笔记的平台，当时改不知道什么是博客，但是看<span style="text-decoration: line-through;">很多人 </span>程序员都有自己的网站写点东西，于是就对其感兴趣了</p><p data-lake-id="39f8636cb14afd1e7e0a872601061e6d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">再后来就发现很多人都拥有自己的个人网站，而且建立也很简单，一个GitHub就可以了，那会就一直玩GitHub，利用GitHub Pages搭建了一个静态网站</p><p data-lake-id="79016ef87fa507d74e85fa61668ccc5e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="80be56b949cb5a9ce3c51bbead1b3625" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">疫情期间正好有一门选修课是JavaWeb，那会我就接触了CS架构模型</p><p data-lake-id="3067b5d791ed4700b4958eb0dd40ea66" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="46df8df78309cc710af16c686a0e6142" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">疫情期间，在家发现网上有好多的博客大神。突然有那么一刹那，我突然意识到，我想写的不是笔记，也不是零零碎碎的小想法，我要写的是一篇篇博客，一篇篇文章呀！</p><p data-lake-id="31b804584570c696e8ea320e26e9f4ea" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c7934e2b02b6d40ffcfbde4bcba20775" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">从那之后，对前端就慢慢了解，前端很难，水很深，需要的自学能力甚至赶超其他行业。</p><p data-lake-id="c49606feb4bd6cb226e0fe51aa7fc1d6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="1c8870608f4926bf4e6e23cfef6bcaf8" id="gQsCw" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">前端</h2><p data-lake-id="f60be6a15b71990dff19e58b6f34ad0e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">其实一直喜欢数据，大一那会，人工智能，机器学习啥的，都特别火，那会我也就学了python，然后数据分析，那会我就挺喜欢数据分析挖掘的，将一堆杂乱的数据经过处理之后，就可以变成各种自己需要的各种数据，还能出图，matplotlib包，我就特别喜欢用这个画各种图</p><p data-lake-id="aceaa9d3d29394e66d88620d6e36a72f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="4b60ced739e8b0da55379b397af86b5a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="5e55e088ebeb13830aaac1b8427f3380" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">2021.04.26更</p><p data-lake-id="392a4c5cea7f24baee6ecf587f5f9134" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">好的，已入前端坑🙃，两个字——鬼魅～</p><p data-lake-id="890d5c1fa7a973f0e8769f32ea9db104" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="03c80d4816d1d81b111bd3892cc02b5b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="afa02f3a67e1c46339d8fe127ba9845c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="8a929880cea610aceb818399ccb02f75" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="9e5eec44a57eff2d2cbe60014751b27e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>万物守恒</title>
      <link href="/essay/ipgq2m/"/>
      <url>/essay/ipgq2m/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C26%5D%2C%5B0%2C0%2C26%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">什么都是守恒的，我一直觉得这世界上很多事物都是守恒的</p><ul data-lake-id="f41dc6a0380592dbd79392c93c9b4e96" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="71604d4a068f0609c501f81d38b46f42">有过很顺的时候，也有过身处逆境</li><li data-lake-id="6d0e9b7b5bf941b8fd15550646b8ffc7">有过巅峰，也有过没落</li><li data-lake-id="10e305127541295efba8bb61559d7ce6">有些时候，你帮助陌生人，到某个时候，你也会被他人帮助</li><li data-lake-id="db95885c159ac2953e4cdc373eca749d">盛极一时的罗马，最后也败于自己</li><li data-lake-id="32e25861b77c470f3e9b1906cce703ed">秦的大一统，也终将没落</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++匿名函数</title>
      <link href="/blog/uq89oe/"/>
      <url>/blog/uq89oe/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h3 data-lake-id="c512eaf71a92e4852a8aed5b134a2fb2" id="5pXad" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">常用形式</h3><div data-card-type="block" data-lake-card="codeblock" id="9NY69" class="lake-card-margin" data-language="cpp"><div class="lake-codeblock-content" style="border: 1px solid rgb(232, 232, 232); max-width: 750px; color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: rgb(249, 249, 249);"><div class="CodeMirror-sizer" style="color: rgb(89, 89, 89); margin: 0px; padding: 16px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><pre class="cm-s-default" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">[](<span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">x</span>, <span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">y</span>) <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">-></span> <span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> { <span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">z</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">=</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">x</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">+</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">y</span>; <span class="cm-keyword" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">return</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">z</span>; } <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">//这样显示指定返回类型:</span><p></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">[](<span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">x</span>, <span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">y</span>) { <span class="cm-keyword" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">return</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">x</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">+</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">y</span>; } <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 隐式返回类型</span><br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">[](<span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span><span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">&amp;</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">x</span>) { <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">++</span><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">x</span>; } <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 没有 return 语句 -&gt; lambda 函数的返回类型是’void’</span><br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><a href=""></a> { <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">++</span><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">global_x</span>; } <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 没有参数,仅访问某个全局变量</span><br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">[]{ <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">++</span><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">global_x</span>; } <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 与上一个相同,省略了()</span></span></span></pre></div></div></div><h3 data-lake-id="279e2274eaf98f290a7b10804c6e7d10" id="b6aC6" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">小例子</h3><div data-card-type="block" data-lake-card="codeblock" id="cbZUs" class="lake-card-margin" data-language="cpp"><div class="lake-codeblock-content" style="border: 1px solid rgb(232, 232, 232); max-width: 750px; color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: rgb(249, 249, 249);"><div class="CodeMirror-sizer" style="color: rgb(89, 89, 89); margin: 0px; padding: 16px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><pre class="cm-s-default" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-meta" style="color: rgb(31, 127, 154); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">#include <iostream></span><br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> <span class="cm-def" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">main</span>() {<br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"> <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// lambda 表达式</span><br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"> <span class="cm-keyword" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">auto</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">multiply</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">=</span> [](<span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">a</span>, <span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">b</span>) <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">-></span> <span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> { <span class="cm-keyword" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">return</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">a</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">*</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">b</span>; };<br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"> <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 匿名函数调用</span><br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"> <span class="cm-keyword" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">auto</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">result</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">=</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">multiply</span>(<span class="cm-number" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">2</span>, <span class="cm-number" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">4</span>);<br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">std::cout</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><<</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">result</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><<</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">std::endl</span>;<br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"> <span class="cm-keyword" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">return</span> <span class="cm-number" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">0</span>;<br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">}</span></span></pre></div></div></div><h3 data-lake-id="f2db07d882cd109da59b5282d55d45ed" id="Idn0s" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">参考</h3><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="731c941f597e22e1c1c49f48f68cf314" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">一些进一步用法<a href="https://www.cnblogs.com/pzhfei/archive/2013/01/14/lambda_expression.html" target="_blank">https://www.cnblogs.com/pzhfei/archive/2013/01/14/lambda_expression.html</a></p></blockquote></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Huffman编码算法</title>
      <link href="/blog/ggu8v9/"/>
      <url>/blog/ggu8v9/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="sgeWE"><span class="ne-text">问题描述</span></h2><p id="9e986f8b518aa874e5488365b4e318ad" class="ne-p"><span class="ne-text">压缩算法，目的就是根据字母的出现频率来“按需分配”编码来优化编码方式。</span></p><p id="077c62ae4385fc6d47f65957345e17f5" class="ne-p"><span class="ne-text">比如：给出一串字母   </span><code class="ne-code"><span class="ne-text">Huffman Coding</span></code><span class="ne-text">   ，按照计算机处理形式，会根据ascll码将这串字符编码，具体形式（十进制）就是104 117 102 102 109 97 110 32 67 111 100 105 110 103，然后转换成二进制，最后会得到需要97个比特来存储。</span></p><h2 id="CaJgL"><span class="ne-text">算法描述</span></h2><p id="7e72a7f72a1ef85799d8e92db7d33404" class="ne-p"><span class="ne-text">算法角度来讲对上述问题ascll编码方式是浪费空间的，优化方向是改变编码方式，根据字母出现的频率来“按需分配”进制位。</span></p><p id="7bcb792f84491e892aa6eec4fe5ff850" class="ne-p"><br></p><p id="3568172be7d1c8656b762c0d960074ad" class="ne-p" style="text-align: left"><span class="ne-text">给出下面所给出的字母，以及出现的频率，来得到哈夫曼编码</span></p><p id="6ccb77d085739e1dd8a502fd7145d98b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605340774734-5ec5e8f1-0fae-47ff-8ded-dccf9611a3ad.png" width="205.5" id="pbDsY" class="ne-image"></p><p id="08528f8a11c5d0ecc0cd3bae97773b5b" class="ne-p" style="text-align: left"><span class="ne-text">先提出将频率小的依次加入。d和h组合权值为9(或者说A只是称呼方便)，然后将这个9“替换d和h”代入整个序列，在进行插入树操作，</span></p><div class="ne-quote"><p id="a5e27cd3dfd648344330915cf07369d8" class="ne-p" style="text-align: left"><span class="ne-text">过程中，遵循数字大的在左数字小的在右原则（互换也没关系，只不过换的是二进制的0和1）</span></p></div><p id="80aefeec8f8b6ab08a4c6c02bfb68c36" class="ne-p"><span class="ne-text">在进行到E的时候，此时的队列应该为120 107 42 37，所以此时需要重新调整队列，然后进行到结束。</span></p><p id="e68706c149a6ec04640e3cad07d51c50" class="ne-p" style="text-align: left"><br></p><p id="c8e68bfc6996011d2dc03f21a12bb5f5" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605340899720-d8867a90-d01c-4bf6-8ec7-ca0e812a99dd.png" width="188" id="vJM66" class="ne-image"></p><p id="4ef66678373379b55daca8b336a95124" class="ne-p" style="text-align: left"><span class="ne-text">最后的编码结果为：</span></p><p id="05a0e15b6dd3480361d88674d68f7b0d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605341313840-61587c86-135d-4ba0-96aa-844868de1d56.png" width="82.5" id="ENEj4" class="ne-image"></p><h2 id="3eVEL"><span class="ne-text">编码实现</span></h2><pre data-language="cpp" id="rNy23" class="ne-codeblock language-cpp">#include <stdio.h><dl><dt>#include <vector><br>#include <algorithm><br>namespace NS_HuffmanCoding {<br>using namespace std;<br>void BuildHuffmanTree();<br>void Initialization(vector&lt;pair&lt;char, int&gt;&gt; chars);<br>void Finalization();<br>struct HFMNode {<br>char Ch; int Freq;<br>HFMNode* Left, * Right;<br>HFMNode(char pCh, int pFreq, HFMNode* pLeft, HFMNode* pRight)<br>: Ch(pCh), Freq(pFreq), Left(pLeft), Right(pRight) {}<br>HFMNode(char pCh, int pFreq)</dt><dd>HFMNode(pCh, pFreq, NULL, NULL) {}<br>};<br>void MinHeapify(vector&lt;HFMNode*&gt;&amp; H);<br>void InsertH(vector&lt;HFMNode*&gt;&amp; H, HFMNode* node);<br>void SiftDown(vector&lt;HFMNode*&gt;&amp; H, int i);<br>void SiftUp(vector&lt;HFMNode*&gt;&amp; H, int i);<br>HFMNode* ExtractMin(vector&lt;HFMNode*&gt;&amp; H);<br>void DeleteANode(HFMNode* node);<br>void ShowInput(vector&lt;pair&lt;char, int&gt;&gt; chars);<br>void Output();<br>static vector&lt;HFMNode*&gt; Q;<br>void HuffmanCodingCaller(vector&lt;pair&lt;char, int&gt;&gt; chars)<br>{<br>ShowInput(chars);<br>Initialization(chars);<br>BuildHuffmanTree();<br>Output();<br>Finalization();<br>}<br>void BuildHuffmanTree()<br>{<br>char C = ‘A’;<br>while (Q.size() &gt; 1)<br>{<br>HFMNode* x = ExtractMin(Q);<br>HFMNode* y = ExtractMin(Q);<br>HFMNode* z = new HFMNode(C++, x-&gt;Freq + y-&gt;Freq, x, y);<br>InsertH(Q, z);<br>}<br>}<br>HFMNode* ExtractMin(vector&lt;HFMNode*&gt;&amp; H)<br>{<br>swap(H.front(), H.back());<br>HFMNode* p = H.back();<br>H.pop_back();<br>if (!H.empty())<br>SiftDown(H, 0);<br>return p;<br>}<br>void SiftDown(vector&lt;HFMNode*&gt;&amp; H, int i)<br>{<br>while ((i = (i &lt;&lt; 1) + 1) &lt; H.size()) {<br>if ((i + 1 &lt; H.size()) &amp;&amp; (H[i + 1]-&gt;Freq &lt; H[i]-&gt;Freq))<br>i = i + 1;<br>if (H[(i - 1) &gt;&gt; 1]-&gt;Freq &gt; H[i]-&gt;Freq)<br>swap(H[(i - 1) &gt;&gt; 1], H[i]);<br>else break;<br>}<br>}<br>void InsertH(vector&lt;HFMNode*&gt;&amp; H, HFMNode* node)<br>{<br>H.push_back(node);<br>SiftUp(H, H.size() - 1);<br>}<br>void SiftUp(vector&lt;HFMNode*&gt;&amp; H, int i)<br>{<br>while (i &gt; 0 &amp;&amp; H[i]-&gt;Freq &lt; H[(i - 1) &gt;&gt; 1]-&gt;Freq) {<br>swap(H[i], H[(i - 1) &gt;&gt; 1]);<br>i = (i - 1) &gt;&gt; 1;<br>}<br>}<br>void MinHeapify(vector&lt;HFMNode*&gt;&amp; H)<br>{<br>for (int i = (H.size() &gt;&gt; 1) - 1; i &gt;= 0; i–) {<br>SiftDown(H, i);<br>}<br>}</dd></dl><p>void Initialization(vector&lt;pair&lt;char, int&gt;&gt; chars)<br>{<br>Q.clear();<br>for (auto ch : chars)<br>Q.push_back(new HFMNode(ch.first, ch.second));<br>MinHeapify(Q);<br>}<br>void Finalization()<br>{<br>DeleteANode(Q[0]);<br>}<br>void DeleteANode(HFMNode* node)<br>{<br>if (node-&gt;Left)<br>{<br>DeleteANode(node-&gt;Left);<br>DeleteANode(node-&gt;Right);<br>}<br>delete node;<br>}<br>void ShowInput(vector&lt;pair&lt;char, int&gt;&gt; chars)<br>{<br>printf(“Huffman coding input: \n”);<br>for (auto c : chars)<br>printf(“%c,%d; “, c.first, c.second);<br>printf(“\n”);<br>}<br>static vector<char> coding;<br>static vector&lt;pair&lt;char, vector<char>&gt;&gt; codingList;<br>void GetHuffmanCoding(HFMNode* node)<br>{<br>if (node-&gt;Left)<br>{<br>coding.push_back(‘0’);<br>GetHuffmanCoding(node-&gt;Left);<br>coding.pop_back();<br>coding.push_back(‘1’);<br>GetHuffmanCoding(node-&gt;Right);<br>coding.pop_back();<br>}<br>else<br>{<br>codingList.push_back(pair&lt;char,<br>vector<char>&gt;(node-&gt;Ch, coding));<br>}<br>}<br>void Output()<br>{<br>printf(“Huffman coding:\n”);<br>coding.clear();<br>codingList.clear();<br>GetHuffmanCoding(Q[0]);<br>sort(codingList.begin(), codingList.end());<br>for (auto c1 : codingList)<br>{<br>printf(“ %c: “, c1.first);<br>for (auto c2 : c1.second)<br>printf(“%c”, c2);<br>printf(“\n”);<br>}<br>printf(“\n”);<br>}<br>} //namespace NS_HuffmanCoding<br>using namespace NS_HuffmanCoding;<br>void TestHuffmanCoding()<br>{<br>vector&lt;vector&lt;pair&lt;char, int&gt;&gt;&gt; charLists = {<br>//Introduction to Algorithms<br>{<br>{ {‘a’,40}, {‘b’,13}, {‘c’,12},<br>{‘d’,16}, {‘e’,9}, {‘f’,5} },<br>},<br>//ÑÏÎµÃô<br>{<br>{ {‘a’,5}, {‘b’,29}, {‘c’,7}, {‘d’,8},<br>{‘e’,14}, {‘f’,23}, {‘g’,3}, {‘h’,11} },<br>},<br>};<br>int n = charLists.size();<br>for (int i = 0; i &lt; n; i++)<br>{<br>HuffmanCodingCaller(charLists[i]);<br>}<br>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树算法（Prim+Kruskal）</title>
      <link href="/blog/ghf568/"/>
      <url>/blog/ghf568/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="5e0adbd3c4d03c372bc5bdbf949fc59c" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">贪心算法四个字总结：目前最优</span></p></div><h2 id="nHUEx"><span class="ne-text">图的一些概念</span></h2><p id="be7203f2c5e3cc70ac3430a06137165d" class="ne-p"><span class="ne-text">具体看先前的一篇文章</span><a href="https://www.wztlink1013.com/blog/gqpli5/" data-href="https://www.wztlink1013.com/blog/gqpli5/" target="_blank" class="ne-link"><span class="ne-text">https://www.wztlink1013.com/blog/gqpli5/</span></a></p><p id="5898cb029323a7e7bcde68a749655cea" class="ne-p"><span class="ne-text"></span></p><p id="0efe0efc44dc0dc883b9f397c6ac1ab9" class="ne-p"><strong><span class="ne-text">连通图</span></strong></p><div class="ne-quote"><p id="8380f5d22f1a9a91b06b0c585ee37581" class="ne-p"><span class="ne-text" style="color: #333333; font-size: 14px">在</span><a href="https://baike.baidu.com/item/%E5%9B%BE%E8%AE%BA/1433806" data-href="https://baike.baidu.com/item/%E5%9B%BE%E8%AE%BA/1433806" target="_blank" class="ne-link"><span class="ne-text">图论</span></a><span class="ne-text" style="color: #333333; font-size: 14px">中，连通图基于连通的概念。在一个</span><a href="https://baike.baidu.com/item/%E6%97%A0%E5%90%91%E5%9B%BE/1680427" data-href="https://baike.baidu.com/item/%E6%97%A0%E5%90%91%E5%9B%BE/1680427" target="_blank" class="ne-link"><span class="ne-text">无向图</span></a><span class="ne-text" style="color: #333333; font-size: 14px"> G 中，若从</span><a href="https://baike.baidu.com/item/%E9%A1%B6%E7%82%B9/11030118" data-href="https://baike.baidu.com/item/%E9%A1%B6%E7%82%B9/11030118" target="_blank" class="ne-link"><span class="ne-text">顶点</span></a><span class="ne-text" style="color: #333333; font-size: 14px">i到顶点j有路径相连（当然从j到i也一定有路径），则称i和j是连通的。如果 G 是</span><a href="https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE" data-href="https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE" target="_blank" class="ne-link"><span class="ne-text">有向图</span></a><span class="ne-text" style="color: #333333; font-size: 14px">，那么连接i和j的路径中所有的边都必须同向。如果图中任意两点都是连通的，那么图被称作连通图。如果此图是有向图，则称为强连通图（注意：需要双向都有路径）。图的</span><a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E6%80%A7/6688865" data-href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E6%80%A7/6688865" target="_blank" class="ne-link"><span class="ne-text">连通性</span></a><span class="ne-text" style="color: #333333; font-size: 14px">是图的基本性质。</span></p></div><p id="665951f6ed45e95795596091ea37cb43" class="ne-p"><strong><span class="ne-text">生成树</span></strong></p><div class="ne-quote"><p id="10112c33ae37e9de266d7dc9ad43da3e" class="ne-p"><span class="ne-text">包含图的全部顶点，边数最少的连通子图</span></p></div><p id="bf98f96271e09d1bf20e8fafda285603" class="ne-p"><strong><span class="ne-text">最小生成树</span></strong></p><div class="ne-quote"><p id="3826220ba76c178c35683068e2ab02a8" class="ne-p"><span class="ne-text">总权值最小的生成树</span></p></div><p id="b7c6c94ca874bae05cd003d128c1f69e" class="ne-p"><span class="ne-text">常见问题（该算法）就是求最小生成树。</span></p><p id="3ad4e5b28974402730ddf0a7a6c9a765" class="ne-p"><strong><span class="ne-text">并查集</span></strong></p><div class="ne-quote"><p id="fb49f1af56a20258b0994e05a5bd822f" class="ne-p"><span class="ne-text">是一个数据结构，功能有查找a和b是否为同一组；将a和b合并为同一组。</span></p></div><h2 id="Vz5Jg"><span class="ne-text">Prim算法思路</span></h2><p id="63b94f88c91d418b3a5ea7c1d40eb1c1" class="ne-p"><code class="ne-code"><span class="ne-text">Prim——普里姆算法</span></code></p><p id="57e1c39936058ab0cf89190777c671eb" class="ne-p"><span class="ne-text"></span></p><p id="65c9dddc9466daf1f87f622ae9013e7e" class="ne-p"><span class="ne-text">类似于图的深度优先遍历一样，在遍历到一个结点的时候，在此根据该节点所连通的各边权值，取最小的，以此往复</span></p><p id="cbff9ebe6415e49d40421bd46dcadcad" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1625102662437-05ab5a6e-fcc3-46d5-8c2d-666c9c23fa9a.png" width="388" id="Qjspy" class="ne-image"></p><h2 id="PFbmU"><span class="ne-text">Kruskal算法</span><span class="ne-text">思路</span></h2><p id="bc1fd8840968eaa8cd942c02348006fc" class="ne-p"><code class="ne-code"><span class="ne-text">Kruskal——克鲁斯卡尔算法</span></code></p><p id="5d99ae9579b08eceffe5b7ad59c14ee2" class="ne-p"><br></p><p id="7a889ea78b39c7c9c9904fcebe169343" class="ne-p"><span class="ne-text">把所有边按照权值全部按数值大小拿出来，然后按顺序选取每条边，利用并查集的思想，如果这条边的两个端点不属于同一集合，那么就将它们合并，直到所有的点都属于同一个集合为止。</span></p><p id="26e6db5a49dd1bdcfc6be897e96f7c38" class="ne-p"><br></p><p id="bb2fe010dc25de5f292f2c92b428fe68" class="ne-p"><span class="ne-text">比如有如下这么一个图：</span></p><p id="6e2e9f3149f755d4f53fdad50964b38b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320252853-c5d445e4-aa0e-4279-b9fd-7477f23b1bc1.png" width="219" id="Hx7aL" class="ne-image"></p><p id="aac64b9ab680edd476d18b367cb142ba" class="ne-p" style="text-align: left"><span class="ne-text">单独分析①②边和③④边情况下，两个不在一个集合里面，</span></p><p id="39ba58d75802638e8beb1aeb08e5f2b4" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320331669-51ec03dc-caf6-449d-9e8b-e4e62b9f35a6.png" width="384.5" id="PuNRa" class="ne-image"></p><p id="c55b6b173dedc37838a3ebc2021f673d" class="ne-p"><span class="ne-text">不断重复，不断判断是否为同一个集合，不在同一个集合的话，就合并，持续如此。比方说当一直操作到权值为3的时候，此时就需要将左右两个集合合并了</span></p><p id="90ebd57d6561894820dc28eb8dba77c2" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320497092-00097419-4852-44c4-884e-febd4d37eb65.png" width="374" id="wsUam" class="ne-image"></p><p id="997a98f28e94a25540a4893a96c5098d" class="ne-p" style="text-align: left"><span class="ne-text">最后的结果样式就为如下</span></p><p id="fd9a3ee6d2a2bf0a101c0dfb8cb7eb03" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320612085-d893c759-4ef1-410c-976e-8f32ddfe6321.png" width="390" id="adOCr" class="ne-image"></p><p id="91b40a459460ec5d2efb79ae1d139a58" class="ne-p" style="text-align: center"><br></p><h2 id="9kZiP"><span class="ne-text">代码实现</span></h2><h3 id="YPhZh"><span class="ne-text">Kruskal算法代码</span></h3><pre data-language="cpp" id="ViSvq" class="ne-codeblock language-cpp">#include <stdio.h><p>#include <vector><br>#include <algorithm><br>namespace NS_KruskalMST {<br>using namespace std;<br>void KruskalMST();<br>int FindSet(int u);<br>void UnionSets(int u, int v);<br>void Initialization();<br>void GenEdges();<br>void MakeSets();<br>void Output(int v0);<br>#define INF INT_MAX<br>static int n;<br>static vector&lt;vector<int>&gt; WMatrix;<br>static vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; Edges;<br>//Node struct for the disjoint set<br>struct DJSNode {<br>int Parent; int Rank;<br>DJSNode(int p) : Parent(p), Rank(0) {}<br>};<br>static vector<DJSNode> DisjointSet;<br>static vector&lt;pair&lt;int, int&gt;&gt; MST;<br>//The adjacency list for MST<br>static vector&lt;vector<int>&gt; MSTList;<br>static vector<int> Prev;<br>void KruskalMSTCaller(int an,<br>vector&lt;vector<int>&gt; &amp;wMatrix, int v0)<br>{<br>n = an;<br>WMatrix = wMatrix;<br>Initialization();<br>KruskalMST();<br>Output(v0);<br>}<br>void KruskalMST()<br>{<br>for (auto &amp;e: Edges)<br>{<br>int u = e.first.first;<br>int v = e.first.second;<br>int setU = FindSet(u);<br>int setV = FindSet(v);<br>if (setU != setV)<br>{<br>MST.push_back(e.first);<br>if (MST.size() == n - 1)<br>break;<br>UnionSets(setU, setV);<br>}<br>}<br>}<br>int FindSet(int u)<br>{<br>while (u != DisjointSet[u].Parent)<br>u = DisjointSet[u].Parent;<br>//For path compression:<br>//DisjointSet[u].Parent =<br>// FindSet(DisjointSet[u].Parent);<br>return u;<br>}<br>void UnionSets(int u, int v)<br>{<br>if (DisjointSet[u].Rank &gt;= DisjointSet[v].Rank)<br>DisjointSet[v].Parent = u;<br>else<br>DisjointSet[u].Parent = v;<br>if (DisjointSet[u].Rank == DisjointSet[v].Rank)<br>DisjointSet[u].Rank++;<br>}<br>void Initialization()<br>{<br>GenEdges();<br>sort(Edges.begin(), Edges.end(),<br>[](pair&lt;pair&lt;int, int&gt;, int&gt;a,<br>pair&lt;pair&lt;int, int&gt;, int&gt;b)<br>{return a.second &lt; b.second; });<br>MakeSets();<br>MST.clear();<br>}<br>void GenEdges()<br>{<br>Edges.clear();<br>//Traverse the upper triangle of WMatrix<br>for (int i = 0; i &lt; n - 1; i++)<br>{<br>for (int j = i + 1; j &lt; n; j++)<br>if (WMatrix[i][j] != INF)<br>Edges.push_back({ {i, j},<br>WMatrix[i][j] });<br>}<br>}<br>void MakeSets()<br>{<br>DisjointSet.clear();<br>for (int i = 0; i &lt; n; i++)<br>DisjointSet.push_back(DJSNode(i));<br>}<br>void OutputWMatrix()<br>{<br>printf(“n = %d\n”, n);<br>printf(“The weight matrix:\n”);<br>printf(“%3c”, ‘ ‘);<br>for (int j = 0; j &lt; n; j++)<br>printf(“%3d”, j + 1);<br>printf(“\n”);<br>for (int i = 0; i &lt; n; i++)<br>{<br>printf(“%3d”, i + 1);<br>for (auto j : WMatrix[i])<br>if (j &lt; INF)<br>printf(“%3d”, j);<br>else<br>printf(“%3c”, ‘*‘);<br>printf(“\n”);<br>}<br>}<br>void OutputPath(int u)<br>{<br>if (Prev[u] == -1)<br>printf(“%d”, u + 1);<br>else<br>{<br>OutputPath(Prev[u]);<br>printf(“-%d”, u + 1);<br>}<br>}<br>void GenMSTList()<br>{<br>MSTList.clear();<br>MSTList.resize(n);<br>for (auto &amp;e: MST)<br>{<br>MSTList[e.first].push_back(e.second);<br>MSTList[e.second].push_back(e.first);<br>}<br>}<br>void GenPrev(int v)<br>{<br>for (auto &amp;u : MSTList[v])<br>if (u != -1)<br>{<br>Prev[u] = v;<br>auto w = find(MSTList[u].begin(),<br>MSTList[u].end(), v);<br>MSTList[u]w - MSTList[u].begin()] = -1;<br>GenPrev(u);<br>}<br>}<br>void Output(int v0)<br>{<br>printf(“Kruskal’s MST algorithm\n”);<br>OutputWMatrix();<br>int wSum = 0;<br>for (int i = 0; i &lt; n - 1; i++)<br>wSum += WMatrix[MST[i].first][MST[i].second];<br>GenMSTList();<br>Prev.clear();<br>Prev.resize(n);<br>Prev[v0] = -1;<br>GenPrev(v0);<br>printf(“The MST edges:\n”);<br>printf(“Edge Weight\n”);<br>for (auto &amp;e : MST)<br>printf(“ %d-%d %d\n”, e.first + 1, e.second + 1,<br>WMatrix[e.first][e.second]);<br>printf(“Total MST weight: %d\n”, wSum);<br>printf(“The MST paths from vertex %d:\n”, v0 + 1);<br>for (int u = 0; u &lt; n; u++)<br>if (u != v0)<br>{<br>printf(“%3d: “, u + 1);<br>OutputPath(u);<br>printf(“\n”);<br>}<br>printf(“\n”);<br>}<br>} //namespace NS_KruskalMST<br>using namespace NS_KruskalMST;<br>void TestKruskalMST(int v0 = 0)<br>{<br>vector&lt;vector&lt;vector<int>&gt;&gt; w = {<br>//<a href="https://www.geeksforgeeks.org/">https://www.geeksforgeeks.org/</a><br>//prims-minimum-spanning-tree-mst-greedy-algo-5/<br>{<br>{ 0, 2,INF, 6,INF },<br>{ 2, 0, 3, 8, 5 },<br>{ INF, 3, 0,INF, 7 },<br>{ 6, 8,INF, 0, 9 },<br>{ INF, 5, 7, 9, 0 }<br>},<br>// Dijkstra’s algorithm on Wikipedia<br>{<br>{ 0, 7, 9,INF,INF, 14 },<br>{ 7, 0, 10, 15,INF,INF },<br>{ 9, 10, 0, 11,INF, 2 },<br>{ INF, 15, 11, 0, 6,INF },<br>{ INF,INF,INF, 6, 0, 9 },<br>{ 14,INF, 2,INF, 9, 0 },<br>},<br>//<a href="https://www.geeksforgeeks.org/">https://www.geeksforgeeks.org/</a><br>//kruskals-minimum-spanning-tree-using-stl-in-c/<br>{<br>{ 0, 4,INF,INF,INF,INF,INF, 8,INF },<br>{ 4, 0, 8,INF,INF,INF,INF, 11,INF },<br>{ INF, 8, 0, 7,INF, 4,INF,INF, 2 },<br>{ INF,INF, 7, 0, 9, 14,INF,INF,INF },<br>{ INF,INF,INF, 9, 0, 10,INF,INF,INF },<br>{ INF,INF, 4, 14, 10, 0, 2,INF,INF },<br>{ INF,INF,INF,INF,INF, 2, 0, 1, 6 },<br>{ 8, 11,INF,INF,INF,INF, 1, 0, 7 },<br>{ INF,INF, 2,INF,INF,INF, 6, 7, 0 },<br>},<br>};<br>int k = w.size();<br>for (int i = 0; i &lt; k; i++)<br>{<br>if (v0 &gt; w[i].size() - 1)<br>v0 = w[i].size() - 1;<br>KruskalMSTCaller(w[i].size(), w[i], v0);<br>}<br>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue接口调用学习笔记</title>
      <link href="/blog/frhg9i/"/>
      <url>/blog/frhg9i/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-tl"><li id="u0a959eeb"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">🔲</span><span class="ne-text">计时器和定时器这方面的知识不太熟悉</span></li></ul><h3 id="97bb9400"><span class="ne-text">接口调用方式</span></h3><ul class="ne-ul"><li id="u67f7bf41"><span class="ne-text">原生ajax</span></li><li id="ua98e6e74"><span class="ne-text">基于jQuery的ajax</span></li></ul><ul class="ne-ul"><li id="u5fe9c88d"><span class="ne-text">fetch</span></li><li id="u247a9172"><span class="ne-text">axios</span></li></ul><h3 id="8b5a247d"><span class="ne-text">异步</span></h3><ul class="ne-ul"><li id="ub41681c0"><span class="ne-text">JavaScript的执行环境是「单线程」</span></li><li id="u304e05f6"><span class="ne-text">所谓单线程，是指JS引擎中负责解释和执行JavaScript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程</span></li></ul><ul class="ne-ul"><li id="ue3ae9387"><span class="ne-text">异步模式可以一起执行</span><strong><span class="ne-text">多个任务</span></strong></li><li id="ue029a487"><span class="ne-text">JS中常见的异步调用 </span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u0ceda00b"><span class="ne-text">定时任何</span></li><li id="ue08e6385"><span class="ne-text">ajax</span></li></ul></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u1dd83cba"><span class="ne-text">事件函数</span></li></ul></ul><p id="u27ec855d" class="ne-p"><br></p><h3 id="promise"><span class="ne-text">promise</span></h3><ul class="ne-ul"><li id="uad1a8bf9"><span class="ne-text">主要解决异步深层嵌套的问题</span></li><li id="ua3091db0"><span class="ne-text">promise 提供了简洁的API  使得异步操作更加容易</span></li></ul><p id="ub5a67814" class="ne-p"><br></p><pre data-language="html" id="dab4fe94" class="ne-codeblock language-html">  <script type="text/javascript">    /*     1. Promise基本使用     我们使用new来构建一个Promise  Promise的构造函数接收一个参数，是函数，并且传入两个参数：           resolve，reject， 分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数    */<pre><code>var p = new Promise(function(resolve, reject)&#123;  //2. 这里用于实现异步任务  setTimeout  setTimeout(function()&#123;    var flag = false;    if(flag) &#123;      //3. 正常情况      resolve(&#39;hello&#39;);    &#125;else&#123;      //4. 异常情况      reject(&#39;出错了&#39;);    &#125;  &#125;, 100);&#125;);//  5 Promise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数 //  在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了  p.then(function(data)&#123;  console.log(data)&#125;,function(info)&#123;  console.log(info)&#125;);</code></pre><p>  </script></pre><p id="uefc52b62" class="ne-p"><br></p><h3 id="4a9453c1"><span class="ne-text">基于Promise发送Ajax请求</span></h3><p id="u1c5dc0e4" class="ne-p"><br></p><pre data-language="html" id="b43f15f1" class="ne-codeblock language-html"><br>  <script type="text/javascript"><br>    /*<br>      基于Promise发送Ajax请求<br>    <em>/<br>    function queryData(url) {<br>     #   1.1 创建一个Promise实例<br>      var p = new Promise(function(resolve, reject){<br>        var xhr = new XMLHttpRequest();<br>        xhr.onreadystatechange = function(){<br>          if(xhr.readyState != 4) return;<br>          if(xhr.readyState == 4 && xhr.status == 200) {<br>            # 1.2 处理正常的情况<br>            resolve(xhr.responseText);<br>          }else{<br>            # 1.3 处理异常情况<br>            reject('服务器错误');<br>          }<br>        };<br>        xhr.open('get', url);<br>        xhr.send(null);<br>      });<br>      return p;<br>    }<br>    # 注意：  这里需要开启一个服务<br>    # 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了<br>    queryData('<a href="http://localhost:3000/data&#39;">http://localhost:3000/data&#39;</a>)<br>      .then(function(data){<br>        console.log(data)<br>        #  1.4 想要继续链式编程下去 需要 return<br>        return queryData('<a href="http://localhost:3000/data1&#39;">http://localhost:3000/data1&#39;</a>);<br>      })<br>      .then(function(data){<br>        console.log(data);<br>        return queryData('<a href="http://localhost:3000/data2&#39;">http://localhost:3000/data2&#39;</a>);<br>      })<br>      .then(function(data){<br>        console.log(data)<br>      });<br>  </script></pre><p id="u5691b63e" class="ne-p"><br></p><h3 id="7110abf5"><span class="ne-text">Promise  基本API</span></h3><p id="u9b3cc2b8" class="ne-p"><br></p><h4 id="273a5d98"><span class="ne-text">实例方法</span></h4><p id="u02f59ee9" class="ne-p"><br></p><h5 id="7d0771d9"><span class="ne-text">.then()</span></h5><p id="ud0dd3a8d" class="ne-p"><br></p><ul class="ne-ul"><li id="ubacea4aa"><span class="ne-text">得到异步任务正确的结果</span></li></ul><p id="u4e414471" class="ne-p"><br></p><h5 id="4229da20"><span class="ne-text">.catch()</span></h5><p id="ubec2858e" class="ne-p"><br></p><ul class="ne-ul"><li id="u96c23d5c"><span class="ne-text">获取异常信息</span></li></ul><p id="u756b245c" class="ne-p"><br></p><h5 id="3a965eb8"><span class="ne-text">.finally()</span></h5><p id="u351ca374" class="ne-p"><br></p><ul class="ne-ul"><li id="u876bfa9d"><span class="ne-text">成功与否都会执行（不是正式标准）</span></li></ul><p id="u7dc9c1d9" class="ne-p"><br></p><pre data-language="html" id="38352c50" class="ne-codeblock language-html"><br>  <script type="text/javascript"><br>    /</em><br>      Promise常用API-实例方法<br>    */<br>    // console.dir(Promise);<br>    function foo() {<br>      return new Promise(function(resolve, reject){<br>        setTimeout(function(){<br>          // resolve(123);<br>          reject('error');<br>        }, 100);<br>      })<br>    }<br>    // foo()<br>    //   .then(function(data){<br>    //     console.log(data)<br>    //   })<br>    //   .catch(function(data){<br>    //     console.log(data)<br>    //   })<br>    //   .finally(function(){<br>    //     console.log('finished')<br>    //   });</p><pre><code>// --------------------------// 两种写法是等效的foo()  .then(function(data)&#123;    # 得到异步任务正确的结果    console.log(data)  &#125;,function(data)&#123;    # 获取异常信息    console.log(data)  &#125;)  # 成功与否都会执行（不是正式标准）   .finally(function()&#123;    console.log(&#39;finished&#39;)  &#125;);</code></pre><p>  </script></pre><p id="ub6570aaf" class="ne-p"><br></p><h4 id="85b97dce"><span class="ne-text">静态方法</span></h4><p id="u7abd85e9" class="ne-p"><br></p><h5 id="1a2d7680"><span class="ne-text">.all()</span></h5><p id="u66155b2d" class="ne-p"><br></p><ul class="ne-ul"><li id="u53165285"><code class="ne-code"><span class="ne-text">Promise.all</span></code><span class="ne-text">方法接受一个数组作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用</span><code class="ne-code"><span class="ne-text">Promise.resolve</span></code><span class="ne-text">转换为一个promise)。它的状态由这三个promise实例决定</span></li></ul><p id="uad5d2694" class="ne-p"><br></p><h5 id="0c943588"><span class="ne-text">.race()</span></h5><p id="u71cf32c4" class="ne-p"><br></p><ul class="ne-ul"><li id="u6ee3199c"><code class="ne-code"><span class="ne-text">Promise.race</span></code><span class="ne-text">方法同样接受一个数组作参数。当p1, p2, p3中有一个实例的状态发生改变（变为</span><code class="ne-code"><span class="ne-text">fulfilled</span></code><span class="ne-text">或</span><code class="ne-code"><span class="ne-text">rejected</span></code><span class="ne-text">），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数</span></li></ul><p id="u188aa265" class="ne-p"><br></p><p id="u7aa5c2dc" class="ne-p"><span class="ne-text"></span></p><p id="u0989c3de" class="ne-p"><br></p><pre data-language="html" id="8e6768d7" class="ne-codeblock language-html">  <script type="text/javascript"></p><pre><code>/*  Promise常用API-对象方法*/// console.dir(Promise)function queryData(url) &#123;  return new Promise(function(resolve, reject)&#123;    var xhr = new XMLHttpRequest();    xhr.onreadystatechange = function()&#123;      if(xhr.readyState != 4) return;      if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;        // 处理正常的情况        resolve(xhr.responseText);      &#125;else&#123;        // 处理异常情况        reject(&#39;服务器错误&#39;);      &#125;    &#125;;    xhr.open(&#39;get&#39;, url);    xhr.send(null);  &#125;);&#125;var p1 = queryData(&#39;http://localhost:3000/a1&#39;);var p2 = queryData(&#39;http://localhost:3000/a2&#39;);var p3 = queryData(&#39;http://localhost:3000/a3&#39;); Promise.all([p1,p2,p3]).then(function(result)&#123;   //   all 中的参数  [p1,p2,p3]   和 返回的结果一 一对应[&quot;HELLO TOM&quot;, &quot;HELLO JERRY&quot;, &quot;HELLO SPIKE&quot;]   console.log(result) //[&quot;HELLO TOM&quot;, &quot;HELLO JERRY&quot;, &quot;HELLO SPIKE&quot;] &#125;)Promise.race([p1,p2,p3]).then(function(result)&#123;  // 由于p1执行较快，Promise的then()将获得结果&#39;P1&#39;。p2,p3仍在继续执行，但执行结果将被丢弃。  console.log(result) // &quot;HELLO TOM&quot;&#125;)</code></pre><p></script></pre><p id="ucb14a8c7" class="ne-p"><br></p><h3 id="fetch"><span class="ne-text">fetch</span></h3><ul class="ne-ul"><li id="ua5c075b4"><span class="ne-text">Fetch API 是新的 ajax 解决方案 Fetch 会返回 Promise</span></li><li id="ude31397a"><strong><span class="ne-text">fetch 不是 ajax 的进一步封装，而是原生 js，没有使用 XMLHttpRequest 对象</span></strong><span class="ne-text">。</span></li></ul><ul class="ne-ul"><li id="u62e8a835"><span class="ne-text">fetch(url, options).then(）</span></li></ul><p id="udd790030" class="ne-p"><br></p><pre data-language="html" id="21b27feb" class="ne-codeblock language-html"> <script type="text/javascript"><br>/_<br>Fetch API 基本用法<br>fetch(url).then()<br>第一个参数请求的路径 Fetch 会返回 Promise 所以我们可以使用 then 拿到请求成功的结果<br><em>/<br>fetch('<a href="http://localhost:3000/fdata&#39;).then(function(data){">http://localhost:3000/fdata&#39;).then(function(data){</a><br>// text()方法属于 fetchAPI 的一部分，它返回一个 Promise 实例对象，用于获取后台返回的数据<br>return data.text();<br>}).then(function(data){<br>// 在这个 then 里面我们能拿到最终的数据<br> console.log(data);<br>})<br></script></pre><p id="u9ccb56b7" class="ne-p"><br></p><h4 id="55f8112b"><span class="ne-text">fetch API   中的 HTTP   请求</span></h4><p id="ueb9b9f92" class="ne-p"><br></p><ul class="ne-ul"><li id="u083a1c04"><span class="ne-text">fetch(url, options).then(）</span></li><li id="ub20af2e4"><span class="ne-text">HTTP 协议，它给我们提供了很多的方法，如 POST，GET，DELETE，UPDATE，PATCH 和 PUT </span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u53cc508f"><span class="ne-text">默认的是 GET 请求</span></li><li id="u61fb4bdc"><span class="ne-text">需要在 options 对象中 指定对应的 method       method:请求使用的方法</span></li></ul></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u90c260e4"><span class="ne-text">post 和 普通 请求的时候 需要在 options 中 设置   请求头 headers   和  body</span></li></ul></ul><p id="u50a8df46" class="ne-p"><br></p><pre data-language="html" id="9370617e" class="ne-codeblock language-html"> <script type="text/javascript"><br>/</em><br>Fetch API 调用接口传递参数<br>_/<br>#1.1 GET 参数传递 - 传统 URL 通过 url ？ 的形式传参<br>fetch('<a href="http://localhost:3000/books?id=123&#39;">http://localhost:3000/books?id=123&#39;</a>, { # get 请求可以省略不写 默认的是 GET<br>method: 'get'<br>})<br>.then(function(data) { # 它返回一个 Promise 实例对象，用于获取后台返回的数据<br>return data.text();<br>}).then(function(data) { # 在这个 then 里面我们能拿到最终的数据<br> console.log(data)<br>});</p><pre><code>  #1.2  GET参数传递  restful形式的URL  通过/ 的形式传递参数  即  id = 456 和id后台的配置有关    fetch(&#39;http://localhost:3000/books/456&#39;, &#123;            # get 请求可以省略不写 默认的是GET            method: &#39;get&#39;        &#125;)        .then(function(data) &#123;            return data.text();        &#125;).then(function(data) &#123;            console.log(data)        &#125;);   #2.1  DELETE请求方式参数传递      删除id  是  id=789    fetch(&#39;http://localhost:3000/books/789&#39;, &#123;            method: &#39;delete&#39;        &#125;)        .then(function(data) &#123;            return data.text();        &#125;).then(function(data) &#123;            console.log(data)        &#125;);   #3 POST请求传参    fetch(&#39;http://localhost:3000/books&#39;, &#123;            method: &#39;post&#39;,            # 3.1  传递数据            body: &#39;uname=lisi&amp;pwd=123&#39;,            #  3.2  设置请求头            headers: &#123;                &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;            &#125;        &#125;)        .then(function(data) &#123;            return data.text();        &#125;).then(function(data) &#123;            console.log(data)        &#125;);   # POST请求传参    fetch(&#39;http://localhost:3000/books&#39;, &#123;            method: &#39;post&#39;,            body: JSON.stringify(&#123;                uname: &#39;张三&#39;,                pwd: &#39;456&#39;            &#125;),            headers: &#123;                &#39;Content-Type&#39;: &#39;application/json&#39;            &#125;        &#125;)        .then(function(data) &#123;            return data.text();        &#125;).then(function(data) &#123;            console.log(data)        &#125;);    # PUT请求传参     修改id 是 123 的    fetch(&#39;http://localhost:3000/books/123&#39;, &#123;            method: &#39;put&#39;,            body: JSON.stringify(&#123;                uname: &#39;张三&#39;,                pwd: &#39;789&#39;            &#125;),            headers: &#123;                &#39;Content-Type&#39;: &#39;application/json&#39;            &#125;        &#125;)        .then(function(data) &#123;            return data.text();        &#125;).then(function(data) &#123;            console.log(data)        &#125;);&lt;/script&gt;&lt;/pre&gt;&lt;p id=&quot;u1d2d50aa&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;h4 id=&quot;05868c0c&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;fetchAPI 中 响应格式&lt;/span&gt;&lt;/h4&gt;&lt;p id=&quot;u505bd3f0&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;ubfb6502a&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;用fetch来获取数据，如果响应正常返回，我们首先看到的是一个response对象，其中包括返回的一堆原始字节，这些字节需要在收到后，需要我们通过调用方法将其转换为相应格式的数据，比如&lt;/span&gt;&lt;code class=&quot;ne-code&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;JSON&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;ne-text&quot;&gt;，&lt;/span&gt;&lt;code class=&quot;ne-code&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;BLOB&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;ne-text&quot;&gt;或者&lt;/span&gt;&lt;code class=&quot;ne-code&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;TEXT&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;ne-text&quot;&gt;等等&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p id=&quot;u0449c4fb&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;pre data-language=&quot;javascript&quot; id=&quot;af936742&quot; class=&quot;ne-codeblock language-javascript&quot;&gt;/*  Fetch响应结果的数据格式*/fetch(&#39;http://localhost:3000/json&#39;).then(function(data)&#123;  // return data.json();   //  将获取到的数据使用 json 转换对象  return data.text(); //  //  将获取到的数据 转换成字符串&#125;).then(function(data)&#123;  // console.log(data.uname)  // console.log(typeof data)  var obj = JSON.parse(data);  console.log(obj.uname,obj.age,obj.gender)&#125;)&lt;/pre&gt;&lt;p id=&quot;u54361e05&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;h3 id=&quot;axios&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;axios&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;u4b29a100&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;u0c76542b&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;基于promise用于浏览器和node.js的http客户端&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;u59029584&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;支持浏览器和node.js&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;u52d558b0&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;支持promise&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;u269520e4&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;能拦截请求和响应&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;u9983aece&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;自动转换JSON数据&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;u5f9323ba&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;能转换请求和响应数据&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p id=&quot;ue5141575&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;h4 id=&quot;f5950c74&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;axios基础用法&lt;/span&gt;&lt;/h4&gt;&lt;p id=&quot;u095eea5d&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;u77160093&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;get和 delete请求传递参数 &lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul class=&quot;ne-list-wrap&quot;&gt;&lt;ul ne-level=&quot;1&quot; class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;uef4257b6&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;通过传统的url  以&lt;/span&gt;&lt;code class=&quot;ne-code&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt; ? &lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;ne-text&quot;&gt;的形式传递参数&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;u8bbfda31&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;restful 形式传递参数&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul class=&quot;ne-list-wrap&quot;&gt;&lt;ul ne-level=&quot;1&quot; class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;u22ffd15f&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;通过params  形式传递参数&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;ue9b5d948&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;post  和 put  请求传递参数 &lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul class=&quot;ne-list-wrap&quot;&gt;&lt;ul ne-level=&quot;1&quot; class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;ue79bcab9&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;通过选项传递参数&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;u7f75e0c2&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;通过 URLSearchParams  传递参数&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p id=&quot;u9ac2da62&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;pre data-language=&quot;javascript&quot; id=&quot;891f8b54&quot; class=&quot;ne-codeblock language-javascript&quot;&gt;    # 1. 发送get 请求axios.get(&#39;http://localhost:3000/adata&#39;).then(function(ret)&#123;  #  拿到 ret 是一个对象      所有的对象都存在 ret 的data 属性里面  // 注意data属性是固定的用法，用于获取后台的实际数据  // console.log(ret.data)  console.log(ret)&#125;)# 2.  get 请求传递参数# 2.1  通过传统的url  以 ? 的形式传递参数axios.get(&#39;http://localhost:3000/axios?id=123&#39;).then(function(ret)&#123;  console.log(ret.data)&#125;)# 2.2  restful 形式传递参数axios.get(&#39;http://localhost:3000/axios/123&#39;).then(function(ret)&#123;  console.log(ret.data)&#125;)# 2.3  通过params  形式传递参数axios.get(&#39;http://localhost:3000/axios&#39;, &#123;  params: &#123;    id: 789  &#125;&#125;).then(function(ret)&#123;  console.log(ret.data)&#125;)#3 axios delete 请求传参     传参的形式和 get 请求一样axios.delete(&#39;http://localhost:3000/axios&#39;, &#123;  params: &#123;    id: 111  &#125;&#125;).then(function(ret)&#123;  console.log(ret.data)&#125;)# 4  axios 的 post 请求# 4.1  通过选项传递参数axios.post(&#39;http://localhost:3000/axios&#39;, &#123;  uname: &#39;lisi&#39;,  pwd: 123&#125;).then(function(ret)&#123;  console.log(ret.data)&#125;)# 4.2  通过 URLSearchParams  传递参数var params = new URLSearchParams();params.append(&#39;uname&#39;, &#39;zhangsan&#39;);params.append(&#39;pwd&#39;, &#39;111&#39;);axios.post(&#39;http://localhost:3000/axios&#39;, params).then(function(ret)&#123;  console.log(ret.data)&#125;)</code></pre><p>#5 axios put 请求传参 和 post 请求一样<br>axios.put(‘<a href="http://localhost:3000/axios/123&#39;">http://localhost:3000/axios/123&#39;</a>, {<br>uname: ‘lisi’,<br>pwd: 123<br>}).then(function(ret){<br>console.log(ret.data)<br>})</pre><p id="u78ff7760" class="ne-p"><br></p><h4 id="233c4676"><span class="ne-text">axios 全局配置</span></h4><p id="u38b2907f" class="ne-p"><br></p><pre data-language="javascript" id="df418265" class="ne-codeblock language-javascript"># 配置公共的请求头<br>axios.defaults.baseURL = '<a href="https://api.example.com&/#39;">https://api.example.com&#39;</a>;</p><h1 id="配置-超时时间"><a href="#配置-超时时间" class="headerlink" title="配置 超时时间"></a>配置 超时时间</h1><p>axios.defaults.timeout = 2500;</p><h1 id="配置公共的请求头"><a href="#配置公共的请求头" class="headerlink" title="配置公共的请求头"></a>配置公共的请求头</h1><p>axios.defaults.headers.common[‘Authorization’] = AUTH_TOKEN;</p><h1 id="配置公共的-post-的-Content-Type"><a href="#配置公共的-post-的-Content-Type" class="headerlink" title="配置公共的 post 的 Content-Type"></a>配置公共的 post 的 Content-Type</h1><p>axios.defaults.headers.post[‘Content-Type’] = ‘application/x-www-form-urlencoded’;</pre><p id="u2ef7f451" class="ne-p"><br></p><h4 id="1033cbba"><span class="ne-text">axios 拦截器</span></h4><ul class="ne-ul"><li id="ubfe9f05f"><span class="ne-text">请求拦截器 </span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u6ceb58ed"><span class="ne-text">请求拦截器的作用是在请求发送前进行一些操作 </span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u41ad5189"><span class="ne-text">例如在每个请求体里加上 token，统一做了处理如果以后要改也非常容易</span></li></ul></ul></ul><ul class="ne-ul"><li id="u172c0d90"><span class="ne-text">响应拦截器 </span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u14e1cc2d"><span class="ne-text">响应拦截器的作用是在接收到响应后进行一些操作 </span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u83709bf4"><span class="ne-text">例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页</span></li></ul></ul></ul><p id="ucf779962" class="ne-p"><br></p><pre data-language="javascript" id="a98b8a0a" class="ne-codeblock language-javascript"> # 1. 请求拦截器<br>axios.interceptors.request.use(function(config) {<br>console.log(config.url) # 1.1 任何请求都会经过这一步 在发送请求之前做些什么<br> config.headers.mytoken = 'nihao'; # 1.2 这里一定要 return 否则配置不成功<br> return config;<br>}, function(err){<br>#1.3 对请求错误做点什么<br> console.log(err)<br>})<br>#2. 响应拦截器<br>axios.interceptors.response.use(function(res) {<br>#2.1 在接收响应做些什么<br> var data = res.data;<br>return data;<br>}, function(err){<br>#2.2 对响应错误做点什么<br> console.log(err)<br>})</pre><p id="uc8d95269" class="ne-p"><br></p><h3 id="64488f24"><span class="ne-text">async   和 await</span></h3><p id="u82b48a3b" class="ne-p"><br></p><ul class="ne-ul"><li id="u3cf38ea6"><span class="ne-text">async 作为一个关键字放到函数前面 </span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ubfce6595"><span class="ne-text">任何一个</span><code class="ne-code"><span class="ne-text">async</span></code><span class="ne-text">函数都会隐式返回一个</span><code class="ne-code"><span class="ne-text">promise</span></code></li></ul></ul><ul class="ne-ul"><li id="u6be13dda"><code class="ne-code"><span class="ne-text">await</span></code><span class="ne-text">关键字只能在使用</span><code class="ne-code"><span class="ne-text">async</span></code><span class="ne-text">定义的函数中使用 </span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u8e20355b"><span class="ne-text">    await 后面可以直接跟一个 Promise 实例对象</span></li><li id="u8b6a5587"><span class="ne-text">     await 函数不能单独使用</span></li></ul></ul><ul class="ne-ul"><li id="ub0e0500e"><strong><span class="ne-text">async/await 让异步代码看起来、表现起来更像同步代码</span></strong></li></ul><p id="u6f21cfdb" class="ne-p"><br></p><pre data-language="javascript" id="a5228ba3" class="ne-codeblock language-javascript"> # 1. async 基础用法 # 1.1 async 作为一个关键字放到函数前面<br>async function queryData() { # 1.2 await 关键字只能在使用 async 定义的函数中使用<br>await 后面可以直接跟一个 Promise 实例对象<br>var ret = await new Promise(function(resolve, reject){<br>setTimeout(function(){<br>resolve('nihao')<br>},1000);<br>})<br>// console.log(ret.data)<br>return ret;<br>} # 1.3 任何一个 async 函数都会隐式返回一个 promise 我们可以使用 then 进行链式编程<br>queryData().then(function(data){<br>console.log(data)<br>})</p><pre><code>#2.  async    函数处理多个异步函数axios.defaults.baseURL = &#39;http://localhost:3000&#39;;async function queryData() &#123;  # 2.1  添加await之后 当前的await 返回结果之后才会执行后面的代码  var info = await axios.get(&#39;async1&#39;);  #2.2  让异步代码看起来、表现起来更像同步代码  var ret = await axios.get(&#39;async2?info=&#39; + info.data);  return ret.data;&#125;queryData().then(function(data)&#123;  console.log(data)&#125;)&lt;/pre&gt;&lt;p id=&quot;u6573baf6&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;h3 id=&quot;6bd5c268&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;图书列表案例&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;u517958e3&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;h4 id=&quot;c8c9466e&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;1. 基于接口案例-获取图书列表&lt;/span&gt;&lt;/h4&gt;&lt;p id=&quot;u3dacfd29&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;u015ac621&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;导入axios   用来发送ajax&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;ub4e1ebd6&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;把获取到的数据渲染到页面上&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p id=&quot;u12513812&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;pre data-language=&quot;html&quot; id=&quot;9bb861dd&quot; class=&quot;ne-codeblock language-html&quot;&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;grid&quot;&gt;        &lt;table&gt;            &lt;thead&gt;                &lt;tr&gt;                    &lt;th&gt;编号&lt;/th&gt;                    &lt;th&gt;名称&lt;/th&gt;                    &lt;th&gt;时间&lt;/th&gt;                    &lt;th&gt;操作&lt;/th&gt;                &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody&gt;                &lt;!-- 5.  把books  中的数据渲染到页面上   --&gt;                &lt;tr :key=&#39;item.id&#39; v-for=&#39;item in books&#39;&gt;                    &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;                    &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;                    &lt;td&gt;&#123;&#123;item.date &#125;&#125;&lt;/td&gt;                    &lt;td&gt;                        &lt;a href=&quot;&quot;&gt;修改&lt;/a&gt;                        &lt;span&gt;|&lt;/span&gt;                        &lt;a href=&quot;&quot;&gt;删除&lt;/a&gt;                    &lt;/td&gt;                &lt;/tr&gt;            &lt;/tbody&gt;        &lt;/table&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;1.  导入axios&lt;script type=&quot;text/javascript&quot; src=&quot;js/axios.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    /*         图书管理-添加图书     */    # 2   配置公共的url地址  简化后面的调用方式    axios.defaults.baseURL = &#39;http://localhost:3000/&#39;;    axios.interceptors.response.use(function(res) &#123;        return res.data;    &#125;, function(error) &#123;        console.log(error)    &#125;);    var vm = new Vue(&#123;        el: &#39;#app&#39;,        data: &#123;            flag: false,            submitFlag: false,            id: &#39;&#39;,            name: &#39;&#39;,            books: []        &#125;,        methods: &#123;            # 3 定义一个方法 用来发送 ajax            # 3.1  使用 async  来 让异步的代码  以同步的形式书写            queryData: async function() &#123;                // 调用后台接口获取图书列表数据                // var ret = await axios.get(&#39;books&#39;);                // this.books = ret.data;                # 3.2  发送ajax请求  把拿到的数据放在books 里面                this.books = await axios.get(&#39;books&#39;);            &#125;        &#125;,        mounted: function() &#123;            #  4 mounted  里面 DOM已经加载完毕  在这里调用函数            this.queryData();        &#125;    &#125;);&lt;/script&gt;&lt;/pre&gt;&lt;p id=&quot;u2be0c85c&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;h4 id=&quot;0673f2de&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;2   添加图书&lt;/span&gt;&lt;/h4&gt;&lt;p id=&quot;ua674eead&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;ub3ff9d3e&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;获取用户输入的数据   发送到后台&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;u74d1bada&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;渲染最新的数据到页面上&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p id=&quot;u4d20c8cc&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;pre data-language=&quot;javascript&quot; id=&quot;1dac960b&quot; class=&quot;ne-codeblock language-javascript&quot;&gt; methods: &#123;handle: async function()&#123;      if(this.flag) &#123;        // 编辑图书        // 就是根据当前的ID去更新数组中对应的数据        this.books.some((item) =&gt; &#123;          if(item.id == this.id) &#123;            item.name = this.name;            // 完成更新操作之后，需要终止循环            return true;          &#125;        &#125;);        this.flag = false;      &#125;else&#123;        # 1.1  在前面封装好的 handle 方法中  发送ajax请求        # 1.2  使用async  和 await 简化操作 需要在 function 前面添加 async        var ret = await axios.post(&#39;books&#39;, &#123;          name: this.name        &#125;)        # 1.3  根据后台返回的状态码判断是否加载数据        if(ret.status == 200) &#123;         # 1.4  调用 queryData 这个方法  渲染最新的数据          this.queryData();        &#125;      &#125;      // 清空表单      this.id = &#39;&#39;;      this.name = &#39;&#39;;    &#125;,</code></pre><p>}</pre><p id="u2c118c35" class="ne-p"><br></p><h4 id="bd612622"><span class="ne-text">3   验证图书名称是否存在</span></h4><p id="u9579c73b" class="ne-p"><br></p><ul class="ne-ul"><li id="u7fe11b16"><span class="ne-text">添加图书之前发送请求验证图示是否已经存在</span></li><li id="ua57dc009"><span class="ne-text">如果不存在 往后台里面添加图书名称 </span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ua1b6706b"><span class="ne-text">图书存在与否只需要修改 submitFlag 的值即可</span></li></ul></ul><p id="u888b4ab5" class="ne-p"><br></p><pre data-language="javascript" id="4974846d" class="ne-codeblock language-javascript"> watch: {<br>name: async function(val) {<br>// 验证图书名称是否已经存在<br>// var flag = this.books.some(function(item){<br>// return item.name == val;<br>// });<br>var ret = await axios.get('/books/book/' + this.name);<br>if(ret.status == 1) {<br>// 图书名称存在<br>this.submitFlag = true;<br>}else{<br>// 图书名称不存在<br>this.submitFlag = false;<br>}<br>}<br>},</pre><p id="u6dab6b5e" class="ne-p"><br></p><h4 id="d995b8a4"><span class="ne-text">4.   编辑图书</span></h4><p id="u07234a7a" class="ne-p"><br></p><ul class="ne-ul"><li id="ud49280d8"><span class="ne-text">根据当前书的 id 查询需要编辑的书籍</span></li><li id="u265f4eb2"><span class="ne-text">需要根据状态位判断是添加还是编辑</span></li></ul><p id="ub5200ab1" class="ne-p"><br></p><pre data-language="javascript" id="d5ed7649" class="ne-codeblock language-javascript"> methods: {<br>handle: async function(){<br>if(this.flag) {<br>#4.3 编辑图书 把用户输入的信息提交到后台<br>var ret = await axios.put('books/' + this.id, {<br>name: this.name<br>});<br>if(ret.status == 200){<br>#4.4 完成添加后 重新加载列表数据<br>this.queryData();<br>}<br>this.flag = false;<br>}else{<br>// 添加图书<br>var ret = await axios.post('books', {<br>name: this.name<br>})<br>if(ret.status == 200) {<br>// 重新加载列表数据<br>this.queryData();<br>}<br>}<br>// 清空表单<br>this.id = '';<br>this.name = '';<br>},<br>toEdit: async function(id){<br>#4.1 flag 状态位用于区分编辑和添加操作<br>this.flag = true;<br>#4.2 根据 id 查询出对应的图书信息 页面中可以加载出来最新的信息 # 调用接口发送 ajax 请求<br> var ret = await axios.get('books/' + id);<br>this.id = ret.id;<br>this.name = ret.name;<br>},</pre><p id="u5f1250bb" class="ne-p"><br></p><h4 id="532db01b"><span class="ne-text">5 删除图书</span></h4><p id="uea687415" class="ne-p"><br></p><ul class="ne-ul"><li id="ua120d507"><span class="ne-text">把需要删除的 id 书籍 通过参数的形式传递到后台</span></li></ul><p id="uc79e5da3" class="ne-p"><br></p><pre data-language="javascript" id="4e14a36b" class="ne-codeblock language-javascript"> deleteBook: async function(id){<br>// 删除图书<br>var ret = await axios.delete('books/' + id);<br>if(ret.status == 200) {<br>// 重新加载列表数据<br>this.queryData();<br>}<br>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git提交规范</title>
      <link href="/blog/lezklv/"/>
      <url>/blog/lezklv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="xQctS"><span class="ne-text">一、提交格式</span></h2><h3 id="fWntM"><span class="ne-text">commit message格式</span></h3><p id="uf7ca8131" class="ne-p"><br></p><pre data-language="bash" id="8d6732ee" class="ne-codeblock language-bash"><type>(<scope>): <subject></pre><p id="u065d4b06" class="ne-p"><br></p><h3 id="l3coW"><span class="ne-text">type(必须）</span></h3><div class="ne-quote"><p id="u5d05744d" class="ne-p"><span class="ne-text">用于说明git commit的类别，只允许使用下面的标识。</span></p></div><p id="uad66bacc" class="ne-p"><span class="ne-text"><p></span><span class="ne-text">feat：新功能（feature）。<br></span><span class="ne-text">fix/to：修复 bug，可以是 QA 发现的 BUG，也可以是研发自己发现的 BUG。</span></p><ul class="ne-ul"><li id="u12c875ce"><span class="ne-text">fix：产生 diff 并自动修复此问题。适合于一次提交直接修复问题</span></li><li id="u5c601204"><span class="ne-text">to：只产生 diff 不自动修复此问题。适合于多次提交。最终修复问题提交时使用 fix</span></li></ul><p id="u23e52ac0" class="ne-p"><span class="ne-text">docs：文档（documentation）。<br></span><span class="ne-text">style：格式（不影响代码运行的变动）。<br></span><span class="ne-text">refactor：重构（即不是新增功能，也不是修改 bug 的代码变动）<br></span><span class="ne-text">perf：优化相关，比如提升性能、体验。<br></span><span class="ne-text">test：增加测试。<br></span><span class="ne-text">chore：构建过程或辅助工具的变动。<br></span><span class="ne-text">revert：回滚到上一个版本。<br></span><span class="ne-text">merge：代码合并。<br></span><span class="ne-text">sync：同步主线或分支的 Bug。</span></p><p id="uf1d446b1" class="ne-p"><span class="ne-text"></span></p><h2 id="WSJ5U"><span class="ne-text">二、开发流程</span></h2><h3 id="qv5kn"><span class="ne-text">线上库命名</span></h3><p id="u3181e763" class="ne-p"><span class="ne-text">master：测试站的分支</span></p><p id="uc859c8ca" class="ne-p"><span class="ne-text">develop：开发站的分支</span></p><p id="uaca724de" class="ne-p"><span class="ne-text">release：部署到正式站的分支</span></p><h3 id="FDk4H"><span class="ne-text">SOP（开发流程）</span></h3><ul class="ne-ul"><li id="u18088f90"><span class="ne-text">在本地 main 主分支下创建新分支</span></li></ul><pre data-language="bash" id="wf9cu" class="ne-codeblock language-bash">git checkout -b "dev/wzt-feat-newFeature"</pre><ul class="ne-ul"><li id="u22dedb3c"><span class="ne-text">push 即可</span></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Pages相关使用</title>
      <link href="/blog/di1z9u/"/>
      <url>/blog/di1z9u/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p id="ufa614c25" class="ne-p"><br></p><p id="de1ebad5da3c0e3bd4cd013c0f83a645" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="e6f0dfb3669688e4d6e678b424581546" class="ne-p"><span class="ne-text">GitHub Pages是GitHub软件的一个页面展示功能，它可以让展示用户的个人信息，也可以为你在GitHub上存放的一个项目定制一个介绍页面（纯静态网站）</span></p></div><p id="uc5db2a84" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="bc3b62e8d75db827d1d70e537e5dc8d9" class="ne-p"><span class="ne-text">官网地址：</span><a href="https://pages.github.com/" data-href="https://pages.github.com/" target="_blank" class="ne-link"><span class="ne-text">https://pages.github.com/</span></a></p></div><h2 id="9Fzdc"><span class="ne-text">xxxx.github.io仓库的创建</span></h2><p id="2407356f1975125a2e2b5283d83d0e5c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616657760639-b6e36a91-6822-4ea2-9dc4-649ec5ef9768.png" width="946.5" id="uq7fd" class="ne-image"></p><p id="544e007406348ad8a78a58d848512e16" class="ne-p"><span class="ne-text">创建一个用户名.github.io的仓库，这个仓库的主分支下的静态网页就可以被访问到了，比如我创建的wztlink1013.github.io仓库，访问https://</span><span class="ne-text">wztlink1013.github.io就可以访问了。</span></p><div data-type="tips" class="ne-alert"><p id="30310b8dcf5bccddf7464c120ccb417a" class="ne-p"><span class="ne-text">需要注意的有：</span></p><ul class="ne-ul"><li id="f0d52154af71f87642d6892a795f6510"><span class="ne-text">仓库必须有index.html文件</span></li></ul></div><h2 id="FGUZN"><span class="ne-text">gh-pages分支的使用</span></h2><p id="7acd869e25b735376c28f9b9de705127" class="ne-p"><span class="ne-text">其他仓库（非</span><span class="ne-text">wztlink1013.github.io仓库</span><span class="ne-text">）下新建gh-pages分支，则gh-pages分支下的静态网页会被访问到，比如</span></p><p id="6391dbc377f75b6ebff10f9606c08cf5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616658110985-fab12af6-362b-4fca-838c-78441e834197.png" width="945.5" id="GVSVP" class="ne-image"></p><h2 id="t2rYS"><span class="ne-text">私有仓库下的共有Pages</span></h2><div class="ne-quote"><p id="2ff5cde4f41fc3102197d60d810da784" class="ne-p"><span class="ne-text">Caution: This repository is private but the published site will be public.</span></p></div><p id="5321ec21aed43a849bbf3f7b3bd2f4ee" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605229290479-7c20a062-56f7-4f20-af37-b3354ca69daf.png" width="444" id="kY2We" class="ne-image"></p><div data-type="info" class="ne-alert"><p id="18cc8868f75eea8cccafb99312f3920b" class="ne-p" style="text-align: left"><span class="ne-text">简单解释一下就是，仓库虽然是私有的，但是gh-pages下的静态页面将会被公开。</span></p></div><h2 id="APzvq"><span class="ne-text">gh-pages分支下的静态css/js资源加载失败</span></h2><div data-type="danger" class="ne-alert"><p id="db3dcacfae54a3abb5fc50357b91494f" class="ne-p"><span class="ne-text">单个仓库下的gh-pages分支，可能导致静态网页css/js等文件加载不了，问题出在网站的css/js的引用方面上</span></p></div><div data-type="info" class="ne-alert"><p id="6b3fcbcd33adfedd6011d8e32850c38e" class="ne-p"><span class="ne-text">更改_yaml文件下的root的路径即可</span></p></div><p id="7d73561e25360191295833fc10874909" class="ne-p"><br></p><p id="2c6f7525a52c3cad853b4d908f64e5d3" class="ne-p"><strong><span class="ne-text">参考：</span></strong></p><ul class="ne-ul"><li id="d30c6b764a2914ffd6409a9c27e1bb8f"><a href="https://blog.csdn.net/simple_the_best/article/details/53403787" data-href="https://blog.csdn.net/simple_the_best/article/details/53403787" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/simple_the_best/article/details/53403787</span></a></li></ul><h2 id="jQwdq"><span class="ne-text">使用issues搭建博客</span></h2><p id="35828e7be91d937fe56644e6dd47328e" class="ne-p"><span class="ne-text">这个就比较会玩了，将GitHub的API接口玩的溜溜的……</span><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1616657583331-5d034146-804a-44e8-a90e-994f86de946a.gif" width="90" id="NXawR" class="ne-image"></p><p id="474b5f0fec8432240646b6f1df1bed1c" class="ne-p"><span class="ne-text">先插个眼，日后技术学到家再来玩玩这个</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616657633200-0f3a1324-21c2-4165-a23f-9a86ac69f399.jpeg" width="51" id="K09k5" class="ne-image"><strong><span class="ne-text"></span></strong></p><p id="5a0b721b44eef4bfb788a1d78bdbf9be" class="ne-p"><a href="https://github.com/Pines-Cheng/blog" data-href="https://github.com/Pines-Cheng/blog" target="_blank" class="ne-link"></a></p><p id="u456cc46d" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建Windows子系统Linux及其相关命令</title>
      <link href="/blog/xnh83z/"/>
      <url>/blog/xnh83z/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="UX4My"><span class="ne-text">Windows子系统Linux</span></h2><h3 id="XwO7W"><span class="ne-text">子系统Linux下载安装</span></h3><p id="4e3035feeb898199586aa056b29e015c" class="ne-p"><span class="ne-text">在windows里面搜索 </span><code class="ne-code"><span class="ne-text">windows功能</span></code><span class="ne-text"> </span></p><p id="5761e24c746bcd3e5d36e0c19ef1182d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604913834448-30d164c9-e0a6-47f8-baac-03c5d6648186.png" width="588" id="CJVjC" class="ne-image"></p><p id="6a72bcc62e58d8943fdbbcd32a7f095d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604913865729-b20b3a35-ab49-48c9-be97-9f3c56d6d7a6.png" width="311.5" id="HcgSp" class="ne-image"></p><p id="2a32bc760492c78ba1c3b3e58f7f548f" class="ne-p" style="text-align: left"><span class="ne-text">然后已知下一步操作即可，该过程中会有重启的过程。</span></p><p id="ced017f33454563c24be9f6992ba3b43" class="ne-p" style="text-align: left"><span class="ne-text">之后重启之后在应用商店下载Ubuntu系统，如下。</span></p><p id="15a884993b3a19476677fa3af2d9d2e6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604913776014-38c5ce17-996d-4827-8c49-bb047b2f7d3c.png" width="429" id="JGNy1" class="ne-image"></p><p id="b8fd1b4bafb7ec17e8995af2b306bd8d" class="ne-p"><span class="ne-text">然后启动的时候，会有让自己输入用户名和密码的情况。输入确认就好了（</span><strong><span class="ne-text">输入密码的时候，终端内不会显示光标以及输入的字符！但是会有密码验证</span></strong><span class="ne-text">）</span></p><p id="u577779aa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1630977376308-3239ad06-8a3a-406a-8c0f-6ed478ce0c3b.png" width="720" id="u250e6022" class="ne-image"></p><h3 id="igB9b"><span class="ne-text">子系统Linux文件目录</span></h3><pre data-language="powershell" id="kiYdX" class="ne-codeblock">C:\Users\wztli\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\home\wztlink1013</pre><p id="e0a95afc1f4b23caefcfc2b984ae3b49" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604914117863-4fc253c2-1978-44b1-94c6-48e82a3ddf3a.png" width="734" id="t36kI" class="ne-image"></p><p id="40049f7f41fc0cf107deaf3ec57ee67b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604914176405-056c5008-8168-40f8-a599-0e7951cad309.png" width="703" id="VZms0" class="ne-image"></p><h3 id="lDQPU"><span class="ne-text">Linux访问Windows文件</span></h3><p id="b3b2b35022c9ff4e6e66ecd67480ac21" class="ne-p"><span class="ne-text">如下图中1所示，访问时，需要先将Windows磁盘挂载到/mnt下面，然后就可以访问了。</span></p><ul class="ne-ul"><li id="u6d22e418"><span class="ne-text">ls命令：列举指定文件夹下的目录</span></li><li id="u2ae08792"><span class="ne-text">cd命令：在指定文件夹下运行该linux环境</span></li></ul><p id="c8d576d5ba7868e7073068d76e514e94" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604914600884-f758bc8f-668d-4354-be9f-f9be774cfff1.png" width="561" id="HLsJa" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——一切都太迟了</title>
      <link href="/essay/gx3g8t/"/>
      <url>/essay/gx3g8t/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p class="ne-p"><span class="ne-text">那天早上，老康起得很早，五点就起床了，说是要坐车去考教资，然后我突然迷迷糊糊被他起床的动静吵醒了，那天早上，我终于想起了什么…原来，黑魔法是存在的！！！</span></p><p class="ne-p"><br></p><p class="ne-p"><strong><span class="ne-text">和一批人上山</span></strong></p><p class="ne-p"><span class="ne-text">有好几伙人，同时登上山顶，像是被什么所指引那般，都像是阻止什么，又好像是为了得到什么……</span></p><p class="ne-p"><br></p><p class="ne-p"><br></p><p class="ne-p"><strong><span class="ne-text">我的境遇</span></strong></p><p class="ne-p"><span class="ne-text">山顶那个小栈好像是取某个物品，</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">夜晚某个时辰，周围突然陷入黑暗，所有人都匆匆忙忙跑下山，那个客栈里面，大量的黑烟逐渐弥漫开来，我们都内心里面清楚，太迟了，我们都太迟了！</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">我赶紧跑下山，摔到了一个村庄，然后一直跑，跑到我那个伙伴的家里，我看到了我那副眼镜，然后一直跑，跑回我自己的地方了</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]uni-app和传统三剑客的不同</title>
      <link href="/blog/ytoag7/"/>
      <url>/blog/ytoag7/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><ul class="ne-ul"><li id="ubad4eaff"><span class="ne-text">本文转载自：</span><a href="https://ask.dcloud.net.cn/article/35657" data-href="https://ask.dcloud.net.cn/article/35657" target="_blank" class="ne-link"><span class="ne-text">白话uni-app </span></a></li></ul><ul class="ne-ul"><li id="6ba6544d23f398a8960f6ae5dae821ab"><span class="ne-text">添加部分细节自己写的内容</span></li></ul></div><h2 id="Mccdr"><span class="ne-text">uni-app相对传统的变化</span></h2><h3 id="RLvYh"><span class="ne-text">网络模型的变化</span></h3><p id="ebcaec8a3b10504ff3c2aa41ffc29473" class="ne-p"><span class="ne-text">之前学习的</span><code class="ne-code"><span class="ne-text">javaweb</span></code><span class="ne-text">形式的是“相互嵌套”类型的，</span><code class="ne-code"><span class="ne-text">jsp</span></code><span class="ne-text">代码里面可以有</span><code class="ne-code"><span class="ne-text">html</span></code><span class="ne-text">代码。</span></p><p id="1a35de55940356ef052bfd79e6e28878" class="ne-p"><br></p><p id="40bb6b01666167168ba6bc8d9223ff27" class="ne-p"><span class="ne-text">以前网页大多是b/s，服务端代码混合在页面里；</span></p><p id="3edc24628088a12403ee446393d3d0d0" class="ne-p"><span class="ne-text">现在是c/s，前后端分离，通过js api(类似ajax的</span><code class="ne-code"><span class="ne-text">uni.request</span></code><span class="ne-text">)获取json数据，把数据绑定在界面上渲染。</span></p><h3 id="kttYu"><span class="ne-text">文件类型变化</span></h3><p id="56d576e87f2b245fd4ebe9a48f84d520" class="ne-p"><span class="ne-text">.vue文件通过编译，编译js文件</span></p><h3 id="pF3pJ"><span class="ne-text">代码架构大变动</span></h3><p id="bcbd3bdf4f55165fa4acd62129909f55" class="ne-p"><span class="ne-text">以前的HTML代码节点，有html大节点，还有script和style两个小结点</span></p><pre data-language="html" id="Pt5Q7" class="ne-codeblock language-html"><!DOCTYPE html><html>      <head>          <meta charset="utf-8" />          <title></title>          <script type="text/javascript"><pre><code>    &lt;/script&gt;    &lt;style type=&quot;text/css&quot;&gt;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;</code></pre></html></pre><p id="c694d805f0f57a4d0b7ba1b45414995e" class="ne-p"><span class="ne-text">现在template是一级节点，用于写</span><strong><span class="ne-text">tag组件</span></strong><span class="ne-text">，script和style是并列的一级节点，也就是有3个一级节点</span></p><pre data-language="vue" id="6jOG2" class="ne-codeblock language-vue"><template>      <view>      注意必须有一个view，且只能有一个根view。所有内容写在这个view下面。      </view>  </template><script>      export default {      }  </script><style>  </style></pre><ul class="ne-ul"><li id="7ad4d4cc815a0ee78d0a950d94985587"><a href="https://cn.vuejs.org/v2/guide/single-file-components.html" data-href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" class="ne-link"><span class="ne-text">Vue 单文件组件</span></a></li></ul><h3 id="LBmHA"></h3><h3 id="HlgtE"><span class="ne-text">组件/标签的变化</span></h3><p id="3a207791db86c2086991f5cd57eebbe3" class="ne-p"><span class="ne-text">下为html标签和uni-app内置组件的映射表：</span></p><p id="632cb615a76108baf949c94c9af7eefa" class="ne-p"><span class="ne-text">（其实老的HTML标签也可以在uni-app里使用，uni-app编译器会在编译时把老标签转为新标签，比如把div编译成view。但不推荐这种用法，调试H5端时容易混乱。）</span></p><p id="c3cb31d4bdac117320e6640e9b5660b3" class="ne-p"><br></p><ul class="ne-ul"><li id="4e255ed4753d8fbf252b643167f65f1b"><span class="ne-text">div 改成 </span><a href="https://uniapp.dcloud.io/component/view" data-href="https://uniapp.dcloud.io/component/view" target="_blank" class="ne-link"><span class="ne-text">view</span></a></li><li id="24409615974d7473d6ac953aca34c2a7"><span class="ne-text">span、font 改成 </span><a href="https://uniapp.dcloud.io/component/text" data-href="https://uniapp.dcloud.io/component/text" target="_blank" class="ne-link"><span class="ne-text">text</span></a></li></ul><ul class="ne-ul"><li id="aed2e12170278288ede1ba61bdd062e9"><span class="ne-text">a 改成 </span><a href="https://uniapp.dcloud.io/component/navigator" data-href="https://uniapp.dcloud.io/component/navigator" target="_blank" class="ne-link"><span class="ne-text">navigator</span></a></li><li id="5da7ace80da533ed5de82da531ff0c9f"><span class="ne-text">img 改成 </span><a href="https://uniapp.dcloud.io/component/image" data-href="https://uniapp.dcloud.io/component/image" target="_blank" class="ne-link"><span class="ne-text">image</span></a></li></ul><ul class="ne-ul"><li id="bfa4385359d666425f13bb5cfdb7d32d"><a href="https://uniapp.dcloud.io/component/input" data-href="https://uniapp.dcloud.io/component/input" target="_blank" class="ne-link"><span class="ne-text">input</span></a><span class="ne-text"> 还在，但type属性改成了confirmtype</span></li><li id="a1160e6db31323e6661ccf094a56a478"><a href="https://uniapp.dcloud.io/component/form" data-href="https://uniapp.dcloud.io/component/form" target="_blank" class="ne-link"><span class="ne-text">form</span></a><span class="ne-text">、</span><a href="https://uniapp.dcloud.io/component/button" data-href="https://uniapp.dcloud.io/component/button" target="_blank" class="ne-link"><span class="ne-text">button</span></a><span class="ne-text">、</span><a href="https://uniapp.dcloud.io/component/checkbox" data-href="https://uniapp.dcloud.io/component/checkbox" target="_blank" class="ne-link"><span class="ne-text">checkbox</span></a><span class="ne-text">、</span><a href="https://uniapp.dcloud.io/component/radio" data-href="https://uniapp.dcloud.io/component/radio" target="_blank" class="ne-link"><span class="ne-text">radio</span></a><span class="ne-text">、</span><a href="https://uniapp.dcloud.io/component/label" data-href="https://uniapp.dcloud.io/component/label" target="_blank" class="ne-link"><span class="ne-text">label</span></a><span class="ne-text">、</span><a href="https://uniapp.dcloud.io/component/textarea" data-href="https://uniapp.dcloud.io/component/textarea" target="_blank" class="ne-link"><span class="ne-text">textarea</span></a><span class="ne-text">、</span><a href="https://uniapp.dcloud.io/component/canvas" data-href="https://uniapp.dcloud.io/component/canvas" target="_blank" class="ne-link"><span class="ne-text">canvas</span></a><span class="ne-text">、</span><a href="https://uniapp.dcloud.io/component/video" data-href="https://uniapp.dcloud.io/component/video" target="_blank" class="ne-link"><span class="ne-text">video</span></a><span class="ne-text"> 这些还在。</span></li></ul><ul class="ne-ul"><li id="bd7ad6f991ca58f5f706aff94e2dedf8"><span class="ne-text">select 改成 </span><a href="https://uniapp.dcloud.io/component/picker" data-href="https://uniapp.dcloud.io/component/picker" target="_blank" class="ne-link"><span class="ne-text">picker</span></a></li><li id="9cc82dc3f7dc7254643314418fcf795e"><span class="ne-text">iframe 改成 </span><a href="https://uniapp.dcloud.io/component/web-view" data-href="https://uniapp.dcloud.io/component/web-view" target="_blank" class="ne-link"><span class="ne-text">web-view</span></a></li></ul><ul class="ne-ul"><li id="01fff985aaa0340be3a027b5e2016ad8"><span class="ne-text">ul、li没有了，都用view替代</span></li><li id="d7bc5fd904fb0dadea5bafe2db17d6ac"><span class="ne-text">audio 不再推荐使用，改成api方式，</span><a href="https://uniapp.dcloud.io/api/media/background-audio-manager?id=getbackgroundaudiomanager" data-href="https://uniapp.dcloud.io/api/media/background-audio-manager?id=getbackgroundaudiomanager" target="_blank" class="ne-link"><span class="ne-text">背景音频api文档</span></a></li></ul><p id="7bc3d1f997ca7cd71e868a8584667a74" class="ne-p"><br></p><p id="b9f38f797e7f384d256df53af1dbb34b" class="ne-p"><strong><span class="ne-text">除了改动外，新增了一批手机端常用的新组件</span></strong></p><p id="f4168a09a115e90fb56294186737feda" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="e87028913fffc43b8fbd1b093d0c89bd"><span class="ne-text">scroll-view </span><a href="https://uniapp.dcloud.io/component/scroll-view" data-href="https://uniapp.dcloud.io/component/scroll-view" target="_blank" class="ne-link"><span class="ne-text">可区域滚动视图容器</span></a></li><li id="2ee2254baacc1c9a9b9dfe8409990592"><span class="ne-text">swiper </span><a href="https://uniapp.dcloud.io/component/swiper" data-href="https://uniapp.dcloud.io/component/swiper" target="_blank" class="ne-link"><span class="ne-text">可滑动区域视图容器</span></a></li></ul><ul class="ne-ul"><li id="59baaf5b3da38aea050c43584321e50c"><span class="ne-text">icon </span><a href="https://uniapp.dcloud.io/component/icon" data-href="https://uniapp.dcloud.io/component/icon" target="_blank" class="ne-link"><span class="ne-text">图标</span></a></li><li id="45b709aa13192ccfbd0f45e19d4bd93a"><span class="ne-text">rich-text </span><a href="https://uniapp.dcloud.io/component/rich-text" data-href="https://uniapp.dcloud.io/component/rich-text" target="_blank" class="ne-link"><span class="ne-text">富文本（不可执行js，但可渲染各种文字格式和图片）</span></a></li></ul><ul class="ne-ul"><li id="601dfac3262ef5d1e07dde1ddf1085ca"><span class="ne-text">progress </span><a href="https://uniapp.dcloud.io/component/progress" data-href="https://uniapp.dcloud.io/component/progress" target="_blank" class="ne-link"><span class="ne-text">进度条</span></a></li><li id="96914b255c8c1c5025228991554561da"><span class="ne-text">slider </span><a href="https://uniapp.dcloud.io/component/slider" data-href="https://uniapp.dcloud.io/component/slider" target="_blank" class="ne-link"><span class="ne-text">滑块指示器</span></a></li></ul><ul class="ne-ul"><li id="d47efbdb64345227dec5f582c298da55"><span class="ne-text">switch </span><a href="https://uniapp.dcloud.io/component/switch" data-href="https://uniapp.dcloud.io/component/switch" target="_blank" class="ne-link"><span class="ne-text">开关选择器</span></a></li><li id="6bdf801a7c402d35e3bfca4b9b085efb"><span class="ne-text">camera </span><a href="https://uniapp.dcloud.io/component/camera" data-href="https://uniapp.dcloud.io/component/camera" target="_blank" class="ne-link"><span class="ne-text">相机</span></a></li></ul><ul class="ne-ul"><li id="59f95112502b75095d91e671e97acb4a"><span class="ne-text">live-player </span><a href="https://uniapp.dcloud.io/component/live-player" data-href="https://uniapp.dcloud.io/component/live-player" target="_blank" class="ne-link"><span class="ne-text">直播</span></a></li><li id="2f6b7fb99bf9fef8babf652765b3c625"><span class="ne-text">map </span><a href="https://uniapp.dcloud.io/component/map" data-href="https://uniapp.dcloud.io/component/map" target="_blank" class="ne-link"><span class="ne-text">地图</span></a></li></ul><ul class="ne-ul"><li id="cb05de41bb30535b85cfaa1e9d1c1d3d"><span class="ne-text">cover-view </span><a href="https://uniapp.dcloud.io/component/cover-view?id=cover-view" data-href="https://uniapp.dcloud.io/component/cover-view?id=cover-view" target="_blank" class="ne-link"><span class="ne-text">可覆盖原生组件的视图容器</span></a><span class="ne-text"><p></span><span class="ne-text">cover-view 需要多强调几句，uni-app 的非 h5 端的 video、map、canvas、textarea 是原生组件，层级高于其他组件。如需覆盖原生组件，则需要使用 cover-view 组件。详见</span><a href="https://uniapp.dcloud.net.cn/component/native-component" data-href="https://uniapp.dcloud.net.cn/component/native-component" target="_blank" class="ne-link"><span class="ne-text">层级介绍</span></a></li></ul><p id="d34fd7a839ad9fdcc0a9804ee5741bc8" class="ne-p"><br></p><p id="5bbeba8f366e6d98e1225bc30528dfdb" class="ne-p"><span class="ne-text">除了内置组件，还有很多开源的扩展组件，把常用操作都进行封装，DCloud 建立了插件市场收录这些扩展组件，详见</span><a href="https://ext.dcloud.net.cn/" data-href="https://ext.dcloud.net.cn/" target="_blank" class="ne-link"><span class="ne-text">插件市场</span></a></p><p id="efb56410ed896c0cce3e4dba80feb905" class="ne-p"><br></p><p id="794eb5668adde6bdf7e9d61f35d03046" class="ne-p"><span class="ne-text"></span></p><h3 id="WAbDY"><span class="ne-text">工程结构和页面管理</span></h3><p id="ca51688a7f2333de0f6af8af2b824520" class="ne-p"><span class="ne-text">uni-app 的工程结构有单独的要求，</span><a href="https://uniapp.dcloud.io/frame?id=%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84" data-href="https://uniapp.dcloud.io/frame?id=%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84" target="_blank" class="ne-link"><span class="ne-text">详见</span></a></p><p id="97cbbfefc56ed306276570ed088e7782" class="ne-p"><br></p><p id="64f439da9672f579681ec2e5eb5202e1" class="ne-p"><span class="ne-text">每个可显示的页面，都必须在 </span><a href="https://uniapp.dcloud.io/collocation/pages" data-href="https://uniapp.dcloud.io/collocation/pages" target="_blank" class="ne-link"><span class="ne-text">pages.json</span></a><span class="ne-text"> 中注册。如果你开发过小程序，那么 pages.json 类似 app.json。如果你熟悉 vue，这里没有 vue 的路由，都是在 pages.json 里管理。</span></p><p id="66a228827511e0ec374498be516de0e1" class="ne-p"><br></p><p id="74cce9d094f35fb68a981a712a407a49" class="ne-p"><span class="ne-text">原来工程的首页一般是 index.html 或 default.html，是在 web server 里配的。而 uni-app 的首页，是在 pages.json 里配的，page 节点下第一个页面就是首页。一般在/pages/xx 的目录下。</span></p><p id="cb34a01c22f471615ff8401d995599e7" class="ne-p"><br></p><p id="571a4cad666921419fbf536155daa95f" class="ne-p"><span class="ne-text">app 和小程序中，为了提升体验，页面提供了原生的导航栏和底部 tabbar，注意这些配置是在 pages.json 中做，而不是在 vue 页面里创建，但点击事件的监听在显示的 vue 页面中做。</span></p><p id="38afb0fdf574c0ca8d62b5d749ff85b6" class="ne-p"><br></p><p id="d351237eccf285ccc5ed8f7193d00697" class="ne-p"><span class="ne-text">如果你熟悉小程序开发的话，对比变化如下：</span></p><ul class="ne-ul"><li id="f587ced0e0e1f88c0cdafb49730028ae"><span class="ne-text">原来 app.json 被一拆为二。页面管理，被挪入了 uni-app 的 pages.json；非页面管理，挪入了 manifest.json</span></li><li id="552eeda22b7a35141566e09fcf34e86e"><span class="ne-text">原来的 app.js 和 app.wxss 被合并到了 app.vue 中</span></li></ul><h2 id="QSNTK"><span class="ne-text">文件导入方式变化</span></h2><h3 id="d11or"><span class="ne-text">js 引入方式</span></h3><p id="727be6b205b2dd52ff98ba32d4019414" class="ne-p"><span class="ne-text">以前通过</span><code class="ne-code"><span class="ne-text">script </span></code><code class="ne-code"><span class="ne-text">src</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">link </span></code><code class="ne-code"><span class="ne-text">href</span></code><span class="ne-text">引入外部的 js 和 css；</span></p><p id="d8e08a9e55c321dd0b2bf76aa9bad3ce" class="ne-p"><span class="ne-text">现在是</span><strong><span class="ne-text">es6</span></strong><span class="ne-text">的写法，</span><code class="ne-code"><span class="ne-text">import</span></code><span class="ne-text">引入外部的 js 模块(注意不是文件)或 css</span></p><p id="b7c5098c81c981b2c33e60289baca27e" class="ne-p"><span class="ne-text">以前</span></p><pre data-language="javascript" id="0FHD6" class="ne-codeblock language-javascript"><script src="js/jquery-1.10.2.js" type="text/javascript"></script></p><link href="css/bootstrap.css" rel="stylesheet" type="text/css"/></pre><p id="b6ee7580af63b747a2d08cdb65f05b98" class="ne-p"><span class="ne-text">现在</span></p><p id="1e2ffab9bc174de22817fcd7aea61a50" class="ne-p"><br></p><div class="ne-quote"><p id="1279ad8f0cb64fcf5fc702b0c6953dc6" class="ne-p"><span class="ne-text">js要require进来，变成了对象。</span></p></div><p id="9e03fe95aadfeb814e444f6851b39c03" class="ne-p"><br></p><p id="dab91d38ea911e4d17e5bc4d2c5218bb" class="ne-p"><span class="ne-text">在hello uni-app项目的common目录有一个工具类</span><code class="ne-code"><span class="ne-text">util.js</span></code><span class="ne-text">，可以在hello uni-app中搜索这个例子查看。</span></p><p id="ac18c630c0bace00b98773b81eb7de1c" class="ne-p" style="text-align: center"><br></p><pre data-language="javascript" id="FSQJP" class="ne-codeblock language-javascript"><script>  var util = require('../../../common/util.js');  //require这个js模块  var formatedPlayTime = util.formatTime(playTime); //调用js模块的方法  </script></pre><p id="aa83aeddd4d086d2fb198078cee14f60" class="ne-p"><span class="ne-text">而在这个</span><code class="ne-code"><span class="ne-text">util.js</span></code><span class="ne-text">里，要把之前的function封装为对象的方法</span></p><p id="21d9e2e89f696d89c68fc2aaa6373473" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604048264989-b4591bb0-e4bc-4581-aae5-bf7615f268b4.png" width="508" id="wkQ3w" class="ne-image"></p><p id="90bd6a79b321bb863e991ddd6636509c" class="ne-p"><span class="ne-text">当然还有一些高级的用法</span></p><pre data-language="javascript" id="bQ79h" class="ne-codeblock language-javascript">var dateUtils = require('../../../common/util.js').dateUtils; //直接使用js模块的属性。在hello uni-app有示例  import * as echarts from '/components/echarts/echarts.simple.min.js'; //将js导入并重命名为echarts，然后使用echarts.来继续执行方法。</pre><p id="d8cc997c2efccfe55bf3f4862cd39fb9" class="ne-p"><br></p><h3 id="72581a45"><span class="ne-text">CSS引入方式</span></h3><pre data-language="css" id="38pUO" class="ne-codeblock language-css"><style>      @import "./common/uni.css";      .uni-hello-text{          color:#7A7E83;      }  </style></pre><p id="f25884384b253fed473bd0514a0bf3c9" class="ne-p"><strong><span class="ne-text">改全局样式：</span></strong><span class="ne-text">在根目录下的app.vue里写入，每个页面都会加载app.vue里的样式。</span></p><h3 id="0WsT0"><span class="ne-text">组件导入</span></h3><p id="3bd6451b4bff23deea29d99719401c43" class="ne-p"><span class="ne-text">类似hexo博客主题设计一样，能以组件的形式模块化导入。</span></p><p id="31e6ffa0a70c54a96c1c76b3efd249bb" class="ne-p"><span class="ne-text">如下是导入一个角标的组件库，在页面上显示一个abc并且右上角有个数字角标1，</span><a href="http://ext.dcloud.net.cn/plugin?id=21" data-href="http://ext.dcloud.net.cn/plugin?id=21" target="_blank" class="ne-link"><span class="ne-text">详见</span></a></p><pre data-language="vue" id="nzQUj" class="ne-codeblock language-vue"><template>      <view>          <uni-badge text="abc" :inverted="true"></uni-badge><!--3.使用组件-->      </view>  </template>  <script>      import uniBadge from "../../../components/uni-badge.vue";//1.导入组件（这步属于传统vue规范，但在uni-app的easycom下可以省略这步）      export default {          data() {              return {              }          },          components: {              uniBadge //2.注册组件（这步属于传统vue规范，但在uni-app的easycom下可以省略这步）          }      }  </script></pre><p id="fdc34858dcff96b87f6e1cf2c9d745fc" class="ne-p"><span class="ne-text">如需要全局导入vue组件，即每个页面都可以直接使用而不用引用和注册的话，在项目根目录下的main.js里处理。如下是hello uni-app里的例子。</span></p><pre data-language="javascript" id="MhTPa" class="ne-codeblock language-javascript">//main.js  import pageHead from './components/page-head.vue' //导入  Vue.component('page-head', pageHead) //注册。注册后在每个vue的page页面里可以直接使用<page-head></page-head>组件。</pre><p id="758d2e3e83f6519710750264cacbf690" class="ne-p"><span class="ne-text">上述的组件使用方式属于传统vue的概念。uni-app 2.7以后推出了更简单的组件使用技术</span><a href="https://uniapp.dcloud.net.cn/collocation/pages?id=easycom" data-href="https://uniapp.dcloud.net.cn/collocation/pages?id=easycom" target="_blank" class="ne-link"><span class="ne-text">easycom</span></a><span class="ne-text">，无需引用和注册组件，直接在template区域使用组件即可。</span></p><p id="b7443f7afae36687f40ef92e4cf4ea11" class="ne-p"><br></p><h2 id="72505980"><span class="ne-text">js的变化</span></h2><p id="61d502f5529ded98c379a721660f839b" class="ne-p"><span class="ne-text">js的变化，分为</span><strong><span class="ne-text">运行环境变化</span></strong><span class="ne-text">、</span><strong><span class="ne-text">数据绑定模式变化</span></strong><span class="ne-text">、</span><strong><span class="ne-text">api变化</span></strong><span class="ne-text">3部分。</span></p><h3 id="vNdy9"><span class="ne-text">运行环境从浏览器变成v8引擎</span></h3><p id="d27940c658c8e04b1e38b28dd72f9dd4" class="ne-p"><span class="ne-text">标准js语法和api都支持，比如if、for、settimeout、indexOf等。</span></p><p id="f7409cc3b0a94b2da6a5701d47de7f18" class="ne-p"><br></p><p id="53640e60cb3f0408c83c1ce0604faa4b" class="ne-p"><span class="ne-text">但</span><strong><span class="ne-text">浏览器专用的</span></strong><span class="ne-text">window、document、navigator、location对象，包括cookie等存储，</span><strong><span class="ne-text">只有在浏览器中才有</span></strong><span class="ne-text">，app和小程序都不支持。</span></p><p id="b3758dc607e5b8c63fb1bb9d4f411f63" class="ne-p"><br></p><div class="ne-quote"><p id="f5a153969de7c094fb6c2cb34c8246bc" class="ne-p"><span class="ne-text">可能有些人以为js等于浏览器里的js。其实js是ECMAScript组织管理的，浏览器中的js是w3c组织基于js规范补充了window、document、navigator、location等专用对象。</span></p></div><p id="c6566e32ff4d4451f3b14b4f94753bf6" class="ne-p"><span class="ne-text">在uni-app的各个端中，除了h5端，其他端的js都运行在一个独立的v8引擎下，不是在浏览器中，所以浏览器的对象无法使用。如果你做过小程序开发，对此应当很了解。</span></p><p id="2132ef2d9349284fac839a33b387b7d2" class="ne-p"><strong><span class="ne-text">这意味着依赖document的很多HTML的库，比如jqurey无法使用。</span></strong></p><p id="be8fb78e319a400ad87d2e93c547dce6" class="ne-p"><span class="ne-text">当然app和小程序支持web-view组件，里面可以加载标准HTML，这种页面仍然支持浏览器专用对象window、document、navigator、location。</span></p><h3 id="04kae"><span class="ne-text">以前的dom操作，改成vue的MVVM模式</span></h3><p id="c3f9b571fdd117cf94df539bc44d0f5a" class="ne-p"><span class="ne-text">现在前端趋势是去dom化，改用</span><strong><span class="ne-text">mvvm模式，</span></strong><span class="ne-text">更简洁的写法，大幅减少代码行数，同时差量渲染性能更好。</span></p><p id="0e876d2cadaed7ebe773db01b197dcd8" class="ne-p"><span class="ne-text">uni-app使用vue的数据绑定方式解决js和dom界面交互的问题。</span></p><p id="d829eda9aa22a42e4cb1d7bea07ed0e2" class="ne-p"><span class="ne-text">如果你想改变某个dom元素的显示内容，比如一个view的显示文字：</span></p><p id="0c5d88300f29c716b63f06777891275b" class="ne-p"><strong><span class="ne-text">以前</span></strong><span class="ne-text">是</span><span class="ne-text" style="text-decoration: underline">给view设id，然后js里通过选择器获取dom元素，进一步通过js进行赋值操作，修改dom元素的属性或值。</span></p><p id="2e023ff3890e11eef3fc3ae164bfbdfd" class="ne-p"><span class="ne-text">如下演示了一段代码，页面中有个显示的文字区和一个按钮，点击按钮后会修改文字区的值</span></p><pre data-language="html" id="or5BF" class="ne-codeblock language-html"><html>      <head>          <script type="text/javascript">              document.addEventListener("DOMContentLoaded",function () {                  document.getElementById("spana").innerText="456"              })              function changetextvalue () {                  document.getElementById("spana").innerText="789"              }          </script>      </head>      <body>          <span id="spana">123</span>          <button type="button" onclick="changetextvalue()">修改为789</button>      </body>  </html></pre><p id="6e0731a9482a90ca8cfd543cac0f5a5d" class="ne-p"><span class="ne-text">现在的做法，是</span><strong><span class="ne-text">vue的绑定模式</span></strong><span class="ne-text">，给这个</span><strong><span class="ne-text">dom元素绑定一个js变量</span></strong><span class="ne-text">，在script中修改js变量的值，dom会自动变化，页面会自动更新渲染</span></p><pre data-language="vue" id="wAHoO" class="ne-codeblock language-vue"><template>      <view>          <text></text><!-- 这里演示了组件值的绑定 -->          <button :type="buttontype" @click="changetextvalue()">修改为789</button><!-- 这里演示了属性和事件的绑定 -->      </view>  </template>  <script>      export default {          data() {              return {                  textvalue:"123",                  buttontype:"primary"              };          },          onLoad() {              this.textvalue="456"//这里修改textvalue的值，其实123都来不及显示就变成了456          },          methods: {              changetextvalue() {                  this.textvalue="789"//这里修改textvalue的值，页面自动刷新为789              }          }      }  </script></pre><p id="bc368c6ca5fe6f2050365c1ca6c94b50" class="ne-p"><span class="ne-text">注意上述代码中的 </span><code class="ne-code"><span class="ne-text">export default &#123;&#125;</span></code><span class="ne-text"> 里的 </span><code class="ne-code"><span class="ne-text">data(): &#123;return &#123; &#125;&#125;</span></code><span class="ne-text">。</span></p><p id="759ea192959475f38176b131034c1804" class="ne-p"><span class="ne-text">在vue的设计中，这里存放着页面中需要绑定的数据，写在data里，才能被界面正确的绑定和渲染。</span></p><p id="00dd11445938bf5ebda6b987b37578ab" class="ne-p"><span class="ne-text">注意：uni-app的vue页面是vue的单文件组件规范，按照vue的定义只接受 function，必须用 return 包起来。</span></p><p id="417ce279021fdf8ddf1a14640853b25c" class="ne-p"><span class="ne-text">如果你学过小程序的数据绑定，但不了解vue，要注意：</span></p><ul class="ne-ul"><li id="929bdf76b10333306717a395b4a75fa9"><span class="ne-text">小程序的数据绑定参考了vue，但自己修改了一些。在uni-app中只支持标准的vue，不支持小程序的数据绑定语法</span></li><li id="52b04def02fc0f6d1e3f7140967aab91"><span class="ne-text">小程序里的setData在uni-app里并不存在，因为vue是自动双向数据绑定的。直接通过赋值方式修改数据，如果数据绑定到界面上，界面会自动更新渲染</span></li></ul><p id="1dd93bf69cfe5d627fa00d8d4a8b39f6" class="ne-p"><span class="ne-text">从上述示例，还可看出事件的写法变化。</span></p><ul class="ne-ul"><li id="44aa4a140ad05a32b9cec86fd5852be7"><span class="ne-text">以前，元素的事件是用onxxx=""，里面写一段js或引用function的name，比如上述代码中的</span><code class="ne-code"><span class="ne-text">onclick="changetextvalue()"</span></code></li><li id="41867f53cd0d583070e864f28ef3d037"><span class="ne-text">现在，需要在js的</span><code class="ne-code"><span class="ne-text">export default &#123;&#125;</span></code><span class="ne-text"> 里的 </span><code class="ne-code"><span class="ne-text">methods: &#123;&#125;</span></code><span class="ne-text"> 里写一个方法，然后在组件中使用</span><code class="ne-code"><span class="ne-text">@click="changetextvalue()"</span></code></li></ul><p id="18e52674a48b83551b618a7df7f6b177" class="ne-p"><span class="ne-text">在js中，与data和methods平级的，如上述示例代码中的</span><code class="ne-code"><span class="ne-text">onload()</span></code><span class="ne-text">，称为生命周期。在普通vue页面里的生命周期叫页面生命周期。在项目根目录的app.vue文件中的生命周期叫应用生命周期。</span></p><p id="319355b017d6c9bc7d7c2ab484dc551d" class="ne-p"><span class="ne-text">除了</span><code class="ne-code"><span class="ne-text">onload</span></code><span class="ne-text">，还有</span><code class="ne-code"><span class="ne-text">onready</span></code><span class="ne-text">等很多生命周期，具体见</span><a href="https://uniapp.dcloud.io/collocation/frame/lifecycle" data-href="https://uniapp.dcloud.io/collocation/frame/lifecycle" target="_blank" class="ne-link"><span class="ne-text">uni-app的生命周期</span></a></p><p id="8cb769a80e78d931024ec7839dbe5131" class="ne-p"><span class="ne-text">在高级用法里，</span><strong><span class="ne-text">vue支持给组件设ref（引用标记）</span></strong><span class="ne-text">，这类似于之前html中给一个dom元素设id，然后在js中也可以用</span><code class="ne-code"><span class="ne-text">this.$refs.xxx</span></code><span class="ne-text">来获取。如下：</span></p><pre data-language="vue" id="foJ6h" class="ne-codeblock language-vue"><template>    <view>      <view ref="testview">11111</view>      <button @click="getTest">获取test节点</button>    </view>  </template>  <script>  export default {    methods: {      getTest() {        console.log(this.$refs.testview)      }    }  };  </script></pre><h3 id="idCpM"><span class="ne-text">js api的变化</span></h3><p id="1346ad461c78f72851d48b28cd0a04de" class="ne-p"><span class="ne-text">因为uni-app的api是</span><strong><span class="ne-text">参考小程序</span></strong><span class="ne-text">的，所以</span><strong><span class="ne-text">和浏览器的js api</span></strong><span class="ne-text">有很多不同，如</span></p><ol class="ne-ol"><li id="1a12d133b7d0017d5f9f9cbc79f49654"><span class="ne-text">alert,confirm 改成 </span><a href="https://uniapp.dcloud.io/api/ui/prompt?id=showmodal" data-href="https://uniapp.dcloud.io/api/ui/prompt?id=showmodal" target="_blank" class="ne-link"><span class="ne-text">uni.showmodel</span></a></li><li id="00389029828cdf1d3e9ee97783342e14"><span class="ne-text">ajax 改成 </span><a href="https://uniapp.dcloud.io/api/request/request" data-href="https://uniapp.dcloud.io/api/request/request" target="_blank" class="ne-link"><span class="ne-text">uni.request</span></a></li></ol><ol start="3" class="ne-ol"><li id="7716c7c0e7a527c6882fc62a1a1774e4"><span class="ne-text">cookie、session 没有了，local.storage 改成 </span><a href="https://uniapp.dcloud.io/api/storage/storage?id=setstorage" data-href="https://uniapp.dcloud.io/api/storage/storage?id=setstorage" target="_blank" class="ne-link"><span class="ne-text">uni.storage</span></a></li></ol><p id="3fa69db8130011eb01a2a82448359762" class="ne-p"><span class="ne-text">uni-app的js api还有很多，但基本就是小程序的api，把wx.xxx改为uni.xxx即可。</span><a href="https://uniapp.dcloud.io/api/README" data-href="https://uniapp.dcloud.io/api/README" target="_blank" class="ne-link"><span class="ne-text">详见</span></a></p><p id="2acdbf6612454e9d34d591577351d275" class="ne-p"><span class="ne-text">uni-app在不同的端，支持条件编译，无限制的使用各端独有的api，</span><a href="https://uniapp.dcloud.io/platform" data-href="https://uniapp.dcloud.io/platform" target="_blank" class="ne-link"><span class="ne-text">详见条件编译</span></a></p><p id="9dc2e2b51cdc23e965e30caef7c0a9c8" class="ne-p"><br></p><h2 id="61f2d4d5"><span class="ne-text">css的变化</span></h2><p id="4595b3949443db62e1fa2a13906f83c9" class="ne-p"><strong><span class="ne-text">标准的css基本都是支持的。</span></strong></p><h3 id="lfkJR"><span class="ne-text">选择器方面</span></h3><div class="ne-quote"><p id="bc0842daf7756f35541ac204b3449f8e" class="ne-p"><span class="ne-text">有2个变化：</span></p></div><ol class="ne-ol"><li id="f935ec358a77e119b405f3a2af015580"><span class="ne-text">*选择器不支持；</span></li><li id="c3504e842b2d83c37b53e0faf325053f"><span class="ne-text">元素选择器里没有body，改为了page。微信小程序即是如此。</span></li></ol><pre data-language="css" id="IEVRv" class="ne-codeblock language-css">page{  }</pre><ul class="ne-ul"><li id="d839e1a36d35735a80f49e1cd5f6d213"><strong><span class="ne-text">单位方面：</span></strong><span class="ne-text">px无法动态适应不同宽度的屏幕，rem无法用于nvue/weex。如果想使用根据屏幕宽度自适应的单位，推荐使用rpx，全端支持。 </span><a href="https://uniapp.dcloud.io/frame?id=%e5%b0%ba%e5%af%b8%e5%8d%95%e4%bd%8d" data-href="https://uniapp.dcloud.io/frame?id=%e5%b0%ba%e5%af%b8%e5%8d%95%e4%bd%8d" target="_blank" class="ne-link"><span class="ne-text">尺寸单位文档</span></a></li><li id="724ea670a147ba2bf3236d8670b2464a"><strong><span class="ne-text">布局方面：</span></strong><span class="ne-text">uni-app推荐使用flex布局，这个布局思路和传统流式布局有点区别。但flex的特色在于，不管是什么技术都支持这种排版，web、小程序/快应用、weex/rn、原生的iOS、Android开发，全都支持flex。它是通吃所有端的新一代布局方案。相关教程请自行百度学习。</span></li></ul><h3 id="wIidY"><span class="ne-text">flex</span></h3><p id="c33ad76392bd8d676d2e1dc676c2676f" class="ne-p"><span class="ne-text">uni-app的vue文件里支持所有web排版方式，不管是流式还是flex。但nvue里，只支持flex，因为它在app端是使用原生排版引擎渲染的。</span></p><p id="6863d421ba7589a46b08bf2e1aad31c7" class="ne-p"><strong><span class="ne-text">注意css里背景图和字体文件，尽量不要大于40k，因为会影响性能。在小程序端，如果要大于40k，需放到服务器侧远程引用或base64后引入，不能放到本地作为独立文件引用。</span></strong></p><h2 id="7zUoo"><span class="ne-text">参考资料</span></h2><ul class="ne-ul"><li id="7675e633752c3528a0c07510e6739b8a"><a href="https://uniapp.dcloud.net.cn/" data-href="https://uniapp.dcloud.net.cn/" target="_blank" class="ne-link"><span class="ne-text">https://uniapp.dcloud.net.cn/</span></a></li><li id="9e83bf2b1195a1d5c3d28c534686e7a1"><a href="https://cn.vuejs.org/index.html" data-href="https://cn.vuejs.org/index.html" target="_blank" class="ne-link"><span class="ne-text">https://cn.vuejs.org/index.html</span></a></li></ul><ul class="ne-ul"><li id="3955ce6848c09d752bea9078f714ef0f"><span class="ne-text">官方教程：</span><a href="https://ke.qq.com/course/343370" data-href="https://ke.qq.com/course/343370" target="_blank" class="ne-link"><span class="ne-text">uni-app跨平台框架官方教程</span></a></li><li id="985d82d6017ab65b2945babdad6ea901"><a href="https://ask.dcloud.net.cn/article/35657" data-href="https://ask.dcloud.net.cn/article/35657" target="_blank" class="ne-link"><span class="ne-text">白话uni-app </span></a></li></ul><ul class="ne-ul"><li id="e196c8a3b3fba790d9311e27e46ace8a"><span class="ne-text">微信官方文档：</span><a href="https://developers.weixin.qq.com/doc/" data-href="https://developers.weixin.qq.com/doc/" target="_blank" class="ne-link"><span class="ne-text">https://developers.weixin.qq.com/doc/</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web其他知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android平台与开发技术</title>
      <link href="/blog/im0an1/"/>
      <url>/blog/im0an1/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="wFtgu"><span class="ne-text">一、目的</span></h2><p id="a430fa648a590878705a06f4b4e672c2" class="ne-p"><span class="ne-text">大学期间，有没有能够</span><strong><span class="ne-text">有专业能力的项目实战</span></strong><span class="ne-text">。希望在你的将来的简历中加入技术方面的项目介绍。</span></p><h2 id="1WhOi"><span class="ne-text">二、考核方式</span></h2><p id="9044483781dc5c603eb8fbbe1708d60e" class="ne-p"><span class="ne-text">PBL的方式组队，开发一个创意项目。</span><strong><span class="ne-text" style="color: black; font-size: 14px"></span></strong></p><h2 id="l2Bzi"><span class="ne-text">三、课程背景</span></h2><ol class="ne-ol"><li id="1b92fe6abf119f37a57ae13afed757b9"><span class="ne-text">Android平台简介</span></li><li id="efa6b9eb6a54afc4effcb5af9d8fb5df"><span class="ne-text">Google 提供了官方的Android Studio</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="8938dd5195d1139a879a488c711574ca"><span class="ne-text">Java 或者 Kotlin</span></li></ol></ol><ol start="3" class="ne-ol"><li id="dfa4902c3a93e1dfaabce23bb97c52ec"><span class="ne-text">Apple提供了官方的开发环境</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="195e639ea9ad339594bb4a241bc57a28"><span class="ne-text">Swift或者OC</span></li></ol></ol><ol start="4" class="ne-ol"><li id="8c996553d687b1d40c45b0fffbd4228b"><span class="ne-text">Wechat提供了官方的开发环境</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="46b408d3f06910182797a912ffc67592"><span class="ne-text">SNS 排第一的产品；Facebook</span></li><li id="662c3b4293ab748ac551c15e815b4f5e"><span class="ne-text">小程序，JD</span></li></ol></ol><ol start="5" class="ne-ol"><li id="c664d32cf93465a7aa31e944eb588d99"><span class="ne-text">其他平台</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="45b7ee62f30f183188a7fb3531495cf5"><span class="ne-text">百度小程序等</span></li></ol></ol><h2 id="s10gz"><span class="ne-text">四、技术路线</span></h2><ol class="ne-ol"><li id="c1515d008e8899a2eddfc99363cecf68"><span class="ne-text">uni-app 是一个使用 </span><a href="https://vuejs.org/" data-href="https://vuejs.org/" target="_blank" class="ne-link"><span class="ne-text" style="color: black">Vue.js</span></a><span class="ne-text"> 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。</span></li><li id="a0dedc56476c72f211fec397e9017edf"><span class="ne-text">DCloud公司</span><span class="ne-text">拥有500万开发者用户，几十万应用案例、10亿手机端月活用户，数千款uni-app插件、70+微信/qq群。阿里小程序工具官方内置uni-app（</span><a href="https://docs.alipay.com/mini/ide/0.70-stable" data-href="https://docs.alipay.com/mini/ide/0.70-stable" target="_blank" class="ne-link"><span class="ne-text" style="color: black">详见</span></a><span class="ne-text">），腾讯课堂官方为uni-app录制培训课程（</span><a href="https://ask.dcloud.net.cn/article/35640" data-href="https://ask.dcloud.net.cn/article/35640" target="_blank" class="ne-link"><span class="ne-text" style="color: black">详见</span></a><span class="ne-text">），开发者可以放心选择。</span></li></ol><ol start="3" class="ne-ol"><li id="4bd1cf68901330387fa0e7d672502aec"><span class="ne-text">uni-app在手，做啥都不愁。即使不跨端，uni-app也是更好的小程序开发框架（</span><a href="https://ask.dcloud.net.cn/article/35947" data-href="https://ask.dcloud.net.cn/article/35947" target="_blank" class="ne-link"><span class="ne-text" style="color: black">详见</span></a><span class="ne-text">）、更好的App跨平台框架、更方便的H5开发框架。不管领导安排什么样的项目，你都可以快速交付，不需要转换开发思维、不需要更改开发习惯。</span></li></ol><h2 id="Vc49F"><span class="ne-text">五、快速上手+安装环境</span></h2><p id="061f2f100a5606d1a45163bfe7397d1d" class="ne-p"><span class="ne-text">uni-app支持通过可视化界面、</span><a href="https://uniapp.dcloud.io/quickstart?id=%e9%80%9a%e8%bf%87vue-cli%e5%91%bd%e4%bb%a4%e8%a1%8c" data-href="https://uniapp.dcloud.io/quickstart?id=%e9%80%9a%e8%bf%87vue-cli%e5%91%bd%e4%bb%a4%e8%a1%8c" target="_blank" class="ne-link"><span class="ne-text" style="color: black">vue-cli命令行</span></a><span class="ne-text"> 两种方式快速创建项目。</span></p><p id="2fe5e3f9e41c3b6a4cdc7f7d0ab0a84a" class="ne-p"><br></p><h3 id="S71ku"><a href="https://uniapp.dcloud.io/quickstart?id=_1-%e9%80%9a%e8%bf%87-hbuilderx-%e5%8f%af%e8%a7%86%e5%8c%96%e7%95%8c%e9%9d%a2" data-href="https://uniapp.dcloud.io/quickstart?id=_1-%e9%80%9a%e8%bf%87-hbuilderx-%e5%8f%af%e8%a7%86%e5%8c%96%e7%95%8c%e9%9d%a2" target="_blank" class="ne-link"><span class="ne-text" style="color: black">通过</span><span class="ne-text" style="color: black"> HBuilderX </span><span class="ne-text" style="color: black">可视化界面</span></a></h3><ol class="ne-ol"><li id="1474f88fe45df08977bcf3b0bc8e04b4"><span class="ne-text">可视化的方式比较简单，HBuilderX内置相关环境，开箱即用，无需配置nodejs。</span></li><li id="6ede59ec30abf404eea475b21a0bf0fd"><span class="ne-text">开始之前，开发者需先下载安装如下工具：</span></li></ol><ol start="3" class="ne-ol"><li id="512d49462be22bfadf3f137f9b3a3356"><span class="ne-text">HBuilderX：</span><a href="https://www.dcloud.io/hbuilderx.html" data-href="https://www.dcloud.io/hbuilderx.html" target="_blank" class="ne-link"><span class="ne-text" style="color: black">官方</span><span class="ne-text" style="color: black">IDE下载地址</span></a></li><li id="60a9ceb1c37f4d821e3d5fd0a928e1df"><a href="https://www.dcloud.io/hbuilderx.html" data-href="https://www.dcloud.io/hbuilderx.html" target="_blank" class="ne-link"><span class="ne-text">HBuilderX</span></a><span class="ne-text">是通用的前端开发工具，但为uni-app做了特别强化。</span></li></ol><ol start="5" class="ne-ol"><li id="6dff256edff5f7aba4d2c28fab54a1c3"><span class="ne-text">下载App开发版，可开箱即用；如下载标准版，在运行或发行uni-app时，会提示安装uni-app插件，插件下载完成后方可使用。</span></li></ol><p id="5dcbe0eb0cb08128ec21bb8d9c4cc88f" class="ne-p"><br></p><h3 id="o463A"><span class="ne-text">Chrome/最新版Edge</span></h3><ul class="ne-ul"><li id="9eae4ed9d76397fe7c1931914a4c2ccf"><a href="https://www.google.com/intl/zh-CN/chrome/" data-href="https://www.google.com/intl/zh-CN/chrome/" target="_blank" class="ne-link"><span class="ne-text">https://www.google.com/intl/zh-CN/chrome/</span></a></li><li id="a4c98286a364204a25112c044924916d"><span class="ne-text">Edge(最新)浏览器：</span><a href="https://www.microsoftedgeinsider.com/en-us/download" data-href="https://www.microsoftedgeinsider.com/en-us/download" target="_blank" class="ne-link"><span class="ne-text">下载地址（DEV版本会消去插件开发者禁用状态）</span></a></li></ul><h3 id="hTDAB"><span class="ne-text">Android Studio</span></h3><ul class="ne-ul"><li id="8283dfcc39fab7fd48dc4f5c33c55db7"><span class="ne-text">下载地址：</span><a href="https://developer.android.com/studio" data-href="https://developer.android.com/studio" target="_blank" class="ne-link"><span class="ne-text">https://developer.android.com/studio</span></a></li></ul><p id="89650aba5b1293f68db6af17d4c30980" class="ne-p"><span class="ne-text">下载及配置参考：</span></p><ul class="ne-ul"><li id="52e27d13f6a0189f26d90315d010da1d"><a href="https://blog.csdn.net/wangmx1993328/article/details/81905195" data-href="https://blog.csdn.net/wangmx1993328/article/details/81905195" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/wangmx1993328/article/details/81905195</span></a></li><li id="85cbbb78372fd298475b4d086a4aaac5"><a href="https://blog.csdn.net/qq_41976613/article/details/91432304" data-href="https://blog.csdn.net/qq_41976613/article/details/91432304" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/qq_41976613/article/details/91432304</span></a></li></ul><ul class="ne-ul"><li id="c5723aa71b1060727e6d2a47aac1eb58"><a href="https://blog.csdn.net/qq_41976613/article/details/104394870" data-href="https://blog.csdn.net/qq_41976613/article/details/104394870" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/qq_41976613/article/details/104394870</span></a></li><li id="0959b34ab63d0073d22f9b4f9505fcbb"><a href="https://blog.csdn.net/liqz666/article/details/80243836" data-href="https://blog.csdn.net/liqz666/article/details/80243836" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/liqz666/article/details/80243836</span></a></li></ul><ul class="ne-ul"><li id="4caeb6dc6eb34bafc6ff73aa8f35ef4f"><a href="https://blog.csdn.net/weixin_43717445/article/details/108719984" data-href="https://blog.csdn.net/weixin_43717445/article/details/108719984" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/weixin_43717445/article/details/108719984</span></a></li></ul><p id="f04491626a83b4d928d2c368e2213358" class="ne-p"><br></p><h3 id="vesdr"><span class="ne-text">gradle国内源配置方法</span></h3><p id="873847124577992992fbd7c3de0f55f5" class="ne-p"><span class="ne-text">Android Studio在构建项目时会拉取gradle资源，而goole和jcenter在国内的网络环境并不好用，容易产生connect timeout等错误。因此将地址修改成阿里云的国内镜像。<p>一、允许使用 maven 仓库<br>　　点击 File-&gt;Settings 进入设置界面，勾选“Enable embedded Maven repository”，</p><p>二、修改 build.gradle<br>　　在项目文件中找到 build.gradle 文件，修改其中的 buildscript 和 allprojects 地址：</span></p><pre data-language="plain" id="KrzVj" class="ne-codeblock language-plain">buildscript {<br>repositories {<br>maven{ url '<a href="http://maven.aliyun.com/nexus/content/groups/public/&#39;">http://maven.aliyun.com/nexus/content/groups/public/&#39;</a> }<br>maven{ url '<a href="http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;}">http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;}</a><br>}<br>dependencies {<br>classpath 'com.android.tools.build:gradle:3.3.0-alpha13'<br>}<br>}<br>allprojects {<br>repositories {<br>maven{ url '<a href="http://maven.aliyun.com/nexus/content/groups/public/&#39;}">http://maven.aliyun.com/nexus/content/groups/public/&#39;}</a><br>maven{ url '<a href="http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;}">http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;}</a><br>}<br>}<br>task clean(type: Delete) {<br>delete rootProject.buildDir<br>}</pre><p id="2dfb76dc0e465544f79e60b754cdff6c" class="ne-p"><span class="ne-text">gradle 的文件下载下来以后会保存在本地，也有缓存。这意味着不同的项目如果有相同的 gradle 依赖，则不需要重复下载。因此也不是每次打开新项目都需要修改 build.gradle 文件。</span></p><p id="af0d9fdae7327c1072c1ddded689b8df" class="ne-p"><br></p><p id="9494f966c6b80d44a198c0bbbbfc138b" class="ne-p"><span class="ne-text">如果修改 build.gradle 后重新 build 还是有错，可以尝试新建一个相同 API 版本的项目。</span></p><p id="76d7b54fc742727c180b86afb40e4c1d" class="ne-p"><br></p><p id="1075834db39bf8498e36425775590aef" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="c6d3599260af4b650bb04bab2cba8c09"><a href="https://maven.aliyun.com/mvn/guide" data-href="https://maven.aliyun.com/mvn/guide" target="_blank" class="ne-link"><span class="ne-text">阿里云 gradle 配置指南</span></a></li></ul><h2 id="B0xb8"><span class="ne-text">六、考核方式</span></h2><p id="728c439c078640dffd0d5fdebc092a42" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605441751743-cb395908-39ce-4303-ab00-0c885d05abe9.png" width="596" id="f7AlH" class="ne-image"></p><h3 id="Dj7kz"><span class="ne-text">后台技术栈</span></h3><ul class="ne-ul"><li id="d7bb8a3069a37036f90a9c5252d3e769"><span class="ne-text">PHP</span></li><li id="05b756c9e890b0a6619dbaccb84f7262"><span class="ne-text">Node.js</span></li></ul><div class="ne-quote"><p id="c598e1f234658828ea227e2943b0d54a" class="ne-p"><span class="ne-text">JavaScript</span></p><p id="2c3be8ae486e0b66c6152f6575f8b750" class="ne-p"><span class="ne-text">node.js+express+ejs</span></p></div><ul class="ne-ul"><li id="344069b073796e40358350dd05f91fa8"><span class="ne-text">Spring Boot</span></li></ul><div class="ne-quote"><p id="517d81c85eef26ffc04149ae903381f3" class="ne-p"><span class="ne-text">Java 框架，难</span></p></div><ul class="ne-ul"><li id="56cf329068a4870c4f2b91bb32d674a2"><span class="ne-text">数据库</span></li></ul><div class="ne-quote"><ul class="ne-ul"><li id="48a349b15d5c34b22c0e712fe8f210bf"><span class="ne-text">MyBatis-Plus</span></li><li id="2ab15cdde202e46722a666e588c1a5b4"><span class="ne-text">DCloud</span></li></ul></div></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web其他知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++广义表</title>
      <link href="/blog/gosz5u/"/>
      <url>/blog/gosz5u/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="EuQc4"><span class="ne-text">广义表举例</span></h2><p id="u0a224aa8" class="ne-p"><span class="ne-text">.</span></p><p id="ee4d796addaa55869cad32441f7911e2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620291002536-6b098e81-6400-4139-876b-9ef890f1dc71.png" width="668.5" id="mXXFN" class="ne-image"></p><h2 id="hgbWz"><span class="ne-text">广义表的3个重要结论</span></h2><p id="510710ca7be796029c3e34b327515cf5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620291048426-17db6fbb-8972-4d82-980e-6ff303f55752.png" width="704.5" id="Pf4IN" class="ne-image"></p><h2 id="9epRZ"><span class="ne-text">广义表的运算</span></h2><p id="d7254dd7bf9ef5ea4827311af3d85987" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620291080210-d88e7855-41ed-45be-a433-1a60a64d3220.png" width="695" id="uZluo" class="ne-image"></p><p id="10780ef1ec3b884cbd0fbf75d2663be2" class="ne-p"><br></p><h2 id="BqmdO"><span class="ne-text">一些题目</span></h2><div class="ne-quote"><p id="c0344972f68040fb4742717d47307a96" class="ne-p"><span class="ne-text">（13）广义表A=(a,b,(c,d),(e,(f,g)))，则Head(Tail(Head(Tail(Tail(A)))))的值为（  ）。</span></p><p id="7fc6b2939e9c9b2f42cf68d7669f63ed" class="ne-p"><span class="ne-text">A．(g)            B．(d)             C．c            D．d</span></p></div><p id="701b1a41924543f8e69ecc226af11c13" class="ne-p"><span class="ne-text">答案：D</span></p><p id="2666f277f741c10e8574926e17f581c7" class="ne-p"><span class="ne-text">解释：Tail(A)=(b,(c,d),(e,(f,g)))；Tail(Tail(A))=( (c,d),(e,(f,g)))； Head(Tail(Tail(A)))= (c,d)；Tail(Head(Tail(Tail(A))))=(d)；Head(Tail(Head(Tail(Tail(A)))))=d。</span></p><p id="5acd8898c58d06ee125f507d9f6bf8a6" class="ne-p"><br></p><div class="ne-quote"><p id="8332376071039a51004352774c468b65" class="ne-p"><span class="ne-text">（14）广义表((a,b,c,d))的表头是（  ），表尾是（  ）。</span></p><p id="5b4580e7a0b310e036317d20d66c2acb" class="ne-p"><span class="ne-text">A．a              B．( )             C．(a,b,c,d)      D．(b,c,d)</span></p></div><p id="7491c703b0e310e88fac7e1c23695de9" class="ne-p"><span class="ne-text">答案：C、B</span></p><p id="ed8f9bd6f3db6d13a6ac0e4b31898b6c" class="ne-p"><span class="ne-text">解释：表头为非空广义表的第一个元素，可以是一个单原子，也可以是一个子表，((a,b,c,d))的表头为一个子表(a,b,c,d)；表尾为除去表头之外，由其余元素构成的表，表为一定是个广义表，((a,b,c,d))的表尾为空表( )。</span></p><p id="43d06cd5b511dcb9b1482f2c907ecbfc" class="ne-p"><br></p><div class="ne-quote"><p id="04f91434e98e3d2fdf156dd21856a2d2" class="ne-p"><span class="ne-text">（15）设广义表L=((a,b,c))，则L的长度和深度分别为（  ）。</span></p><p id="366e639445d485e8c76d1ad23b69e3c9" class="ne-p"><span class="ne-text">A．1和1          B．1和3          C．1和2          D．2和3  </span></p></div><p id="24e6fbe5058a8ce9e4b95e57abd47ea1" class="ne-p"><span class="ne-text">答案：C</span></p><p id="1eb889738236c426269487ba5ac0fa6f" class="ne-p"><span class="ne-text">解释：广义表的深度是指广义表中展开后所含括号的层数，广义表的长度是指广义表中所含元素的个数。根据定义易知L的长度为1，深度为2。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>周围的喧嚣</title>
      <link href="/essay/nqm77s/"/>
      <url>/essay/nqm77s/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p id="d9a1b748e9d5bf4c733df9798ece4464" class="ne-p"><span class="ne-text">现在的文章，喧嚣</span></p><p id="udd66b3fc" class="ne-p"><br></p><p id="u4baa13e0" class="ne-p"><span class="ne-text">动不动一篇文章出来个广告</span></p><p id="ue0a96af3" class="ne-p"><br></p><p id="u2015d2bc" class="ne-p"><span class="ne-text">目的性太强</span></p><p id="u91c22381" class="ne-p"><br></p><p id="u204225f2" class="ne-p"><span class="ne-text">为了写而写，就像是，文字什么时候变得这么苍白</span></p><p id="ee6aed8d571b29cca6f68bd19bd71169" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>npm- ERR! Unexpected end of JSON input while parsing</title>
      <link href="/blog/gcwu9h/"/>
      <url>/blog/gcwu9h/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="bSDCD"><span class="ne-text">报错信息</span></h2><pre data-language="bash" id="JO7G7" class="ne-codeblock language-bash">npm WARN deprecated circular-json@0.5.9: CircularJSON is in maintenance only, flatted is its successor.<p>npm ERR! Unexpected end of JSON input while parsing near ‘…:”~0.0.0”,”webpack-de’</p><p>npm ERR! A complete log of this run can be found in:<br>npm ERR! C:\文件路径\npm-cache_logs\2018-12-13T10_24_02_151Z-debug.log<br>Package install failed, see above.</pre><p id="06af6ffd74b72b308a7f888280d0fd48" class="ne-p"><span class="ne-text">（具体的报错信息和这个类似）</span></p><p id="f0ded4340ae48e218dd60d4bd9c2fd2c" class="ne-p"><span class="ne-text">升级 hexo5.0 过程中，npm i –save 出错，各种插件都不能很好的下载。</span></p><h2 id="U89GZ"><span class="ne-text">问题解决</span></h2><p id="adc70ba36adaa07c248b88ef1f68e611" class="ne-p"><span class="ne-text">在 node 安装目录下配置的 node_cache 目录里面 </span><code class="ne-code"><span class="ne-text">D:\Develop\nodejs</span></code><span class="ne-text"> </span></p><p id="839f9c58ecba97f26c3f0f8f48df0195" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603808754530-64316710-95b9-4e13-98dd-efda5197f782.png" width="387" id="St4i0" class="ne-image"></p><p id="22bcd7d55023f3a054cde39ab4ca933c" class="ne-p"><span class="ne-text">系统盘的</span><span class="ne-text">AppData/roaming 的文件夹</span><span class="ne-text">并没有一个 npm 的缓存目录，安装 node 的时候将</span><code class="ne-code"><span class="ne-text">D:\Develop\nodejs</span></code><span class="ne-text"> 放到系统环境变量的 Path 路径了。</span></p><p id="247d44e11774504d671a5b636d9d5f2b" class="ne-p"><br></p><p id="f69393bcd16ad38efe00e22913c105cf" class="ne-p"><span class="ne-text">所以只需要一下两条命令即可</span></p><pre data-language="bash" id="WaFOg" class="ne-codeblock language-bash">npm cache clean --force</p><p>npm install</pre><p id="99b8e0cc298119b5e710d71e70bfb0c7" class="ne-p"><strong><span class="ne-text"></span></strong></p><h2 id="NIBxf"><span class="ne-text">参考资料</span></h2><ul class="ne-ul"><li id="8ba0164231157cd10ede4123cde43bb4"><a href="https://stackoverflow.com/questions/53759929/npm-err-unexpected-end-of-json-input-while-parsing" data-href="https://stackoverflow.com/questions/53759929/npm-err-unexpected-end-of-json-input-while-parsing" target="_blank" class="ne-link"><span class="ne-text">stackoverflow-npm ERR! Unexpected end of JSON input while parsing</span></a></li><li id="e6aaaf4d92463f28bc9fa39dd749b86d"><a href="https://www.ruanyifeng.com/blog/2016/01/npm-install.html" data-href="https://www.ruanyifeng.com/blog/2016/01/npm-install.html" target="_blank" class="ne-link"><span class="ne-text">阮一峰-npm 模块安装机制简介</span></a></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《许三观卖血记》</title>
      <link href="/essay/ghwn6o/"/>
      <url>/essay/ghwn6o/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B11%2C0%2C33%5D%2C%5B11%2C0%2C33%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="d4cea9740a69221dffc5f2ba9e3f7db3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">===有一个场景我记得很清楚，当许玉兰被批斗的时候，许三观送饭，在饭下面藏着几块肉，那样的场景，温情脉脉</p><p data-lake-id="602e0d465d59f9fad75c23b850601196" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">还有在家里的时候，玉兰说出自己曾经的种种不堪的事情的时候，许三观为了在几个儿子面前维护玉兰，也同等说出自己的许多不堪的事</p><p data-lake-id="099db7dbd436f79364b4e901ac4c41ff" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">我觉得，这种关系，才像是一起经历过苦难的夫妻作为，那个家庭场景，老实说，我感到很有温度</p><p data-lake-id="c77249fb93f55829de65225e0a08320e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="8f8ff8415a08cea2870450099f3b7f18" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="60c44371af314bbc5d8e0b0bf4f4732b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">===小说最后，让我有点痛心的就是三个儿子对许三观说出的一番话。</p><p data-lake-id="90eca51690bc80a509b2c071009e504b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">子女永远不知道自己父母付出的有多少</p><p data-lake-id="51af3b00918ea9ababfabf97a0ea1618" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">好在身边一直有的是玉兰。</p><p data-lake-id="05202ccf59cd392160058e84b14fb836" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="110d2cf60e2d3d58c9c7b87d2daa4645" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="e73f342f845d00a5ef9992ee105dde8f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">===突然又想到《活着》，突然又想到富贵的人生似乎更为惨淡，一生下来，经历种种苦楚，最后的人生和一头老牛在田野远远望去</p><p data-lake-id="f93769d5a9c011b9344ab9683729bcdb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">家珍，还有一个女儿，一个儿子…说实话，他们的结局，也是挺悲惨的……</p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CPP-LINK : fatal error LNK1561: 必须定义入口点</title>
      <link href="/blog/oyvpk4/"/>
      <url>/blog/oyvpk4/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h2 data-lake-id="7faede1978a2c691d05c770ba738ccb3" id="Ut5od" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">问题描述</h2><div data-card-type="block" data-lake-card="codeblock" id="NDNri" class="lake-card-margin" data-language="cpp"><div class="lake-codeblock-content" style="border: 1px solid rgb(232, 232, 232); max-width: 750px; color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: rgb(249, 249, 249);"><div class="CodeMirror-sizer" style="color: rgb(89, 89, 89); margin: 0px; padding: 16px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><pre class="cm-s-default" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">LINK</span> : <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">fatal</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">error</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">LNK1561</span>: <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">必须定义入口点</span></span></span></pre></div></div></div><h2 data-lake-id="1c3e891f67453a2bdd97cceb49617f4f" id="bcHsw" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">问题解决</h2><p data-lake-id="3bf55654de9f46939d894f3feda2d972" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">每个应用程序(文件格式为exe)都应该有个启动点，这个点就是main函数。缺少就会出现link error 。</p><p data-lake-id="8c3267d446f144093717a985f98e93ca" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="49e6c6c970d4e5a85be40a573a1eb2a7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">解决方法</p><ol data-lake-id="9dfa7d1a8ec54d744a3404b36ddcca3e" start="1" lake-indent="0" style="list-style-type: decimal; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="b0382fb3b6197c45d06a05695dfb00bf">添加含有main函数的CPP文件</li><li data-lake-id="c25c54f7b55f752b8ec14229b21dec0a">右击属性，在常规项中修改配置类型，将应用程序修改为库，动静态库</li></ol></div>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++随机字符串生成函数</title>
      <link href="/blog/zeszpb/"/>
      <url>/blog/zeszpb/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="512ec903a675f1d65946a0ae6c669460" class="ne-p"><br></p><p id="ufa821b96" class="ne-p"><br></p><pre data-language="cpp" id="HnEbN" class="ne-codeblock language-cpp">//C++ 随机字符串生成函数<p>#include<iostream><br>#include<ctime><br>using namespace std;</p><p>const int LEN_NAME=4;</p><p>char *rand_str(char *str,const int len)<br>{<br>int i;<br>for(i=0;i&lt;len;++i)<br>str[i]=’A’+rand()%26;<br>str[++i]=’\0’;<br>return str;<br>}</p><p>void main()<br>{<br>srand(time(NULL));<br>int i;<br>char name[LEN_NAME+1];</p><pre><code>for(i=0;i&lt;20;++i)&#123;    cout&lt;&lt;rand_str(name,LEN_NAME)&lt;&lt;endl;&#125;</code></pre><p>}</pre><p id="a5fd2b717bc3549e236bcb1670a6c8c2" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分治算法+归并排序</title>
      <link href="/blog/ab9fkt/"/>
      <url>/blog/ab9fkt/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="cfcVz"><span class="ne-text">分治算法</span></h2><p id="35aafef4a9bcda56fd4b3dba1a40d2bd" class="ne-p"><span class="ne-text">此前学习的</span><strong><span class="ne-text">递归设计方法</span></strong><span class="ne-text">，是针对规模大的问题拆成规模小的问题，并且规模大的问题和规模小的问题的解决办法相同。</span></p><p id="c255444429f9bde357299190cda1ce10" class="ne-p"><span class="ne-text">分治算法与递归设计方法的不同之处就是，该规模较大的问题分解为多个不重叠的子问题，并将其称为</span><strong><span class="ne-text">“分而治之”</span></strong></p><p id="f5da9f304053283051d36c3209602cb2" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="f7be74539c18b7442691d70eaff3e713" class="ne-p"><span class="ne-text">分治的三个步骤：</span></p><ol class="ne-ol"><li id="f57c5c6c8a092421769e80ff6e62e52e"><span class="ne-text">分解：将原问题分解为若干个规模较小、相互不重叠与原问题形式相同的子问题</span></li><li id="69c2c7d170be1f23ed1ada962ac0a89c"><span class="ne-text">解决：</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="5caa5d0a43955bb47e82d0562c29ac25"><span class="ne-text">若子问题规模较小且易于解决时候直接解出</span></li><li id="7637769c316422d46a9df77dc13cbd48"><span class="ne-text">否则递归地解决各个子问题</span></li></ol></ol><ol start="3" class="ne-ol"><li id="c28caab89b84198c68a66eeaa4db0791"><span class="ne-text">合并：将各个子问题的解个并未原问题的解</span></li></ol><p id="66b67bebe7070a915d898cf3fe17d3c4" class="ne-p"><br></p><h2 id="eyoCp"><span class="ne-text">归并排序</span></h2><h3 id="MwiZs"><span class="ne-text">问题分析</span></h3><ul class="ne-ul"><li id="f1be42afae72c8b1f39e714ade5bd973"><span class="ne-text">分解：将排序数组分解为左右两个相等的不重叠的数组</span></li><li id="478a66cbae93c17af3e2defd24c869a3"><span class="ne-text">解决：递归</span></li><li id="cc673598dbfe5bbab9b7e8308ee61396"><span class="ne-text">合并：将两个已经有序的数组合并为一个有序的数组</span></li></ul><p id="d13888f50bb29ce34b29389eced48dfe" class="ne-p"><br></p><p id="dd044635c677c7d57855fe4bb0139137" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603617542157-07613fda-ebed-4924-bf6a-091c19b12fc7.png" width="447.5" id="UFs9X" class="ne-image"></p><h3 id="vaZYS"><span class="ne-text">代码实现</span></h3></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 分治算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA-控制台输出中文乱码问题</title>
      <link href="/blog/lkgrkx/"/>
      <url>/blog/lkgrkx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h2 data-lake-id="3445993c8397f923f593148c9678b2be" id="12NJp" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">问题描述</h2><p data-lake-id="27cf45e30730ae904801551a4fd45618" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">在java实现ping/tracert两个命令时候，输出到控制台里面中文乱码。</p><h2 data-lake-id="e41747057624da1fda53f1692c2abf8b" id="6Mrsg" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">问题分析</h2><p data-lake-id="aa4133aacb145f7a60e48ec97e02b1ff" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">应该是调用了终端，而windows的终端默认是GBK的编码，所以要对其更改管用的utf-8编码，改为GBK编码。</p><p data-lake-id="bf8885768c610002aed1a805dff4db9e" style="text-align: center; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613519544-dc851d0f-e0c0-4a0a-9a2d-0043285b3db0.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="441px" style="visibility: visible; width: 353px;"></span></p><h2 data-lake-id="e6d5080eb6263c31f10245126b9c609a" id="nikHe" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">问题解决</h2><h3 data-lake-id="a77363c514edff9c5855074c2adede07" id="9YLoX" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">编码更改</h3><p data-lake-id="8232504546bba3aebade5ca7d951282f" style="text-align: center; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613302488-7bd6d045-81c3-470c-a57c-05a020588fcd.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="511px" style="visibility: visible; width: 724.5px;"></span></p><p data-lake-id="028c31c7314a8565212d048087ec748e" style="text-align: center; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613687953-21f1bbc9-b0bc-4db4-a935-3fcf6275909f.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="185px" style="visibility: visible; width: 960px;"></span></p><p data-lake-id="45a541a368680486dfd89aed4c5900ab" style="text-align: center; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613719305-ac9dc39b-2c6a-4350-9f31-49d48dbedfe5.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="110px" style="visibility: visible; width: 382px;"></span></p><ul data-lake-id="ad98330023369022e7c492b154832ac9" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="31314182133023b36174255e06cef8e6"><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Reload</code> 表示使用新编码重新加载，新编码不会保存到文件中</li><li data-lake-id="645132a8a849b3c30b2b2b05e47511c3"><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Convert</code> 表示使用新编码进行转换，新编码会保存到文件中</li><li data-lake-id="54c65ef286ef227dae57eaf3b6cce40f">含有中文的代码文件，<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Convert</code> 之后可能会使中文变成乱码，所以在转换成请做好备份，不然可能出现转换过程变成乱码，无法还原</li></ul><h3 data-lake-id="d617008360d65738588699c203e3edf4" id="qL8ve" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">BOM问题</h3><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="4f754943ed27cdaf17e219840aa83198" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>BOM：byte-order mark 字节顺序标记</span></p><p data-lake-id="7e72738ee6656e87f9aeb8c7d67711a4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F" target="_blank">https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F</a></p></blockquote><p data-lake-id="c186f2a92de8812276f9c8df946d62dc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="e4bd50c23f781957256b7bc15a11fb39" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">可能会出现的问题有：</p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="dc869bf9f63b3fd02cd80938c3fc3072" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">编译报错：<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">找不到符号</code>、<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">未结束的字符串文字</code> 或者是 提示 <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">非法字符</code></p></blockquote><p data-lake-id="d03a593e0d7aec1949563aa2a6a50e3b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="0fa9f222416e1c1f128b3ed7afb5660e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">解决办法：有上述百科可知，UTF-8编码分有BOM和无BOM两种分类。IDEA打开Eclipse项目，会提示出现上述编译问题，因为<strong>Eclipse默认是有BOM的文件编译</strong>，而<strong>IDEA只能编译无BOM的文件编译</strong>，所以解决办法就是对项目进行<strong>BOM去除</strong>操作。</p><p data-lake-id="c01cd8ce07fe1dc7047ba8953b14a750" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>莱文斯坦距离(LD)问题</title>
      <link href="/blog/bvk4ok/"/>
      <url>/blog/bvk4ok/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><h2 id="IPeo8"><span class="ne-text">问题描述</span></h2><p id="50f7f61626c9cea10ad11df3d32e6d78" class="ne-p"><strong><span class="ne-text">Levenshtein Distance</span></strong><span class="ne-text">也称</span><strong><span class="ne-text">莱文斯坦距离</span></strong></p><p id="94b372e58c2def29b24b287d2ca70e56" class="ne-p"><br></p><p id="c891008a0ab5f196e1064f8395543d31" class="ne-p"><span class="ne-text">具体形式就是求一个字符串到另一个字符串所需要的</span><strong><span class="ne-text">最少操作步数</span></strong><span class="ne-text">，操作形式有：</span></p><ul class="ne-ul"><li id="db162df517a0dcc5c15edc37ba727945"><span class="ne-text">替换字母</span></li><li id="6dfe0c3dfb3d85638d4936ba5d511017"><span class="ne-text">删除字母</span></li><li id="15fa4b9d318b31488329c0948ec7bede"><span class="ne-text">插入字母</span></li></ul><h2 id="lrKvr"><span class="ne-text">问题分析</span></h2><p id="d4286e3fb8b1a8b8b8cfa22c583b466f" class="ne-p"><span class="ne-text">利用动态规划思想，将其剖析为一个个子问题，用其子问题的解决方式来解决该问题。问题分解出来的子问题存在重叠的情况，这是区分分治算法的不同。</span></p><p id="84e9545dbb3cf8bc12a504de0b98e08c" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603615056984-36cbce7c-c55e-456a-bb90-eb18471167e0.png" width="513" id="qpRoD" class="ne-image"></p><p id="31510a6c776efeddd9241dda48ae654c" class="ne-p"><br></p><p id="8cc72b13408e66840d6974e7da61d8b3" class="ne-p"><strong><span class="ne-text">莱文斯坦的公式化</span></strong><span class="ne-text">表述为：</span></p><p id="8de07f27492486c9eada6c9e310e1aed" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603614727015-dad259b0-7904-4e5d-9ec8-f4ac284af2e5.png" width="437" id="OLKIR" class="ne-image"></p><p id="edf04eb3be987bfa921b098a3ba8ea53" class="ne-p"><br></p><p id="a30741b57baf655228acfec9a9c39546" class="ne-p"><span class="ne-text">下面利用表格的形式来步步推出该字母所需要达到相应的目标字母序列的步数。</span></p><table id="3PvI2" class="ne-table" style="width: 594px"><tbody><tr style="height: 33px"><td width="86" style="background-color: #F5F5F5"><p id="f3e472ab12f9966dab4e6b74aeb56b9d" class="ne-p"><br></p></td><td width="95" style="background-color: #F5F5F5"><p id="f16c561e219b1ff75664df8f04727ca0" class="ne-p"><span class="ne-text" style="color: #F5222D"></span></p></td><td width="97" style="background-color: #F5F5F5"><p id="67673e77ebf482a713c4c13946c504d4" class="ne-p"><span class="ne-text">s</span></p></td><td width="164" style="background-color: #F5F5F5"><p id="70a201ceeb03fa2fe27ea15b1fb4f457_p_0" class="ne-p"><span class="ne-text">o</span></p></td><td width="152" style="background-color: #F5F5F5"><p id="fc06ea377ed3bb2f227b8d21f4771bce_p_0" class="ne-p"><span class="ne-text">n</span></p></td></tr><tr style="height: 33px"><td width="86" style="background-color: #F5F5F5"><p id="80541b5a35403e1d0187d5985b6ce42e" class="ne-p"><span class="ne-text" style="color: #F5222D"></span></p></td><td width="95" style="background-color: #F5F5F5"><p id="515141c761d1a2676477bcc490f86bc4_p_0" class="ne-p"><span class="ne-text">0</span></p></td><td width="97" style="background-color: #F5F5F5"><p id="f5288918051daac58a0cdf74b1d666a8_p_0" class="ne-p"><span class="ne-text">1</span></p></td><td width="164" style="background-color: #F5F5F5"><p id="2437cac6ad8f03448ae403be9a3af9ed_p_0" class="ne-p"><span class="ne-text">2</span></p></td><td width="152" style="background-color: #F5F5F5"><p id="51d6cd746c79a513e0ce3a75ec25e3f9_p_0" class="ne-p"><span class="ne-text">3</span></p></td></tr><tr style="height: 33px"><td width="86" style="background-color: #F5F5F5"><p id="f699b6228a0ee572bf4fb4d49a92b3a0_p_0" class="ne-p"><span class="ne-text">s</span></p></td><td width="95" style="background-color: #F5F5F5"><p id="u6d4d522e" class="ne-p"><span class="ne-text">1</span></p></td><td width="97" style="background-color: #F5F5F5"><p id="uc8d8518d" class="ne-p"><span class="ne-text">0</span></p></td><td width="164" style="background-color: #F5F5F5"><p id="u7b01e8b3" class="ne-p"><span class="ne-text">1</span></p></td><td width="152" style="background-color: #F5F5F5"><p id="ud61300b3" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="86" style="background-color: #F5F5F5"><p id="d494e79b3ef38df3865761fcf4432084_p_0" class="ne-p"><span class="ne-text">u</span></p></td><td width="95" style="background-color: #F5F5F5"><p id="ueead533a" class="ne-p"><span class="ne-text">2</span></p></td><td width="97" style="background-color: #F5F5F5"><p id="u5ea1e755" class="ne-p"><span class="ne-text">1</span></p></td><td width="164" style="background-color: #F5F5F5"><p id="u14510cdb" class="ne-p"><span class="ne-text">1</span></p></td><td width="152" style="background-color: #F5F5F5"><p id="ub7b1b851" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="86" style="background-color: #F5F5F5"><p id="u39513c29" class="ne-p"><span class="ne-text">n</span></p></td><td width="95" style="background-color: #F5F5F5"><p id="ucc281d76" class="ne-p"><span class="ne-text">3</span></p></td><td width="97" style="background-color: #F5F5F5"><p id="ua96d5dd5" class="ne-p"><span class="ne-text">2</span></p></td><td width="164" style="background-color: #F5F5F5"><p id="u9393e833" class="ne-p"><span class="ne-text">2</span></p></td><td width="152" style="background-color: #F5F5F5"><p id="u9eb8ca53" class="ne-p"><span class="ne-text">1</span></p></td></tr></tbody></table><p id="4e386a904d040c2995c6a0aeb36c5c74" class="ne-p"><span class="ne-text">记横（son）为i字符串序列，纵（sun）为j字符串序列。需要完成的字符串变换为i->j。现举例格子数值该怎么填：</span></p><p id="4581bb5d4677bbf6b767df7cfccb3152" class="ne-p"><br></p><p id="f7d67b4bb4a022d082b6bc52dd63ad43" class="ne-p"><span class="ne-text">当到了第三行第三列的那一格，需要完成s->s，有三种情况可以选择</span></p><ol class="ne-ol"><li id="40767cc511a12f666908c40020a80f19"><span class="ne-text">左操作(i-1,j)：删除s字符然后插入s字符===操作步数两步</span></li><li id="d108b1360974e2c055f24f1db19dcd20"><span class="ne-text">上操作(i,j-1)：插入s字符然后删除s字符===操作步数两步</span></li><li id="38d82807972ec8c28f30be0d048dc363"><span class="ne-text">左上操作(i-1,j-1)：替换步骤，因为这个元素相同，故===操作步数零部</span></li></ol><p id="d7ce6a0e344a6a4058733108d421bc30" class="ne-p"><span class="ne-text">然后选取上述三种情况最短步数的数值0</span></p><p id="3a7417d853b4f22e665459afbcacb791" class="ne-p"><br></p><p id="624cd4681ef4cf611d94acb24b00a849" class="ne-p"><span class="ne-text">然后再看第三行第四列，需要完成so->s，</span></p><ol class="ne-ol"><li id="c192fffaeebe1cf6aa83be59c62e3b56"><span class="ne-text">左操作：删除o===一步</span></li><li id="cbf04063dd6b83559883d81d2bbc92ac"><span class="ne-text">上操作：插入s删除so===三步</span></li><li id="eb344f34b82fb264eec4412eda9da4e3"><span class="ne-text">做上操作：替换s删除o===两步</span></li></ol><p id="6419b9242f10f326ff180798ce0d0fe5" class="ne-p"><span class="ne-text">综上应该填1</span></p><p id="d9647893b32b0b730cdb4c275a3fec91" class="ne-p"><br></p><p id="ee64389c1d418a3ad8262bd7f919a8dc" class="ne-p"><span class="ne-text">其他格子也一样以上述方法填写。</span></p><p id="0a7afece280e72a6e374318d8becb0fb" class="ne-p"><br></p><p id="12d3e2d8ce5ff3c66eeb2a69e61a0787" class="ne-p"><span class="ne-text">有个作业遗留问题，在CAAIS里面每个得出的值右上标的 </span><code class="ne-code"><span class="ne-text">U</span></code><span class="ne-text">  </span><code class="ne-code"><span class="ne-text">L</span></code><span class="ne-text">  </span><code class="ne-code"><span class="ne-text">0</span></code><span class="ne-text">  </span><code class="ne-code"><span class="ne-text">1</span></code><span class="ne-text">  这些的依次顺序是怎么个顺序？ </span></p><p id="699db9ca10ac4e09d630178423ea19f9" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603615446981-23bea432-08ee-490a-9037-018ba6280c3b.png" width="325.5" id="C4QpM" class="ne-image"></p><p id="4b29ce52a9487cf0312dd1d7b8a78017" class="ne-p"><br></p><h2 id="zQ0uK"><span class="ne-text">代码实现</span></h2><pre data-language="cpp" id="fstVV" class="ne-codeblock language-cpp">#include <string><p>#include <vector><br>#include <algorithm><br>#include<iostream><br>#include<ctime></p><p>const int LEN_NAME=100;</p><p>namespace NS_LSEditDist {<br>using namespace std;<br>void Initialization(const string &amp;x, const string &amp;y);<br>int GetLSEditDist(const string &amp;x, const string &amp;y);<br>void GetLSEdits(const string &amp;x, const string &amp;y);<br>void Output(const string &amp;x, const string &amp;y, int OptD);<br>void OutputE(const string &amp;x, const string &amp;y);<br>void OutputP(const string &amp;x, const string &amp;y);<br>static int m, n;<br>static vector&lt;vector<int>&gt; E;<br>static vector&lt;vector<char>&gt; P;<br>static string xe, ye;<br>void LSEditDistCaller(const string &amp;x, const string &amp;y)<br>{<br>Initialization(x, y);<br>int OptD = GetLSEditDist(x, y);<br>GetLSEdits(x, y);<br>Output(x, y, OptD);<br>}<br>int GetLSEditDist(const string &amp;x, const string &amp;y)<br>{<br>for (int i = 1; i &lt;= m; i++)<br>for (int j = 1; j &lt;= n; j++)<br>{<br>E[i][j] = min(E[i - 1][j] + 1,<br>min(E[i][j - 1] + 1,<br>E[i - 1][j - 1] + (x[i - 1] != y[j - 1])));<br>if (E[i][j] == E[i - 1][j] + 1)<br>P[i][j] = ‘U’;<br>else if (E[i][j] == E[i][j - 1] + 1)<br>P[i][j] = ‘L’;<br>else if (x[i - 1] != y[j - 1])<br>P[i][j] = ‘1’;<br>}<br>return E[m][n];<br>}<br>void GetLSEdits(const string &amp;x, const string &amp;y)<br>{<br>int i = m, j = n;<br>while (i &gt; 0 || j &gt; 0)<br>{<br>if (P[i][j] == ‘0’ || P[i][j] == ‘1’)<br>{<br>xe.insert(0, 1, x[i - 1]);<br>ye.insert(0, 1, y[j - 1]);<br>i–; j–;<br>}<br>else if (P[i][j] == ‘U’)<br>{<br>xe.insert(xe.begin(), x[i - 1]);<br>ye.insert(ye.begin(), ‘-‘);<br>i–;<br>}<br>else<br>{<br>xe.insert(xe.begin(), ‘-‘);<br>ye.insert(ye.begin(), y[j - 1]);<br>j–;<br>}<br>}<br>}<br>void Initialization(const string &amp;x, const string &amp;y)<br>{<br>m = x.length();<br>n = y.length();<br>E.clear();<br>E.resize(m + 1, vector<int>(n + 1, 0));<br>P.clear();<br>P.resize(m + 1, vector<char>(n + 1, ‘0’));<br>for (int j = 1; j &lt;= n; j++)<br>{<br>E[0][j] = j;<br>P[0][j] = ‘L’;<br>}<br>for (int i = 1; i &lt;= m; i++)<br>{<br>E[i][0] = i;<br>P[i][0] = ‘U’;<br>}<br>xe.clear();<br>ye.clear();<br>}<br>void Output(const string &amp;x, const string &amp;y, int OptD)<br>{<br>printf(“Levenshtein distance: \n”);<br>printf(“Strings: %s, %s\n\n”, x.c_str(), y.c_str());<br>OutputE(x, y);<br>OutputP(x, y);<br>printf(“Distance: %d\n”, OptD);<br>printf(“Edited strings:\n”);<br>for (auto c : xe)<br>printf(“%2c”, c);<br>printf(“\n”);<br>for (auto c : ye)<br>printf(“%2c”, c);<br>printf(“\n\n”);<br>}<br>void OutputE(const string &amp;x, const string &amp;y)<br>{<br>printf(“ E “);<br>for (int j = 0; j &lt; n; j++)<br>printf(“%2c”, y[j]);<br>printf(“\n”);<br>for (int i = 0; i &lt;= m; i++)<br>{<br>if (i == 0)<br>printf(“ “);<br>else<br>printf(“%2c”, x[i - 1]);<br>for (int j = 0; j &lt;= n; j++)<br>{<br>printf(“%2d”, E[i][j]);<br>}<br>printf(“\n”);<br>}<br>printf(“\n”);<br>}<br>void OutputP(const string &amp;x, const string &amp;y)<br>{<br>printf(“ P “);<br>for (int j = 0; j &lt; n; j++)<br>printf(“%2c”, y[j]);<br>printf(“\n”);<br>for (int i = 0; i &lt;= m; i++)<br>{<br>if (i == 0)<br>printf(“ “);<br>else<br>printf(“%2c”, x[i - 1]);<br>for (int j = 0; j &lt;= n; j++)<br>{<br>printf(“%2c”, P[i][j]);<br>}<br>printf(“\n”);<br>}<br>printf(“\n”);<br>}<br>} //namespace NS_LSEditDist<br>char *rand_str(char *str,const int len)<br>{<br>int i;<br>for(i=0;i&lt;len;++i)<br>str[i]=’a’+rand()%26;<br>str[++i]=’\0’;<br>return str;<br>}<br>using namespace NS_LSEditDist;<br>int main()<br>{<br>vector&lt;vector<string>&gt; abs = {<br>{ “water”, “wheat” },<br>{ “servant”, “reveal” }<br>};<br>for (auto ab : abs)<br>{<br>string a = ab[0];<br>string b = ab[1];<br>LSEditDistCaller(a, b);<br>}</p><pre><code>cout&lt;&lt;&quot;两个100位字符串的LevenShtein距离：&quot;&lt;&lt;endl;srand(time(NULL));int i;char name[LEN_NAME+1];string x = rand_str(name,LEN_NAME);string y = rand_str(name,LEN_NAME);cout&lt;&lt;&quot;字符串1：&quot;&lt;&lt;x&lt;&lt;endl;cout&lt;&lt;&quot;字符串2：&quot;&lt;&lt;y&lt;&lt;endl;LSEditDistCaller(x, y);</code></pre><p>}</pre><h2 id="RJs7f"><span class="ne-text">参考资料</span></h2><ul class="ne-ul"><li id="f334999207f869e2b2ef6c8458528f61"><a href="https://zh.wikipedia.org/wiki/%E8%90%8A%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E9%9B%A2" data-href="https://zh.wikipedia.org/wiki/%E8%90%8A%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E9%9B%A2" target="_blank" class="ne-link"><span class="ne-text">莱文斯坦距离</span></a></li><li id="36faa47bd0df5696577ae0214bd92488"><a href="https://www.dazhuanlan.com/2019/12/06/5dea0cb03281f/" data-href="https://www.dazhuanlan.com/2019/12/06/5dea0cb03281f/" target="_blank" class="ne-link"><span class="ne-text">理解 Levenshtein Distancee</span></a></li><li id="4a60131c436c156ea072cc4afa51c663"><a href="https://www.throwable.club/2020/03/08/learn-about-levenshtein-distance-algorithm/" data-href="https://www.throwable.club/2020/03/08/learn-about-levenshtein-distance-algorithm/" target="_blank" class="ne-link"><span class="ne-text">Levenshtein Distance（编辑距离）算法与使用场景</span></a></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用WireShark捕获并分析以太网报文结构</title>
      <link href="/blog/bw80k6/"/>
      <url>/blog/bw80k6/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><p id="7f76e8a93084cc3bd1203ea842e80463" class="ne-p"><span class="ne-text">学习网络协议分析工具WireShark，利用WireShark捕获并分析以太网报文结构，最重要的是后面超星网登录案例分析，用实际例子将计网的所学知识串起来。</span></p></div><div class="ne-quote"><p id="483fc60921d2cb8c6e28ccf682601256" class="ne-p"><span class="ne-text">文章更新内容说明：无线上网和有线上网的MAC地址是不一样的</span></p><p id="542f6b8c4bef85750f8441adcb8f0b61" class="ne-p"><span class="ne-text">【查看本地地址的截图是在家里的查看，wireshark的使用是在学校】</span></p></div><p id="u846af37d" class="ne-p"><br></p><h2 id="oJyzb"><span class="ne-text">查看信息</span></h2><h3 id="batDK"><span class="ne-text">查看本地的mac地址</span></h3><p id="35d0a1f21db4bc7c3bc8b11f369bc572" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612839562082-cbc1fcf8-a520-4820-bafc-e26f07ba1177.png" width="960" id="ctz1g" class="ne-image"></p><p id="8cf1f24f09ab4ce3d5091569e56dbd32" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612839610832-5568023d-da16-41af-b95e-1787acadf747.png" width="667.5" id="gbTD4" class="ne-image"></p><h3 id="ZQKy5"><span class="ne-text">ping命令</span></h3><div class="ne-quote"><p id="0a8db97e13e25c87031ff1df3a98abf3" class="ne-p"><span class="ne-text">先使用ping命令找到需要抓包的网站的ip地址</span></p></div><p id="b348e59c5de96bfd78107335a4aa4e69" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612845955475-12f08386-5ec4-4b3f-8cbf-56059d79677c.png" width="414" id="wPIZW" class="ne-image"></p><h2 id="Zw1Iq"><span class="ne-text">WireShark使用</span></h2><h3 id="1Xcn3"><span class="ne-text">WireShark使用及面板功能区域</span></h3><p id="fa98de219118fb378ff82828fe9006c9" class="ne-p"><span class="ne-text">进入软件，若成功适配电脑网卡，则出现如下类似接口列表</span></p><p id="358c8fadfc38c1e8f0cc9fb2ea6321d3" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603434019601-cc879af3-8784-4ada-83dc-642d64e02981.png" width="608" id="A49JU" class="ne-image"></p><p id="1e4fd55e1cf4991e3742ff8b35188327" class="ne-p" style="text-align: left"><span class="ne-text">直接双击上图中WLAN行即可抓包，也可以如下设置网卡启动抓包</span></p><p id="4b00f5e6301cc3f49309448ee54593b7" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603434096441-73c67d75-4e36-4e76-ae3c-0a8b8976da28.png" width="634" id="VEwdC" class="ne-image"></p><p id="cc1c0b09556c84ce2a4810c4417e6026" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603431676018-f4988b52-5aef-4d92-8b9b-15109a08adab.png" width="641" id="wQqBe" class="ne-image"></p><h3 id="CGYGl"><span class="ne-text">1区域-显示过滤器</span></h3><div class="ne-quote"><p id="55c603a7cecbc1e31135a88af4b0695c" class="ne-p"><span class="ne-text">为过滤ip地址区域。相关表达式语法有</span></p></div><ol class="ne-ol"><li id="285faedea56f60e2bf1d633a16edc188"><span class="ne-text">协议过滤。比如TCP，只显示TCP协议。</span></li><li id="b8c3ee5012ea92cd61208814567ec55b"><span class="ne-text">IP 过滤。比如 ip.src == 192.168.1.102,显示源地址为192.168.1.102，</span></li></ol><p id="eb5f60d8e1b6f401cb94dd65f16bf230" class="ne-p"><span class="ne-text">    ip.dst == 192.168.1.102, 目标地址为192.168.1.102。</span></p><ol start="3" class="ne-ol"><li id="f43ad1194c54db6141aab755159e47b8"><span class="ne-text">端口过滤。   tcp.port ==80,  端口为80的</span></li></ol><p id="ad8af10993aec72ea64e2579f3516b90" class="ne-p"><span class="ne-text">        tcp.srcport == 80,只显示TCP协议的愿端口为80的。</span></p><ol start="4" class="ne-ol"><li id="63c0219a2b5e2278fe8f7a416f0bfd0b"><span class="ne-text">Http模式过滤。http.request.method=="GET",   只显示HTTP GET方法的。</span></li><li id="828b646a4d94632f9a6e92b8a275c186"><span class="ne-text">逻辑运算符为 AND/ OR</span></li></ol><h3 id="1fMmM"><span class="ne-text">2区域-获取的数据包</span></h3><div class="ne-quote"><p id="d0df4ea9d84c3ba8a2ef5af6c067492d" class="ne-p"><span class="ne-text">封包列表(Packet List Pane)</span></p></div><h3 id="sX7cp"><span class="ne-text">3区域-单个数据包各层详细内容</span></h3><div class="ne-quote"><p id="bbea5dd017f419081df244135164a278" class="ne-p"><span class="ne-text">选定的封包详细信息 (Packet Details Pane)</span></p></div><ol class="ne-ol"><li id="57e605ee544b17a27f91c692c50ec5dc"><span class="ne-text" style="color: #F5222D">Frame:物理层的数据帧概况。</span></li></ol><pre data-language="http" id="JTjOd" class="ne-codeblock language-http">Frame 165: 74 bytes on wire (592 bits), 74 bytes captured (592 bits) on interface \Device\NPF_{B016AB5D-3088-41BD-8997-48F19D9DEBFA}, id 0 //165号帧，对方发送74字节，实际收到74字节<pre><code>Interface id: 0 (\Device\NPF_&#123;B016AB5D-3088-41BD-8997-48F19D9DEBFA&#125;) //接口id为0    Interface name: \Device\NPF_&#123;B016AB5D-3088-41BD-8997-48F19D9DEBFA&#125;    Interface description: WLANEncapsulation type: Ethernet (1) //封装类型Arrival Time: Oct 23, 2020 13:37:43.372763000 中国标准时间//捕获日期和时间（中国标准时间）[Time shift for this packet: 0.000000000 seconds]Epoch Time: 1603431463.372763000 seconds[Time delta from previous captured frame: 0.008472000 seconds]//与前一包时间间隔[Time delta from previous displayed frame: 0.000000000 seconds][Time since reference or first frame: 36.349570000 seconds]//此包与第一帧的时间间隔Frame Number: 165//帧序号Frame Length: 74 bytes (592 bits)//帧长度Capture Length: 74 bytes (592 bits)//捕获字节长度[Frame is marked: False]//是否做了标记[Frame is ignored: False]//是否被忽略[Protocols in frame: eth:ethertype:ip:icmp:data]//帧内封装的协议层次结构[Coloring Rule Name: ICMP]//着色标记的协议名称[Coloring Rule String: icmp || icmpv6]//着色规则显示的字符串&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;ne-ol&quot;&gt;&lt;li id=&quot;7a30f31ca568f601cb330100ba9fb7e7&quot;&gt;&lt;span class=&quot;ne-text&quot; style=&quot;color: #F5222D&quot;&gt;Ethernet II:数据链路层以太网帧头部信息。&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-language=&quot;http&quot; id=&quot;STESV&quot; class=&quot;ne-codeblock language-http&quot;&gt;Ethernet II, Src: IntelCor_fb:33:94 (0c:54:15:fb:33:94), Dst: HuaweiTe_da:ff:f3 (7c:a1:77:da:ff:f3)Destination: HuaweiTe_da:ff:f3 (7c:a1:77:da:ff:f3)//目的MAC地址Source: IntelCor_fb:33:94 (0c:54:15:fb:33:94)//源MAC地址（就是我电脑的MAC地址）Type: IPv4 (0x0800)//0x0800表示使用IP协议&lt;/pre&gt;&lt;p id=&quot;d99f5d6b708fcb626d50bbca01757bc5&quot; class=&quot;ne-p&quot; style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1484158/1603432754493-20843464-3bbb-4c01-9ceb-e781759a583d.png&quot; width=&quot;960&quot; id=&quot;JoqS9&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;ol start=&quot;3&quot; class=&quot;ne-ol&quot;&gt;&lt;li id=&quot;9ff3eec3fe96bcffcd9cb5168103fd63&quot;&gt;&lt;span class=&quot;ne-text&quot; style=&quot;color: #F5222D&quot;&gt;Internet Protocol Version 4:互联网层IP包头部信息。&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-language=&quot;http&quot; id=&quot;Y5HVi&quot; class=&quot;ne-codeblock language-http&quot;&gt;Internet Protocol Version 4, Src: 192.168.43.36, Dst: 39.156.66.180100 .... = Version: 4//互联网协议IPv4.... 0101 = Header Length: 20 bytes (5)//IP包头部长度Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)//差分服务字段Total Length: 60//IP包的总长度Identification: 0xdf8c (57228)//标志字段Flags: 0x0000//标记字段Fragment offset: 0//分的偏移量Time to live: 128//生存期TTLProtocol: ICMP (1)//此包内封装的上层协议为TCPHeader checksum: 0x05ba [validation disabled]//头部数据的校验和[Header checksum status: Unverified]Source: 192.168.43.36//来源IP地址Destination: 39.156.66.18//目标IP地址&lt;/pre&gt;&lt;p id=&quot;20508231b2a2787b1d1ea1029c345645&quot; class=&quot;ne-p&quot; style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1484158/1603433033837-c88714a1-eaa1-45cb-b836-5672e4515eee.png&quot; width=&quot;320&quot; id=&quot;K9phM&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;ol start=&quot;4&quot; class=&quot;ne-ol&quot;&gt;&lt;li id=&quot;e4be22a4d0c4f8e0b67c7be8e4e91770&quot;&gt;&lt;span class=&quot;ne-text&quot; style=&quot;color: #F5222D&quot;&gt;Transmission Control Protocol:传输层T的数据段头部信息，此处是TCP。&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-language=&quot;http&quot; id=&quot;jVYQw&quot; class=&quot;ne-codeblock language-http&quot;&gt;Transmission Control Protocol, Src Port: 80 (80), Dst Port: 50362 (50362), Seq: 1025, Ack: 447, Len: 714</code></pre><p>Source Port: 80 (80) //源端口号<br>Destination Port: 50362 (50362) //目标端口号<br>Sequence number: 1025 (relative sequence number) //序列号（相对序列号）<br>[Next sequence number: 1739 (relative sequence number)] //下一个序列号<br>Acknowledgment number: 447 (relative ack number) //确认序列号<br>Header Length: 20 bytes //头部长度<br>…. 0000 0001 1000 = Flags: 0x018 (PSH, ACK) //TCP 标记长度<br>Window size value: 5896 //流量控制的窗口大小<br>Checksum: 0x915b [validation disabled] //TCP 数据段的校验和</pre><p id="b15538e2b44aff1c225daef842e5367c" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603433149527-0125377e-b64b-4e32-9eb0-e122d0c111cb.png" width="289.5" id="R5Mls" class="ne-image"></p><ol start="5" class="ne-ol"><li id="4db6e77e82b1f3a4eff25f9a42178e87"><span class="ne-text" style="color: #F5222D">Hypertext Transfer Protocol:应用层的信息，此处是 HTTP 协议。</span></li></ol><p id="da4e8f8527b3023dc25a25c37cc87ab5" class="ne-p"><br></p><ol start="6" class="ne-ol"><li id="54a2b39754a8591a93d5438ea0b09342"><span class="ne-text" style="color: #F5222D">Data（312 bytes）：数据。</span></li></ol><p id="6972f071d3fbe559dbd5b5286eb02c5d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603434354567-45e84cc7-63a9-4136-adde-85c377345e92.png" width="813" id="EWPd6" class="ne-image"></p><h2 id="71BCN"><span class="ne-text">超星网登录案例分析</span></h2><h3 id="LTTI3"><span class="ne-text">网站请求和响应</span></h3><p id="75aefee6d41f432def583b317335cdd6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849248230-2f38b355-ee1f-4ee1-8b8a-291e64f4e1bd.png" width="960" id="mun7j" class="ne-image"></p><h3 id="0G2ii"><span class="ne-text">发送请求相应协议</span></h3><p id="b1fa9d0aed7d119e738df1b195566f3e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849740094-cbdefdda-f504-43f3-9e41-ac8dc8029fd3.png" width="960" id="FoSDc" class="ne-image"></p><h3 id="V55oa"><span class="ne-text">收到响应相应协议</span></h3><p id="d13a0e437b254f6bcf67656eebc023e4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849811431-437bd72d-ac54-4c28-b731-9e128b6b998f.png" width="959" id="kW7LF" class="ne-image"></p><div class="ne-quote"><p id="da9a5f2a31839f9fd37773017af15042" class="ne-p"><span class="ne-text">接下来的 7 个小节内容来具体对数据报头做出分析 ❗</span></p></div><h3 id="JA1F5"><span class="ne-text">Hypertext Transfer Protocol</span></h3><p id="d5a0569d34990a4bd7efde0442233906" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849851243-b18b3e15-f21e-4998-bcfe-45c0b92aabde.png" width="960" id="U7606" class="ne-image"></p><div class="ne-quote"><p id="0a184dc93573f69a44ce7d5a430b037c" class="ne-p"><span class="ne-text">HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤，大家按照固定的步骤和格式进行通信</span></p><p id="3063fd4e006703c1ee2275705845cab6" class="ne-p"><span class="ne-text">根据 URL 可以定位请求资源的位置，但是对于这个资源可能还有多种处理方法，比如是请求资源还是要删除指定资源？</span></p></div><p id="ee891ecf6b864e3d18cdeebc0dd721f1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612851558692-ed870a9e-f619-4235-bb98-85d22557340f.png" width="960" id="AtlPY" class="ne-image"></p><p id="9d3dd303e0d8f0cc2ad21fa8bed4193c" class="ne-p"><span class="ne-text">这个时候</span><strong><span class="ne-text">浏览器</span></strong><span class="ne-text">将需要请求的信息，按照 HTTP 协议约定的格式，封装成为 HTTP 请求报文</span></p><p id="8e66507c1adba2e9d97d7deff2742256" class="ne-p"><span class="ne-text">HTTP 主要请求方法为 GET 和 POST</span></p><p id="1ec2199fef69997b754da0850e31b2a1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612851687862-c1a44f57-065b-4547-93bb-4ae9b1f9cb95.png" width="346.5" id="j4FRd" class="ne-image"></p><div class="ne-quote"><p id="3db622fedd5dd7c59a1cf2508fa3729f" class="ne-p"><span class="ne-text">请求报文和响应报文的具体形式参考课本</span></p></div><h3 id="w0nqa"><span class="ne-text">Line-based text data</span></h3><p id="acd78ccc6fafd19cd16cf613a658da46" class="ne-p"><span class="ne-text">这里面内容就是请求成功所返回的 Html 代码</span></p><p id="10408f86909761c20966effe0a6cdb93" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612851995920-233bc149-948d-43e1-a549-fc2887c23163.png" width="960" id="BoWGc" class="ne-image"></p><h3 id="Kt97I"><span class="ne-text">Transmission Control Protocol</span></h3><p id="6214a23a4ae50bf55e14e7af5ff422dd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852359910-50409417-8113-4600-bbb6-6d0e02db4894.png" width="960" id="Ja3wE" class="ne-image"></p><p id="c33eb87ecff11f2745b9977786d3a2df" class="ne-p"><span class="ne-text">这个数据报传输使用的可靠的 TCP 协议，而不是 UDP，所以会有相应的滑动窗口、流量控制等等相关机制，还有三次握手，四次挥手……</span></p><p id="1f6cc3d7a0f9bfea84bd32f1d46ad733" class="ne-p"><span class="ne-text">（插个眼，日后再复习一下……）</span></p><p id="f122a3c15130065fea8ba8437479ba98" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1612852762215-ba49fa51-55e0-440d-afa7-b567540e39a2.gif" width="218" id="Wnesc" class="ne-image"></p><p id="91620e41543360b96857863946dda522" class="ne-p"><span class="ne-text">（插眼专用图/滑稽）</span></p><h3 id="41wDc"><span class="ne-text">Internet Protocol Version 4</span></h3><p id="ef5a852c4c7bebc8f9ce82641870ad8e" class="ne-p"><span class="ne-text">好了，接下来到了 IP 层，需要给上面来的数据报加上 IP 头部，IP 数据报结构如下：</span></p><p id="0731b26a1e6c3ad160fe123905554b55" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612853140617-ff243167-abb7-4c65-b5c3-b0bbaa77b5aa.png" width="446" id="inliL" class="ne-image"></p><p id="4c7e0c411f2e50dea19af40f6c166e76" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612853444183-7fa048ef-3e75-4586-82a7-ac9cc58c3630.png" width="960" id="uodGK" class="ne-image"></p><p id="147230e658b8beddd38ad140f0ba7556" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852425531-82ec984f-ac3b-4f8a-a06e-0c48080815f6.png" width="960" id="ixgOl" class="ne-image"></p><p id="a6e478f2600c4aa706ae3f70701baa45" class="ne-p"><span class="ne-text">比如说</span><code class="ne-code"><span class="ne-text">45 </span></code><span class="ne-text">这个字节这具体表现是 ip 数据报的第一行和第二行的具体信息，IP 版本为 IPv4，报头长度为二十个字节，往后的各个字段都是这样一一对应的关系，具体还要加强对那张 ip 数据报结构图的理解，要了然于胸。</span></p><h3 id="vKnIg"><span class="ne-text">Ethernet II, Src</span></h3><p id="685a52a31e8df273d5bdb2d1ba2344b8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612853924295-ea6fe64c-bc90-4e49-ad4e-5ff212448fdc.png" width="452" id="lBSIK" class="ne-image"></p><p id="f1ca664128e3df6a651637d36f6557a0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612850191706-18807d7d-16b5-44fa-a436-5c2b7c4ed5ed.png" width="960" id="yU23P" class="ne-image"></p><div class="ne-quote"><p id="12b13bd6786e930e7cd17c39908451a7" class="ne-p" style="text-align: left"><span class="ne-text">图中三个方框的 14 个字节对应以太网 MAC 帧的前 14 个字节：前 6 个字节是目的地址，接下来的 6 个字节是源地址，最后两个字节是类型字段(用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据交给上一层的这个协议。0x8000 代表上层使用的是 IP 数据报)，后面是数据部分。</span></p><p id="09f9916c2b48c349b53c26ec64d712be" class="ne-p"><span class="ne-text">另外：wireshark 把 8 字节的前序（前同步码）和 4 字节的 FCS（帧开始界定符）都给过滤掉了，所以捕获到的帧里看不到这两部分。</span></p></div><h3 id="2QvJK"><span class="ne-text">Frame 75</span></h3><p id="7c2bdc1183114f8020222dd1d6392462" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852486656-87756b19-ff3d-4833-9af9-d2006a401068.png" width="960" id="gaYxa" class="ne-image"></p><ul class="ne-ul"><li id="8ad34ce80451781402eeb842fba3b836"><span class="ne-text">对方发送 5520 字节，实际收到 5520 字节</span></li><li id="224ee446863c116125f2a48f36c1b91c"><span class="ne-text">第一行表示接口位 0 号</span></li></ul><h3 id="oeNHm"><span class="ne-text">总体数据表示</span></h3><p id="dd6ccf5512fccc15209d0583d52f8362" class="ne-p"><span class="ne-text">其实在计算机看来，网络中的数据传输就是传输下面的这些字节</span></p><div class="ne-quote"><p id="b838ea6f2d333781d1eb8714b5476a44" class="ne-p"><span class="ne-text">一个字节由八个位组成，而位就是我们通常所说的二进制中的 0 或 1</span></p></div><p id="a944ca7be0a0e0f2900b763ee32af5f8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852578885-9519d1d0-a72d-409b-a480-f8554b87fd0d.png" width="959" id="BmzUj" class="ne-image"></p><h2 id="XFqxp"><span class="ne-text">后记</span></h2><h3 id="bRCHY"><span class="ne-text">Wireshark 抓不到 HTTPS 数据包</span></h3><div class="ne-quote"><p id="bbd3cba14f9102cbeb9483144e8f79c5" class="ne-p"><span class="ne-text">有些时候 HTTP 包也抓不到抑或是抓的不全，用如下方式解决即可。</span></p></div><p id="c43d74a0502c52adc94c89d66a4ce293" class="ne-p"><span class="ne-text">在 C 盘根目录下创建如下目录和文件，.log 就是后缀不要 txt</span></p><p id="5684d1f9cf60f3c415e924c1c24d684b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612847971131-6c3c2084-c6d8-41ae-8a82-8a4df65748b8.png" width="405.5" id="MTMvQ" class="ne-image"></p><p id="bc4a18221495485ee9926d7264e6a76f" class="ne-p"><span class="ne-text">添加环境变量</span></p><p id="8a4e3d09482be0cb3966bdf62c046f3f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612848066208-6f22250b-e74d-4156-aa31-c5de17d2e812.png" width="484" id="SJvIm" class="ne-image"></p><p id="929a0d53efd15ff230fc090f3750a7bf" class="ne-p"><span class="ne-text">进入 wireshark 软件</span></p><p id="e4bc3833b6e6e97b5a7ac398208efc15" class="ne-p"><code class="ne-code"><span class="ne-text">编辑 </span></code><code class="ne-code"><span class="ne-text">首选项</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">Protocols</span></code></p><p id="8dcceb0603ce39e060374186028b2f6b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612848155164-ace1e002-1971-4910-8d04-cf9c388eb5cd.png" width="681" id="ccyel" class="ne-image"></p><h3 id="KVsMi"><span class="ne-text">参考资料</span></h3><ul class="ne-ul"><li id="8be9e4995ac78bca3845b353eba314d7"><a href="https://www.cnblogs.com/linyfeng/p/9496126.html" data-href="https://www.cnblogs.com/linyfeng/p/9496126.html" target="_blank" class="ne-link"><span class="ne-text">wireshark 抓包新手使用教程</span></a></li><li id="b6d8694534be197c58bd29958a938c2c"><a href="https://zhuanlan.zhihu.com/p/82498482" data-href="https://zhuanlan.zhihu.com/p/82498482" target="_blank" class="ne-link"><span class="ne-text">https://zhuanlan.zhihu.com/p/82498482</span></a></li><li id="01a33d33cac36d91474456fa7143680e"><a href="https://zhuanlan.zhihu.com/p/264942536" data-href="https://zhuanlan.zhihu.com/p/264942536" target="_blank" class="ne-link"><span class="ne-text">https://zhuanlan.zhihu.com/p/264942536</span></a></li><li id="9f988f01118465c675c266195d220c2f"><a href="https://blog.csdn.net/zam183/article/details/103783785" data-href="https://blog.csdn.net/zam183/article/details/103783785" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/zam183/article/details/103783785</span></a></li><li id="a07301b383f225ea1c853cbfeb683b38"><span class="ne-text">TODO: </span><a href="https://www.cnblogs.com/zhaopei/p/12152139.html#autoid-2-6" data-href="https://www.cnblogs.com/zhaopei/p/12152139.html#autoid-2-6" target="_blank" class="ne-link"><span class="ne-text">Wireshark 抓包，带你快速入门</span></a></li><li id="0ca6bbfae534b48adc8e57d6d082108d"><span class="ne-text">TODO: </span><a href="https://www.cnblogs.com/noteless/p/10256470.html#21" data-href="https://www.cnblogs.com/noteless/p/10256470.html#21" target="_blank" class="ne-link"><span class="ne-text">网络是如何连接的？网络发展简介（四）</span></a></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ping、traceroute命令编程实现</title>
      <link href="/blog/qlrcf6/"/>
      <url>/blog/qlrcf6/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="NcA1c"><span class="ne-text">ping和tracert命令</span></h3><p id="u99edc073" class="ne-p"><br></p><p id="e1e4c2d83c19f3cbcdd3e821665410f2" class="ne-p"><strong><span class="ne-text">ping</span></strong><span class="ne-text">命令一般用来测试两台机器或者机器和服务器之间网络是否连通。</span></p><p id="99d7c143653b8aee0e100c60af247f91" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603437323252-a3bf1470-c4ae-450a-b0fd-4d83281aab46.png" width="719.5" id="iYLwF" class="ne-image"></p><p id="74ee36d8d4fff217167eaf6fda55ce4e" class="ne-p"><strong><span class="ne-text">tracert</span></strong><span class="ne-text">命令显示数据报到达目标主机途中所经过的路径（路由器），并且显示到达每个节点（路由器）的花费时间，显示的信息比ping出来的信息要多，要详细。</span></p><p id="826ccd031113feeba65616a9453a7b78" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603437358485-aef50645-6ff9-4395-bbae-0bfe22ce3dc1.png" width="718" id="E5tYJ" class="ne-image"></p><h3 id="ehxra"><span class="ne-text">编程实现</span></h3><h4 id="ccfCW"><span class="ne-text">Code</span></h4><pre data-language="java" id="aG6Gu" class="ne-codeblock language-java">import java.net.InetAddress;<p>import java.net.MalformedURLException;<br>import java.net.URL;<br>import java.net.UnknownHostException;</p><p>import java.io.BufferedReader;<br>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.InputStreamReader;</p><p>import java.util.Scanner;</p><p>public class CommandUtil {</p><pre><code>String tracert = &quot;tracert -h 10 &quot;; //模拟tracert命令String ping = &quot;ping&quot;;//模拟 ping 命令String routePrint = &quot;route print -4&quot;;//模拟route print命令public static void main(String args[])&#123;    String input = null;    @SuppressWarnings(&quot;resource&quot;)    Scanner scanner = new Scanner(System.in);    //利用while循环接收输入的命令行参数    while(true)&#123;        System.out.println(&quot;Please input destination server IP address ：\n&quot;);        input = scanner.next();        CommandUtil host = new CommandUtil();        host.tracert = host.tracert + &quot; &quot; + input;        host.ping = host.ping + &quot; &quot; + input;        try &#123;            host.command(host.routePrint);        &#125; catch (IOException exception) &#123;            exception.printStackTrace();        &#125;        try &#123;            host.command(host.tracert) ;        &#125; catch (IOException exception) &#123;            exception.printStackTrace();        &#125;        try &#123;            host.command(host.ping);        &#125; catch (IOException exception) &#123;            exception.printStackTrace();        &#125;        InetAddress ipAddress;        try &#123;            ipAddress = InetAddress.getByName(input);            System.out.println(&quot;IP address : &quot;+ipAddress);        &#125; catch (UnknownHostException exception) &#123;            exception.printStackTrace();        &#125;        URL url;        try &#123;            url = new URL(&quot;http&quot;,input,80,&quot;index.html&quot;);            System.out.println();//输出服务器地址            System.out.println(&quot;Get the Server-Name# : &quot;+url.getHost());            System.out.println();//输出首页文件            System.out.println(&quot;Get the default file# : &quot;+url.getFile());            System.out.println();//输出首页协议和端口            System.out.println(&quot;Get the protocol# : &quot;+url.getProtocol()+&quot; &quot;+url.getPort());            System.out.println();        &#125; catch (MalformedURLException e) &#123;            e.printStackTrace();        &#125;        System.out.println();        try &#123;            System.out.println(&quot;Get serverName &amp; IPAddress：&quot;+InetAddress.getByName(input));        &#125; catch (UnknownHostException e) &#123;            e.printStackTrace();        &#125;        long freeMemory = Runtime.getRuntime().freeMemory();        System.out.println(&quot;Surplus memory of JVM: &quot;+freeMemory+&quot;B&quot;);    &#125;&#125;//模拟 tracert 命令StringBuffer commandResult = null;private void command(String tracerCommand) throws IOException&#123;    //第一步：创建进程(是接口不必初始化)    //1.通过Runtime类的getRuntime().exec()传入需要运行的命令参数    System.out.println();    System.out.println(InetAddress.getByName(&quot;localhost&quot;)+&quot; is tracking the destination server...&quot;);    Process process = Runtime.getRuntime().exec(tracerCommand);    readResult(process.getInputStream());    process.destroy();&#125;//第二步：通过输入流来将命令执行结果输出到控制台private void readResult(InputStream inputStream) throws IOException&#123;    commandResult = new StringBuffer();  //初始化命令行    String commandInfo = null; //定义用于接收命令行执行结果的字符串    BufferedReader bufferedReader =            new BufferedReader(new InputStreamReader(inputStream));    while ( (commandInfo = bufferedReader.readLine()) != null)  &#123;        System.out.println(commandInfo);    &#125;    bufferedReader.close();&#125;</code></pre><p>}</pre><h4 id="qhQAd"><span class="ne-text">Result</span></h4><pre data-language="plain" id="gjFHh" class="ne-codeblock language-plain">D:\Java\jdk1.8.0_181\bin\java.exe "-javaagent:D:\JetBrains\IntelliJ IDEA 2020.1.3\lib\idea_rt.jar=39614:D:\JetBrains\IntelliJ IDEA 2020.1.3\bin" -Dfile.encoding=GBK -classpath D:\Java\jdk1.8.0_181\jre\lib\charsets.jar;D:\Java\jdk1.8.0_181\jre\lib\deploy.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\access-bridge-64.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\cldrdata.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\dnsns.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\jaccess.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\jfxrt.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\localedata.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\nashorn.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunec.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunjce_provider.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunmscapi.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunpkcs11.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\zipfs.jar;D:\Java\jdk1.8.0_181\jre\lib\javaws.jar;D:\Java\jdk1.8.0_181\jre\lib\jce.jar;D:\Java\jdk1.8.0_181\jre\lib\jfr.jar;D:\Java\jdk1.8.0_181\jre\lib\jfxswt.jar;D:\Java\jdk1.8.0_181\jre\lib\jsse.jar;D:\Java\jdk1.8.0_181\jre\lib\management-agent.jar;D:\Java\jdk1.8.0_181\jre\lib\plugin.jar;D:\Java\jdk1.8.0_181\jre\lib\resources.jar;D:\Java\jdk1.8.0_181\jre\lib\rt.jar;D:\project-java\jiwang\out\production\jiwang CommandUtil<br>Please input destination server IP address ：</p><p>baidu.com</p><h1 id="localhost-127-0-0-1-is-tracking-the-destination-server…"><a href="#localhost-127-0-0-1-is-tracking-the-destination-server…" class="headerlink" title="localhost/127.0.0.1 is tracking the destination server…"></a>localhost/127.0.0.1 is tracking the destination server…</h1><p>接口列表<br>6…b4 b6 86 df cc 9d ……Realtek PCIe GbE Family Controller<br>11…0c 54 15 fb 33 95 ……Microsoft Wi-Fi Direct Virtual Adapter<br>14…0e 54 15 fb 33 94 ……Microsoft Wi-Fi Direct Virtual Adapter #2<br>16…0c 54 15 fb 33 94 ……Intel(R) Dual Band Wireless-AC 3168<br>17…0c 54 15 fb 33 98 ……Bluetooth Device (Personal Area Network)<br>1………………………Software Loopback Interface 1<br>===========================================================================</p><h1 id="IPv4-路由表"><a href="#IPv4-路由表" class="headerlink" title="IPv4 路由表"></a>IPv4 路由表</h1><p>活动路由:<br>网络目标 网络掩码 网关 接口 跃点数<br>0.0.0.0 0.0.0.0 192.168.2.1 192.168.2.132 35<br>127.0.0.0 255.0.0.0 在链路上 127.0.0.1 331<br>127.0.0.1 255.255.255.255 在链路上 127.0.0.1 331<br>127.255.255.255 255.255.255.255 在链路上 127.0.0.1 331<br>192.168.2.0 255.255.255.0 在链路上 192.168.2.132 291<br>192.168.2.132 255.255.255.255 在链路上 192.168.2.132 291<br>192.168.2.255 255.255.255.255 在链路上 192.168.2.132 291<br>224.0.0.0 240.0.0.0 在链路上 127.0.0.1 331<br>224.0.0.0 240.0.0.0 在链路上 192.168.2.132 291<br>255.255.255.255 255.255.255.255 在链路上 127.0.0.1 331<br>255.255.255.255 255.255.255.255 在链路上 192.168.2.132 291<br>===========================================================================<br>永久路由:<br>无</p><p>localhost/127.0.0.1 is tracking the destination server…</p><p>通过最多 10 个跃点跟踪<br>到 baidu.com [39.156.69.79] 的路由:</p><p>1 1 ms 1 ms 1 ms RM2100.lan [192.168.2.1]<br>2 * * _ 请求超时。<br>3 _ * _ 请求超时。<br>4 4 ms 3 ms 3 ms 192.168.100.253<br>5 4 ms 5 ms 10 ms 192.168.100.114<br>6 3 ms 3 ms 3 ms 192.168.100.118<br>7 _ * _ 请求超时。<br>8 _ * _ 请求超时。<br>9 _ * _ 请求超时。<br>10 _ * * 请求超时。</p><p>跟踪完成。</p><p>localhost/127.0.0.1 is tracking the destination server…</p><p>正在 Ping baidu.com [39.156.69.79] 具有 32 字节的数据:<br>来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48<br>来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48<br>来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48<br>来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48</p><p>39.156.69.79 的 Ping 统计信息:<br>数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，<br>往返行程的估计时间(以毫秒为单位):<br>最短 = 20ms，最长 = 20ms，平均 = 20ms<br>IP address : baidu.com/39.156.69.79</p><p>Get the Server-Name# : baidu.com</p><p>Get the default file# : index.html</p><p>Get the protocol# : http 80</p><p>Get serverName &amp; IPAddress：baidu.com/39.156.69.79<br>Surplus memory of JVM: 124194640B</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>继承和多态</title>
      <link href="/blog/bn6afv/"/>
      <url>/blog/bn6afv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="awvbQ"><span class="ne-text">extends和super</span></h2><ul class="ne-ul"><li id="33f2fdc852defe16759be1d814e3a3b3"><span class="ne-text">子类继承父类用关键字 </span><code class="ne-code"><span class="ne-text">extends</span></code><span class="ne-text"> </span></li><li id="42279eac9187a3930ee60ef102ade2c4"><span class="ne-text">super关键字作用有</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="7a340188d733c2369699ab23faa24116"><span class="ne-text">继承父类的构造函数</span></li><li id="5072468ec0e6bbca672185b375980339"><span class="ne-text">构造方法链</span></li><li id="8a2f589ca8bdad475920826d2bf2d55a"><span class="ne-text">调用父类的方法（一般不怎么用）</span></li></ul></ul><h2 id="fzQA3"><span class="ne-text">方法重写和方法重载</span></h2><div class="ne-quote"><p id="2e1b332c486bbbe798aed425ce35394a" class="ne-p"><span class="ne-text">方法重写注意要子类和父类的方法都得是一样的签名和返回类型</span></p></div><p id="b234490804163988d22e1541658a4c24" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600089343780-c8d0a28c-dc06-4aab-a331-9ac926a65498.png" width="382" id="kHlhK" class="ne-image"></p><p id="3490a4a668d38b032dbad5ea2ab9aa40" class="ne-p" style="text-align: center"><br></p><p id="f53e36aef60ceb65730aa77f7122ad4d" class="ne-p" style="text-align: left"><span class="ne-text">为了避免编写程序过程中方法重载和方法重写的误用，使用</span><strong><span class="ne-text">重写标注 </span></strong><code class="ne-code"><strong><span class="ne-text">@Override</span></strong></code><span class="ne-text"> 来区分，</span><span class="ne-text">系统可以检查方法的正确性。</span></p><h2 id="Ldp8q"><span class="ne-text">Object类</span></h2><div class="ne-quote"><p id="734b6ce2d3cd881f5850e80337a57e10" class="ne-p"><span class="ne-text">java中所有类都继承子java.lang.Object类，其中toString就是该类里面的方法之一，所有许多接口/类都会重写这个方法，手写的链表里面的该方法就是重写之后的方法</span></p></div><h2 id="tfo9C"><span class="ne-text">多态与动态绑定</span></h2><div class="ne-quote"><p id="4e13fc2a801a8c2bb100755fe12b0ef4" class="ne-p"><span class="ne-text">多态</span></p></div><p id="f9cb595476fadfa835c2c66852310ae4" class="ne-p"><span class="ne-text">使用夫类对象的地方都可以使用子类对象。也就意味着父类的变量可以引用子类型的对象</span></p><p id="88119842b402d6e8bc568bbdf31594f4" class="ne-p"><br></p><div class="ne-quote"><p id="330f677d9ad5604363423dbd31db6576" class="ne-p"><span class="ne-text">动态绑定</span></p></div><p id="abaa02ebf8ae1138a5d319cc70362b90" class="ne-p"><span class="ne-text">如果定义了一个父类的对象，该对象调用了一个方法，该方法不存在父类当中，但是存在其父类下面的多个子类当中，那么这个方法调用的是哪个子类当中的该方法呢？JVM有这么一个机制，从“辈分最小的类”依次往上找，第一个找到含有该方法的类，则调用该类当中的那个方法</span></p><p id="805dc9df1323d3f74035b8902e515dbf" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600138148812-5cc991ce-0577-4f01-b57c-bec631518a99.png" width="483" id="IXvxo" class="ne-image"></p><p id="d55d06ce4d5a7898f2e1be516ada4888" class="ne-p" style="text-align: center"><span class="ne-text">注：Cn为父类，往后都是以此继承的子类</span></p><h2 id="uGszw"><span class="ne-text">对象转换</span></h2><div class="ne-quote"><p id="69f7077a82c94d3b61bcdede74a44d8b" class="ne-p"><span class="ne-text">向下转换与向上转换</span></p></div><pre data-language="java" id="woYXJ" class="ne-codeblock language-java">Object o = new Student(); // 可以：因为Student的实例也是Object的实例<p>Student a = o; // (o 是 Object 对象)不可以：因为“级别”的不可逆</p><p>Student s = Student(o); //向上转换</pre><div class="ne-quote"><p id="1d6d234ffa5f55964237e1f68e817c6b" class="ne-p"><span class="ne-text">instanceof</span></p></div><p id="6d2d1eec3ffc9daecc6871dcd0e993ab" class="ne-p"><span class="ne-text">如果一个对象不是 Student 实例，他就不能转换成 Student 类型的变量，会报错 </span><code class="ne-code"><span class="ne-text">ClassCastException</span></code><span class="ne-text"> 。因此，在此之前最好先确保该对象是另一个对象的实例，于是用到关键字 </span><code class="ne-code"><span class="ne-text">instanceof</span></code></p><p id="c7ab37ffd3c4c3387a5cd8c7ca7fbe7d" class="ne-p"><br></p><pre data-language="java" id="vO52K" class="ne-codeblock language-java">Object myObject = new Circle();<br>... // Some lines of code<br>/*_ Perform casting if myObject is an instance of Circle _/<br>if (myObject instanceof Circle) {<br>System.out.println("The circle diameter is " +<br>((Circle)myObject).getDiameter());<br>...<br>}</pre><h2 id="Gn1ts"><span class="ne-text">@override </span></h2><p id="b6a2ac362a45bb4786300ef30246340f" class="ne-p"><span class="ne-text">在重写父类的函数时，在方法前面加上</span><a href="https://www.yuque.com/Override" data-href="https://www.yuque.com/Override" target="_blank" class="ne-link"><span class="ne-text">@Override </span></a><span class="ne-text"> 系统可以帮你检查方法的正确性。 </span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>抽象类和接口</title>
      <link href="/blog/akog9h/"/>
      <url>/blog/akog9h/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="71IRy"><span class="ne-text">概念名词</span></h2><ul class="ne-ul"><li id="56be3051b397ee4e3350ab3537f79f53"><strong><span class="ne-text">接口</span></strong><span class="ne-text">：许多类的</span><strong><span class="ne-text" style="text-decoration: underline">共同行为</span></strong><span class="ne-text">（包含非相关类），就当与给客户看的。</span></li><li id="5ae9c8c840f173e8686cfb045e963cbe"><strong><span class="ne-text">抽象类</span></strong><span class="ne-text">：就相当于一个父类，该父类</span><span class="ne-text" style="text-decoration: underline">包含其子类的</span><strong><span class="ne-text" style="text-decoration: underline">共性</span></strong><span class="ne-text" style="text-decoration: underline">特征</span><span class="ne-text">，就像是子类园和子类长方形，两个类可以有一个共同的父类，该父类定义为抽象类，其包含一个</span><strong><span class="ne-text">抽象方法</span></strong><span class="ne-text">，比如求面积或是求周长</span></li></ul><p id="u234ed369" class="ne-p"><span class="ne-text"></span></p><h2 id="QidSb"><span class="ne-text">接口的一些要点</span></h2><div class="ne-quote"><p id="2e71e13d39166690040117cfbb79f878" class="ne-p"><code class="ne-code"><span class="ne-text">public interface List<E> &#123; &#125;</span></code></p></div><ul class="ne-ul"><li id="5b267cd5a5a4613b7530fdce1f22c3bb"><span class="ne-text" style="text-decoration: underline">接口是一个</span><strong><span class="ne-text" style="text-decoration: underline">写注释</span></strong><span class="ne-text" style="text-decoration: underline">的好地方</span></li></ul><h2 id="4CIZ1"><span class="ne-text">抽象类的一些要点</span></h2><div class="ne-quote"><p id="648dc79d06d9abca3ca7067042c1a727" class="ne-p"><code class="ne-code"><span class="ne-text">public abstract class AbstractList<E> implements List<E> &#123; &#125;</span></code></p><p id="a72eca167583562b0ffc45a6facde8f9" class="ne-p"><code class="ne-code"><span class="ne-text">public abstract class Test()&#123;&#125;</span></code></p><p id="50deb558e6899de244bfc879275786f8" class="ne-p"><code class="ne-code"><span class="ne-text">public abstract double getTest()&#123;&#125;</span></code></p></div><p id="761ea2dde749381118ca01c700d8593d" class="ne-p"><br></p><ul class="ne-ul"><li id="3d1a189f1f5f548c0031b9511076d864"><span class="ne-text">抽象类当中的</span><strong><span class="ne-text" style="text-decoration: underline">抽象方法</span></strong><span class="ne-text">要在其子类当中实现，因为抽象类“抽象”的以至于没有实例</span></li><li id="c643d6237801e0dad70a276f54b5407b"><span class="ne-text">包含抽象方法的类必定是抽象类</span></li><li id="cfc0a5b0c70f698d5661d151beea4634" style="text-align: left"><strong><span class="ne-text">抽象类的构造函数实现要加上protected，因为其构造函数只被其子类所使用，在创建子类实例的时候，其父类构造函数被调用来初始化该父类的数据域</span></strong></li><li id="777886b062fa283774548ced3c169d28" style="text-align: left"><strong><span class="ne-text">抽象类不可以new对象，不对外公开，只抽取公共代码，eg：ArrayList和LinkedList</span></strong></li><li id="7b1abbaeac5702e01e6fe3727f25e70e" style="text-align: left"><strong><span class="ne-text">抽象类可以不是先接口里面的部分函数</span></strong></li><li id="4d43a90062534514213584d9ceeff945" style="text-align: left"><strong><span class="ne-text">抽象类作用：放“公共代码”</span></strong></li></ul><p id="01e94bef717cf7f6acf8d25a4e55e0ea" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636557-2700f743-9f28-435a-b771-86bdf7b2b25c.png" width="416" id="SYEBn" class="ne-image"></p><p id="bf49b5b59c1eff4bf0f2235986f632ae" class="ne-p"><br></p><p id="8b0fc585cae133d0117b3fabfab5834a" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA队列设计</title>
      <link href="/blog/zqmygi/"/>
      <url>/blog/zqmygi/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="LaKGf"><span class="ne-text">Queue队列设计</span></h2><div class="ne-quote"><p id="ac52ddc375fb2102c6135f5574ffbc64" class="ne-p"><span class="ne-text">在头尾两端进行操作，先进先出FIFO</span></p></div><p id="3e5326d211f6e4b86271a61fb80d22ac" class="ne-p"><span class="ne-text">队列的接口设计</span></p><p id="ud2eeb6ba" class="ne-p"><span class="ne-text"></span></p><p id="u343a0a17" class="ne-p"><span class="ne-text"></span></p><pre data-language="java" id="1m4VW" class="ne-codeblock language-java">int size(); //队列元素个数<p>boolean isEmpty(); //队列是否为空<br>void clear(); //清空队列元素<br>void enQueue(E element); //入队<br>E deQueue(); // 出队<br>E front(); //获取队列的头元素</pre><pre data-language="java" id="xRhaL" class="ne-codeblock language-java">package com.wztlink1013.ds.queue;</p><p>import com.wztlink1013.ds.queue.list.LinkedList;<br>import com.wztlink1013.ds.queue.list.List;</p><p>public class Queue<E> {<br>private List<E> list = new LinkedList&lt;&gt;();</p><pre><code>public int size() &#123;    return list.size();&#125;public boolean isEmpty() &#123;    return list.isEmpty();&#125;public void clear() &#123;    list.clear();&#125;public void enQueue(E element) &#123;    list.add(element);&#125;public E deQueue() &#123;    return list.remove(0);&#125;public E front() &#123;    return list.get(0);&#125;</code></pre><p>}</pre><h2 id="TZeCs"><span class="ne-text">Deque 双端队列设计</span></h2><div class="ne-quote"><p id="af7aaae0a02d7ec3a05c28f48a5a7e0d" class="ne-p"><span class="ne-text">双端队列是能在头尾两端添加、删除的队列</span></p></div><pre data-language="java" id="VyodE" class="ne-codeblock language-java">package com.wztlink1013.ds.queue;</p><p>import com.wztlink1013.ds.queue.list.LinkedList;<br>import com.wztlink1013.ds.queue.list.List;</p><p>public class Deque<E> {<br>private List<E> list = new LinkedList&lt;&gt;();</p><pre><code>public int size() &#123;    return list.size();&#125;public boolean isEmpty() &#123;    return list.isEmpty();&#125;public void clear() &#123;    list.clear();&#125;public void enQueueRear(E element) &#123;    list.add(element);&#125;public E deQueueFront() &#123;    return list.remove(0);&#125;public void enQueueFront(E element) &#123;    list.add(0, element);&#125;public E deQueueRear() &#123;    return list.remove(list.size() - 1);&#125;public E front() &#123;    return list.get(0);&#125;public E rear() &#123;    return list.get(list.size() - 1);&#125;</code></pre><p>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++顺序表设计</title>
      <link href="/blog/nlhg88/"/>
      <url>/blog/nlhg88/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="17b89f0817a52e14ae8000bacb0a5935" class="ne-p"><span class="ne-text">类似一个简易版本的数组</span></p></div><h2 id="Qlc9m"><span class="ne-text">代码</span></h2><ul class="ne-tl"><li checked="true" id="63ca34a96f85b4dd1e58bcd2f6106ad9"><span class="ne-text">顺序表存储形式</span></li></ul><pre data-language="cpp" id="um63n" class="ne-codeblock language-cpp">/* 顺序表的存储形式就是连续存储空间，地址连续的，其实就是数组 */<p>typedef struct {<br>int *arr;<br>int length;<br>}SqList;</pre><ul class="ne-tl"><li checked="true" id="c4c430a0bf31bd44c7ad82fd0a74f7b6"><span class="ne-text">打印</span></li><li checked="true" id="ecf1ca33414f6a84470bc6f41baee82c"><span class="ne-text">取值</span></li><li checked="true" id="575c964652363409f0fcb36a7f90e6a7"><span class="ne-text">查找</span></li><li checked="true" id="dcc87412e379afd95293b68abfce065b"><span class="ne-text">插入</span></li><li checked="true" id="786cd662043221242464c67ddfd57162"><span class="ne-text">删除</span></li><li checked="true" id="d6835b58b8bd16893dd238c74a55cc8e"><span class="ne-text">升序</span></li><li checked="true" id="3e50b4048010643e7b42ebb021d7508f"><span class="ne-text">逆置</span></li></ul><pre data-language="cpp" id="mvP0g" class="ne-codeblock language-cpp">#include<bits/stdc++.h><br>using namespace std;<br>#define MAXSIZE 100</p><p>/**</p><ul><li>顺序表</li><li></li><li>顺序表的基本操作： 初始化、打印、取值、查找、插入、删除、升序、逆置<br>*/</li></ul><p>/_ 顺序表的存储形式就是连续存储空间，地址连续的，其实就是数组 _/<br>typedef struct {<br>int *arr;<br>int length;<br>}SqList;</p><p>/_ 初始化 _/<br>void InitList(SqList &amp;L)<br>{<br>L.arr = new int[MAXSIZE];<br> if (!L.arr) exit(-1);<br> L.length = 0;<br>}</p><p>/_ 初始化添加元素 <em>/<br>void ListInsert(SqList &amp;L) {<br>cout &lt;&lt; “请输入元素个数 n：”;<br>int n;<br>cin &gt;&gt; n;<br>for (int i = 0; i &lt; n;i++){<br>cin &gt;&gt; L.arr[i];<br>L.length++;<br>}<br>}<br>/</em> 打印 _/<br>void TraverseList(SqList &amp;L) {<br>cout &lt;&lt; “该顺序表元素遍历结果为：”;<br>for (int i = 0; i &lt; L.length;i++) {<br>cout &lt;&lt; L.arr[i] &lt;&lt; ‘ ‘;<br>}<br>cout &lt;&lt; “\n”;<br>}<br>/_ 最大值 _/<br>void NumberMax (SqList &amp;L){<br>cout &lt;&lt; “该顺序表最大值为：”;<br>int max = L.arr[0];<br>for (int i = 0; i &lt; L.length;i++) {<br>if(L.arr[i]&gt;max)<br>max = L.arr[i];<br>}<br>cout &lt;&lt; max&lt;&lt;”\n”;<br>}</p><p>/_ 插值 _/<br>void InsertOneElement (SqList &amp;L) {<br>cout &lt;&lt; “请分别输入在 n 位置插入的 e 值：”;<br>int n;<br>int e;<br>cin &gt;&gt; n &gt;&gt; e;<br>for (int i = L.length - 1; i &gt;= n-1;i–){<br>L.arr[i + 1] = L.arr[i];<br>}<br>L.arr[n-1] = e;<br>L.length++;<br>cout &lt;&lt; “\n”&lt;&lt;”插入值之后的顺序表为：”;<br>TraverseList(L);<br>}</p><p>/_ 删除 <em>/<br>void DeleteOneElement (SqList &amp;L) {<br>cout &lt;&lt; “请输入要删除 n 位置的 n 值：”;<br>int n;<br>cin &gt;&gt; n;<br>for (int i = 0; i &lt; L.length;i++){<br>if (i&gt;=n-1){<br>L.arr[i] = L.arr[i + 1];<br>}<br>}<br>L.length–;<br>cout &lt;&lt; “\n”&lt;&lt;”删除值之后的顺序表为：”;<br>TraverseList(L);<br>}<br>/_ 升序 _/<br>void IncrList (SqList &amp;L) {<br>cout &lt;&lt; “升序之后的顺序表为：”;<br>for (int i = 0; i &lt; L.length;i++){<br>for (int j = 0; j &lt; L.length;j++){<br>if (L.arr[j]&gt;L.arr[i]) {<br>int temp;<br>temp = L.arr[j];<br>L.arr[j] = L.arr[i];<br>L.arr[i] = temp;<br>}<br>}<br>}<br>TraverseList(L);<br>}<br>/</em> 逆置 _/<br>void ReverseList (SqList &amp;L) {<br>cout &lt;&lt; “逆序之后……”;<br>for (int i = 0; i &lt; L.length / 2;i++){<br>int temp;<br>temp = L.arr[i];<br>L.arr[i] = L.arr[L.length-i-1];<br>L.arr[L.length-i-1] = temp;<br>}<br>TraverseList(L);<br>}</p><p>int main () {<br>SqList test;<br>InitList(test);//1<br>ListInsert(test);//1<br>TraverseList(test);//1<br>NumberMax(test);//2<br>InsertOneElement(test);//3<br>DeleteOneElement(test);//4<br>IncrList(test);//5<br>ReverseList(test);//6<br>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20. 有效的括号🔖栈</title>
      <link href="/blog/aritwv/"/>
      <url>/blog/aritwv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u250f831a"><a href="https://leetcode-cn.com/problems/valid-parentheses/" data-href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/valid-parentheses/</span></a></li></ul><h2 id="3H4Uf"><span class="ne-text">问题思路</span></h2><p id="a6aa5c3b8ed802ced4ca290e5002d985" class="ne-p"><span class="ne-text">将所有的左半边括号push到栈内，然后遇到右半边括号，就将其与栈顶元素匹配测试，若能匹配成功则继续匹配，反之输出false。</span></p><p id="68251b5bc897786f2791581cca554016" class="ne-p"><br></p><p id="d6745d88d12858cbb36ae4e2a190ed6a" class="ne-p"><span class="ne-text">在这之间注意比较当栈内没有元素了，而字符串还有待匹配的字符，输出false，当栈内还有元素，外面与之匹配测试的右半边括号，也输出false。</span></p><h3 id="hVDJG"><span class="ne-text">ts实现</span></h3><pre data-language="typescript" id="Fp8h4" class="ne-codeblock language-typescript">function isValid(s: string): boolean {<p>let stack: Array<string> = []<br>for (let i of s) {<br>if ([‘(‘, ‘[‘, ‘{‘].includes(i)) {<br>stack.push(i)<br>} else {<br>switch (i) {<br>case ‘)’:<br>if (stack[stack.length - 1] === ‘(‘) {<br>stack.pop()<br>} else {<br>return false<br>}<br>break<br>case ‘]’:<br>if (stack[stack.length - 1] === ‘[‘) {<br>stack.pop()<br>} else {<br>return false<br>}<br>break<br>case ‘}’:<br>if (stack[stack.length - 1] === ‘{‘) {<br>stack.pop()<br>} else {<br>return false<br>}<br>break<br>}<br>}<br>}<br>return stack.length ? false : true<br>}</pre><p id="u0a351627" class="ne-p"><span class="ne-text"></span></p><h3 id="hkttw"><span class="ne-text">之前的 java 代码实现</span></h3><h4 id="coOPC"><span class="ne-text">栈实现</span></h4><pre data-language="java" id="FMgFR" class="ne-codeblock language-java">class Solution {<br>public boolean isValid(String s) {<br>Stack<Character> stack = new Stack<>();</p><pre><code>    int len = s.length();    for (int i=0;i&lt;len;i++) &#123;        char c = s.charAt(i);        if (c == &#39;(&#39; || c == &#39;[&#39; || c == &#39;&#123;&#39;) &#123;            stack.push(c);        &#125; else &#123;            if (stack.isEmpty()) return false;            char left = stack.pop();            if (left == &#39;(&#39; &amp;&amp; c !=&#39;)&#39;) return false;            if (left == &#39;[&#39; &amp;&amp; c !=&#39;]&#39;) return false;            if (left == &#39;&#123;&#39; &amp;&amp; c !=&#39;&#125;&#39;) return false;        &#125;    &#125;    return stack.isEmpty();&#125;</code></pre><p>}</pre><pre data-language="java" id="b4N3h" class="ne-codeblock language-java">class Solution {<br>public boolean isValid(String s) {<br>Stack<Character> stack = new Stack<>();<br>for (int i = 0; i< s.length();i++){<br>if (s.charAt(0) == ')' || s.charAt(0) == ']' || s.charAt(0) == '}'){<br>return false;<br>}<br>if (s.charAt(i) == '(' || s.charAt(i) == '[' || s.charAt(i) == '{'){<br>stack.push(s.charAt(i));<br>}<br>if (s.charAt(i) == ')' || s.charAt(i) == ']' || s.charAt(i) == '}'){<br>if (s.charAt(i) == ')'){<br>if (stack.isEmpty() == true) {<br>return false;<br>}<br>if (stack.pop() != '(')<br>return false;</p><pre><code>            &#125;            if (s.charAt(i) == &#39;]&#39;)&#123;                if (stack.isEmpty() == true) &#123;                    return false;                &#125;                if (stack.pop() != &#39;[&#39;)                    return false;            &#125;            if (s.charAt(i) == &#39;&#125;&#39;)&#123;                if (stack.isEmpty() == true) &#123;                    return false;                &#125;                if (stack.pop() != &#39;&#123;&#39;)                    return false;            &#125;        &#125;    &#125;    if (stack.isEmpty() == true)&#123;        return true;    &#125; else &#123;        return false;    &#125;&#125;</code></pre><p>}</pre><h4 id="wlwJM"><span class="ne-text">HashMap 实现</span></h4><pre data-language="java" id="JI6gO" class="ne-codeblock language-java">class Solution {<br>private static HashMap<Character, Character> map = new HashMap<>();<br>static {<br>// key - value<br>map.put('(', ')');<br>map.put('{', '}');<br>map.put('[', ']');<br>}<br>public boolean isValid(String s) {<br>Stack<Character> stack = new Stack<>();<br>int len = s.length();<br>for (int i = 0; i < len; i++) {<br>char c = s.charAt(i);<br>if (map.containsKey(c)) { // 左括号<br>stack.push(c);<br>} else { // 右括号<br>if (stack.isEmpty()) return false;<br>if (c != map.get(stack.pop())) return false;<br>}<br>}<br>return stack.isEmpty();<br>}<br>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA栈设计</title>
      <link href="/blog/yxy6mv/"/>
      <url>/blog/yxy6mv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="mbNmd"><span class="ne-text">栈的设计</span></h2><h3 id="YmYSZ"><span class="ne-text">栈的特点</span></h3><p id="ubb584bef" class="ne-p"><br></p><p id="356e5feffef0d675b37bcabe5fa4307e" class="ne-p"><span class="ne-text">栈的最重要特点就是其元素的</span><strong><span class="ne-text">后进先出，先进后出</span></strong><span class="ne-text">。</span></p><h3 id="UnewH"><span class="ne-text">栈的接口设计</span></h3><p id="62d1abe431f740f5969fba7a50b8eb23" class="ne-p"><span class="ne-text">栈可以</span><strong><span class="ne-text">直接继承</span></strong><span class="ne-text">之前所学的ArrayList亦或是List接口。</span></p><p id="fca3f98f0da0c22facd6ecd71c0ddc55" class="ne-p"><span class="ne-text">这过程中需要注意，最好不要直接继承，因为如果直接继承，会将接口里面的其他方法也继承下来，会导致栈的对外接口不合理，解决办法就是在</span><strong><span class="ne-text">类设计内部new一个private List对象</span></strong><span class="ne-text">来设计栈。</span></p><pre data-language="java" id="GWvoo" class="ne-codeblock language-java">int size(); // 元素的数量<p>boolean isEmpty(); // 栈是否为空<br>void push(E element); // 入栈<br>E pop(); // 出栈<br>E top(); // 获取栈顶元素<br>void clear(); // 清空栈</pre><pre data-language="java" id="bTK2d" class="ne-codeblock language-java">package com.wztlink1013.ds.stack;</p><p>import com.wztlink1013.ds.stack.list.ArrayList;<br>import com.wztlink1013.ds.stack.list.List;</p><p>public class Stack<E> {<br>private List<E> list = new ArrayList&lt;&gt;();</p><pre><code>public void clear() &#123;    list.clear();&#125;public int size() &#123;    return list.size();&#125;public boolean isEmpty() &#123;    return list.isEmpty();&#125;public void push(E element) &#123;    list.add(element);&#125;public E pop() &#123;    return list.remove(list.size() - 1);&#125;public E top() &#123;    return list.get(list.size() - 1);&#125;</code></pre><p>}</pre><h2 id="mu0a8"><span class="ne-text">栈的应用</span></h2><p id="33858337566dce4c7d285a24ff302120" class="ne-p"><br></p><p id="ee4232e23b9b7490b87b5aac01895525" class="ne-p"><strong><span class="ne-text">浏览器的前进和后退</span></strong><span class="ne-text">的功能。</span></p><p id="7aa224657e2e60c1bd4e8bd9d7fdc6cf" class="ne-p"><span class="ne-text">假如有网页 a、b、c、d，依次点击 abc 三个网页，然后回退至 b 网页，这个时候，就相当于在 1 栈中有 ab 两个网页（且 b 为栈顶元素），c 暂时放到 2 栈中，此时依然可以使用回退前进功能，但是现在在 b 页面上在新输入 d 网页并进入，此时 2 栈被清空，d 为 1 栈的栈顶元素，在此时的 d 页面内，不能使用浏览器的前进功能，只能使用后退功能。</span></p><p id="db8f06bbe0e3d7e68cfad7a8ba312d40" class="ne-p"><br></p><h2 id="zLWwa"></h2></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+PicGo构建免费图床及其高效使用</title>
      <link href="/blog/bzf30z/"/>
      <url>/blog/bzf30z/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="48eafeef"><span class="ne-text">一、搭建缘由</span></h2><p id="4f727f40e64576fad71ffc08f56ca87c" class="ne-p"><span class="ne-text">一开始搭建博客，避免不了要用许多图片，最初使用七牛云来做博客图床，但是后来发现，七牛云只有30天的临时域名，hhhhhhh，果然啊，天下就没有免费的好事啊~后来就发现GitHub配合PicGo可以作图床，而且加上jsDlivr速度可观。</span></p><p id="f8544afa12ece5d6eec191b42a8e569d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956661-8671ebfe-4f99-494d-b759-a9c75cd67b41.png" width="807" id="tXrax" class="ne-image"></p><p id="f939000ee37f2623e67e59c7074ef5ce" class="ne-p"><br></p><h2 id="57b1f41b"><span class="ne-text">二、GitHub相关配置</span></h2><h3 id="26376074"><span class="ne-text">新建figure图床仓库</span></h3><p id="3843538455ea7c52a556be1d1af1ece4" class="ne-p"><span class="ne-text">常规新建仓库方式，命名figure</span></p><p id="a79702fb454d475a470f7123f4e328cc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926957158-9c7f8749-4d8e-4bc9-9e1c-7d3db5a307b1.png" width="1812" id="c5Wn2" class="ne-image"></p><h3 id="8489cf17"><span class="ne-text">生成一个Token密匙</span></h3><p id="02e8231dd6bcf875d8fe8066777938ef" class="ne-p"><span class="ne-text">点击setting</span></p><p id="bad4478c9fe69ab21f3696e3c58d98c6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956634-4c139fbc-0469-4749-89b8-f139226aa7d2.png" width="1823" id="y83dC" class="ne-image"></p><p id="678091010234f5965af82ef3ded03e1e" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605839703428-b18e3c24-48e0-44ed-9715-81fcd822d4e8.png" width="599" id="DEbkz" class="ne-image"></p><p id="aee1e903788fc37cb85056e504a4cb23" class="ne-p" style="text-align: center"><strong><span class="ne-text">只需要勾选第一个仓库选项就可以了！</span></strong></p><h2 id="b8d02c8e"><span class="ne-text">三、PicGo相关配置</span></h2><h3 id="c8f7b5c7"><span class="ne-text">下载及注意事项</span></h3><p id="3cf4d4e8136aaeec683bb50405bcc9ba" class="ne-p"><a href="https://github.com/Molunerfinn/PicGo/releases" data-href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" class="ne-link"><span class="ne-text">下载地址</span></a></p><p id="35bcd5a2382809b424ff1d62a1a10e70" class="ne-p"><span class="ne-text">注意：下载picgo时候，要科学上网</span></p><h3 id="224e2ccd"><span class="ne-text">配置</span></h3><p id="9feb30085d6e8942a7a8f7d6b1ebab98" class="ne-p"><br></p><p id="5770b3fd2b9105f65561b47f1ddb65b5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956815-db5cf455-f628-4c4d-9242-1687e15a7f03.png" width="1002" id="nHxuO" class="ne-image"></p><p id="31e915163b1a1651c09159cdbff6051c" class="ne-p"><br></p><h2 id="fbe1b2a5"><span class="ne-text">四、高效写博客</span></h2><h3 id="11d50b82"><span class="ne-text">Snipaste截图软件</span></h3><div class="ne-quote"><p id="9799af9cd3667277d32b5ea87c60631a" class="ne-p"><strong><span class="ne-text">常用</span></strong><span class="ne-text">快捷键【作者是用的惠普笔记本电脑，不同电脑键盘的使用方式会不一样】</span></p></div><p id="f85db0c436b1b87dcf584523118d2f8b" class="ne-p"><span class="ne-text">fn+f1：截屏（可编辑）</span></p><p id="93f8ff2d082d9f568ea5085d5031623e" class="ne-p"><span class="ne-text">esc：退出</span></p><p id="414660940139dc91e3db3868f0563866" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956785-4e12ba13-c4c6-4e5a-9758-5d3de27f9718.png" width="553" id="c5EI8" class="ne-image"></p><h3 id="71752a89"><span class="ne-text">结合PicGo使用</span></h3><p id="a536457bb941d527dc20da0c3c941d6f" class="ne-p"><span class="ne-text">PicGo+Snipaste快捷键结合<p></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956619-08d5eae3-3b21-42cc-a2d8-85d6d2f8ed62.png" width="847" id="RxuyV" class="ne-image"></p><h3 id="a3f18b89"><span class="ne-text">综合使用 SOP</span></h3><ol class="ne-ol"><li id="87c8ff2aa9721a37a58ea86860d9ed7f"><span class="ne-text">按</span><code class="ne-code"><span class="ne-text">fn+f1</span></code><span class="ne-text">截完图，再按</span><code class="ne-code"><span class="ne-text">ctrl+c</span></code><span class="ne-text">将刚刚截图放到剪贴板</span></li><li id="2b28bb3a32d1e678f3cf5afe4e960dad"><span class="ne-text">再按</span><code class="ne-code"><span class="ne-text">ctrl+shift+p</span></code><span class="ne-text">使用 picgo 快捷键将剪贴板上的图片上传同时将此时图片的外链复制到剪贴板</span></li></ol><h2 id="723e94d8"><span class="ne-text">五、相关补充</span></h2><h3 id="54e5de42"><span class="ne-text">上传失败</span></h3><p id="5dbc1861a69ad02c481adec93ad8cd9c" class="ne-p"><code class="ne-code"><span class="ne-text">问题 1：有些时候上传 picgo 时，会出现配置报错的情况</span></code></p><div class="ne-quote"><p id="a772c8ec68b4dbf0b7e9a43a89a7d81b" class="ne-p"><span class="ne-text">方案 1：在 picgo 的配置中，改一下文件夹名字（相当于在仓库下新建一个文件夹），就比如本来存到 blogarticle3/文件夹下，改成 blogarticle4/就好了</span></p><p id="b31febe9734c042c303ce8b69612b817" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956579-eafc7cfa-1e0b-41be-ae5b-c6560b8c7638.png" width="1320" id="SUtOG" class="ne-image"></p><p id="3d16f291f6f140b6fd1c647947f9038d" class="ne-p"><span class="ne-text">方案 2：将下图所示的</span><code class="ne-code"><span class="ne-text">上传前重命名</span></code><span class="ne-text">打开同时</span><code class="ne-code"><span class="ne-text">设置 Server</span></code><span class="ne-text">内容开换成关，关换成开，玄学……</span></p><p id="fd626682e799bf03c7785c18cfb1ac43" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956785-fb091672-3c17-49db-a0e7-965e20c93f5c.png" width="1002" id="mBrId" class="ne-image"></p><p id="52abdd57c3356b6bf288a42e6f1062d3" class="ne-p"><span class="ne-text">方案 3：将 PicGo 软件叉掉重新运行。玄学····</span></p><p id="d90a16a878589f6728d9f8297737cf42" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926957260-3a981036-cd74-4a90-8665-d2510470f2c9.png" width="1002" id="uDV56" class="ne-image"></p><p id="812bd0c26f8627db68f72d542fc17c9e" class="ne-p"><span class="ne-text">方案 4（最优方案）：科学上网</span></p></div><h3 id="474294e8"><span class="ne-text">关于插件</span></h3><p id="104a6257dfb8536020fe3057822fcf31" class="ne-p"><span class="ne-text">在插件列表里面下载这三个拓展插件，其中两个国内的托管 coding 和 gitee，还有一个 github plus 版本，不过觉得国内的外链范围肯定是要小一点的应该，最好是优先使用 github 图床，coding 和 gitee 的作为文章使用，有关博客配置的使用 CDN 等。</span></p><p id="0d48474349378fd3eb0896899595196b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956548-b7b5ad1b-2586-42c5-8f7d-9dd17c265fcf.png" width="771" id="jVclk" class="ne-image"></p><p id="29f236751d44d58ebd95b7350ae77f88" class="ne-p"><br></p><h4 id="75295b5b"><span class="ne-text">Coding 配置</span></h4><p id="83d8fb5eb3e64366f2897f9e56ef40c1" class="ne-p"><br></p><p id="906d0696e8c8bb72d0bc2aeb62ab8469" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956265-035a546d-2ecd-48c3-8eec-c9ef7779653b.png" width="739" id="tS4xk" class="ne-image"></p><p id="7d5fa74befbe566d6186f5810131678b" class="ne-p"><br></p><h4 id="becf3f88"><span class="ne-text">gitee 配置</span></h4><p id="96b269d8fd73c4b78ed0845fb8a72fcb" class="ne-p"><br></p><p id="5bd04874e8c3563dc4e10baae7725b27" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956286-859465c2-411f-4761-8921-526656b8a191.png" width="778" id="Dz7ij" class="ne-image"></p><p id="3b714b4341176f6827f03784d9b58a74" class="ne-p"><br></p><h4 id="222c511c"><span class="ne-text">GitHub plus 配置</span></h4><p id="3a44d21f09f952693fe82bec1028280a" class="ne-p"><br></p><p id="01ef99aa2eb19766d33cf1be636b3c64" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956274-6e705ace-8e6f-4226-9fae-ffaaa66a2aa9.png" width="727" id="I5d4B" class="ne-image"></p></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jsDelivr+Github或NPM+国内镜像源两种方法构建免费CDN库</title>
      <link href="/blog/erx9hf/"/>
      <url>/blog/erx9hf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ufff27c93" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641718461641-3811ef80-de8d-4fe8-adf5-1e80d9bc3a4f.png" width="900" id="ue9c0ff30" class="ne-image"></p><p id="u2c6acca8" class="ne-p"><span class="ne-text">前言：此前一直使用jsDelivr+GitHub来构建免费的CDN服务，但是在2121.12.20左右，jsDelivr貌似崩了，究其原因是其在国内的备案失效了，导致网宿停止对该域名的服务，之后恢复之后，国内节点也不会像之前一样的解析得快了，具体体现就是网站中涉及jsDelivr静态资源CDN处打开会有卡顿的访问情况。</span></p><p id="uf2abdbbd" class="ne-p"><span class="ne-text"></span></p><p id="u9f61f891" class="ne-p"><span class="ne-text">所以本文介绍新一种搭建免费CDN的方案：将静态资源发布NPM包+国内镜像引用的方式，另一种是之前一直用的jsDelivr+GitHub仓库引用的方案。</span></p><h3 id="L1aek"><span class="ne-text">何为内容分发网络CDN</span></h3><div class="ne-quote"><p id="840ab83f70eedb9e6b563de4a14509fd" class="ne-p"><span class="ne-text">CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科</span></p></div><p id="90ac18bee2af62f6e23446cfb8d2e32c" class="ne-p"><br></p><p id="5c8c490b737bbbf78164784095359219" class="ne-p"><span class="ne-text">通俗来说就是提取外链，同时加速访问的好处。Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，</span><span class="ne-text" style="text-decoration: line-through">jsDelivr + Github便是免费且好用的CDN</span><span class="ne-text">（jsDelivr cdn 半挂状态），非常适合博客网站使用。</span></p><p id="u27dd36b3" class="ne-p"><span class="ne-text"></span></p><h2 id="ZAcHs"><span class="ne-text">方法一：NPM包+国内镜像</span></h2><p id="uaa8bcd1b" class="ne-p"><span class="ne-text">原因：</span></p><ul class="ne-ul"><li id="ucbee54c9"><span class="ne-text">网站引入的静态资源，如js、css、图片等资源，使用公共的CDN库来引入会更好地优化网站速度。</span></li><li id="u8bfdfc51"><span class="ne-text">不用jsDelivr+GitHub做CDN的缘由是，镜像没有npm的镜像多</span></li><li id="ufedf9993"><span class="ne-text">jsDelivr cdn 挂了（盲猜薅羊毛导致），备案证书过期，国内速度不再是从前的那般快了</span></li></ul><h3 id="pvyK8"><span class="ne-text">CDN镜像源</span></h3><ul class="ne-ul"><li id="uf1fcafcb"><span class="ne-text">饿了么做的：</span><a href="https://npm.elemecdn.com/" data-href="https://npm.elemecdn.com/" target="_blank" class="ne-link"><span class="ne-text">https://npm.elemecdn.com/</span></a></li></ul><p id="u9e6ee108" class="ne-p"><a href="https://unpkg.zhimg.com/yuque-hexo-lyrics@1.0.0/config.js" data-href="https://unpkg.zhimg.com/yuque-hexo-lyrics@1.0.0/config.js" target="_blank" class="ne-link"><span class="ne-text">https://unpkg.zhimg.com/yuque-hexo-lyrics@1.0.0/config.js</span></a></p><ul class="ne-ul"><li id="u13b6279b"><span class="ne-text">知乎做的：</span><a href="https://unpkg.zhimg.com/" data-href="https://unpkg.zhimg.com/" target="_blank" class="ne-link"><span class="ne-text">https://unpkg.zhimg.com/</span></a></li></ul><p id="uc65b504f" class="ne-p"><a href="https://npm.elemecdn.com/yuque-hexo-lyrics@1.0.0/config.js" data-href="https://npm.elemecdn.com/yuque-hexo-lyrics@1.0.0/config.js" target="_blank" class="ne-link"><span class="ne-text">https://npm.elemecdn.com/yuque-hexo-lyrics@1.0.0/config.js</span></a></p><ul class="ne-ul"><li id="ubdcd697e"><span class="ne-text">UNPKG（unpkg镜像用的是CloudFlare，国内加速效果不好）：</span><a href="https://unpkg.com/" data-href="https://unpkg.com/" target="_blank" class="ne-link"><span class="ne-text">https://unpkg.com/</span></a></li></ul><p id="ua50cbc0a" class="ne-p"><a href="https://unpkg.com/yuque-hexo-lyrics@1.0.0/config.js" data-href="https://unpkg.com/yuque-hexo-lyrics@1.0.0/config.js" target="_blank" class="ne-link"><span class="ne-text">https://unpkg.com/yuque-hexo-lyrics@1.0.0/config.js</span></a></p><ul class="ne-ul"><li id="u9206eec1"><span class="ne-text">……</span></li></ul><h3 id="WDSHp"><span class="ne-text">实现思路</span></h3><p id="u9f7905cb" class="ne-p"><span class="ne-text">将GitHub仓库私有化，同时配置GitHub Actions，如果发布版本/fork/star等操作，就将其pulish到npm包</span></p><p id="ua952998e" class="ne-p"><span class="ne-text"></span></p><p id="u7154484c" class="ne-p"><span class="ne-text">每次更新GitHub仓库之后，需要将package.json文件中的version字段的值指定，然后才能使用GitHub Actions进行自动化部署</span></p><p id="u16dd565c" class="ne-p"><span class="ne-text"></span></p><p id="u094e8964" class="ne-p"><span class="ne-text">具体使用形式：</span></p><ul class="ne-ul"><li id="u54d149a3"><a href="https://unpkg.zhimg.com/cdn-website@0.0.0/ico/heroes_villains/Totoro.ico" data-href="https://unpkg.zhimg.com/cdn-website@0.0.0/ico/heroes_villains/Totoro.ico" target="_blank" class="ne-link"><span class="ne-text">https://unpkg.zhimg.com/cdn-website@0.0.0/ico/heroes_villains/Totoro.ico</span></a></li><li id="u146d4300"><a href="https://unpkg.zhimg.com/cdn-pictures@0.0.0/about/teacher.png" data-href="https://unpkg.zhimg.com/cdn-pictures@0.0.0/about/teacher.png" target="_blank" class="ne-link"><span class="ne-text">https://unpkg.zhimg.com/cdn-pictures@0.0.0/about/teacher.png</span></a></li><li id="ud9f1bbfa"><a href="https://unpkg.zhimg.com/cdn-articles@0.0.0/article1/20200725094728.jpg" data-href="https://unpkg.zhimg.com/cdn-articles@0.0.0/article1/20200725094728.jpg" target="_blank" class="ne-link"><span class="ne-text">https://unpkg.zhimg.com/cdn-articles@0.0.0/article1/20200725094728.jpg</span></a></li></ul><p id="u6ba2595e" class="ne-p"><span class="ne-text"></span></p><p id="ud0434ae6" class="ne-p"><span class="ne-text">其中，上述链接中的CDN链接</span><a href="https://unpkg.zhimg.com/" data-href="https://unpkg.zhimg.com/" target="_blank" class="ne-link"><span class="ne-text">https://unpkg.zhimg.com/</span></a><span class="ne-text">都可以用其他镜像源（unpkg、elemecdn、jsdelivr等）替换</span></p><h2 id="m2ViF"><span class="ne-text">方法二：jsDelivr+GitHub仓库</span></h2><h3 id="ktjsG"><span class="ne-text">GitHub新建CDN仓库</span></h3><p id="c284058895633e58a2ba2a3fe54eaafe" class="ne-p"><br></p><p id="0878494016df1c3e17d3b62b4207e8ac" class="ne-p"><span class="ne-text">在本地电脑进行一系列clone/pull等一系列操作，同时发布版本（最好上传一次就发布依次版本）</span></p><p id="15aac5478cfe89fc751f3736e48bcc10" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926808858-fcdea51e-42b2-4582-b46d-e9c105842039.png" width="1844" id="H2FW1" class="ne-image"></p><p id="db5bd10a52ba645c649a6ec2f84185e2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926808290-99384f86-d857-415a-83e6-9be3b5bcf279.png" width="1832" id="nIJCg" class="ne-image"></p><p id="1832f2183d844a77a49e94a0eb6ee9db" class="ne-p"><br></p><h3 id="zpcmm"><span class="ne-text">使用jsDelivr</span></h3><p id="073ec0ba7b6f2f2cc3dba983ab009d5e" class="ne-p"><code class="ne-code"><a href="https://cdn.jsdelivr.net/gh/wztlink1013/CDN-Volantis@" data-href="https://cdn.jsdelivr.net/gh/wztlink1013/CDN-Volantis@" target="_blank" class="ne-link"><strong><span class="ne-text">https://cdn.jsdelivr.net/gh/wztlink1013/CDN-Volantis@</span></strong></a><strong><span class="ne-text">版本号/文件夹/文件名.文件后缀</span></strong></code></p><p id="2913f52497204ca38cfe2b79246d0eb4" class="ne-p"><strong><span class="ne-text">举个栗子</span></strong></p><ul class="ne-ul"><li id="b38f58c6e41dad0025a997b77e18a657"><a href="https://cdn.jsdelivr.net/gh/wztlink1013/CDN@2.4/Pictures/blogbackground/fengbaobao_1.jpg" data-href="https://cdn.jsdelivr.net/gh/wztlink1013/CDN@2.4/Pictures/blogbackground/fengbaobao_1.jpg" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/wztlink1013/CDN@2.4/Pictures/blogbackground/fengbaobao_1.jpg</span></a></li><li id="867dc0cd4fc6b6a4a46840eccf31d26a"><a href="https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4" data-href="https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The Pet Girl of Sakurasou.mp4</span></a></li></ul><p id="29df8afaa1feb78832fc9b8d0c811dcc" class="ne-p"><br></p><div class="ne-quote"><p id="3bf1ef921059d895947a569bd00904f1" class="ne-p"><span class="ne-text">0、具体使用教程</span></p></div><ul class="ne-ul"><li id="a6c07817ec1826e0ee0100c52ece3ae3"><a href="https://blog.wztlink1013.com/2020/02/25/Hexo/jsDelivr%E5%92%8CGitHub%E6%9E%84%E5%BB%BA%E5%85%8D%E8%B4%B9CDN/" data-href="https://blog.wztlink1013.com/2020/02/25/Hexo/jsDelivr%E5%92%8CGitHub%E6%9E%84%E5%BB%BA%E5%85%8D%E8%B4%B9CDN/" target="_blank" class="ne-link"><span class="ne-text">jsDelivr和Github构建免费CDN</span></a></li><li id="e987a4e3cecd805913c4fdc0056b7638"><a href="https://www.jsdelivr.com/" data-href="https://www.jsdelivr.com/" target="_blank" class="ne-link"><span class="ne-text">jsdelivr官网网站</span></a></li></ul><p id="434883797f9d5ce1690005e7bfa8529b" class="ne-p"><br></p><div class="ne-quote"><p id="1f4eb5777e6e48253a2f87cf2d1e7df6" class="ne-p"><span class="ne-text">1、加载任何Github发布、提交或分支</span></p></div><ul class="ne-ul"><li id="98e48520e5f0df70314dfa0803b9a20f"><a href="https://cdn.jsdelivr.net/gh/user/repo@version/file" data-href="https://cdn.jsdelivr.net/gh/user/repo@version/file" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/user/repo@version/file</span></a></li></ul><div class="ne-quote"><p id="5fc01cec3d879c6027c5b63e0cde73c9" class="ne-p"><span class="ne-text">2、加载 jQuery v3.2.1</span></p></div><ul class="ne-ul"><li id="8044a13c7fab2ec6bd5b09a50079aa7c"><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js" data-href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js</span></a></li></ul><p id="c1755bc347326be221542560d52c51f2" class="ne-p"><br></p><div class="ne-quote"><p id="3b840d7fe5df9b288c0dcbc6c7fe578b" class="ne-p"><span class="ne-text">3、使用版本范围而不是特定版本</span></p></div><ul class="ne-ul"><li id="155b258f84fed50dca398969efed1fe7"><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js" data-href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js</span></a></li><li id="df0286308c62fdea9a8e538cf9646bd7"><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js" data-href="https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js</span></a></li></ul><p id="ade19f7333fde57d4630be05ec397499" class="ne-p"><br></p><div class="ne-quote"><p id="fe85c27c0afda11a8e5ffa5e21865b20" class="ne-p"><span class="ne-text">4、完全省略该版本以获取最新版本</span></p></div><ul class="ne-ul"><li id="e532c26a90f4c8d77e48dc3bb0082cba"><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js" data-href="https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js</span></a></li></ul><p id="1a0044b5faeb3f5f51e4a7c6cfbb7ef0" class="ne-p"><br></p><div class="ne-quote"><p id="9f8eece216416d831eeb0c388c3b42be" class="ne-p"><span class="ne-text">5、将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成</span></p></div><ul class="ne-ul"><li id="69446385cee77f5e9285ef32d4c3f386"><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js" data-href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js</span></a></li></ul><p id="ca071a7d9ea8bd378d666c79a5378eea" class="ne-p"><br></p><div class="ne-quote"><p id="4124ef81391f3dcca87546eacb99b342" class="ne-p"><span class="ne-text">6、在末尾添加 / 以获取资源目录列表</span></p></div><ul class="ne-ul"><li id="097bad980a01b3a8419b7ba208706950"><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/" data-href="https://cdn.jsdelivr.net/gh/jquery/jquery/" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/jquery/jquery/</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yuque-未拉取成功</title>
      <link href="/blog/wsmygb/"/>
      <url>/blog/wsmygb/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="8143e79b"><span class="ne-text">一、报错信息</span></h2><p id="ub9bc7109" class="ne-p"><br></p><p id="ue271ff8c" class="ne-p"><br></p><p id="7259d1ad2fb3c05221fb0b280efd9bf2" class="ne-p"><br></p><pre data-language="bash" id="41d4b783" class="ne-codeblock language-bash">$ yuque-hexo sync<p>[INFO] clear previous directory.<br>[INFO] remove yuque posts: D:\Blog\blog-wztlink1013-3.0\source\yuque<br>Mon, 01 Jun 2020 04:02:22 GMT yuque-hexo deprecated TOKEN of yuque will be required while verion &gt;v1.6.0. at ....\Develop\nodejs\node_global\node_modules\yuque-hexo\lib\Downloader.js:39:19<br>[INFO] reading from local file: D:\Blog\blog-wztlink1013-3.0\yuque.json<br>[WARNING] Cannot find module ‘D:\Blog\blog-wztlink1013-3.0\yuque.json’<br>Require stack:</p><ul><li>D:\Develop\nodejs\node_global\node_modules\yuque-hexo\lib\Downloader.js</li><li>D:\Develop\nodejs\node_global\node_modules\yuque-hexo\command\sync.js</li><li>D:\Develop\nodejs\node_global\node_modules\yuque-hexo\node_modules\common-bin\lib\command.js</li><li>D:\Develop\nodejs\node_global\node_modules\yuque-hexo\node_modules\common-bin\index.js</li><li>D:\Develop\nodejs\node_global\node_modules\yuque-hexo\index.js</li><li>D:\Develop\nodejs\node_global\node_modules\yuque-hexo\bin\yuque-hexo.js<br>⚠️ Error: fail to fetch article list, response: {“status”:401,”message”:”Unauthorized”}<br>⚠️ Command Error, enable <code>DEBUG=common-bin</code> for detail</pre><p id="3783f22f52ba4cdb5ad929b4fb283f06" class="ne-p"><br></p><h2 id="8435b3ec"><span class="ne-text">二、分析并解决问题</span></h2><p id="770cf5a2b8d9f1930b64428902c30204" class="ne-p"><br></p><p id="d33a14b18ee204cef7bc0d5f151dc9c3" class="ne-p"><span class="ne-text">认证出错，应该和下面三个原因有关</span></p><p id="d54081a7a11ccaab118725f45815ee4e" class="ne-p"><br></p><ul class="ne-ul"><li id="1a66ad505d472ec0a4c67ec0de1eda29"><span class="ne-text">客户端将其身份验证凭据发送到服务器，但是服务器由于某种原因拒绝了凭据。</span></li><li id="7857ae1a35fc01b1ab9df826a69579f8"><span class="ne-text">客户端无法在请求中提供任何身份验证凭据。</span></li><li id="79bc0a946469cc7854541384e0a69fab"><span class="ne-text">客户端由于某种原因被禁止。某些应用程序用来限制来自特定 IP 地址的访问请求，因此，如果身份验证不是问题，则可能是服务器端禁止。401 Unauthorized Errors</span></li></ul><p id="ef9ed5ff596b79a160c618b2a14a4269" class="ne-p"><br></p><p id="737b5b808234c906278584ed6bb72d74" class="ne-p"><span class="ne-text">也就是身份没有被验证，首先检查用户元信息相关</span></p><p id="fbf6e5542fe72b8eea3628c6f8028ff9" class="ne-p"><br></p><p id="fbd141fa3572dd9dce2b54d114a70c0e" class="ne-p"><span class="ne-text">的确，配置都是没有问题的，然后去 issue 里面查看相关问题，了解到是语雀官方出于对知识库安全性的调整，需要使用第三方 API 访问知识库，需要传入环境变量 YUQUE_TOKEN。</span></p><p id="854356c59a4af054601bdd36c56532b9" class="ne-p"><br></p><p id="48262f6eb3f9b7cb0d61a5a16d815840" class="ne-p"><span class="ne-text">然后根据两种指导方式，传入参数即可</span></p><p id="40fe23d765053b0ab785941c08636479" class="ne-p"><br></p><ul class="ne-ul"><li id="3580ed9179f4ab4bb97ea0d48f6a6893"><span class="ne-text">设置全局的环境变量 YUQUE_TOKEN</span></li><li id="b214870ae58bb288ca0df344c675e7f6"><span class="ne-text">命令执行时传入环境变量</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="2f803d78327a64005d102c85d9c9bb10"><span class="ne-text">mac / linux: YUQUE_TOKEN=xxx yuque-hexo sync</span></li><li id="6374caae7b94163c4e9440e554714efb"><span class="ne-text">windows: set YUQUE_TOKEN=xxx &amp;&amp; yuque-hexo sync</span></li></ul></ul><p id="80b7a6176f74c553bec5f0b4e7dc6f72" class="ne-p"><br></p><p id="d98a0c16f0c78b2db09f687555835312" class="ne-p"><span class="ne-text">传入之后会有一封邮件发过来，然后新开 git bash 窗口，重新键入命令即可</span></p><p id="67c39da07103d4b23b265ef69b2fa057" class="ne-p"><br></p><p id="46c16134c60623cc08d63a8b2a685498" class="ne-p"><span class="ne-text">成功之后是这个样子的</span></p><p id="605a4b572a6bac241c4e93d7b37a43c5" class="ne-p"><br></p><pre data-language="bash" id="12a68a67" class="ne-codeblock language-bash">$ yuque-hexo sync<br>[INFO] clear previous directory.<br>[INFO] remove yuque posts: D:\Blog\blog-wztlink1013-3.0\source_posts\yuque<br>[INFO] reading from local file: D:\Blog\blog-wztlink1013-3.0\yuque.json<br>[INFO] article amount: 2<br>[INFO] download articles done!<br>[INFO] writing to local file: D:\Blog\blog-wztlink1013-3.0\yuque.json<br>[INFO] create posts directory (if it not exists): D:\Blog\blog-wztlink1013-3.0\source_posts\yuque<br>[INFO] generate post file: D:\Blog\blog-wztlink1013-3.0\source_posts\yuque\hexo-test.md<br>[INFO] generate post file: D:\Blog\blog-wztlink1013-3.0\source_posts\yuque\语雀文章测试.md<br>[INFO] yuque-hexo sync done!</pre><p id="5ab2aa07cbdc7953228996e945bdf01a" class="ne-p"><br></p><h2 id="71997347"><span class="ne-text">相关参考</span></h2><p id="de79a711fdbd5ab555f6690ed4f99a54" class="ne-p"><br></p><ul class="ne-ul"><li id="a3fe61b48a4b226a4b7a6f12028145e8"><a href="https://airbrake.io/blog/http-errors/401-unauthorized-error" data-href="https://airbrake.io/blog/http-errors/401-unauthorized-error" target="_blank" class="ne-link"><span class="ne-text">https://airbrake.io/blog/http-errors/401 U-unauthorized E-error:What It Is and How to Fix It</span></a></li><li id="30bd1db6228b8458b5ba1f52a8bf7366"><a href="https://www.yuguocong.cn/yuque/eg7hkp.html#Reference" data-href="https://www.yuguocong.cn/yuque/eg7hkp.html#Reference" target="_blank" class="ne-link"><span class="ne-text">使用语雀编辑器写静态博客 https://www.yuguocong.cn/yuque/eg7hkp.html#Reference</span></a></li><li id="623a1f349f83a1b71d0fecedaf180812"><a href="https://blog.csdn.net/Caoyang_He/article/details/82181695?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" data-href="https://blog.csdn.net/Caoyang_He/article/details/82181695?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" class="ne-link"><span class="ne-text">windows10 环境变量设置及理解环境变量</span></a></li></ul></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-路径和nltk</title>
      <link href="/blog/uatg7m/"/>
      <url>/blog/uatg7m/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="6cb6c7f7"><span class="ne-text">一、路径相关</span></h2><h3 id="6ee0e6b6"><span class="ne-text">路径相关报错信息</span></h3><p id="4572a7354aab604138d885135048872d" class="ne-p"><br></p><pre data-language="python" id="66e8d9a3" class="ne-codeblock language-python">IOError: [Errno 2] No such file or directory</pre><p id="f25522bdb71fc742445b3197abc62381" class="ne-p"><br></p><pre data-language="python" id="b24040cd" class="ne-codeblock language-python">pandas.read_csv() 报错 OSError: Initializing from file failed</pre><p id="77b109b94605ef2a5e27757c7dc7205b" class="ne-p"><br></p><pre data-language="python" id="69c21780" class="ne-codeblock language-python">(unicode error) 'unicodeescape' codec can't decode bytes in position 2-3: truncated \UXXXXXXXX escape [duplicate]</pre><p id="b60edebe83dbf86246674b4c6af422bb" class="ne-p"><br></p><pre data-language="python" id="0ddbcd7c" class="ne-codeblock language-python">File b'train.csv' does not exist even though file exist</pre><p id="a316d145247105cdf0ba63d72c97d5d7" class="ne-p"><br></p><h3 id="23232096"><span class="ne-text">分析与解决问题</span></h3><p id="18dca0c7cdec33832180efc3da091854" class="ne-p"><br></p><p id="d16ae3a35aacbeb16dada31a93ccd7ca" class="ne-p"><span class="ne-text">编写python代码过程中，出现了类似这种一系列路径相关的错误，原因是，自己更改了</span><strong><span class="ne-text">相关文件夹/文件在电脑中的位置</span></strong><span class="ne-text">，解决办法就新建一个项目建一个全新路径或者修改现有路径</span></p><p id="e59d58fa2d2fe14d08e139b0efa22691" class="ne-p"><br></p><ul class="ne-ul"><li id="1a6eef5d0ccc2c6ee0ff14a8008f00e8"><code class="ne-code"><span class="ne-text">\</span></code><span class="ne-text">绝对路径 会报错（转义字符）处理：①双引号前面加一个r②</span><code class="ne-code"><span class="ne-text">\</span></code><span class="ne-text">换成</span><code class="ne-code"><span class="ne-text">\\</span></code><span class="ne-text">（硬盘代号后面的第一个）</span></li><li id="98df76572544ac1d18830058449ec39c"><code class="ne-code"><span class="ne-text">./</span></code><span class="ne-text">相对路径</span></li></ul><p id="51e22662287482e60928a4f653e88f5d" class="ne-p"><br></p><div class="ne-quote"><p id="7f956e229304152140484388f6e2c27a" class="ne-p"><span class="ne-text">三种解决方式</span></p><p id="6d409d8e37e7746f60de847ae6fe3b89" class="ne-p"><code class="ne-code"><span class="ne-text">r"C:\Users\YJG\Desktop\pi_digits.txt"</span></code></p><p id="60023f44cfe8f3239ef0a14cbc51d28e" class="ne-p"><code class="ne-code"><span class="ne-text">"C:\\Users\\YJG\\Desktop\\pi_digits.txt"</span></code></p><p id="368cecf545b73963cf3f48eb34394ced" class="ne-p"><code class="ne-code"><span class="ne-text">"C:/Users/YJG/Desktop/pi_digits.txt"</span></code></p></div><p id="0130f444cb27d4e3f231021e65c19049" class="ne-p"><br></p><h3 id="d252fb78"><span class="ne-text">PS：路径含中文</span></h3><p id="c9374d00a9b99aa410c3e1ca8a1f506f" class="ne-p"><br></p><p id="37468547ba25c2bf9bb9c7e411b1fe81" class="ne-p"><span class="ne-text">假如路径、文件名都完整，还是报错的原因是这个参数中有中文，即使Python3已经支持中文，但是调用pandas的read_csv()方法时，默认使用C engine作为parser engine，而当文件名中含有中文的时候，用C engine在部分情况下就会出错。所以在调用read_csv()方法时指定engine为Python就可以解决问题。根治：将路径编程全英文，这是必要素养习惯！</span></p><p id="523ad4dcba199dfa88e073f63aae22d0" class="ne-p"><br></p><p id="5d6ca3481b155b9518674862cd029000" class="ne-p"><code class="ne-code"><span class="ne-text">da4=pd.read_csv(xxxxxxxxxx,engine='python')</span></code></p><p id="5e5562d2ed4c57d81f6e8247742a7a3c" class="ne-p"><br></p><h3 id="e39bd83f"><span class="ne-text">PS：utf-8</span></h3><p id="c3b42e6aa5f6f8c52749c90950432a7b" class="ne-p"><br></p><pre data-language="plain" id="06337e9b" class="ne-codeblock language-plain">UnicodeDecodeError：: 'utf-8' codec can't decode byte 0xc8 in position 0: invalid contin</pre><p id="a5bece3a9a19565d2d1859c79539039d" class="ne-p"><br></p><div class="ne-quote"><p id="a914bb65d1269e2db74878a49f937c23" class="ne-p"><span class="ne-text">解决办法：</span><code class="ne-code"><span class="ne-text">data_1 = pd.read_csv(data1, encoding = 'gb2312')</span></code><span class="ne-text">或者gb2312换成gbk</span></p><p id="d12146d16852fb2ed497c307e21d919d" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/qq_18888869/article/details/82625343" data-href="https://blog.csdn.net/qq_18888869/article/details/82625343" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/qq_18888869/article/details/82625343</span></a></p></div><p id="300f902454be93b73d6799c083b90f8d" class="ne-p"><br></p><h2 id="1f1ff85b"><span class="ne-text">二、nltk相关</span></h2><p id="5f970449ad105f93602d5219004fbe5f" class="ne-p"><br></p><h3 id="50e37e8c"><span class="ne-text">nltk下载报错信息</span></h3><p id="86a67e61602f3f374027d37b4e1ea626" class="ne-p"><br></p><pre data-language="plain" id="d576af4c" class="ne-codeblock language-plain">bug:[WinError 10054] 远程主机强迫关闭了一个现有的连接</pre><p id="42cb1a2feb3d2b55b4fc758a07553bf4" class="ne-p"><br></p><h3 id="23232096-1"><span class="ne-text">分析与解决问题</span></h3><p id="d4fb6afc1f4b300011bb68ff044efe35" class="ne-p"><br></p><p id="9b0d8477193bb99726118cc416881992" class="ne-p"><span class="ne-text">原因：模型权重参数文件（.h5）较大，下载出现中断，下载失败</span></p><p id="c0e52bc335036398dc4557328dc97e2d" class="ne-p"><br></p><div class="ne-quote"><ul class="ne-ul"><li id="8406610a1907fc3a4c7a5628184ce9c3"><span class="ne-text">解决办法：手动下载模型，放到指定目录</span></li><li id="dad1ec73df28aa1c45d5870fc2477a31"><code class="ne-code"><span class="ne-text">C:\Users\XXX\AppData\Roaming</span></code></li></ul></div><p id="989b666510388075cfd915130f709b10" class="ne-p"><br></p><p id="dfd955e933a230756233255d25a2854f" class="ne-p"><a href="https://pan.baidu.com/s/1oUsf-FgVAZnQAtZWRwiK4w" data-href="https://pan.baidu.com/s/1oUsf-FgVAZnQAtZWRwiK4w" target="_blank" class="ne-link"><span class="ne-text">下载地址</span></a><span class="ne-text">  （密码9sar）</span></p><p id="8a60970ce06cd75e72a86f0ea972bb8f" class="ne-p"><br></p><h2 id="d17a0f0b"><span class="ne-text">参考</span></h2><p id="af71db04b34e3ce5951654ee0ae16651" class="ne-p"><br></p><ul class="ne-ul"><li id="ec7e0bef0a86f630f160680ec0254583"><a href="https://blog.csdn.net/zln_whu/article/details/103448420" data-href="https://blog.csdn.net/zln_whu/article/details/103448420" target="_blank" class="ne-link"><span class="ne-text">CSDN-103448420</span></a></li><li id="dccfaa5b278c9b44f0ae14f381df9fdb"><a href="https://www.jianshu.com/p/0e1d51a7549d" data-href="https://www.jianshu.com/p/0e1d51a7549d" target="_blank" class="ne-link"><span class="ne-text">nltk简书详细讲解</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javaweb-8080端口被占用</title>
      <link href="/blog/qi1md8/"/>
      <url>/blog/qi1md8/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h2 id="8143e79b" data-lake-id="6e6e7508ba3b5435e2b1f1f31d3721f6" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">一、报错信息</h2><p data-lake-id="1b5f8aaa4df491e018ca5f29d568a55c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="codeblock" id="638e3cf4" data-language="plain"><div class="lake-codeblock-content" style="border: 1px solid rgb(232, 232, 232); max-width: 750px; color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: rgb(249, 249, 249);"><div class="CodeMirror-sizer" style="color: rgb(89, 89, 89); margin: 0px; padding: 16px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><pre class="cm-s-default" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">localhost:8080 is already in use<p></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">Port 8080 required by Tomcat v8.0 Server at localhost is already in use. The server may already be running in another process, or a system process may be using the port. To start this server you will need to stop the other process or change the port number(s).<br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">Error running Tomcat8: Address localhost:8080 is already in use</span></span></pre></div></div></div><p data-lake-id="e4349de5bd7f8f254d74416b46dd2788" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 id="ddf7c1a7" data-lake-id="31ab5fbf0ac1440219c327547324593f" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">一、分析并解决问题</h2><p data-lake-id="7c296753c51224da3f6f8ba86099478a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="7b830aa09272d2dd170ab75569ebe12c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">电脑中 8080 端口被占用，导致 web 项目不能运行</p></blockquote><p data-lake-id="55e542800a9d1849918b1951eff3f12b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="3766c87d3d6fb43d668722db6b993e29" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">任务管理器关闭占用 8080 端口的程序</p></blockquote><p data-lake-id="1951daa14ef067b509b51dfc01982e59" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h3 id="2943492d" data-lake-id="4a5d871e69c23370660c26c5ca25d322" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">netstat -ano</h3><p data-lake-id="c6a33238a58c8d1107d0242d17011aa5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="59abdcdd660923e328cb466acc0e4017" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926284869-236a07ed-16de-4b45-9fb3-08aa10dd3df8.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="600px" style="visibility: visible; width: 1200px;"></span></p><p data-lake-id="e7a3f8e5e9ad71f255140e140473fc2a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h3 id="tasklist" data-lake-id="71ae2e730075815b21e9d9a87b21a10f" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">tasklist</h3><p data-lake-id="6ca90fd8f888c59dee73ac67b7ef68c6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="e1bc1b9363024045cd856135cdf88044" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926285001-7e1779f1-5c00-4f0d-ad38-20b653849c37.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="221px" style="visibility: visible; width: 1200px;"></span></p><p data-lake-id="9ebfb697e2449fe0287d85487119855a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926284877-544af23f-b422-49de-af28-86f9c7a37ce3.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="183px" style="visibility: visible; width: 1200px;"></span></p><p data-lake-id="1a7c764a03c949479b2152f9ef987f9c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h3 id="69ad1550" data-lake-id="1a455bf815a857916cb9a3b3a9340b92" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">任务管理器</h3><p data-lake-id="711499bc584bb73d78ba43fc155d6240" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="d3ae8add94374a3de6911dd3f39bb3be" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926285182-6bfb20a5-33a4-4a6b-8969-eaae9b7c67e4.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="550px" style="visibility: visible; width: 834px;"></span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java-数组越界和格式输出</title>
      <link href="/blog/ggg01q/"/>
      <url>/blog/ggg01q/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="6953feac"><span class="ne-text">一、数组越界</span></h2><p id="ef8d9c449b9c1595eee4574c958052a7" class="ne-p"><br></p><pre data-language="plain" id="undefinedjava.lang.ArrayIndexOutOfBoundsException" class="ne-codeblock language-plain">java.lang.ArrayIndexOutOfBoundsException</pre><p id="365dbf1ad5e831e9ac666e50b1ec62e2" class="ne-p"><br></p><p id="0a5ef263206536f3d8aba91a5ac29c67" class="ne-p"><span class="ne-text">在进行判断条件的时候，注意java当中的数组“尾巴”不要溢出，数组arr的合法错误范围是[0, arr.length-1]</span></p><p id="b7fb4213061462c3d8ffe3b97510e143" class="ne-p"><br></p><div class="ne-quote"><ul class="ne-ul"><li id="115f5c8864dbc7860bf4f7483828f107"><span class="ne-text">解决办法</span></li><li id="9b5e076598c645840f671a68b6be4610"><span class="ne-text">①debug看数组的尾巴部分输出情况【数组空间小的情况】</span></li><li id="ceb10f9eccfeb3d572e114a2c3f5ff33"><span class="ne-text">②打印出遍历数组的索引值【通法】</span></li></ul></div><p id="d321e72e5e5ea5888c26e8aaaac190d1" class="ne-p"><br></p><p id="451fa4ca0566b107b1a3f910de9e9e01" class="ne-p"><span class="ne-text">回顾java初始化数组的方式：</span></p><p id="9eed60078362de9769f1be52daa98536" class="ne-p"><br></p><ul class="ne-ul"><li id="c0b493a3fcbc1459efd18bab206ffd73"><span class="ne-text">静态初始化：初始化时由程序员显式指定每个数组元素的初始值，有系统决定数组的长度</span></li></ul><p id="55cf7232943b58c78b0333979f7ad75a" class="ne-p"><br></p><div class="ne-quote"><p id="b4497d258f084bfc71a1572d642eb1f7" class="ne-p"><span class="ne-text">arrayName = new type[]{element1,element2,element3...}</span></p></div><p id="de17ad4ebe2d619a5e80036fc407baaa" class="ne-p"><br></p><pre data-language="plain" id="0759d62d" class="ne-codeblock language-plain">int[] intArr;<p>intArr = new int[]{1,2,3,4,5,9};<br>或者<br>String[] strArr = {“one”,”two”,”three”};</pre><p id="9283aef11a653b0b37b8aec0cd7a3bba" class="ne-p"><br></p><ul class="ne-ul"><li id="03d46573ddf9904f5530386eb82eaf65"><span class="ne-text">动态初始化：初始化时由程序员指定数组的长度，由系统初始化每个数组元素的默认值</span></li></ul><p id="4dc5dfcaa68bfffd95a8e849bb540f56" class="ne-p"><br></p><div class="ne-quote"><p id="6fbae475735826aa743ea704e205f3e7" class="ne-p"><span class="ne-text">arrayName = new type[length];</span></p></div><p id="8470ce9eeb19741aab7fb8a824ac834d" class="ne-p"><br></p><pre data-language="plain" id="088a49c2" class="ne-codeblock language-plain">int[] price = new int[4];</pre><p id="2f0dd1a0e2b6c1f5db5ffbd687dbea5b" class="ne-p"><br></p><h2 id="96385a14"><span class="ne-text">二、printf；println；print</span></h2><p id="721b6280ca8d22d8781b1ca32fd2a3ec" class="ne-p"><br></p><ul class="ne-ul"><li id="99ed124d8558c69232540d087f1aaa9d"><span class="ne-text">printf：遇到浮点型数值，继承 C 语言里面的使用，</span><strong><span class="ne-text">格式化</span></strong><span class="ne-text">输出（注意，参数顺序）</span></li><li id="4d859ec6733c79e1339c0ac2a3a84fbe"><span class="ne-text">print：就是一般的标准输出，但是不换行</span></li><li id="d3c56ae7a320ace2d0efcac97bc63425"><span class="ne-text">println：比 print 多的就是最后会换行</span></li></ul><p id="27a1cc90deb12ac3203b9cb3703930d1" class="ne-p"><br></p><pre data-language="java" id="29b9ff61" class="ne-codeblock language-java">int i = 4;<br>double j = 5;<br>System.out.print("用 print 输出 i:"+ i);<br>System.out.println( "用 println 输出 i:"+ i);<br>System.out.printf("i 的值为%d,j 的值为%f", i,j);</pre><p id="21a22fb39f77371a3719428561eb008d" class="ne-p"><br></p><pre data-language="java" id="59a97872" class="ne-codeblock language-java">用 print 输出 i:4 用 println 输出 i:4<br>i 的值为 4,j 的值为 5.000000</pre><p id="4c5dac63daeed25029624c7ee1457dad" class="ne-p"><br></p><ul class="ne-ul"><li id="3dc5d732d1617382de279b78a19e5d1e"><span class="ne-text">printf 补充</span></li></ul><p id="4d998a17d694cb8d98c3a44ebb29bba9" class="ne-p"><br></p><div class="ne-quote"><p id="be6192fed2951aa1e87ebaae7eb79ea5" class="ne-p"><code class="ne-code"><span class="ne-text">%.2f</span></code><span class="ne-text">的意思是输出两位小数点</span></p><p id="98a3e25683868903bd438347cf9630c6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926246151-1730c963-0816-46d1-bd3d-3a5cc7b30403.png" width="1162" id="yNmwS" class="ne-image"></p></div></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]java-找不到或无法加载主类</title>
      <link href="/blog/qp81g3/"/>
      <url>/blog/qp81g3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%2C0%5D%2C%5B0%2C0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="5f3f8ed1c94a28a194dab640dcde88d1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><a href="https://www.cnblogs.com/wangxiaoha/p/6293340.html" target="_blank">https://www.cnblogs.com/wangxiaoha/p/6293340.html</a></p><p data-lake-id="c5110275132a34c3c5e42d12c7266950" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="41f609406e519eb7211946495647cff9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><a href="https://bbs.csdn.net/topics/391862656?page=1" target="_blank">https://bbs.csdn.net/topics/391862656?page=1</a></p><p data-lake-id="c4a0d3d36977e1aacb2fdaf61d5f0d50" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="d641d0fae7066365428190f8100d86e9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><a href="https://blog.csdn.net/qinshijangshan/article/details/53048342?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1&utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1" target="_blank">https://blog.csdn.net/qinshijangshan/article/details/53048342?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1&utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1</a></p><p data-lake-id="82fa89a7de79ce001871809d8627e522" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="f0fda97727a41a23f270bcad738d74d2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><a href="https://blog.csdn.net/lanchunhui/article/details/76339252" target="_blank">https://blog.csdn.net/lanchunhui/article/details/76339252</a></p><p data-lake-id="fd9a27cb9134d644c33609d20ecdd164" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="136c7bd2247aa2025a52a24d364b5fe0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><a href="https://blog.csdn.net/qq_37717853/article/details/78218606?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank">eclipse下的输入参数方式</a></p></div>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo-生成文章出错</title>
      <link href="/blog/pxpix4/"/>
      <url>/blog/pxpix4/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="8143e79b"><span class="ne-text">一、报错信息</span></h2><p id="udc9d4e1d" class="ne-p"><br></p><p id="0290256124b20eb1dffc0915b07ff279" class="ne-p"><br></p><pre data-language="bash" id="c55039df" class="ne-codeblock language-bash">hexo g<p>INFO Start processing<br>FATAL Somethings wrong. Maybe you can find the solution here: <a href="https://hexo.io/docs/troubleshooting.html">https://hexo.io/docs/troubleshooting.html</a><br>Template render error: (unknown path)<br>unexpected end of file<br>at Object._prettifyError (D:\Blog\blog-wztlink1013-3.0\node_modules\nunjucks\src\lib.js:36:11)<br>at Template.render (D:\Blog\blog-wztlink1013-3.0\node_modules\nunjucks\src\environment.js:536:21)<br>at Environment.renderString (D:\Blog\blog-wztlink1013-3.0\node_modules\nunjucks\src\environment.js:378:17)<br>at D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\extend\tag.js:120:48<br>at tryCatcher (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\util.js:16:23)<br>at Function.Promise.fromNode.Promise.fromCallback (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:209:30)<br>at Tag.render (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\extend\tag.js:120:18)<br>at Object.onRenderEnd (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\hexo\post.js:291:22)<br>at D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\hexo\render.js:79:21<br>at tryCatcher (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\util.js:16:23)<br>at Promise._settlePromiseFromHandler (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:547:31)<br>at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:604:18)<br>at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)<br>at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)<br>at _drainQueueStep (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:93:12)<br>at _drainQueue (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:86:9)<br>at Async._drainQueues (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:102:5)<br>at Immediate.Async.drainQueues (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:15:14)<br>at processImmediate (internal/timers.js:456:21)</pre><p id="a6f9e2b26b91c578ff98443908ffdb5e" class="ne-p"><br></p><h2 id="8435b3ec"><span class="ne-text">二、分析并解决问题</span></h2><p id="8116886521e85c899667ead8b0939441" class="ne-p"><br></p><p id="81c68d6aebd4c5df313760f694ce83ee" class="ne-p"><span class="ne-text">根据报错信息，包 nunjucks、bluebird 使用异常</span></p><p id="752dccd22df2accc971e1af2f6f4842c" class="ne-p"><br></p><p id="24fafb7d6f3bf1242f3e94519e1e8995" class="ne-p"><span class="ne-text">然后进到 node_modules 文件夹里面分别找到两个包，进入 README.md 进入官网，numjucks 包应该是渲染文章有关，期间出错应该是 markdown 文章里面所使用的标签与 nunjucks 模板引擎的标签冲突，</span></p><p id="92cfd6a7216a1a70cb3922ed6874d9c8" class="ne-p"><br></p><p id="bf9d4f2cb0f538212d0c492fc13933f5" class="ne-p"><span class="ne-text">根据文档定位英文大括号的使用，定位文章使用带有大括号的 fancybox 标签，标签结束忘记加 end 而导致出错</span></p><p id="84594cbd2668af5006192182d8ee9498" class="ne-p"><br></p><h2 id="e439b6ae"><span class="ne-text">三、hexo g 出错总结</span></h2><p id="4ed95a6a5dba1c9f93e05752e4e283ae" class="ne-p"><br></p><p id="81f39ca9a90a4429135f849befd2e58e" class="ne-p"><span class="ne-text">hexo g 出错总结多为文件格式出错，主题配置出错，抑或是文章格式出错等</span></p><p id="8071d35b5aabe8d9c91b79eb1a4dce51" class="ne-p"><br></p><h3 id="a7851469"><span class="ne-text">文章头部</span></h3><p id="27050f9c56314d5415841c203b157e72" class="ne-p"><br></p><ul class="ne-ul"><li id="6e12cc6c48adc8ae1d03f3b434236566"><em><span class="ne-text">hexo 相关文章报错，大多数为格式出错，文章头部的使用严格遵循 hexo 官方文档的使用，但是目录优化插件，使得文章头部的元信息更为简单化</span></em></li><li id="0094e52e5e0b5bdf749eb907f2ace394"><span class="ne-text">减号</span><code class="ne-code"><span class="ne-text">-</span></code><span class="ne-text">分隔符，注意头部 front-matter、markdown 行分隔。如果没有加 front-matter，文章还用了 markdown，会报错<br></span><code class="ne-code"><span class="ne-text">YAMLException: end of the stream or a document separator is expected at line 6, column 1:</span></code></li><li id="b89d0887667d0801fb9ee3b28cd257bd"><span class="ne-text">目录优化插件的使用</span></li></ul><p id="f13ef048f86d86b522a2e6edce54091b" class="ne-p"><br></p><h3 id="d5bce8fc"><span class="ne-text">文章体</span></h3><p id="579711fa71a925dd2c3d0f97bbc49f6d" class="ne-p"><br></p><ul class="ne-ul"><li id="0a42815bf740f97e80d3c67440418199"><span class="ne-text">英文大括号的使用要“有始有终”，Volantis 主题的大括号标签使用</span></li></ul><p id="b3cae8064e5d996bfaac2b365b037af5" class="ne-p"><br></p><h3 id="6feddb88"><span class="ne-text">空格问题</span></h3><p id="73742133f5f51e192492336031a9afe6" class="ne-p"><br></p><pre data-language="bash" id="8f8d73c5" class="ne-codeblock language-bash">ERROR Process failed: _posts/yuque/外汇时间序列预测.md<br>YAMLException: end of the stream or a document separator is expected at line 2, column 11:<br>categories:<br>^<br>at generateError (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:167:10)<br>at throwError (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:173:9)<br>at readDocument (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:1545:5)<br>at loadDocuments (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:1588:5)<br>at Object.load (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:1614:19)<br>at parseYAML (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo-front-matter\lib\front_matter.js:78:23)<br>at parse (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo-front-matter\lib\front_matter.js:54:12)<br>at D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\plugins\processor\post.js:48:20<br>at tryCatcher (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\util.js:16:23)<br>at Promise._settlePromiseFromHandler (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:544:35)<br>at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:604:18)<br>at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)<br>at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)<br>at Promise._fulfill (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:673:18)<br>at PromiseArray._resolve (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:127:19)<br>at PromiseArray._promiseFulfilled (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:145:14)<br>at PromiseArray._iterate (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:115:31)<br>at PromiseArray.init [as _init] (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:79:10)<br>at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:601:21)<br>at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)<br>at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)<br>at Promise._fulfill (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:673:18)<br>at PromiseArray._resolve (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:127:19)<br>at PromiseArray._promiseFulfilled (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:145:14)<br>at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:609:26)<br>at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)<br>at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)<br>at Promise._fulfill (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:673:18)<br>INFO Generating Baidu urls for last 1 posts</pre><p id="10e2910c1eb345ce483a118a0b0aac93" class="ne-p"><br></p><p id="64c77b8979194e0ea31bed3b51962930" class="ne-p"><span class="ne-text">奇葩错误，在最上面的三个分隔符后面也要加空格，可能是语雀那边同步过来的文章问题</span></p><p id="1e3923d7d621d60a86b2a271d041570f" class="ne-p"><br></p><h2 id="d17a0f0b"><span class="ne-text">参考</span></h2><p id="127424fd9c6256ada29b9793e5c43d35" class="ne-p"><br></p><ul class="ne-ul"><li id="3a670f8cba1c6b1ef1852f5fb14eeeef"><a href="https://mozilla.github.io/nunjucks/cn/getting-started.html" data-href="https://mozilla.github.io/nunjucks/cn/getting-started.html" target="_blank" class="ne-link"><span class="ne-text">nunjucks 文档</span></a></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSH-登录报错</title>
      <link href="/blog/pix070/"/>
      <url>/blog/pix070/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B1%2C0%2C0%5D%2C%5B1%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><div data-card-type="block" data-lake-card="hr" class="lake-selected"></div><h2 id="8143e79b" data-lake-id="f844a36677bf492050ebc7f11f63c401" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">一、报错信息</h2><p data-lake-id="761152f5c808cb7d38ef42984e7cc521" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="codeblock" id="38b44fda" data-language="bash"><div class="lake-codeblock-content" style="border: 1px solid rgb(232, 232, 232); max-width: 750px; color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: rgb(249, 249, 249);"><div class="CodeMirror-sizer" style="color: rgb(89, 89, 89); margin: 0px; padding: 16px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><pre class="cm-s-default" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">remote: Coding 提示: Authentication failed.<p></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">remote: 认证失败，请确认您输入了正确的账号密码。<br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">fatal: Authentication failed <span class="cm-keyword" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">for</span> <span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">‘<a href="https://e.coding.net/wztlink1013/wztlink1013.git/&#39;">https://e.coding.net/wztlink1013/wztlink1013.git/&#39;</a></span><br></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">##[error]Process completed with exit code 128.</span></span></span></pre></div></div></div><p data-lake-id="a8bd6aa03824b3fee9b508b237904085" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 id="8435b3ec" data-lake-id="e6932990382774d563240f5a3903bc1f" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">二、分析并解决问题</h2><p data-lake-id="0a7298dd94a9898e274849cfba8e27f0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="d0f3fe7639a6665610483bd06e887764" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">自动化部署过程中，coding 认证出错，我觉得应该有两个可能性</p><p data-lake-id="97d4f0e71b685f58b34fab6cc8d08c8a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><ol start="1" data-lake-id="4a69e448b2d49ab957765c25c68f89b1" lake-indent="0" style="list-style-type: decimal; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="146323826f704af268d5f04419aa45c8">字面意思账号密码出错</li><li data-lake-id="2c31f3bf4f9adabb87b8df236856237c">SSH 密匙没有匹配到</li><li data-lake-id="2a1164156ca68200a987ea75243e764e">在 GitHub Actions 上所配置的 Token 信息之间也修改了一次，会不会是忘了改用户名</li></ol><p data-lake-id="c51b636f86f0c517cf986af15d5b7476" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="a55a081aca880a4fc853f8fd5123f55a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">如果是第一种情况，已经进入控制面板中的凭据管理器，更改了 coding 在本机上的默认永久密码，不弹窗理论没事，但是无效，</p><p data-lake-id="6971a343522590a3830dc423dce83ba0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="7db10bb3a80c392794d2f314954c6e2d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">根据上次在本机上克隆 coding 仓库也没有其任何反应，所以问题应该出在 ssh 密匙上面，进一步回想，自己重装电脑后，当时是打算不使用全局用户没加上 global 打算使用各个用户，但是最后又换成全局用户，所以生成的.ssh 文件夹下的 config 文件有被删除了，会不会是 config 里面的 coding host 被删除，就默认这个电脑只有初始化 github 用户呢？</p><p data-lake-id="6c9b8adf912cd8c0e1e677e9c63a8ac2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="46ac5f8a84910d50f6f10ed68c11b899" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">好的，试验了一下，解决了在本地电脑 coding“不算用户”的问题，但是自动化部署的问题未解决</p><p data-lake-id="c418c4409e76cd3ffba5b8ae0c5c3167" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="d74b5f15ae3207ad791d90bd7c369b75" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">最后试一下 GitHub Actions 上是不是 coding 用户名之间忘了换一次，的确是……</p><p data-lake-id="a955016f8030a00026cf6fe38aea877c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 id="d17a0f0b" data-lake-id="19e03c439997d90dc5d2b06466085f99" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">参考</h2><p data-lake-id="b06903a987f6793be74653c8518d67a3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><ul data-lake-id="c8a55060d83b00c160376ff098e887a6" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="144069c225a0fb5a70f6b2f5d56fceef"><a href="https://www.jianshu.com/p/501277e1bada" target="_blank">一台电脑利用秘钥绑定多个 ssh-key 账号（实 n</a></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Navicat-1045报错</title>
      <link href="/blog/wp9hok/"/>
      <url>/blog/wp9hok/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B1%2C0%2C0%5D%2C%5B1%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="49d9a52fd6c657cc2839c1fa0936025a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="8248fb69e3bab28e9665c9cca1825e23" id="WeVFN" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">一、报错信息</h2><p data-lake-id="cf5f4a7f1083fe6d2f0bbaf1b5b84145" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="codeblock" id="a8d3827a" data-language="plain"><div class="lake-codeblock-content" style="border: 1px solid rgb(232, 232, 232); max-width: 750px; color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: rgb(249, 249, 249);"><div class="CodeMirror-sizer" style="color: rgb(89, 89, 89); margin: 0px; padding: 16px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><pre class="cm-s-default" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">1045-Access denied for user root@localhost(using password:YES)</span></span></pre></div></div></div><p data-lake-id="eedf373a200787f1fbef38cc5612986b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 id="43117871" data-lake-id="fb99415e3ff4ec518003c40d69cf2759" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">二、问题分析与解决</h2><p data-lake-id="2c339a4453f6351b9b3a2b08e57487ce" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="b627d75ea66c5a0c93c14c0598a057ba" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">不被接入，改root密码</p><p data-lake-id="e3ae1b1417fdb74f54415345d17e187b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="130a3667ffbbf7789245b583f79b25fc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">在mysql控制台里面改密码</p><p data-lake-id="488f9d4e1a58439def93d24f16d5a4a7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="e9cc0fdbe2507031a2f5f37cc2b22ff1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码';</code></p><p data-lake-id="a5b3c1f6f0cbba5c627f295099ee9988" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c60fe0d946ea3a88bfc10502a28436b4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">刷新数据库</p><p data-lake-id="223e3e13d2036f1356f8c3fca17090fd" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="034821b17ea0bac9ced4ddf0ad122d5a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">flush privileges;</code></p><p data-lake-id="dd50c550c7e8962d61e96ee6a110cfbe" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="3a94eff37557d8316b987dfd47a34f0e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">退出</p><p data-lake-id="76ebc5952b42a751224a0e25846f5f5e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="eeac4566ed6043956c11313ec270d7a7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">quit;</code></p><p data-lake-id="701ba1c28f8c40d7a2d0ec3ad5ea1fad" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="7cc50a2f0b953b821b843276aa571580" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">重启Navicat再次链接即可。</p><p data-lake-id="167333e5553eeced03dc96ea275ee4d9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 id="d17a0f0b" data-lake-id="f3cc9e72f0b777fe04e652a3a2224bb1" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">参考</h2><p data-lake-id="b3a317b50036cee0e03be7e3b516003a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><ul data-lake-id="bc09f8b6673740b3ba3410c03989a4f4" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="70986a211afe210d9bf4b76d270a5e2a"><a href="https://blog.csdn.net/acoolgiser/article/details/82967317?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159185926319725250149590%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=159185926319725250149590&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_ctr_v3-4-82967317.ecpm_v1_rank_ctr_v3&utm_term=1045-Access+denied+for+user+ro" target="_blank">acoolgiser</a></li><li data-lake-id="5e3aebd52bb51d553f88676be9d8606b"><a href="https://blog.csdn.net/zhang_yu_ling/article/details/103177296?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159185926319725250149590%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=159185926319725250149590&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_ctr_v3-2-103177296.ecpm_v1_rank_ctr_v3&utm_term=1045-Access+denied+for+user+ro" target="_blank">张张张i</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『斩·赤红之瞳』</title>
      <link href="/essay/vbkkpv/"/>
      <url>/essay/vbkkpv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="4d5347df929630415d1eaa23d5a8f0b4" id="4d5347df929630415d1eaa23d5a8f0b4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>赤瞳的“葬送！”永远无敌，威尔的乡巴佬（贵族）战车甚是让人怀念！</span></p><p data-lake-id="u02c38766" id="u02c38766" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="tBuFQ"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1620268429108-34b6b7b4-9e0e-44f5-aec6-6ea523773328.jpeg" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="60px" style="visibility: visible; width: 60px;"></span></p><p data-lake-id="u011e84f1" id="u011e84f1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="uab433b80" id="uab433b80" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>最喜欢威尔这个角色，有自己的信仰，却又不被信仰所蒙蔽双眼！</span></p><p data-lake-id="u2b652480" id="u2b652480" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="u9c94a2b1" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620268376141-97fd7be2-f256-442b-970d-1ab2b6b29214.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="540px" style="visibility: visible; width: 960px;"></span></p><p data-lake-id="u39838fd4" id="u39838fd4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="uac513801" id="uac513801" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="uf72f0f30" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619317355425-0fe5d175-5fc4-4e3c-b6e0-ecef02d26cf6.png" data-raw-src="" class="image lake-drag-image" alt="592276.png" title="592276.png" data-height="1080px" style="visibility: visible; width: 1920px;"></span></p><p data-lake-id="2d98ab074f3c7042e488f2cbe8a8fc8b" id="2d98ab074f3c7042e488f2cbe8a8fc8b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="KgBwl" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619403236436-3b1f1084-70d1-470c-8033-8da759333d26.png" data-raw-src="" class="image lake-drag-image" alt="81852880_p0.png" title="81852880_p0.png" data-height="2039px" style="visibility: visible; width: 1378px;"></span></p><p data-lake-id="7dc62483859c13d4e812cef7cd35d93a" id="7dc62483859c13d4e812cef7cd35d93a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="OBENY" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619403320717-174bfe62-fc0d-4470-ade4-dfaec764e1a8.jpeg" data-raw-src="" class="image lake-drag-image" alt="605796.jpg" title="605796.jpg" data-height="1080px" style="visibility: visible; width: 1920px;"></span></p><p data-lake-id="c724b4145e0046b3240614788eaa0dfc" id="c724b4145e0046b3240614788eaa0dfc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="BZQXf" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619403335035-06379a53-3aa1-4ed1-8194-864aa0423edf.png" data-raw-src="" class="image lake-drag-image" alt="610221.png" title="610221.png" data-height="1359px" style="visibility: visible; width: 1920px;"></span></p><p data-lake-id="635826ac418eda5a93f130567610a042" id="635826ac418eda5a93f130567610a042" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="poIeY" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619403340923-d3a0d8f3-2a53-4f2d-ae07-18c5a4d10d3b.jpeg" data-raw-src="" class="image lake-drag-image" alt="554303.jpg" title="554303.jpg" data-height="1080px" style="visibility: visible; width: 1920px;"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>榕树下的男孩和女孩</title>
      <link href="/essay/rqlvig/"/>
      <url>/essay/rqlvig/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="1d7566e2ce91837757f63ad4c71dc461" class="ne-p"><span class="ne-text">趁着伙伴们都还在睡觉那天还未入夜，他朝着桥的那头跑去，那天月亮高高挂起，像是蒙娜丽莎的那般深邃眼眸观望着他，突然，他像是被什么东西拍打了一下，男孩往后望去，是个小女孩，那女孩头发短短的，头发末梢还有些卷卷的，就像是柳树下的枝柳发梢一般，凌乱有致，最重要的是男孩被那饱含星辰大海的眼眸所吸引，还有那唇……小男孩突然一愣，回应道：“你是谁？”女孩说：“我练完了，想去桥的那头玩玩！”男孩惊讶之，连忙回应：“我也是”，榕树那边的风景亦是观之，却不能让我陶醉，说罢，小男孩帮那个小女孩整理一番身边的杂草，他想牵起哪个女孩的手，但是他并没有，他在害怕吗？不知道。我想可能是他没有这般前期过别人的手吧。</span></p><p id="4441b864f887e27f7ccf204b29aaccb7" class="ne-p"><br></p><p id="3190081a6e59df3c1441b07abc83880c" class="ne-p"><span class="ne-text">桥的那头好漂亮，哪里有些许的繁华，还有些唱作，同时传来了一阵阵的童谣响起，那个女孩心里一颤，她说，如熟悉的唱作，和我家乡一般，她说她听到了她儿时的童谣，男孩向她的眼眸观去，他像是看到了星辰，他瞬间感受到一种温度，是的！他喜欢上她了。</span></p><p id="a5c0557a57bacf31ec6fad3c7a9a026b" class="ne-p"><br></p><p id="a56aad4aa282c86bfa6016bb8246d630" class="ne-p"><span class="ne-text">榕树下的人们，是有着各自的命运的，男孩和女孩，男孩子要往前走，因为这里的人们是不能停滞的。因为它们本该如此。</span></p><p id="cd07cb19ab0d9b7ed28b6e7e57891e2a" class="ne-p"><br></p><p id="7d0db8c5f650bd4d67fac45439107db1" class="ne-p"><span class="ne-text">男孩终于忍不住了，他对女孩说：“你喜欢这个童谣吗？”女孩说：“好感动，能在这个地方听到这个童谣”，女孩有一个动作，她用手指收起了她的眼泪，男孩心里想着，桥是禁忌，按照他们的文明，那是他们不能逾越的禁忌。</span></p><p id="2d5b2b73089d8c223e2e84e4ab37cd00" class="ne-p"><br></p><p id="750dcb31634e19f9342bc273a591bf68" class="ne-p"><span class="ne-text">旁边的蛐蛐们开始了，仿佛开始为那童谣奏乐了，周围很喧闹，但是他的内心足够安静的，一切都是那般静，那一瞬间，那个男孩就像静静地享受着这般安静与温暖，就像是圆月下的海面，波光涟漪却也有着阵阵波澜。</span></p><p id="e81d44610904b1fb7a710f1c62c7d174" class="ne-p"><br></p><p id="8fa5f2a123c69946518c38feb8be5d17" class="ne-p"><span class="ne-text">桥就像是时间的奴隶，夜深了，桥头的那根锁链开始叮叮叮~的响起，像是提醒着失足的孩子们该回去了，男孩和女孩的时间不读了，往日，男孩会跑着回桥的那头榕树下，来日再来看看这繁华的都市，然后回到榕树下面，因为本该如此，他比谁都清楚榕树下的他背负着怎么样的命运。</span></p><p id="bf773ddc8ebbc413d245ca9a9ce98de2" class="ne-p"><br></p><p id="5e65cf931f30609108468b0a568faa49" class="ne-p"><span class="ne-text">黑夜里，男孩再也看不见女孩的脸，月光很圆，周围的灯也是明亮着的，但男孩却觉得周围一切都是暗淡的，因为他再也看不见那深邃的眼眸。</span></p><p id="bf7c1ce617753b73746228c3656ff276" class="ne-p"><br></p><p id="701110b2feba53e25a78ee149c96e9db" class="ne-p"><span class="ne-text">女孩对男孩说：“谢谢你帮我越过那座桥，我才有了这般幸运，在这榕树下的文明之外还能听到这般旋律，谢谢你！”</span></p><p id="17b374ef3671a31ce0cfc933e636ac65" class="ne-p"><br></p><p id="63d690780371f847b501d7fa5d01a446" class="ne-p"><span class="ne-text">但是男孩心里想要的不是这句谢谢，是她眼神之下的温暖的星辰大海，因为他一直往前走，修炼。</span></p><p id="e6373480df5c8b13e5682bb37b355adb" class="ne-p"><br></p><p id="bf86e966e4fced747e73743c61952f9e" class="ne-p"><span class="ne-text">他想要在榕树下成为一个真正的男人，特立独行，无惧生死，因为他觉得，他本该如此！可今天，他似乎被他的脸庞融化了。</span></p><p id="a4ef5a86c0d7e8da0acc15641c1a2fb9" class="ne-p"><br></p><p id="8226b772c42542e024ff90eccad992c4" class="ne-p"><span class="ne-text">一路上，男孩和女孩说着话，他从来没有这般欣喜，来到榕树下面，这个新生的文明之下，可是，女孩的话却在变少。</span></p><p id="1b64e79979726d07de770d8d9d1af857" class="ne-p"><br></p><p id="09826dd0ccd0dcb374010907d7edf95b" class="ne-p"><span class="ne-text">回到榕树下，隧道已经慢慢如期开启，男孩和女孩要走了，男孩心里清楚着，他不会再见她了，他心里忧伤，却也无奈，因为，在此之下的文明，亦是如此，就像是之前所述的“内壁”那般文明、国度。或者还可以说，文明之间，男孩和女孩是不合适的，因为她走的和他走的路从一开始就是相反的道路，但在榕树下的男孩确实一直以来有着思想的精灵，他有些忍不住了，在女孩走向隧道那扇门之前那么一瞬，男孩大声说：“喂，你，你的眼睛很好看，虽然夜太黑，但我心里还记得，我喜欢你，喜欢你喜欢的童谣，喜欢你眼睛中的星辰大海！我从没有想过，在榕树下的文明，还能遇见此般的你。还有，我很喜欢你的微笑。”女孩说：“嗯。”</span></p><p id="f0977dd3725c4a2381780c8afffe3662" class="ne-p"><br></p><p id="65bfb4e9a768829c0f3c1419f9950934" class="ne-p" style="text-align: right"><span class="ne-text">2020.10.12 文渊楼C区255 划水ing</span></p><p id="e6b7dac91bae278c8857fc939b6fada0" class="ne-p"><br></p><p id="5e80a729e612ce99e0932a44d8485b18" class="ne-p"><br></p><p id="3423b105bfebc4d3900d307e7afb39a7" class="ne-p"><br></p><p id="d86240bf1f2f2d9aad38e7931f8cd558" class="ne-p"><br></p><p id="7b12c62ef43b24559f609a23304f3d86" class="ne-p"><br></p><p id="ba1c4c70ad519486533e6e926f432c36" class="ne-p"><br></p><p id="f2a32ac6ba0dc1c7568f79d430f3367e" class="ne-p"><br></p><p id="f24eaaa0d5cd4d22c9456ab81811a36f" class="ne-p"><br></p><p id="4f7b3eb7f81cf8a97ad2ea936c89b425" class="ne-p"><br></p><p id="1dc644f52f7290e6962924c310411cd4" class="ne-p"><br></p><p id="fc014c80621168c1c9f88a93bd3e3eb1" class="ne-p"><br></p><p id="5a04c1a2e4fe27c0194f9e9b62416321" class="ne-p"><br></p><p id="1212e6a9c2a608df86f5c07188246a0e" class="ne-p"><br></p><p id="c0751504927e50bc1c9a47d7705d3158" class="ne-p"><br></p><p id="9545187d3685a16dc3522d493ab9c3e0" class="ne-p"><br></p><p id="3e9e7a5c222f1d644557e25b8d5f0a95" class="ne-p"><br></p><p id="714dfd2fd5943aa16fa426ff14c08c36" class="ne-p"><br></p><p id="03614da8e3615918912ba895082e229c" class="ne-p"><br></p><p id="e6f32b19cd698891d69d8c896d94de0e" class="ne-p"><br></p><p id="663279fcd51f2aa3c1294bff04483d92" class="ne-p"><br></p><p id="480a4e0f5342fcfa1e791861735a0c44" class="ne-p"><br></p><p id="93bac6acd442264a945de2d3261188be" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>鸟儿飞走了</title>
      <link href="/essay/pyxkf8/"/>
      <url>/essay/pyxkf8/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p class="ne-p"><span class="ne-text">学校又要建楼了，地点是图书馆靠西边的那片树林。</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">去二餐的靠建筑工地的那条沿路上，总是听到叽叽喳喳的小鸟叫声，定睛一看，原来是因建筑而没有去路的小鸟，它们就在那片矮秃秃的草丛里面，就像是饿了的稚鸟在窝里面叽叽喳喳等它们母亲回来一般。</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">“济南一建”的速度真是快，短短一个月不到，那栋楼就建成有二、三层高楼那般模样，可我却不太喜欢它们这么快速度，因为那样，就会挡住我在E区各个楼道往学校南边观去的视线，正好挡住学校后面的双龙山，学校的小鸟也会少了，估计它们会生气般地往山上飞去，不再飞回来了。</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">为什么我会有些许的伤感……</span></p><p class="ne-p"><br></p><p class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对待问题要静心处理</title>
      <link href="/essay/wgtfly/"/>
      <url>/essay/wgtfly/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-traditional" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B4%2C0%2C28%5D%2C%5B4%2C0%2C28%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">在配置安卓环境的时候，遇到sdk漏下载的情况，中间有几次心态爆炸，遇到问题发现自己还是不能很好的解决</p><p data-lake-id="c789ee93d870002ab938c2a1eaa2945c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="8a79987fff927dee2a879f619b9d093d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">这过程中，S同学说到他配置环境用到了三天，最后成功了，而且，他的环境远劣于我，突然让我想到一句话，<strong>谁都会遇到问题，甚至遇到的问题都一样</strong>。但是不同的人会有不同的处理方式以及对待问题的态度，我的心真的还不够静，甚至可以说，依旧那么浮躁…</p><p data-lake-id="cce84e6685db6643aa7e727e2610a2da" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="dd4591e6ca22fb5dbaba5cfa73b9180c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">遇到困难，要静下心来，纸上得来终觉浅，绝知此事要躬行啊～</p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL命令</title>
      <link href="/blog/emv1ek/"/>
      <url>/blog/emv1ek/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="pJGka"><span class="ne-text">登陆命令</span></h2><pre data-language="sql" id="510a2266" class="ne-codeblock language-sql">mysql -u用户名 -p密码</pre><p id="9d3e4cdd32d13a017bdacf93b6aa46c2" class="ne-p"><br></p><p id="6e5a7a202012b590b171e47b52fe8cc1" class="ne-p"><span class="ne-text">用户名和-u选项之间可以有空格，但是密码和-p选项之间必须无空格。但是这样密码会是明文。你可以在键入-p之后，回车再输入密码，就是密文。</span></p><h3 id="9bd86151"><span class="ne-text">常用选项</span></h3><table id="6e556dd0" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"><p id="u962cab27" class="ne-p"><span class="ne-text">缩写</span></p></td><td width="250"><p id="ub2ac1b2f" class="ne-p"><span class="ne-text">全写</span></p></td><td width="250"><p id="ue7dfffb2" class="ne-p"><span class="ne-text">描述</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u8d129bd7" class="ne-p"><span class="ne-text">-h</span></p></td><td width="250"><p id="u14c8a173" class="ne-p"><span class="ne-text">--host</span></p></td><td width="250"><p id="ufda5cbaf" class="ne-p"><span class="ne-text">主机</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u02cf65e9" class="ne-p"><span class="ne-text">-p</span></p></td><td width="250"><p id="u7c8b7a89" class="ne-p"><span class="ne-text">--password</span></p></td><td width="250"><p id="uce52538b" class="ne-p"><span class="ne-text">密码</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="uda7d026b" class="ne-p"><span class="ne-text">-P</span></p></td><td width="250"><p id="u81f0a0e1" class="ne-p"><span class="ne-text">--port</span></p></td><td width="250"><p id="u53666f3b" class="ne-p"><span class="ne-text">端口</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u04e80790" class="ne-p"><span class="ne-text">-V</span></p></td><td width="250"><p id="u52ce53b6" class="ne-p"><span class="ne-text">--version</span></p></td><td width="250"><p id="u8c4174c1" class="ne-p"><span class="ne-text">版本信息</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u1c14005f" class="ne-p"><span class="ne-text">-u</span></p></td><td width="250"><p id="u0ccb3304" class="ne-p"><span class="ne-text">--user</span></p></td><td width="250"><p id="u66e5d746" class="ne-p"><span class="ne-text">用户</span></p></td></tr><tr style="height: 33px"><td width="250"></td><td width="250"><p id="ubb2212db" class="ne-p"><span class="ne-text">--prompt</span></p></td><td width="250"><p id="ub5b712a7" class="ne-p"><span class="ne-text">修改提示符</span></p></td></tr></tbody></table><h3 id="0uwjs"><span class="ne-text">--prompt</span></h3><p id="538b864922bf84bca428b7f2a1503405" class="ne-p"><span class="ne-text">--prompt 支持几个转义词组</span></p><ul class="ne-ul"><li id="4bcf9d78e5bc336af2ba268eca6f1431"><span class="ne-text">\h 主机名</span></li><li id="92ff3e8e115c6d9cc2451e3ee77b1536"><span class="ne-text">\D 完整日期</span></li><li id="82afff459f190e6e0ab1ab4496a0a3ee"><span class="ne-text">\d 当前数据库</span></li><li id="ec61665eb6c4347b1ca7b754722a1faa"><span class="ne-text">\u 当前用户</span></li></ul><h2 id="bb3550c3"><span class="ne-text">登陆之后</span></h2><h3 id="c3992269"><span class="ne-text">退出</span></h3><ul class="ne-ul"><li id="980b2fa0b7b57f2f78384b1969d9f6de"><span class="ne-text">exit</span></li><li id="0b129395f79f8eb9d823433b14311d60"><span class="ne-text">quit</span></li><li id="4b8c1c7e503302d5ab9b6b5f602c330a"><span class="ne-text">\q</span></li></ul><p id="30cd48337396ed4d706daf057f51f438" class="ne-p"><span class="ne-text">都能退出mysql，系统显示Bye。</span></p><h3 id="92e3a830"><span class="ne-text">帮助</span></h3><p id="2a1e8bb2abbc06007d4e9e91dc1ccf4c" class="ne-p"><span class="ne-text">键入</span><code class="ne-code"><span class="ne-text">help</span></code><span class="ne-text">或</span><code class="ne-code"><span class="ne-text">\h</span></code><span class="ne-text">。</span></p><h3 id="31738526"><span class="ne-text">显示信息</span></h3><p id="98aa3ee3fb9f096652d5a434b1f50ea6" class="ne-p"><span class="ne-text">select:</span></p><ul class="ne-ul"><li id="17ca8a09c666ba3cc0ceab8d932ff74f"><span class="ne-text">version(); 版本信息</span></li><li id="dc10cee22edb2e039b71b69d30d24c45"><span class="ne-text">now(); 当前时间</span></li><li id="205d24b50521967ec181576267f9f32e"><span class="ne-text">user(); 用户@主机名</span></li></ul><h3 id="1e95f265"><span class="ne-text">使用系统命令</span></h3><p id="6b132b365ce19075359ffc4be9ab4636" class="ne-p"><strong><span class="ne-text">!</span></strong><span class="ne-text"> 后加shell命令可以在mysql中执行shell命令。</span></p><div class="ne-quote"><p id="2326e1b9156228fc6d31ccf9e2c4b0a3" class="ne-p"><span class="ne-text">gdb使用shell加命令来执行shell命令。</span></p></div></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL表查询操作</title>
      <link href="/blog/igxqxi/"/>
      <url>/blog/igxqxi/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="BAHT9"><span class="ne-text">基本词汇</span></h2><div class="ne-quote"><p id="281ac2126bb3f15c34855cb037ef59f1" class="ne-p"><span class="ne-text">查询就是SELECT语句</span></p></div><pre data-language="sql" id="WhDJ5" class="ne-codeblock language-sql">SELECT  [ ALL | DISTINCT ]<pre><code>    [ TOP expression [ PERCENT ] [ WITH TIES ] ]&lt;列名&gt;                                             /*指定要选择的列及其限定*/[ INTO &lt;表名&gt; ]                             /*INTO子句，指定结果存入新表*/[ FROM &lt;查询对象&gt; ]                        /*FROM子句，指定表或视图*/[ WHERE &lt;条件&gt; ]                             /*WHERE子句，指定查询条件*/[ GROUP BY &lt;分组表达式&gt;]                 /*GROUP BY子句，指定分组表达式*/[ HAVING &lt;分组统计条件&gt;]                 /*HAVING子句，指定分组统计条件*/[ ORDER BY &lt;排序表达式&gt; [ ASC | DESC ] ] /*ORDER子句，指定排序表达式和顺序*/</code></pre><p></pre><div class="ne-quote"><p id="4531c0da0da9a1258271824694ebff28" class="ne-p"><span class="ne-text">说明：所有被使用的子句必须按语法说明中显示的顺序严格地排序。例如，一个HAVING子句必须位于GROUP BY子句之后，并位于ORDER BY子句之前。</span></p><p id="eeb63e310ce88f6799d083e7792faacb" class="ne-p"><span class="ne-text">SELECT语句返回一个表的结果集，通常该结果集被称为表值表达式。</span></p></div><h3 id="6dc7a717"><span class="ne-text">distinct</span></h3><p id="fd53e647a7907bfb73bd61e511df1db6" class="ne-p"><span class="ne-text">去掉重复的行</span></p><h3 id="MP2oa"><span class="ne-text">where</span></h3><div class="ne-quote"><p id="acbdd8aff3701871c1e5eb3b0fb5b1a0" class="ne-p"><span class="ne-text">条件</span></p></div><pre data-language="sql" id="1819D" class="ne-codeblock language-sql">select distinct Sname<br>        from Student<br>        where Sdept='CS'</pre><h3 id="VaMqd"><span class="ne-text">as</span></h3><p id="d9713f77d96e56752ea9608cf3711677" class="ne-p"><br></p><pre data-language="sql" id="8e1a0e1b" class="ne-codeblock language-sql">SELECT id AS userId，username AS uname<br>    FROM users;</pre><p id="0a7683985a492fc96205f2276289b805" class="ne-p"><br></p><p id="a5f6598ca4f824c5d1463ff8af6222c2" class="ne-p"><span class="ne-text">查询出来的列名，就变成了别名。AS其实可以省略，但可能会出现问题。</span></p><p id="5bbf5b398e0497c6449f873132394594" class="ne-p"><br></p><pre data-language="sql" id="1fdcc784" class="ne-codeblock language-sql">SELECT id username  FROM users;</pre><p id="ff49d08443d85b0933eaed9abca91b4c" class="ne-p"><br></p><p id="a697740377cad6b21f828f6ee3d7b953" class="ne-p"><span class="ne-text">这样会将username视作id的别名。</span></p><p id="2ecf77b59883f38893a621b52ffe096e" class="ne-p"><br></p><h3 id="d2nhV"><span class="ne-text">like </span></h3><pre data-language="sql" id="uRWYl" class="ne-codeblock language-sql">SELECT 书名 AS BookName, 作译者 AS Author, 出版社 AS Press<br>FROM TBook<br>WHERE 书名 LIKE '%SQL Server%'</pre><pre data-language="sql" id="zXFP0" class="ne-codeblock language-sql">select Sname, Sno, Ssex<br>    from Student<br>    where Sname not like '刘_'</pre><h3 id="ed92d"><span class="ne-text">is not</span></h3><pre data-language="sql" id="uIciX" class="ne-codeblock language-sql">select Sno, Cno<br>    from SC<br>    where Grade is not null</pre><h3 id="dbCr3"><span class="ne-text">and、or</span></h3><pre data-language="sql" id="9VsPY" class="ne-codeblock language-sql">select Sname, Ssex<br>    from Student<br>    where Sdept='CS' or Sdept='MA' or Sdept='IS'</pre><div class="ne-quote"><p id="adb32849efc88d55c2cf30c3a5374d20" class="ne-p"><span class="ne-text">键可以不用引号，但是值要引号</span></p><p id="4b3a0da6caa18adae6001b5849b80b5f" class="ne-p"><span class="ne-text">列名又空格也需要加引号</span></p></div><h3 id="dGNnp"><span class="ne-text">top</span></h3><div class="ne-quote"><p id="a9172d454d894153ef9934a50bd99be5" class="ne-p"><span class="ne-text">前五行数据</span></p></div><pre data-language="sql" id="KawG9" class="ne-codeblock language-sql">select top 5 *<br>    from rating</pre><h3 id="fxnoz"><span class="ne-text">not in</span></h3><pre data-language="sql" id="96RAf" class="ne-codeblock language-sql">select Sname, Ssex<br>    from Student<br>    where Sdept not in ('CS', 'MA', 'IS')</pre><h3 id="rlZsi"><span class="ne-text">多表查询</span></h3><ul class="ne-ul"><li id="8ac489789f94b187322d0cdc18cf5e78"><span class="ne-text">有公共的列，在前面表名以示区分</span></li><li id="f92a34621cec7f3b9a0b6c3979eaa7c7"><span class="ne-text">指明两个表的公共</span><strong><span class="ne-text">相等</span></strong><span class="ne-text">的列</span></li></ul><p id="5f508966e82e1181e498b1b9368226c7" class="ne-p"><br></p><pre data-language="sql" id="R6UHO" class="ne-codeblock language-sql">select TLend.ISBN, TLend.借书时间, TLend.借书证号, TLend.图书ID, TLend.应还时间,TReader.姓名<br>from TReader,TLend, TBook<br>where TReader.借书证号 = TLend.借书证号<br>    and TBook.ISBN = TLend.ISBN<br>    and TLend.借书证号 = '081101'<br>    and TBook.书名 = 'SQL Server实用教程（第3版）'</pre><p id="5ead02499b17dc7850d53fc75b2b3412" class="ne-p"><br></p><h3 id="aplrm"><span class="ne-text">join on</span></h3><pre data-language="sql" id="otVzf" class="ne-codeblock language-sql">select 姓名<br>    from TReader join HLend<br>    on TReader.借书证号 = HLend.借书证号<br>    where (还书时间 - 借书时间)>5</pre><p id="7d549f41dbeaa3adcfac5c7e60a74784" class="ne-p"><br></p><h3 id="o7p21"><span class="ne-text">count</span></h3><pre data-language="sql" id="2wLFx" class="ne-codeblock language-sql">select count(<em>) 读者总数<br>    from TReader</pre><h3 id="OwVTx"><span class="ne-text">order by</span></h3><p id="5a3acfe63f9a872b07ab292fcf16c909" class="ne-p"><span class="ne-text">排序ORDER BY</span></p><pre data-language="sql" id="9fa3f3f2" class="ne-codeblock language-sql">select Sno, Grade<br>    from SC<br>    where Cno='3'<br>    order by Grade desc</pre><p id="014af1100827bc3acb9c02b77e2bc202" class="ne-p"><br></p><pre data-language="sql" id="00d9d92f" class="ne-codeblock language-sql">SELECT *<br>        FROM users<br>    ORDER BY id DESC;</pre><p id="483a65d5078046613cc9d0e5ddcee7c8" class="ne-p"><br></p><p id="70726d943f542af6b025aca5d1c563ab" class="ne-p"><span class="ne-text">可以排序多个字段，如果第一个字段能排出结果，就不会用到第2个字段。比如：</span></p><p id="8329dde98bc38a7ce9cea68501c907fd" class="ne-p"><br></p><pre data-language="sql" id="4f3316a5" class="ne-codeblock language-sql">select *<br>    from Student<br>    order by Sdept asc, Sage desc</pre><p id="2ac4c26b9311f6d34de6dd4ee273f93a" class="ne-p"><br></p><p id="3ad877dee5e11d750dc533bb5a405170" class="ne-p"><span class="ne-text">因为年龄age有相同的，继续排序就要用到id的降序。</span></p><h3 id="Picn0"><span class="ne-text">limit</span></h3><p id="8abc030f3ba54deeceeb9546528aa4c9" class="ne-p"><span class="ne-text">限制返回记录的数量LIMIT</span></p><p id="8661b05ac0d65f80d90f7ec2bd98c4ff" class="ne-p"><br></p><p id="12b5c6dcde437cf2254ad1ebf95f8ff1" class="ne-p"><span class="ne-text">LIMIT有两种语法结构，第一种比较常见。</span></p><p id="8dfa2d111a3ef8934eabbf6e23c85b4d" class="ne-p"><br></p><pre data-language="sql" id="3e926842" class="ne-codeblock language-sql">[LIMIT {[offset,] row_count|row_count OFFSET offset}]</pre><p id="d7652c18e1385552436b5b86d06f1fce" class="ne-p"><br></p><p id="adc857a105cbdddacdfad48be8a47190" class="ne-p"><span class="ne-text">起始位置，偏移量</span></p><p id="0f48eae9cf7ba61f3bf7693a0106b160" class="ne-p"><br></p><pre data-language="sql" id="51eb5ef9" class="ne-codeblock language-sql">SELECT * FROM users ;<br>SELECT * FROM users LIMIT 3,2;<br>SELECT * FROM users LIMIT 2;</pre><p id="39e528143c423496958047bbfa312a2e" class="ne-p"><br></p><p id="466af24c8b5a652791546c053aae5e7a" class="ne-p"><span class="ne-text">3，2：表示从第3条开始返回，返回两条记录。注意记录从0开始编号，即结果集中的从第0条开始。</span></p><p id="6a7c63f313d4b4660cc2fde3880870ee" class="ne-p"><span class="ne-text">如果LIMIT后面只有一个参数，认作是偏移量，起始位置缺省为0。</span></p><h3 id="ZGe8y"><span class="ne-text">union</span></h3><div class="ne-quote"><p id="bf62e876116b6699d55de270a0e65bbb" class="ne-p"><span class="ne-text">合并查询结果UNION</span></p></div><p id="43989b427a41d639e28fb6195bbf4fa6" class="ne-p"><br></p><p id="2d376262551d119cbf5c7c16f587109f" class="ne-p"><span class="ne-text">在多条查询语句之间，使用</span><code class="ne-code"><span class="ne-text">UNION</span></code><span class="ne-text">关键字会合并所有查询结果。</span></p><p id="22e5197503f961dbdfe1e2691fd3cbf3" class="ne-p"><span class="ne-text">默认会去掉重复行，如果不想去掉重复行，请使用</span><code class="ne-code"><span class="ne-text">UNION ALL</span></code></p><p id="e7a161b58d34360ebdaf1a6f733787be" class="ne-p"><span class="ne-text">需要注意的是，要联合的查询结果必须有相同的列数（列名可以不同）</span></p><p id="80b32292eb23024a24c4a389a207112b" class="ne-p"><br></p><div class="ne-quote"><p id="45781a46e2b90fbe68964d5b7bec265d" class="ne-p"><span class="ne-text">去重效率比不去重效率低</span></p></div><h2 id="b314d699"><span class="ne-text">group by</span></h2><p id="ac8f94bdad64203162d6e031ff1f3b8b" class="ne-p"><br></p><pre data-language="sql" id="a3bca44c" class="ne-codeblock language-sql">[GROUP BY {col_name|position} [ASC|DESC],...]</pre><p id="03d55535e34290137d6b15f46f7ffba0" class="ne-p"><br></p><pre data-language="sql" id="4lUi9" class="ne-codeblock language-sql">select 专业, count(</em>) 不同专业人数<br>    from TReader<br>    group by 专业</pre><p id="3e2228cd0c39e475a148771c8dc672bd" class="ne-p"><br></p><h3 id="8Tk5D"><span class="ne-text">having</span></h3><p id="660abed82a1c3f051696d3a05507c778" class="ne-p"><br></p><p id="418f511347293cb6c5e6d382e07bb60e" class="ne-p"><span class="ne-text">与GROUP BY分组联用。只对部分记录做分组操作。有两种用法，比如：</span></p><p id="e650a089613a601f28e56af68764cd79" class="ne-p"><br></p><pre data-language="sql" id="e804bb6a" class="ne-codeblock language-sql">SELECT sex,age<br>    FROM users<br>  GROUP BY sex<br>  HAVING age > 35;<br>SELECT sex<br>    FROM users<br>  GROUP BY sex<br>  HAVING count(id) >=2;</pre><p id="45011a6607bdd5fee5736b771f0a2a79" class="ne-p"><br></p><ul class="ne-ul"><li id="a865927409cb49c1d5a9972f8dd4ade7"><span class="ne-text">第一种，注意后面的HAVING的字段必须在前面SELECT部分出现才行。</span></li><li id="3fe9ea7ca402c7b34fc9c5fa6665e941"><span class="ne-text">第二种，在HAVING后面使用</span><em><span class="ne-text">聚合函数</span></em><span class="ne-text">，前面无需出现相应字段。</span></li></ul><h3 id="eeigV"><span class="ne-text">asc、desc</span></h3><p id="5dc31ad70623ca877473d3382b43e18b" class="ne-p"><span class="ne-text">排序升序asc、降序desc</span></p><pre data-language="sql" id="j9H5d" class="ne-codeblock language-sql">SELECT *<br>    FROM TReader<br>    WHERE 专业='计算机'<br>    ORDER BY 出生时间 desc</pre><h2 id="KKotB"></h2><h2 id="5qtqd"><span class="ne-text">子查询</span></h2><p id="4eb3539e532e05ef2d8807304b1e2712" class="ne-p"><span class="ne-text">子查询（Subquery）是指嵌套在查询内部，且必须始终出现在圆括号内。外面的查询并非只是指的查找。可以包含的关键字或条件：</span></p><p id="3e5d234ec64c9db23c6f007fbc1edd5c" class="ne-p"><br></p><pre data-language="plain" id="73814030" class="ne-codeblock language-plain">DISTINCT、GROUP BY、ORDER BY、LIMIT、函数等</pre><p id="bc2f8a49be62677959cda3523fcb7ddf" class="ne-p"><br></p><p id="cba664cd34a1463059d2a0de318677af" class="ne-p"><span class="ne-text">外层的查询可以是：</span></p><pre data-language="plain" id="KkxiH" class="ne-codeblock language-plain">SELECT、INSERT、UPDATE、SET、DO</pre><p id="bb2dcce48080eadc8e634a2b952092d7" class="ne-p"><br></p><h3 id="c20a854c"><span class="ne-text">①使用比较运算符的子查询</span></h3><p id="61bbe9b8f6c9e56ae9409704114ac210" class="ne-p"><br></p><ul class="ne-ul"><li id="d1a4e57d08eefdbe73eaa21074c5a292"><span class="ne-text">比较运算符</span></li></ul><div class="ne-quote"><p id="90f885d99059bf5298bdac4254924043" class="ne-p"><span class="ne-text">=,&gt;,&lt;,&gt;=,&lt;=,&lt;&gt;,!=,&lt;=&gt;</span></p></div><pre data-language="sql" id="9f0de077" class="ne-codeblock language-sql">SELECT *<br>    FROM av<br>  WHERE 身高>=(<br>    SELECT AVG(身高)<br>    FROM av);</pre><ul class="ne-ul"><li id="4d14d43f0cfaf0163ad55c93632e8c05"><span class="ne-text">修饰比较运算符</span></li></ul><div class="ne-quote"><p id="831bf50f68e8c205ffb57a2ba9fa9216" class="ne-p"><span class="ne-text">使用ANY、SOME、ALL，ANY和SOME是等价的。</span></p></div><table id="b57b04cd" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"></td><td width="250"><p id="ueb01277f" class="ne-p"><span class="ne-text">ANY</span></p></td><td width="250"><p id="u359438cc" class="ne-p"><span class="ne-text">ALL</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="udb1e1be3" class="ne-p"><span class="ne-text">&gt;,&gt;=</span></p></td><td width="250"><p id="u75800521" class="ne-p"><span class="ne-text">最小值</span></p></td><td width="250"><p id="ud5788adf" class="ne-p"><span class="ne-text">最大值</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u7532e55b" class="ne-p"><span class="ne-text">&lt;,&lt;=</span></p></td><td width="250"><p id="uc73eecdb" class="ne-p"><span class="ne-text">最大值</span></p></td><td width="250"><p id="u97e62f36" class="ne-p"><span class="ne-text">最小值</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ueb1bbb2f" class="ne-p"><span class="ne-text">=,&lt;=&gt;</span></p></td><td width="250"><p id="uc1c1cfb0" class="ne-p"><span class="ne-text">任意值</span></p></td><td width="250"></td></tr><tr style="height: 33px"><td width="250"><p id="u031e803b" class="ne-p"><span class="ne-text">&lt;&gt;,!=</span></p></td><td width="250"></td><td width="250"><p id="uf9627cd1" class="ne-p"><span class="ne-text">任意值</span></p></td></tr></tbody></table><p id="883142559a32aedc80f551ce437abf33" class="ne-p"><br></p><pre data-language="sql" id="z9ORH" class="ne-codeblock language-sql">select emp.empno,emp.ename,emp.job,emp.sal<br>    from scott.emp<br>  where sal >any(<br>    select sal<br>    from scott.emp<br>    where job="MANAGER");</pre><p id="4bd629ff4606f6c8c8232194b6a79177" class="ne-p"><span class="ne-text">等价于下边两步的执行过程：</span></p><p id="7ef8ba5a0ef89dc534f154e5a2ba54f8" class="ne-p"><span class="ne-text">（1）执行“select sal from scott.emp where job=”MANAGER””</span></p><p id="60710ae1df17911ff409807e322e6d96" class="ne-p"><span class="ne-text">（2）查询到3个薪水值2975、2850和2450，父查询执行下列语句：</span></p><p id="48a8f9f18b8eb74f6c42f7c31079591b" class="ne-p"><span class="ne-text">select emp.empno,emp.ename,emp.job,emp.sal from scott.emp where</span><strong><span class="ne-text"> sal &gt;2975 or sal&gt;2850 or sal&gt;2450;</span></strong></p><p id="43d523eb3403f3e415ad8d5f6ba940b8" class="ne-p"><br></p><h3 id="2a70086d"><span class="ne-text">②使用[not]in的子查询</span></h3><p id="2b197f1c63e1945e5c3cf21334fe4c95" class="ne-p"><br></p><pre data-language="plain" id="9a051b14" class="ne-codeblock language-plain">operand comparison_operator [NOT] IN (subquery)</pre><p id="0561a4e8a1dfe0fe1190ee3a2c628b9b" class="ne-p"><br></p><p id="e71700f53886c787f975673837e82b71" class="ne-p"><span class="ne-text">=ANY和IN等效</span></p><p id="155544c5673d207a078d0e87606f04e5" class="ne-p"><span class="ne-text">!=ALL和NOT IN等效</span></p><p id="59a25caea3dbe30ebbc6b8a21e67453b" class="ne-p"><br></p><h3 id="bce73132"><span class="ne-text">③使用[not]exists的子查询</span></h3><p id="d2d7cb964a28eb75b8ca2f4f57064cd8" class="ne-p"><br></p><p id="46729483bfe6cecb3e7e451f47781822" class="ne-p"><span class="ne-text">如果子查询返回任何行，EXISTS将返回TRUE，否则返回FALSE。</span></p><p id="6177da588331b479ef62f4c63843e42a" class="ne-p"><span class="ne-text">该类子查询使用较少</span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL数据库操作</title>
      <link href="/blog/afuf5u/"/>
      <url>/blog/afuf5u/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="NtKL9"><span class="ne-text">创建数据库</span></h2><p id="0137b33a88e2a14b4cdebae6363de1b1" class="ne-p"><br></p><pre data-language="sql" id="dd87b296" class="ne-codeblock language-sql">CREATE {DATABASE|SCHEMA} [IF NOT EXISTS] db_name [DEFAULT] CHARCTER SET [=] charset_name;</pre><p id="761d7943cd1f51a6c49e73715407a1c4" class="ne-p"><br></p><div class="ne-quote"><p id="56387d24eb0c30ad36984cef4453f00a" class="ne-p"><span class="ne-text">注意设置字符集的时候，utf-8要写作utf8</span></p></div><h2 id="UDttS"><span class="ne-text">使用数据库</span></h2><div class="ne-quote"><p id="515a62ea8b08a3c21f0c30d78c60ce81" class="ne-p"><span class="ne-text">使用指定数据库</span></p></div><pre data-language="sql" id="Nd1NY" class="ne-codeblock language-sql">use DATABASE<p>go</pre><h2 id="2ba003cd"><span class="ne-text">修改数据库</span></h2><p id="96eab48725a6aa3892050109c090162a" class="ne-p"><br></p><pre data-language="sql" id="de99fce5" class="ne-codeblock language-sql">ALTER {DATABASE|SCHEMA} db_name [DEFAUTL] CHARCTER SET [=] charset_name;</pre><p id="b61a45a2644317b170c67858f82ad776" class="ne-p"><br></p><h3 id="93674c0f"><span class="ne-text">修改数据库编码格式</span></h3><p id="92e23fa621dabbfaaa0e74fd4b315be8" class="ne-p"><br></p><pre data-language="plain" id="f082ac68" class="ne-codeblock language-plain">SET NAMES GBK;</pre><p id="a7bb72209db368725722d07108577b6b" class="ne-p"><br></p><p id="e56dd3966c1a307e176315b7375d3f80" class="ne-p"><span class="ne-text">GBK 也可以是其他编码格式。但这只是修改你客户端显示的编码格式。服务端并不变化。</span></p><p id="def5d5d77821b424a883406f3d68f639" class="ne-p"><strong><span class="ne-text">修改配置文件来改服务端编码</span></strong></p><p id="910253dcae1c4fa192a08bba2ed8c87f" class="ne-p"><span class="ne-text">打开/etc/my.cnf 文件</span></p><p id="8d065465916e3444e3f8c941d4a999d5" class="ne-p"><span class="ne-text">在[mysqld]条目下：增加</span></p><p id="3b1df4b618d5636178d8864dee70ea2f" class="ne-p"><br></p><pre data-language="plain" id="10b2d11e" class="ne-codeblock language-plain">character_set_server=utf8<br>init_connect='SET NAMES utf8'</pre><p id="64524bbe902c88ab127a47ba10fc1f33" class="ne-p"><br></p><p id="83df3ccfe22e4e52ddf08a404d944cda" class="ne-p"><span class="ne-text">有时在数据库创建完成后，编码格式是无法修改的。只能删掉重新建。</span></p><p id="30e932e656359eb38a88f84c8fe9c96a" class="ne-p"><br></p><h2 id="17d6bfc2"><span class="ne-text">删除数据库</span></h2><p id="79cfe8bc49838caf6911423d666b7f61" class="ne-p"><br></p><pre data-language="plain" id="dd539067" class="ne-codeblock language-plain"> DROP {DATABASE|SCHEMA} [IF EXISTS] db_name;</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL表基本操作</title>
      <link href="/blog/zqbaxc/"/>
      <url>/blog/zqbaxc/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h1 id="Bbv6P"><span class="ne-text">表基本操作</span></h1><h2 id="7tt1c"><span class="ne-text">创建表</span></h2><p id="u5096f51f" class="ne-p"><br></p><p id="2bfba170ff6dfe1afda6cbd45dbd9fa5" class="ne-p"><br></p><pre data-language="sql" id="a62f7150" class="ne-codeblock language-sql">Create table student(<pre><code>Sno char(9),Same char(20),Ssex char(2),Sage smallint,Sdept char(20)</code></pre><p>);<br>Create table course(<br>Cno char(4),<br>Cname char(40),<br>Cpno char(4),<br>Ccredit smallint<br>);<br>Create table sc(<br>Sno char(9),<br>Cno char(4),<br>Grade smallint<br>);<br>Insert into student values(‘200215121’,’李勇’,’男’,20,’cs’);<br>Insert into student values(‘200215122’,’刘晨’,’女’,19,’cs’);<br>Insert into student values(‘200215123’,’王敏’,’女’,18,’ma’);<br>Insert into student values(‘200515124’,’张立’,’男’,19,’is’);<br>Insert into course values (‘1’,’数据库’,’5’,4);<br>Insert into course values (‘2’,’数学’,NULL,2);<br>Insert into course values(‘3’,’信息系统’,’1’,4);<br>Insert into course values(‘4’,’操作系统’,’6’,3);<br>Insert into course values(‘5’,’数据结构’,’7’,4);<br>Insert into course values(‘6’,’数据处理’,NULL,2);<br>Insert into course values(‘7’,’pascal 语言’,’6’,4);<br>Insert into sc values(‘200215121’,’1’,92);<br>Insert into sc values(‘200215121’,’2’,85);<br>Insert into sc values(‘200215121’,’3’,88);<br>Insert into sc values(‘200215122’,’2’,90);<br>Insert into sc values(‘200215122’,’3’,80);</pre><h2 id="e9efaab2"><span class="ne-text">查看表</span></h2><p id="0edce77211314d065bddec62dd0347d5" class="ne-p"><br></p><pre data-language="sql" id="3e8fe54a" class="ne-codeblock language-sql"> SHOW TABLES [FROM db_name] [LIKE 'pattern'|WHEAR expr];</pre><p id="41ad3e744952d676c9a5dca289d9a441" class="ne-p"><br></p><h2 id="b45b493d"><span class="ne-text">查看列（表的组织结构）</span></h2><p id="b16e3855ac87f9eb477a0f211d8c0895" class="ne-p"><br></p><pre data-language="sql" id="9c6ed30d" class="ne-codeblock language-sql"> SHOW COLUMNS FROM tb_name;<br>DESC tb_name;</pre><p id="faa907d5d5db8505e26cfad0ca2bcce0" class="ne-p"><br></p><p id="5f1c912fde623a742919df1c9c686675" class="ne-p"><span class="ne-text">以上两条语句都可以。</span></p><p id="ff0997c14d8b2a1380d104ef972f2782" class="ne-p"><br></p><h2 id="6763c1c5"><span class="ne-text">查看表的内容</span></h2><p id="b5886419b19bba8e41ecabb1ec26753f" class="ne-p"><br></p><pre data-language="sql" id="0e14ac7a" class="ne-codeblock language-sql"> SELECT _ FROM tb_name;</pre><p id="95df1a3f8fda68fbb1c05ce27ea4b0f5" class="ne-p"><br></p><h2 id="131d2cc4"><span class="ne-text">插入数据</span></h2><p id="d32a19556322d8f39916008934fb680a" class="ne-p"><br></p><pre data-language="sql" id="4fca220d" class="ne-codeblock language-sql"> INSERT [INTO] tb_name [(col_name,...)] VALUES(val,...);</pre><p id="9f7f0fb435b53aae6be2684bfea14264" class="ne-p"><br></p><p id="e16272e4a571e75352cb2028fe0b10c2" class="ne-p"><span class="ne-text">如果不指明任何字段名，那么插入的数据必须要包含所有的字段。</span></p><p id="45a0f79544a7ac873df1a827a6aa3277" class="ne-p"><br></p><h1 id="ea44402b"><span class="ne-text">插入记录</span></h1><p id="7389be37da995f42513e3fafef16d052" class="ne-p"><br></p><p id="24abcc0e245a4ae60eaef254765aff6f" class="ne-p"><span class="ne-text">共有三种 Insert 语句。</span></p><p id="d27c8f99f568ada487c4d2b355d6920a" class="ne-p"><br></p><h2 id="INSERT"><span class="ne-text">INSERT</span></h2><p id="5c7dfc37519b140d6759ea36754d902e" class="ne-p"><br></p><pre data-language="sql" id="0e4efb2e" class="ne-codeblock language-sql">INSERT [INTO] tb_name [(col_name,.....)] {VALUE|VALUES} ({expr|DEFAULT},...) (...),...</pre><p id="1942e4aa5170d0571b8d50cd71684256" class="ne-p"><br></p><ul class="ne-ul"><li id="82cb94f30dfc6b9dc8b0c7d88260d0ac"><span class="ne-text">values 是标准 SQL 关键字，value 是 MySQL 自己的。</span></li><li id="76d0494653a23978f69fb2568a3ff9d7"><span class="ne-text">插入语句可以一次性插入多条记录。</span></li><li id="a017c1470988e836f0a76b364fd0c5b3"><span class="ne-text">值可以是：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="44be2704375bdd8b1f6620db902ea5bf"><span class="ne-text">函数</span></li><li id="177f769ab45b709e11b693fcdf0df177"><span class="ne-text">数学表达式</span></li><li id="94bd5a9e8d954dbefa285fa9871cd06b"><span class="ne-text">等</span></li></ul></ul><p id="153c9daae3034bb40cd203e51c669552" class="ne-p"><br></p><p id="1d9b80c99da6f23b8561258974619c44" class="ne-p"><span class="ne-text">默认值</span></p><p id="84daaba7470f2501eba275792485a5a7" class="ne-p"><br></p><p id="6b3ac9de00450738fd42dcbd5f5283d6" class="ne-p"><span class="ne-text">在创建数据表的时候可以设置 DEFAUTL。</span></p><p id="c9fb2a944d8c66a543010132cb5f7ff5" class="ne-p"><br></p><pre data-language="sql" id="2dd7df07" class="ne-codeblock language-sql">CREATE TABLE users(<br>id SAMLLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,<br>username SAMLLINT VARCHAR(20) NOT NULL,<br>password SAMLLINT VARCHAR(20) NOT NULL,<br>age TINYINT UNSIGNED NOT NULL DEFAULT 10,<br>sex BOOLEAN<br>);</pre><p id="caa286ba4fd9089469a97759946bca9d" class="ne-p"><br></p><p id="6b11b7f7a0db68ef51af0d30cb9190ca" class="ne-p"><span class="ne-text">INSERT 的时候如果为自动编号的字段（比如上表中主键 id）赋值的话，可写作 NULL，或 DEFAULT 就会采用默认值。</span></p><p id="80554680c2af40dead6d5be4a754bf9b" class="ne-p"><span class="ne-text">如果字段设置了 DEFAULT（比如上表中 age），那么值直接写 DEFAULT 就行，注意此时，不能为 NULL。例如：</span></p><p id="f41cdad2570f87b1cd685dbb0d5bdc2c" class="ne-p"><br></p><pre data-language="sql" id="c4d548e4" class="ne-codeblock language-sql">INSERT users VALUES(NULL,'TOM','123',DEFAULT,1);</pre><p id="9b4bc12e4e227b8794902dc336ae135f" class="ne-p"><br></p><h2 id="INSERT...SET"><span class="ne-text">INSERT…SET</span></h2><p id="1d8001a043db59e55d810481558b5011" class="ne-p"><br></p><pre data-language="sql" id="e154b0dd" class="ne-codeblock language-sql">INSERT [INTO] tb_name SET col_name={expr|DEFAULT},...</pre><p id="038c4e1dc09407157bc02ddb601847d4" class="ne-p"><br></p><p id="477deef1560839de76b8301242f5c974" class="ne-p"><span class="ne-text">采用了</span><a href="%E5%AD%90%E6%9F%A5%E8%AF%A2.md" data-href="%E5%AD%90%E6%9F%A5%E8%AF%A2.md" class="ne-link"><span class="ne-text">子查询</span></a><span class="ne-text">。例如，上表中插入：</span></p><p id="1a54292d5e5a3cdd55653b9405b0d110" class="ne-p"><br></p><pre data-language="sql" id="13128c44" class="ne-codeblock language-sql">INSERT users SET username='Ben',password='456';</pre><p id="53f9113d4d59affb2620c5c49f2e8fd3" class="ne-p"><br></p><p id="01c50264da2b7856f84b0167d4104a4f" class="ne-p"><span class="ne-text">因为 id，和 age 都有默认值，所以可以不写。而 sex 允许为空，也可以不写。</span></p><p id="478ebeb45586f737c27012ce7b4a0a41" class="ne-p"><br></p><h2 id="be74e164"><span class="ne-text">INSERT…SELECT_</span></h2><p id="41288b8eabab13960bd87ef8cc071e46" class="ne-p"><br></p><p id="a1a732cdfe886daeac4e355621ea8626" class="ne-p"><span class="ne-text">将查找的结果写入记录中。</span></p><p id="f456f0bc74f876f10b0f8abdcb52bf39" class="ne-p"><br></p><pre data-language="sql" id="d856c68b" class="ne-codeblock language-sql">INSERT test(username) SELECT username FROM users WHERE age >=30;</pre><p id="505300ce9d84625ea16b930b6c02b4a9" class="ne-p"><br></p><h1 id="a790208c"><span class="ne-text">删除记录</span></h1><p id="190ee8fcb585a5332fe69a465286235b" class="ne-p"><br></p><p id="910a985e4203fc2e283c25e41421fc2e" class="ne-p"><span class="ne-text">同样分为：</span></p><p id="a80746ad0cc1e7cc085b423110edfbd5" class="ne-p"><br></p><ul class="ne-ul"><li id="89cb5133e329d3995ce15256645dc8f7"><span class="ne-text">单表删除</span></li><li id="40a1101204c05c6f22654902f851ddaf"><span class="ne-text">多表删除</span></li></ul><p id="3cb9d25d2006918b3b422370e1c2e84a" class="ne-p"><br></p><pre data-language="plain" id="8291caa1" class="ne-codeblock language-plain">DELETE FROM tb_name [WHERE where_condition];</pre><p id="2e16d5591146c043e21f1c74880bcbc4" class="ne-p"><br></p><p id="ddcfa7f97d9228e978918263c4a4db37" class="ne-p"><span class="ne-text">没有 where 部分则会删除全部记录。</span></p><h1 id="du2gc"><span class="ne-text">更新记录-单表更新</span></h1><p id="2b5cbd74033c2008113972aeaf0dfafa" class="ne-p"><span class="ne-text">更新记录分为：</span></p><p id="0587a973a4c487f563704ebe55825319" class="ne-p"><br></p><ul class="ne-ul"><li id="46cfc4f01e1813cccc2d6c3e118796e6"><span class="ne-text">单表更新</span></li><li id="28c79a7cc87c23cf4a63d4527b02d8f1"><span class="ne-text">多表更新（要涉及连接）</span></li></ul><p id="dbac7d7178b47f94fa92f7b85041d5cd" class="ne-p"><br></p><div class="ne-quote"><p id="c5c9596f764cd78f29e513bc32cbda05" class="ne-p"><span class="ne-text">单表更新</span></p></div><pre data-language="plain" id="9712f0d6" class="ne-codeblock language-plain">UPDATE [LOW_PRIORITY] [IGNORE] tb_reference<br>SET col_name1={expr|DEFAULT} [,col_name2={expr|DEFAULT}]...<br>[WHERE where_condition]</pre><p id="258dfe20332c29036f5601d3cc5380b4" class="ne-p"><br></p><p id="39d7fa4ce6da08b2a3faa49275d236fb" class="ne-p"><span class="ne-text">不写 where 会更新全部的记录。</span></p><h1 id="8d1e69db"><span class="ne-text">更新记录-连接（多表更新）</span></h1><p id="e73faf597eeb5aed351f3a0359fb528c" class="ne-p"><br></p><h2 id="76ad9a84"><span class="ne-text">多表更新</span></h2><p id="064e4ff2fb927cfdfb6ae2dbddd06990" class="ne-p"><br></p><pre data-language="plain" id="4b62f04e" class="ne-codeblock language-plain">UPDATE table_references<br>SET col_name1={expr1|DEFAULT}<br>[,col_name2={expr2|DEFAULT}]...<br>[WHERE where_condition]</pre><p id="1ca581e114b5e27b895e3a9ab8e453d3" class="ne-p"><br></p><h2 id="CREATE...SELECT"><span class="ne-text">CREATE…SELECT</span></h2><p id="a43aaebc98533654cd53159c38cdf22d" class="ne-p"><br></p><p id="ffb68cda1eadb385887e7f09a68df31a" class="ne-p"><span class="ne-text">创建数据表同时将查询结果写入到数据表</span></p><p id="1d242b3741f788c505b4fb69ba438770" class="ne-p"><br></p><pre data-language="plain" id="2f6646e7" class="ne-codeblock language-plain">CREATE TABLE [IF NOT EXISTS]tb_name<br>[(create_definetion,...)]<br>select_statement</pre><p id="caa5f844d00a61901bc903e63d8f4c02" class="ne-p"><br></p><p id="44dc4f9e4209290bb34c6ac08db7f56c" class="ne-p"><span class="ne-text">比如：</span></p><p id="c4637eefa014fa2da4f43c10b356d474" class="ne-p"><br></p><pre data-language="plain" id="2bf5acc0" class="ne-codeblock language-plain">CREATE TABLE tall (<br>tall_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,<br>num INT<br>) SELECT 身高 AS num FROM<br>av<br>GROUP BY 身高;</pre><p id="2e3b2905182b181e9aae282980f598a8" class="ne-p"><br></p><p id="5ab71fe37034f48deccc06ebceca561b" class="ne-p"><span class="ne-text">创建新表 tall，并从 av 表中选取身高字段插入到 tall 表的 num 字段。</span></p><p id="8dbced6607206b9b7bd2c2d03743ecdb" class="ne-p"><br></p><h2 id="30f7dd4e"><span class="ne-text">连接</span></h2><p id="c98e26095940275e5b2f82658e1a4052" class="ne-p"><br></p><h3 id="804ed42b"><span class="ne-text">语法结构</span></h3><p id="739cbd9012eebd5f881e222b748ffc66" class="ne-p"><br></p><pre data-language="plain" id="c111e82e" class="ne-codeblock language-plain">table_reference<br>{[INNER|CROSS] JOIN|{LELT|RIGHT}[OUTER] JOIN}<br>table_reference<br>ON conditional_expr</pre><p id="c565c5e07af8373cabf58deac3c9ea50" class="ne-p"><br></p><p id="4cece135c2ab26473202cad6a010395f" class="ne-p"><span class="ne-text">ON 为条件。</span></p><p id="c203d00128a2c817da55949c3b47c192" class="ne-p"><span class="ne-text">三种连接，即：</span></p><p id="d8742fa4efc4fbe15986b0cc82b6d50d" class="ne-p"><br></p><ul class="ne-ul"><li id="507027516ffd278f4809da376c9cf2eb"><span class="ne-text">内连接</span></li><li id="46eaf6f733c22e6088d2875039ca4dda"><span class="ne-text">左外连接</span></li><li id="ea335329116896fcd992d0ad4c78de83"><span class="ne-text">右外连接</span></li></ul><p id="5a99dfe8668812b08ea928076c30086c" class="ne-p"><br></p><h4 id="1da1d322"><span class="ne-text">内连接</span></h4><p id="ee8d444d6af5156cd3f5b24ed4a7a46b" class="ne-p"><br></p><p id="204f2c3eaf1c1cd2058e2c8acbe6a9b2" class="ne-p"><span class="ne-text">显示左表及右表符合连接条件的记录（交集）</span></p><p id="eacc4735d57a386b6c1ef29824957d94" class="ne-p"><br></p><h4 id="3cb26c64"><span class="ne-text">左外连接</span></h4><p id="df7d795b795708235b68a37451b994a7" class="ne-p"><br></p><p id="b36a298248b832cc026f740de3e024f3" class="ne-p"><span class="ne-text">显示左表的全部记录及右表符合连接条件的记录</span></p><p id="dd0052344cbdba362b0cd7fda2930cbe" class="ne-p"><br></p><h4 id="0abc0f82"><span class="ne-text">右外连接</span></h4><p id="5bd17482e7913e88520c9ffa74ebbc46" class="ne-p"><br></p><p id="a1ad1e85d651fa9ccb46a94e7a01dff5" class="ne-p"><span class="ne-text">类别左外连接</span></p><p id="6ded0059a59810d5309e171d99f270f6" class="ne-p"><br></p><h3 id="UPDATE..JOIN..SET"><span class="ne-text">UPDATE..JOIN..SET</span></h3><p id="50d6adad3e8e89c89d756cff49a8cb1f" class="ne-p"><br></p><p id="a8af1fbb7276aec34849146c19247c46" class="ne-p"><span class="ne-text">比如</span></p><p id="eef29f93edd5b6bff263f470a5533e39" class="ne-p"><br></p><pre data-language="plain" id="329a6a0b" class="ne-codeblock language-plain">UPDATE actor AS a<br>INNER JOIN<br>tall AS b ON a.tall = b.num<br>SET<br>a.tall = b.tall_id;</pre><p id="f96e30b14e15c7d4cb11743d21bc2b66" class="ne-p"><br></p><p id="5d876d73698232f110182d396d355364" class="ne-p"><span class="ne-text">依据实际情况，选择是否使用别名。（如果两个表中进行比较的字段名相同，则需要别名）</span></p><p id="6f8d5ca38b7a640e63288d0d6ef6a5b2" class="ne-p"><span class="ne-text">该语句完成了一个替换，将 actor 表中具体的身高数值，替换为 tall 表中身高的对应 id。</span></p><p id="ce2677e2b72606ce433927b3dda675d6" class="ne-p"><br></p><p id="21a4cb36daa0fc03e25801dd3a9b72d6" class="ne-p"><br></p><h1 id="dc15d5f9"><span class="ne-text">修改数据表</span></h1><p id="ed1f8f7b8b6317e120717010ff3dd45f" class="ne-p"><br></p><p id="54b81631cb7cf81d72070b0ed9d8361b" class="ne-p"><span class="ne-text">所有的数据表的修改 SQL 语句的开头都是 ALTER TABLE+表名称。</span></p><p id="93eec81050a9c842166a3841b179e8b7" class="ne-p"><br></p><h2 id="988f7bc5"><span class="ne-text">给表改名</span></h2><p id="9e354744cf5ead8b77c5131c50fd456c" class="ne-p"><br></p><pre data-language="sql" id="93e45754" class="ne-codeblock language-sql">ALTER TABLE tb_name RENAME {TO|AS} tb_new_name;</pre><p id="13340f0101dfed8138f98ab685c5ec25" class="ne-p"><br></p><p id="c58656481f17f9097b09e7b765afeac9" class="ne-p"><span class="ne-text">另外有个写法是：</span></p><p id="ebb660649610a88661d258ee89491516" class="ne-p"><br></p><pre data-language="sql" id="351a3688" class="ne-codeblock language-sql">RENAME TABLE tb_name TO tb_new_name;</pre><p id="d58f9f4ef307d673c8bdfe7ffdee50e7" class="ne-p"><br></p><p id="eed10987cda338eec19acf34adebd97f" class="ne-p"><span class="ne-text">这句可以批量修改多个表的名称。</span></p><p id="cc59cc5e57bdb554245e39a7eabe6e2a" class="ne-p"><br></p><div class="ne-quote"><p id="7bd88d4ced6e49d09225e548dd9d7402" class="ne-p"><span class="ne-text">尽量不要随意修改表的名称。对视图有影响。</span></p></div><p id="44eca86c0422544a4bce80075f5f4c4f" class="ne-p"><br></p><h2 id="74e1e78f"><span class="ne-text">添加/删除列</span></h2><p id="7edd44f8648e30e4cdab53aa35cd2199" class="ne-p"><br></p><h3 id="3d3d1ae0"><span class="ne-text">插入列</span></h3><p id="b9b0689567c79496c8191db333af79fc" class="ne-p"><br></p><pre data-language="sql" id="0e8273cf" class="ne-codeblock language-sql">ALTER TABLE tb_name ADD [COLUMN] col_name column_definition [FIRST|AFTER col_name];</pre><p id="c1c2aa59e4aaf0b4c04fb8e2a2efd372" class="ne-p"><br></p><p id="4f719905204b24073549c5d42b94dc8e" class="ne-p"><span class="ne-text">默认会插入到表的最下面，指定 FIRST，则置于最上面，或者用</span><code class="ne-code"><span class="ne-text">AFTER col_name</span></code><span class="ne-text"> 指定为</span><code class="ne-code"><span class="ne-text">col_name</span></code><span class="ne-text">的下面。</span></p><p id="4f5a3e57a668bd9ac5c0a21e793aba6f" class="ne-p"><br></p><h3 id="3aac0e33"><span class="ne-text">删除列</span></h3><p id="c89b92048bcc8c8780eb853a6ead82bf" class="ne-p"><br></p><pre data-language="sql" id="5db2ad5b" class="ne-codeblock language-sql">ALTER TABLE tb_name DROP col_name,DROP.....;</pre><p id="b09eb58c10c9d2c8ed7d056488ce19d9" class="ne-p"><br></p><p id="a91574fa695629fc1c492f7b6265b327" class="ne-p"><span class="ne-text">可以一次性删除多个列。</span></p><p id="682cf8e3f6882e0b487d68e82f46b991" class="ne-p"><br></p><h2 id="67998807"><span class="ne-text">修改列</span></h2><p id="79774b9538b04c5aaf479bf942a8e079" class="ne-p"><br></p><h3 id="42ddcc1d"><span class="ne-text">修改列定义</span></h3><p id="05352f44c4668f01f95b1d89cd14da9d" class="ne-p"><br></p><p id="61f982f71377ae323e9c20407cef0b8b" class="ne-p"><span class="ne-text">即修改列的属性。</span></p><p id="6451358430f6afbc36cef369f288ffe8" class="ne-p"><br></p><pre data-language="sql" id="527a5d08" class="ne-codeblock language-sql">ALTER TABLE tb_name MODIFY col_name column_definition [FIRST|AFTER col_name];</pre><p id="cba9bad81a8cb8fa4867b552bf5cee7c" class="ne-p"><br></p><p id="3d88c0e299daf7752afca030b1670500" class="ne-p"><span class="ne-text">比如：</span></p><p id="1c5b4bc3d818be498a01c270ae3dec6b" class="ne-p"><br></p><pre data-language="sql" id="46427dcd" class="ne-codeblock language-sql">ALTER TABLE test ADD id SMALLINT unsigned KEY auto_increment first;</pre><p id="99698519ebf3917d00123f9ceca093b7" class="ne-p"><br></p><p id="2e5b7ea82e65f98b2d5b5cbcdd2a3cb0" class="ne-p"><span class="ne-text">key 可以表示主键，无需 primary。fitrst 表示插入的位置。</span></p><p id="df7ef49ea09a7a7f7e8a67f6ff3ef6df" class="ne-p"><br></p><div class="ne-quote"><p id="93d4ccf6931ab3b5c33c16faef6410ce" class="ne-p"><span class="ne-text">如果要修改的列已经是</span><code class="ne-code"><span class="ne-text">主键</span></code><span class="ne-text">了，则修改列定义的时候再加上</span><code class="ne-code"><span class="ne-text">主键</span></code><span class="ne-text">字段会报错。</span></p></div><p id="dfcf1d3b5a3ca0549a18d4975bd198a8" class="ne-p"><br></p><h3 id="620f3b9b"><span class="ne-text">修改列名</span></h3><p id="cc46a2a1da4b95b04030678ec3143d75" class="ne-p"><br></p><pre data-language="sql" id="231f7dc1" class="ne-codeblock language-sql">ALTER TABLE tb_name CHANGE col_name col_new_name column_definition [FIRST|AFTER col_name];</pre><p id="122664258f6dd3f84df9e720801be136" class="ne-p"><br></p><p id="a6e05b4080e82a793dc30d4d3ac30fa5" class="ne-p"><span class="ne-text">修改列名时，新列名后面要指明数据类型。</span></p><p id="a459593041f2df10f8f77b7ed2cf46a1" class="ne-p"><br></p><h3 id="cdb14e66"><span class="ne-text">修改列顺序</span></h3><p id="9f39225dbff2385a00e3148f6eac4b4e" class="ne-p"><br></p><p id="9b19ba2669940fdb7f297ebc4c692c59" class="ne-p"><span class="ne-text">其实同上，具体比如：</span></p><p id="92a1fcfe609687cf10dda860089d217c" class="ne-p"><br></p><pre data-language="sql" id="09ce42a4" class="ne-codeblock language-sql">ALTER TABLE <code>user</code> CHANGE <code>join_time</code> <code>join_time</code> DATE NULL DEFAULT NULL AFTER <code>role</code>;</pre><p id="f55da1127f8ae9e883e635c95b68d0a5" class="ne-p"><br></p><p id="e076461ae47cac79b8cbb555adb4dbea" class="ne-p"><span class="ne-text">把 join_time 列放到 role 列后面。</span></p><p id="f49dec30a6df7d97177d9e6ab071ce52" class="ne-p"><br></p><h2 id="ce722eca"><span class="ne-text">修改约束</span></h2><p id="d6ce3d585916862fc431e6be900eea43" class="ne-p"><br></p><h3 id="a6f1dc8f"><span class="ne-text">PRIMARY KEY</span></h3><p id="333db360852f4109e6ea8f12137a9029" class="ne-p"><br></p><p id="e3d9c1a0b539ecdc6f7ac7b64d3586bc" class="ne-p"><span class="ne-text">添加主键约束</span></p><p id="43b7644200197e6550813278394143df" class="ne-p"><br></p><pre data-language="sql" id="8f323973" class="ne-codeblock language-sql">ALTER TABLE tb_name ADD [CONSTRAIN[symbol]] PRIMARY KEY [index.type] (index_col_name,.....);</pre><p id="d3180966f9bbd433b5eed03ea49e0242" class="ne-p"><br></p><p id="fc6fc3f4f39b9947ae6ec65bb1c432d2" class="ne-p"><span class="ne-text">删除主键约束</span></p><p id="f1d3686383649b63333a89f8de4f73f8" class="ne-p"><br></p><pre data-language="sql" id="9e7ea784" class="ne-codeblock language-sql">ALTER TABLE tb_name DROP [index.type] PRIMARY KEY;</pre><p id="3b289fe1242c5f7a4339e3604f8bb7d3" class="ne-p"><br></p><p id="46316e12d47e3dcc42c157bf42d34163" class="ne-p"><span class="ne-text">不需要指定列名，因为每个表只有一个主键。</span></p><p id="5d5ff63fc1ee6fb8df03c4351e484755" class="ne-p"><span class="ne-text">注意！只有一个主键并不意味着主键只有一列。</span></p><p id="b5609fd47ba207413c298d6eecc78131" class="ne-p"><br></p><h3 id="UNIQUE"><span class="ne-text">UNIQUE</span></h3><p id="bb98eb97b1354a26645bd711c394508f" class="ne-p"><br></p><p id="ce9c7dc1c486cc9883bcce2ad88668b2" class="ne-p"><span class="ne-text">添加唯一约束</span></p><p id="02dcadac04080c909be6b9c644ebc13c" class="ne-p"><br></p><pre data-language="sql" id="c6ba291b" class="ne-codeblock language-sql">ALTER TABLE tb_name ADD [index.type] unique(col_name);</pre><p id="9b7a80ceff5e2b850a9e50c90ee0d821" class="ne-p"><br></p><p id="4fa1ed6a9fa5cfd351166cbb12c66d0e" class="ne-p"><span class="ne-text">删除唯一约束</span></p><p id="8160458a658452491af0ea4052dc8fd0" class="ne-p"><br></p><pre data-language="sql" id="d357a163" class="ne-codeblock language-sql">ALTER TABLE tb_name DROP [index.type] unique(col_name);</pre><p id="8569b42a9b6213edf029dfa8a284eeb2" class="ne-p"><br></p><h3 id="DEFAULT"><span class="ne-text">DEFAULT</span></h3><p id="d39269fa9d5d95931555d3b9d9fd28fe" class="ne-p"><br></p><pre data-language="sql" id="0dd959a7" class="ne-codeblock language-sql">ALTER TABLE tb_name ALTER [COLUMN] col_name {SET DEFAULT literal|DROP DEFAULT};<br>for example:<br>ALTER TABLE users ALTER age SET DEFAULT 20;</pre><p id="06fa49b8e68199e9af616b210d48a5e9" class="ne-p"><br></p><h3 id="7efc1efe"><span class="ne-text">FOREIGN KEY</span></h3><p id="3f63612be3a1e087a1f7c78bf767bd93" class="ne-p"><br></p><p id="a39da979180ccc98d49662cd0d757290" class="ne-p"><span class="ne-text">添加外键约束</span></p><p id="1b442bb84bbdde69658bcb768e2865f9" class="ne-p"><br></p><pre data-language="sql" id="804a8577" class="ne-codeblock language-sql">ALTER TABLE tb_name ADD [CONSTRAIN[symbol]] FOREIGN KEY <a href="index_col_name,...">index_name</a>reference_definition;<br>for example:<br>ALTER TABLE users add FOREIGN KEY (pid) REFERENCE provinces (id);</pre><p id="09cefe28114cd8420be412563c2c1214" class="ne-p"><br></p><p id="c813b9a99bacc7ca4f88c285fbce6476" class="ne-p"><span class="ne-text">删除外键约束</span></p><p id="6a8551b2fe8af6c693bd94914e079751" class="ne-p"><br></p><pre data-language="sql" id="81362de3" class="ne-codeblock language-sql">ALTER TABLE tb_name DROP FOREIGN KEY fk_symbol;</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]Premiere</title>
      <link href="/blog/edproq/"/>
      <url>/blog/edproq/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><p id="282691fc2cf4ef4f1e5a5024fd937ccb" class="ne-p"><span class="ne-text">本文转载自：</span><a href="https://zhuanlan.zhihu.com/p/32130541" data-href="https://zhuanlan.zhihu.com/p/32130541" target="_blank" class="ne-link"><span class="ne-text">5分钟学会Premiere视频剪辑全流程</span></a></p></div><h2 id="trBKe"><span class="ne-text">第1步，打开软件，新建项目</span></h2><p id="99224e1e1475c7b2c17c94b83d5be140" class="ne-p"><br></p><p id="8e7bfa5c24bdd2047e0a483429d18d22" class="ne-p"><strong><span class="ne-text">a.</span></strong><span class="ne-text"> 填写项目名称；</span></p><p id="2af2a322bff2926c0c6e817a8bcf09fb" class="ne-p"><br></p><p id="0410541ea40deec5ccea26c7aad2404c" class="ne-p"><strong><span class="ne-text">b.</span></strong><span class="ne-text"> 选择项目保存位置，建议建一个用于存放视频项目的文件夹；</span></p><p id="e4042634bf9d39c1a594d76b4aa16255" class="ne-p"><br></p><p id="4cdfb50608e328ba5a6537f253ebf293" class="ne-p"><strong><span class="ne-text">c.</span></strong><span class="ne-text"> 其他的可以不用改动，点击“确定”。</span></p><p id="de5c0b6332e60bca8522d64078413b7b" class="ne-p"><br></p><p id="ea0aeef9de09cf17414c39b747e208a4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1609848527644-14d127eb-6145-4323-8d7e-dc1b813b7d17.jpeg" width="624" id="zEeVT" class="ne-image"></p><p id="2f3633635bb46e1254e45669c047b980" class="ne-p"><br></p><p id="e9046b4991ef025b13e5996854a45be0" class="ne-p"><strong><span class="ne-text">进入“面板”后</span></strong></p><p id="538720de62e9477c5d60b8c9f33e8eaf" class="ne-p"><br></p><p id="5abf9a6924721c9c195f3c6117a819d6" class="ne-p"><strong><span class="ne-text">a.</span></strong><span class="ne-text"> Ctrl+N新建一个序列；</span></p><p id="06acaeafb020ce53e9b07842048dcae0" class="ne-p"><br></p><p id="7586fcb8c69f69a4edbc0b6a7a048404" class="ne-p"><strong><span class="ne-text">b.</span></strong><span class="ne-text"> 点击“设置”，编辑模式选择“自定义”；</span></p><p id="e8be510ee3777f4b352bc66c6ed2050e" class="ne-p"><br></p><p id="15bc7f9b03a11400f8102d06acdbbde5" class="ne-p"><strong><span class="ne-text">c.</span></strong><span class="ne-text"> 帧速率我一般习惯用23.976，也有的人喜欢用24、25或者是30帧；</span></p><p id="7448d2138443a0bd52417f0aef4cc002" class="ne-p"><br></p><p id="eca35925217a7e8c6fdb94a98290c8ae" class="ne-p"><span class="ne-text">（至于它们具体有什么区别，我在这里就不详细说了，你们可以自行百度一下）</span></p><p id="3c383211cf7726c043d240a7f8d39bae" class="ne-p"><br></p><p id="3131931788cf094f4c008543ae2797cd" class="ne-p"><strong><span class="ne-text">d.</span></strong><span class="ne-text"> 帧大小也就是分辨率，我们通常设置为1920*1080；</span></p><p id="42c5873534e4ae71cd72e218b584f442" class="ne-p"><br></p><p id="3ec0d942267144a66fc2674bd02603e2" class="ne-p"><strong><span class="ne-text">e.</span></strong><span class="ne-text"> 像素长宽比选择“方形像素”，场序选择“逐行”；</span></p><p id="e9c92e004e874ec7ddfa69f52e1c27d7" class="ne-p"><br></p><p id="d5ec1c990a833662a66d88da8b7ca8b9" class="ne-p"><strong><span class="ne-text">f.</span></strong><span class="ne-text"> 写上序列名称，其他的可以暂时先不研究。</span></p><p id="6f74f3823981f8a7385f918630288acd" class="ne-p"><br></p><p id="420185d409a0e86252f08bcb35735f25" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1609848527668-82cc24b0-26f6-4cad-880e-b71650f5b9f4.jpeg" width="720" id="nu9qn" class="ne-image"></p><p id="731ae86505e256e394c4677a1a71add1" class="ne-p"><br></p><h2 id="yi3mw"><span class="ne-text">第2步，将素材导入PR</span></h2><p id="87b74e727ce28e1299e07d82a24e02b9" class="ne-p"><br></p><p id="a59231a74c12571937f1fe6a85d19628" class="ne-p"><span class="ne-text">在“项目面板”内的空白处单击右键导入素材，或者直接将素材选中拖入“项目面板”，如果直接选择一个文件夹的话，直接拖入项目面板，它会生成一个素材箱；</span></p><p id="12fb5588125cbcc63c8c01197943f2b1" class="ne-p"><br></p><p id="43f5dfc08fedf7194047e4f41a192da2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1609848527661-1f047b51-da0e-4a8d-af96-6cadf1a8ab75.gif" width="420" id="sTxPt" class="ne-image"></p><p id="15fae6837014f32dad16eaf2562cccdf" class="ne-p"><br></p><p id="6b9bd79d9ee990e8caf06aeb67a8240e" class="ne-p"><span class="ne-text">也可以点击右下角的图标，新建一个素材箱，素材箱便于我们进行整理和归类。</span></p><p id="836ab25e6fe448669b9ad4b61e10a57b" class="ne-p"><br></p><p id="398d37c128d77bb99ec80adf604f9c17" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1609848527781-1f3c610b-49e4-45e0-a13b-96df9b2fb96b.gif" width="423" id="eBoj9" class="ne-image"></p><p id="f4b18bc290021667e0d0576f7adaaa7e" class="ne-p"><br></p><p id="214582524171b865f77b1fb9e06fb0fd" class="ne-p"><span class="ne-text">除了视频和音频可以导入PR之外，图片和GIF都可以导入PR进行编辑。</span></p><p id="eb2ac2b04bc415a96481ff3993a6b2e4" class="ne-p"><br></p><h2 id="BVlJi"><span class="ne-text">第3步，将素材拖入时间轴</span></h2><p id="28c51840339095c51abc200f0043a603" class="ne-p"><br></p><p id="ddaf7cefef403d69974a63638b5b722c" class="ne-p"><strong><span class="ne-text">剪辑工作需要在时间轴里面进行：</span></strong></p><p id="3d883a7e081f18225f2da43567c13090" class="ne-p"><br></p><p id="75662f70dc2e18c25a6d15d30f104845" class="ne-p"><strong><span class="ne-text">a.</span></strong><span class="ne-text"> 先用鼠标点中素材不放，拖入时间轴的空白处松开就可以了；</span></p><p id="87b97d482177cfef275af8afb4f63333" class="ne-p"><br></p><p id="8c7dd1c8755eb0f24a4dedfc5b3bccc1" class="ne-p"><span class="ne-text">（时间轴上的两个蓝条，上面的轨道是视频，下面的轨道是音频）</span></p><p id="b776298c3a178142db798a8fcc6fcacf" class="ne-p"><br></p><p id="7083c49fc001d197f7cc7eb399488422" class="ne-p"><strong><span class="ne-text">b.</span></strong><span class="ne-text"> 如果你觉得拖入整条素材太长，也可以先截选片段，鼠标按住视频画面不放，将截选的片段拖到时间轴上；</span></p><p id="bd10503b577665de8b591eef6e013268" class="ne-p"><br></p><p id="68b499c566c495ccd94e301c2f9df19b" class="ne-p"><strong><span class="ne-text">c.</span></strong><span class="ne-text"> 拖入时间轴后如果出现“剪辑不匹配警告”的提示，点击“保持现有设置”，然后右键点击素材，选择“缩放为帧大小”就可以了。</span></p><p id="a19935b6440863bff34a37fc17a28674" class="ne-p"><br></p><p id="efd1622ecd55e2df0a77caddc025e226" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609848527688-a4109e9f-d436-4e57-9461-8945695f19c8.png" width="523" id="Pl1RI" class="ne-image"></p><p id="afa924638daee647b5d9452df148314c" class="ne-p"><br></p><h2 id="kzMiH"><span class="ne-text">第4步：剪辑（精剪）</span></h2><p id="ce80e7bc9abdfc4682d8e2aa09dd444e" class="ne-p"><br></p><p id="ba02bcf11fa5a013a99cc3852103759e" class="ne-p"><strong><span class="ne-text">剪辑工作</span></strong><span class="ne-text">包括对素材进行</span><strong><span class="ne-text">裁剪</span></strong><span class="ne-text">、</span><strong><span class="ne-text">拼接</span></strong><span class="ne-text">，</span><strong><span class="ne-text">调色</span></strong><span class="ne-text">，添加</span><strong><span class="ne-text">配乐</span></strong><span class="ne-text">、</span><strong><span class="ne-text">音效</span></strong><span class="ne-text">，还可以添加</span><strong><span class="ne-text">转场</span></strong><span class="ne-text">、</span><strong><span class="ne-text">特效</span></strong><span class="ne-text">等等，关于这些进阶内容我们后面会有专门的课程进行深入地解析，这里就不多说了。</span></p><p id="0d94ba61a6d81568075367b5ac3a4b95" class="ne-p"><br></p><p id="fb9b3dc8d7f103101bbc80a2f7573c48" class="ne-p"><span class="ne-text">完成整个视频的制作以后，我们就可以进行</span></p><p id="17785822f020e8165c24fbbff53ae4e9" class="ne-p"><br></p><h2 id="p2xGH"><span class="ne-text">第5步：渲染输出</span></h2><p id="7c63ee3498d46879e78cb01b11179ebc" class="ne-p"><br></p><p id="7ae3c62e9fec6762ab923ba9994ddedc" class="ne-p"><strong><span class="ne-text">a.</span></strong><span class="ne-text"> 在“文件”中，点击“导出”，选择“媒体”，弹出渲染设置面板；</span></p><p id="a7f183084bd6fc010e46c3bdd130f9a5" class="ne-p"><br></p><p id="de350d1ed0956048e7b656024263e9f9" class="ne-p"><strong><span class="ne-text">b.</span></strong><span class="ne-text"> 格式我一般选择H.264，预设选择“匹配源—高比特率”；</span></p><p id="96ab001735754f895214d93c7cfe5b0b" class="ne-p"><br></p><p id="59b45f44a7925b5a91ecc03185c9b17a" class="ne-p"><strong><span class="ne-text">c.</span></strong><span class="ne-text"> 设置文件保存位置和文件名。</span></p><p id="8419f243199bfb73991d5d96672529bc" class="ne-p"><br></p><p id="bc1208e2be500a48ea8437b932255686" class="ne-p"><span class="ne-text">其他的参数可以不用改动，对于一般的用户来说这样的设置就够用了，最后点击“导出”就完成了。</span></p><p id="032dedb913ced659f300649758cba432" class="ne-p"><br></p><p id="7016e605efe79e5595ea87e7fe83214f" class="ne-p"><span class="ne-text">以上内容是我为大家总结整理的PR剪辑的基本流程，它不是最全面的，但如果你掌握了前面所说的这些内容，简单地剪辑一个视频几乎没有什么问题了。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 后期制作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0-1背包问题</title>
      <link href="/blog/kb5sse/"/>
      <url>/blog/kb5sse/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="lRlkk"><span class="ne-text">问题描述</span></h2><h3 id="7Fox1"><span class="ne-text">问题描述</span></h3><p id="a77700202349a06007d1c20950f36da7" class="ne-p"><span class="ne-text">给定一组已知重量和价值的物品和一个容量已知的背包，求解在不超过背包容量情况下，选用那些物品放入背包，使得所选用的所有物品价值最大化。</span></p><table id="Kxcnj" class="ne-table" style="width: 568px"><tbody><tr style="height: 33px"><td width="284"><p id="386a7bca1015834bb8197ed23406c2cd" class="ne-p"><span class="ne-text">物品总数N</span></p></td><td width="284"><p id="b7385dd6795340d6cd8537cb2272b4cd" class="ne-p"><span class="ne-text">4</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">背包容量M</span></p></td><td width="284"><p id="ba275721c17bb484c2a65dfa4c4be9d4" class="ne-p"><span class="ne-text">8</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="bbd8a608ef98cdcde660b7027123ae52" class="ne-p"><span class="ne-text">每个物品重量wi</span></p></td><td width="284"><p id="2aff6ad44c7ee56d73718d58fdf5d9cd" class="ne-p"><span class="ne-text">{5, 4, 3, 2}</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="7c374bf7c0c403036462af9122de9eb7" class="ne-p"><span class="ne-text">每个物品价值vi</span></p></td><td width="284"><p id="8f8b3b671af4cf8c7022a234e79217e8" class="ne-p"><span class="ne-text">{15, 10, 6, 2}</span></p></td></tr></tbody></table><h3 id="kV86b" style="text-align: left"><span class="ne-text">问题的判定性说法</span></h3><h3 id="6UUMl" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597489691-e0d838af-003e-404e-8a40-5145d2fefbad.png" width="484.5" id="jAqDv" class="ne-image"></h3><h3 id="Wuaqr"><span class="ne-text">问题的形式化定义</span></h3><p id="ac18c94ee3a340915739dbc1f8bfed15" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597354257-45eba2b3-641c-433a-8732-9b6c11a16061.png" width="532.5" id="PlZXH" class="ne-image"></p><h2 id="vPxMl"><span class="ne-text">问题思路</span></h2><h3 id="8v4Q2"><span class="ne-text">动态规划思路</span></h3><p id="5b1dd1177277e0a2231abc79a2504715" class="ne-p"><strong><span class="ne-text">动态规划</span></strong><span class="ne-text">解决该问题，类似于</span><strong><span class="ne-text">莱文斯坦距离</span></strong><span class="ne-text">的解法类似。利用CAAIS数据来说明这个问题的解决思想。</span></p><p id="1f80558ddd90268ceaf49ec6143fa0b1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943092299-49a0bc97-f2cf-4258-8dde-022b4aae06d1.png" width="421" id="bAWry" class="ne-image"></p><p id="dce4c11cc328491c5f934cdc0faf723e" class="ne-p" style="text-align: left"><strong><span class="ne-text">动态规划DP方程构造</span></strong></p><p id="a491a318199a14597b77b639908925f3" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943375703-889cea96-f3a0-41df-b806-386dca8bcc82.png" width="510" id="FlFHG" class="ne-image"></p><p id="819e04e2fb8c81394923d7b13367d2a9" class="ne-p" style="text-align: center"><strong><span class="ne-text">PS：V[i,j]表示在前i件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值</span></strong></p><p id="016745efdd21ed5b2551c84cdfe5b959" class="ne-p" style="text-align: left"><span class="ne-text"></span></p><p id="a8e4731a61f3becea162ae74ad1e0140" class="ne-p" style="text-align: left"><span class="ne-text">（整张表格是从上往下，从左往右地填）</span></p><p id="b0f70ea6d985134ca3546f3ee969eb47" class="ne-p" style="text-align: left"><span class="ne-text">举例说明表格中的数值填法，</span><strong><span class="ne-text">倒数第二行倒数第四列的16 4</span></strong><span class="ne-text">的填法：</span></p><ul class="ne-ul"><li id="fd0af2766eddd8d677c7fed7cc6508c5"><span class="ne-text">首先不满足DP方程的第一种和第二种情况</span></li><li id="1e0486298cdf7b14fdc49498e589ff51"><span class="ne-text">所以代入取最大值max函数</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="122cc3f4fa9b3b221f5816dd01191edb"><span class="ne-text">V（i-1，j）：不选本物品（3，6），还是用之前的值，继承上面的第一个物品和第二个物品，DP值为15 U</span></li><li id="210f1f8f22481b0e5f36a6a10d6f26bf"><span class="ne-text">V（i-1，j）+vi：用该容量（7）-所选物品的重量为4，然后再查容量为4的时候DP值为10，然后求出该情况DP是，10加上该物品的价值，所以该情况下的DP值为16，右上标为4（CAAIS），值来源于前面容量为4的情况。</span></li></ul></ul><p id="4d7e42f132c33e5d1739b85934eab5fe" class="ne-p"><strong><span class="ne-text"> </span></strong></p><p id="2baa3e54a74f1948a2278ea4430ad71a" class="ne-p"><strong><span class="ne-text">格子如上方式填就好了！</span></strong></p><h3 id="iFSbE"><span class="ne-text">递归思路</span></h3><p id="bb4af9858c11fb268b7bba45a9477a7d" class="ne-p"><span class="ne-text">第二节课将递归的时候，也讲了这个问题的递归思路。不过复杂度记得是指数级的，暂时不写了~~</span></p><h2 id="Mh56N"><span class="ne-text">代码实现</span></h2><h3 id="i668W"><span class="ne-text">动态规划Code</span></h3><pre data-language="cpp" id="ugQAd" class="ne-codeblock language-cpp">#include <iostream><p>#include <vector><br>using namespace std;<br>namespace NS_DP0_1Knapsack {<br>int DP0_1Knapsack(int n, int W, int *w, int *v);<br>void Output(int n, int W, int *w, int *v, int OptV);<br>static vector&lt;vector<int>&gt; V;<br>static vector<int> x;<br>void DP0_1KnapsackCaller(int n, int W, int *w, int *v)<br>{<br>V.clear();<br>V.resize(n + 1, vector<int>(W + 1, 0));<br>x.resize(n + 1);<br>int OptV = DP0_1Knapsack(n, W, w, v);<br>Output(n, W, w, v, OptV);<br>}<br>int DP0_1Knapsack(int n, int W, int *w, int *v)<br>{<br>for (int i = 1; i &lt;= n; i++)<br>for (int j = 1; j &lt;= W; j++)<br>if (j &lt; w[i - 1])<br>V[i][j] = V[i - 1][j];<br>else if (V[i - 1][j] &gt;=<br>V[i - 1]j - w[i - 1]] + v[i - 1])<br>V[i][j] = V[i - 1][j];<br>else<br>V[i][j] = V[i - 1]j - w[i - 1]] + v[i - 1];<br>int j = W;<br>for (int i = n; i &gt; 0; i–)<br>if (V[i][j] == V[i - 1][j])<br>x[i] = 0;<br>else<br>{ x[i] = 1; j -= w[i - 1]; }<br>return V[n][w];<br>}<br>void Output(int n, int W, int *w, int *v, int OptV)<br>{<br>//inputs<br>printf(“DP to solve 0-1 knapsack:\n”);<br>printf(“%d items with knapsack capacity %d.\n”, n , W);<br>printf(“%-6s: “, “Weight”);<br>for (int i = 0; i &lt; n; i++)<br>printf(“%3d”, w[i]);<br>printf(“\n”);<br>printf(“%-6s: “, “Value”);<br>for (int i = 0; i &lt; n; i++)<br>printf(“%3d”, v[i]);<br>printf(“\n”);<br>//the value matrix<br>printf(“\nThe value matrix:\n”);<br>printf(“ “);<br>for (int j = 0; j &lt;= W; j++)<br>printf(“%3d”, j);<br>printf(“\n”);<br>for (int i = 0; i &lt;= n; i++)<br>{<br>printf(“%2d”, i);<br>for (int j = 0; j &lt;= W; j++)<br>printf(“%3d”, V[i][j]);<br>printf(“\n”);<br>}<br>//solution<br>printf(“\nThe optimal value: %d\n”, OptV);<br>printf(“The optimal solution:\n”);<br>for (int i = 1; i &lt;= n; i++)<br>printf(“%2d”, x[i]);<br>printf(“\n\n”);<br>}<br>} //namespace NS_DP0_1Knapsack<br>using namespace NS_DP0_1Knapsack;<br>int main()<br>{<br>// 物品个数<br>vector<int> N = { 4, 10};<br>// 背包容量<br>vector<int> W = { 8, 100};<br>// 各物品重量<br>vector&lt;vector<int>&gt; w = {<br>{ 5, 4, 3, 2 },<br>{ 4, 3, 7, 2, 9, 3, 1, 7, 2, 5 }<br>};<br>// 各物品价值<br>vector&lt;vector<int>&gt; v = {<br>{ 15, 10, 6, 2 },<br>{ 15, 10, 6, 2, 23, 12, 33, 7, 22, 10 }<br>};</p><pre><code>int m = N.size();for (int i = 0; i &lt; m; i++)&#123;    DP0_1KnapsackCaller(N[i], W[i], &amp;w[i][0], &amp;v[i][0]);&#125;return 0;</code></pre><p>}</pre><h3 id="OJalB"><span class="ne-text">动态规划 Result</span></h3><p id="00a1ce1dd408aefacd8ac2534241b04e" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943258085-fac4811f-87e7-4eef-8194-ee47d88063a6.png" width="960" id="zluPB" class="ne-image"></p><p id="09adf6c6abcf90133480f096836f6a43" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943276039-f6f74edf-4871-426d-8af8-e1a62edaf071.png" width="960" id="nfyc3" class="ne-image"></p><p id="cc8df1961f2421b4edd6b1e108e851ec" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943291836-84a15101-d6e7-4c9f-91b5-1122afd7ac5c.png" width="960" id="FpXM4" class="ne-image"></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TSP问题</title>
      <link href="/blog/bkbll1/"/>
      <url>/blog/bkbll1/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="ZHb7n"><span class="ne-text">问题描述</span></h2><p id="17bc640017c4e7c4683b7e4a0374f4a4" class="ne-p"><span class="ne-text">假设有n个城市，各个城市与城市间的距离也已知，有一位旅行商需要途径所有的这n个城市，且每个城市只能且必须经过以此，求出一条路线，使得旅行商所走过的路程最短</span></p><h2 id="Q952s"><span class="ne-text">问题思路</span></h2><h2 id="LYpm0"><span class="ne-text">代码思路</span></h2><h2 id="C9pn9"><span class="ne-text">代码实现</span></h2><h2 id="itSa6"><span class="ne-text">参考资料</span></h2><ul class="ne-ul"><li id="01521159061afdf5727facd6f4cb2439"><a href="https://jerkwin.github.io/2016/03/17/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%95%86%E9%97%AE%E9%A2%98TSP%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E6%B3%95/" data-href="https://jerkwin.github.io/2016/03/17/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%95%86%E9%97%AE%E9%A2%98TSP%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E6%B3%95/" target="_blank" class="ne-link"><span class="ne-text">旅行推销商问题TSP的动态规划解法</span></a></li><li id="dbc24a26ebb401b61f70faaff2cda805"><a href="https://blog.csdn.net/joekwok/article/details/4749713" data-href="https://blog.csdn.net/joekwok/article/details/4749713" target="_blank" class="ne-link"><span class="ne-text">TSP(旅行者问题)——动态规划详解</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TODO: 46. 全排列🔖递归</title>
      <link href="/blog/kgaymi/"/>
      <url>/blog/kgaymi/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="uca5e700f"><a href="https://leetcode-cn.com/problems/permutations/" data-href="https://leetcode-cn.com/problems/permutations/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/permutations/</span></a></li><li id="uf2f2c88e"><a href="https://leetcode-cn.com/problems/permutations-ii/" data-href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/permutations-ii/</span></a></li></ul><h2 id="uK3fK"><span class="ne-text">问题描述</span></h2><p id="0b066c7dcf442f3491a28066cab231ea" class="ne-p"><span class="ne-text">给定n个有序元素的集合，列出其可能出现的排列。</span></p><h2 id="sMXsU"><span class="ne-text">问题思路</span></h2><h2 id="NsHpX"><span class="ne-text">代码思路</span></h2><ul class="ne-ul"><li id="436e466cec138ae286ab1c3a4ee05202"><span class="ne-text">利用动态数组数据结构</span></li></ul><h2 id="YzpDm"><span class="ne-text">代码实现</span></h2><pre data-language="java" id="7Fnit" class="ne-codeblock language-java">package com.wztlink1013.al._递归法_;<p>import java.util.ArrayList;</p><p>/**</p><ul><li>全排列问题</li><li>*/</li></ul><p>public class Permuting {<br>static ArrayList<Integer> x = new ArrayList<Integer>();<br>static int N;<br>static int cnt = 0;<br>static int t;</p><pre><code>public static void main(String args[]) &#123;    int n = 10;    Times.test(&quot;当n = &quot; + n + &quot;时候的耗费时间&quot;, new Times.Task() &#123;        public void execute() &#123;            PermutingCaller(n);        &#125;    &#125;);&#125;private static void PermutingCaller(int n) &#123;    N = n;    for (int i = 0; i &lt; n; ++i)        x.add(i + 1);    Permuting(0);&#125;private static void Permuting(int i) &#123;    if (i &lt; N - 1) &#123;        for (int j = i; j &lt; N; j++) &#123;            t = x.get(i);            x.set(i, x.get(j));            x.set(j, t);            Permuting(i + 1);            t = x.get(i);            x.set(i, x.get(j));            x.set(j, t);        &#125;    &#125;    else        OutputOnePermutation();&#125;private static void OutputOnePermutation()&#123;    System.out.print(++cnt + &quot; : &quot;);    for (int x : x)        System.out.print(x + &quot; &quot;);    System.out.println();&#125;</code></pre><p>}</pre><div class="ne-quote"><p id="4da02f40c1cd063d40e69e44ad57d9db" class="ne-p"><span class="ne-text">n:10</span></p></div><p id="075b4e7747e1029e40faec7ceb139a49" class="ne-p"><br></p><div class="ne-quote"><p id="85f46c500eb90d2f54166377f17b7852" class="ne-p"><span class="ne-text">n</span></p></div></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线性搜索</title>
      <link href="/blog/ete0k7/"/>
      <url>/blog/ete0k7/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h2 data-lake-id="c1890278ba67c58bbae4eb1fb7169f2f" id="CRGUS" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">问题描述</h2><p data-lake-id="6aff1e7e83bb6c4ddb5ed7c3da579477" style="text-align: center; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599481660030-a834223b-30e4-4a9e-a290-243f028112f2.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="325px" style="visibility: visible; width: 520px;"></span></p><p data-lake-id="d5810dad979e39b899134401480aa668" style="text-align: left; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="fa302002469ab36b98237d76f3288ea3" id="VnaIB" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">问题思路</h2><h2 data-lake-id="6de205eb8258f2cd589a20e7ffd32d8d" id="7iRKh" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">代码思路</h2><h2 data-lake-id="6eeba5194a0e08b66ee205464517a2fe" id="BXK7k" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">代码实现</h2></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 穷举算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>穷举算法+百元买百兔、素性测试、洗牌问题</title>
      <link href="/blog/czgm7d/"/>
      <url>/blog/czgm7d/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="9dZGL"><span class="ne-text">穷举思想</span></h2><p id="701034f23e618154434f87d75290519f" class="ne-p"><span class="ne-text">穷举法就是针对问题可能出现的结果，对其逐个进行测验并得出是否为符合要求的结果，穷举法也是许多高级算法中的某个部分。</span><strong><span class="ne-text">有点像高中数学里面的对问题进行分类讨论</span></strong><span class="ne-text">的过程中，寻找所有的情况的异曲同工之处。</span></p><h3 id="yuQ8P"><span class="ne-text">两部分组成</span></h3><ol class="ne-ol"><li id="d125884b53c39c6e816069df78dfd590"><span class="ne-text">系统化地枚举问题各种可能的候选解</span></li><li id="5de4a93dacb15c70033bb6d45da6cd27"><span class="ne-text">检查验证每一个候选解是否满足问题的求解要求</span></li></ol><p id="udea0ab48" class="ne-p"><span class="ne-text"></span></p><h3 id="35c7035a"><span class="ne-text">穷举的抽象算法伪代码</span></h3><p id="0c6e4f6483dc4ac48c110f30517cae62" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599469820927-b990d8a2-9025-4f33-becb-46a03890bf07.png" width="548.5" id="J9C5J" class="ne-image"></p><h2 id="GppXW"><span class="ne-text">百元买百兔问题</span></h2><p id="89151cb71f121dc41c1bf5a031ad6c4e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621393290050-0aa37db7-c08b-407b-8088-c4ede29b80b5.png" width="559.5" id="Ys3JG" class="ne-image"></p><h2 id="zkq0Z"><span class="ne-text">洗牌问题</span></h2><p id="c5bfc9757b0ec7e046981409eee9a8e5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599475674143-ee86ef49-1b68-4940-baef-e556f225e43d.png" width="528" id="YAiZx" class="ne-image"></p><h3 id="Sy39a"><span class="ne-text">问题思路</span></h3><ul class="ne-ul"><li id="0eca9bf3dc25065b5ff97041e54925ff"><span class="ne-text">在1~n-1当中随机选择一个数k1，将其与第n个数互换；</span></li><li id="64b861b55c3bebc88ae1996ff8260453"><span class="ne-text">在1~n-2当中随机选择一个属k2，将其与第n-1个数互换；</span></li><li id="e228f261b87001e5189e2859a5f9a648"><span class="ne-text">在第i轮之后，1~n-</span><strong><span class="ne-text">(i-1)</span></strong><span class="ne-text">当中选择一个数ki，将其与第n-</span><strong><span class="ne-text">(i-1)</span></strong><span class="ne-text">个数互换；</span></li></ul><h3 id="BMa7D"><span class="ne-text">代码思路</span></h3><ul class="ne-ul"><li id="7375bca2adbdc78011c5ef2a39453e87"><span class="ne-text">在区间之间随机数的生成</span></li><li id="3c1788deb88593e1aa228354c26fe00b"><span class="ne-text">交换函数</span></li><li id="6cb0b75ba8f7cd66516ca20b41cdae95"><span class="ne-text">泛型：支持各种类型数据的“洗牌”</span></li></ul><p id="6bc76bbc1ebbeaa6465a1e70916c7927" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 穷举算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TODO: 78. 子集🔖递归</title>
      <link href="/blog/mz8hpp/"/>
      <url>/blog/mz8hpp/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="uc83ba6b1"><a href="https://leetcode-cn.com/problems/subsets/" data-href="https://leetcode-cn.com/problems/subsets/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/subsets/</span></a></li></ul><p id="u0d912814" class="ne-p"><span class="ne-text"></span></p><h2 id="oWCtR"><span class="ne-text">问题描述</span></h2><p id="u987a602d" class="ne-p"><span class="ne-text">给定一个正整数n，生成集合 {1,2,3,…n} 的所有子集</span></p><h2 id="TTeaW"><span class="ne-text">问题思路</span></h2><div class="ne-quote"><p id="u4d5d2633" class="ne-p"><span class="ne-text">思路一：二进制法</span></p></div><p id="u9cfecfd5" class="ne-p"><span class="ne-text">利用</span><strong><span class="ne-text">二进制</span></strong><span class="ne-text">“</span><strong><span class="ne-text">是否显现”</span></strong><span class="ne-text">的转换思路来解决这个问题，一个数字在子集当中就标记为1反之标记为0，就比如 </span><code class="ne-code"><span class="ne-text">n=3</span></code><span class="ne-text"> ，输出： </span><code class="ne-code"><span class="ne-text">&#123;&#125;&#123;1,0,0&#125;&#123;0,1,0&#125;&#123;0,0,1&#125;&#123;1,1,0&#125;&#123;1,0,1&#125;&#123;0,1,1&#125;&#123;1,1,1&#125;</span></code><span class="ne-text"> </span></p><h2 id="nasxE"><span class="ne-text">代码思路</span></h2><div class="ne-quote"><p id="u6c37ed60" class="ne-p"><span class="ne-text">思路一：利用动态数组数据结构</span></p></div><p id="u03f8fd6a" class="ne-p"><span class="ne-text">输入的n就是动态数组的初始大小</span></p><p id="u19e25500" class="ne-p"><span class="ne-text">然后依次利用“吞进来”和“吐出去”尾元素来实现</span></p><h2 id="sJsJW"><span class="ne-text">java代码实现</span></h2><pre data-language="java" id="KEILY" class="ne-codeblock language-java">package com.wztlink1013.al._递归法_;<p>/*</p><ul><li>作用：测量代码运行时间<br>*/<br>import java.text.SimpleDateFormat;<br>import java.util.Date;</li></ul><p>public class Times {<br>private static final SimpleDateFormat fmt = new SimpleDateFormat(“HH:mm:ss.SSS”);</p><pre><code>public interface Task &#123;    void execute();&#125;public static void test(String title, Task task) &#123;    if (task == null) return;    title = (title == null) ? &quot;&quot; : (&quot;【&quot; + title + &quot;】&quot;);    System.out.println(title);    System.out.println(&quot;开始：&quot; + fmt.format(new Date()));    long begin = System.currentTimeMillis();    task.execute();    long end = System.currentTimeMillis();    System.out.println(&quot;结束：&quot; + fmt.format(new Date()));    double delta = (end - begin) / 1000.0;    System.out.println(&quot;耗时：&quot; + delta + &quot;秒&quot;);    System.out.println(&quot;-------------------------------------&quot;);&#125;</code></pre><p>}</pre><pre data-language="java" id="peGzk" class="ne-codeblock language-java">package com.wztlink1013.al.<em>递归法</em>;</p><p>import java.util.ArrayList;</p><p>/**</p><ul><li><p>子集问题<br>*/<br>public class SubSetting {<br>static ArrayList<Integer> x = new ArrayList<Integer>();<br>static int cnt = 0;<br>public static void main(String args[]) {<br>int n = 4;<br>Times.test(“当 n = “ + n + “时候的耗费时间”, new Times.Task() {<br>public void execute() {<br>Subsetting(n);<br>}<br>});<br>}</p><pre><code>private static void Subsetting(int n) &#123;    if (n &gt; 0) &#123;        x.add(0);        Subsetting(n - 1);        x.remove(x.size() - 1);        x.add(1);        Subsetting(n - 1);        x.remove(x.size() - 1);    &#125;else &#123;        OutputOneSubsetBinary();        OutputOneSubset();        System.out.print(&quot;\n&quot;);    &#125;&#125;private static void OutputOneSubset() &#123;    System.out.printf(&quot;; &#123;&quot;);    int k = 0;    for (int i = x.size() - 1; i &gt;=0; i--) &#123;        if (x.get(i) == 1) &#123;            if (k &gt; 0)                System.out.printf(&quot;,&quot;);            System.out.printf(&quot;%d&quot;, x.size() - i);            k++;        &#125;    &#125;    System.out.printf(&quot;&#125;&quot;);&#125;private static void OutputOneSubsetBinary() &#123;    System.out.printf(&quot;%010d: &quot;, ++cnt);    for (int i = x.size() - 1; i &gt;= 0; i--)        System.out.printf(&quot;%d&quot;, x.get(i));&#125;</code></pre><p>}</pre><p id="u846ac0c3" class="ne-p"><span class="ne-text">运行结果：</span></p><div class="ne-quote"><p id="u62b76a93" class="ne-p"><span class="ne-text">n：18（分钟）</span></p></div><p id="u65fd3b0a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600319992252-d49865a4-9a9d-4c65-88c8-ea72f140bf85.png" width="960" id="fUSjb" class="ne-image"></p><div class="ne-quote"><p id="u91007ebb" class="ne-p"><span class="ne-text">n：19（分钟）</span></p></div><p id="u7ed8826a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600320121635-ea76638e-a4c2-4686-a017-0d97088dc417.png" width="960" id="vPsbY" class="ne-image"></p><div class="ne-quote"><p id="u9ab386d4" class="ne-p"><span class="ne-text">n：20（分钟）</span></p></div><p id="uf3e3294b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600320284010-b885d1eb-01da-40d9-a098-f5d84744d847.png" width="960" id="ulpx3" class="ne-image"></p><div class="ne-quote"><p id="u9dd37efc" class="ne-p"><span class="ne-text">n：21（分钟）</span></p></div><p id="u20a0d9f9" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600320620721-cf61057d-1eac-48d3-b724-36d0d21c4d1e.png" width="960" id="oFf1t" class="ne-image"></p><div class="ne-quote"><p id="u0fc251d1" class="ne-p"><span class="ne-text">n：22（分钟）</span></p></div><p id="u047f9967" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600321218265-60888e51-2006-4dd7-bbe0-60b336895b8c.png" width="960" id="Gkj9x" class="ne-image"></p><div class="ne-quote"><p id="u4c599785" class="ne-p" style="text-align: left"><span class="ne-text">n：23（分钟）</span></p></div><p id="ub5346238" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600329834700-9cb11fdc-fec8-463d-934a-b140b45cc0ae.png" width="960" id="FPV45" class="ne-image"></p><div class="ne-quote"><p id="u836b42f4" class="ne-p"><span class="ne-text" style="background-color: #FADB14">网上查的代码！</span></p></div><pre data-language="java" id="l71fk" class="ne-codeblock language-java">class Main<br>{<br>static void printSubsets(String[] set)<br>{<br>int n = set.length;<br>for (int i = 0; i < (1<<n); i++)<br>{<br>System.out.print("{ ");<br>for (int j = 0; j < n; j++)<br>if ((i & (1 << j)) > 0)<br>System.out.print(set[j] + " ");<br>System.out.println("}");<br>}<br>}<br>public static void main(String[] args)<br>{<br>String[] set = {"1", "2", "3", "4",<br>"5", "6", "7", "8"};<br>printSubsets(set);<br>}<br>}</pre><p id="ucfd2866f" class="ne-p"><br></p></div></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用类</title>
      <link href="/blog/rnsz9o/"/>
      <url>/blog/rnsz9o/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="hu2tb"><span class="ne-text">java.util.Date</span></h2><p id="u90320dc3" class="ne-p"><br></p><pre data-language="java" id="eTK8f" class="ne-codeblock language-java">java.util.Date date = new java.util.Date();<p>System.out.println(date.toString());</pre><pre data-language="plain" id="DvDTZ" class="ne-codeblock language-plain">Sun Mar 09 13:50:19 EST 2020</pre><h2 id="bGgjz"><span class="ne-text">java.util.Random</span></h2><div class="ne-quote"><p id="3ebc3aa752139df15b3b84eec82e1bfb" class="ne-p"><span class="ne-text">Math.Random()：Math 类里面的随机数函数，范围是 0.0 到 0.1</span></p></div><p id="a0966ea30f501dd358a4cbe5d0fd47dd" class="ne-p"><br></p><div class="ne-quote"><p id="b4f9e6ac9806372413c926ee61932a0d" class="ne-p"><span class="ne-text">java.util.Random </span></p></div><p id="d50507f457166c83a53d93400af6343f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600085762621-35c72adc-6c6e-4ab2-ac8b-d76d50e570e5.png" width="449.5" id="wOnz7" class="ne-image"></p><p id="2092969a19f287a6f7c288e43e280a0a" class="ne-p" style="text-align: center"><br></p><h2 id="8rhVQ"><span class="ne-text">javafx.geometry.Point2D</span></h2><p id="75b80ea1aee10da394909335a3c78b0f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600086091697-6fa8f4e4-137d-490a-8fe0-3546693a1f86.png" width="480" id="F3zQL" class="ne-image"></p><pre data-language="java" id="cRKIR" class="ne-codeblock language-java">import java.util.Scanner;<br>import javafx.geometry.Point2D;<br>public class TestPoint2D {<br>public static void main(String[] args){</p><pre><code>Scanner input= new Scanner(System.in);System.out.println(&quot;Enter point1&#39;s x-,y-coordinates:&quot;);double x1=input.nextDouble();double y1=input.nextDouble();System.out.println(&quot;Enter point2&#39;s x-,y-coordinates:&quot;);double x2=input.nextDouble();double y2=input.nextDouble();Point2D p1 =new Point2D(x1,y1);Point2D p2 =new Point2D(x2,y2);System.out.println(&quot;p1 is&quot;+p1.toString());System.out.println(&quot;p2 is&quot;+p2.toString());System.out.println(&quot;distance is&quot;+p1.distance(p2));&#125;</code></pre><p>}</pre><pre data-language="plain" id="c0KIS" class="ne-codeblock language-plain">Enter point1's x-,y-coordinates:<br>1 2<br>Enter point2's x-,y-coordinates:<br>3 4<br>p1 isPoint2D [x = 1.0, y = 2.0]<br>p2 isPoint2D [x = 3.0, y = 4.0]<br>distance is2.8284271247461903</pre><h2 id="cfrIf"><span class="ne-text">String 和 StringBuilder 和 StringBuffer</span></h2><p id="c96272c27bf97d8a091e5fe92acb1db5" class="ne-p"><br></p><h2 id="KFk2b"><span class="ne-text">Object</span></h2><h3 id="9LDLB"><span class="ne-text">toString()方法</span></h3><h3 id="323B6"><span class="ne-text">equals()方法</span></h3><div class="ne-quote"><p id="f796af356e2eece6fe52e1fcdf774a2c" class="ne-p"><span class="ne-text">默认实现的方法</span></p></div><pre data-language="java" id="MIs2D" class="ne-codeblock language-java">public boolean equals(Object obj) {<br>return (this == obj);<br>}</pre><div class="ne-quote"><p id="57042814c9899def2684ff3eba0159e7" class="ne-p"><span class="ne-text">重写例子</span></p></div><pre data-language="java" id="uctZp" class="ne-codeblock language-java">public boolean equals(Object obj) {<br>if (o instanceof Circe)<br>return radius == ((Circle)o).radius;<br>else<br>return this == o;<br>}</pre><p id="76768b7678f7b008f5ba9e7830055fdc" class="ne-p"><br></p><p id="de74c54ab0bf22d0c294e571b04c8a5b" class="ne-p"><br></p><p id="43ef6a2a08160c4a79107bb7fabf3eac" class="ne-p"><br></p><p id="24f6e318ea16b7922e289a49a36c90aa" class="ne-p"><br></p><p id="0dd07e2a49f0b4d23a27fa1084a9a439" class="ne-p"><br></p><p id="1c266256220313f5a316bd2cbb9afca9" class="ne-p"><br></p><p id="36fd9bb1cd8e04c7b37b5cb4195b5e40" class="ne-p"><br></p><p id="c51df20b12b79079022a36b0d3c405e4" class="ne-p"><br></p><p id="78c06392a68bc5cd11384cb8531e1b04" class="ne-p"><br></p><p id="b1c15509562284ea1c4df857d638c4c3" class="ne-p"><br></p><p id="a8a4609032789c13cd6f2dd0127cda0b" class="ne-p"><br></p><p id="240b47d1c095fbba948d18ebf5a74acf" class="ne-p"><br></p><p id="6e6b1644a3ad3ca45d4eae24030617a1" class="ne-p"><br></p><p id="c66e211ccbe193dfd5fca2521d4d60f1" class="ne-p"><br></p><p id="b157532cebe9521a769a255f17afe3cf" class="ne-p"><br></p><p id="e24566882138240a169e32389529dc4e" class="ne-p"><br></p><p id="a1bc8fa86745692fa2c9ea6e3a0ba861" class="ne-p"><br></p><p id="8b7b8e3f8fde4b245e0258e8a75c0947" class="ne-p"><br></p><p id="d3d2905383183702ebcfd8ad70896b5e" class="ne-p"><br></p><p id="71bcfe7d999828ca48d1a58416032acd" class="ne-p"><br></p><p id="62681aaf1c448c3cf45f6a36153a1c27" class="ne-p"><br></p><p id="d16baf99b221016c7803b7b0f1c2e0a5" class="ne-p"><br></p><p id="e03a961c1f666e936355abd15f1cf635" class="ne-p"><br></p><p id="25fcc9b9f62775b33a5a944b2e956af6" class="ne-p"><br></p><p id="b5ceff8c2a47105ee3244256cadf335a" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>206.反转链表🔖链表</title>
      <link href="/blog/ipiwza/"/>
      <url>/blog/ipiwza/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="MFdvm"><span class="ne-text">206. 反转链表</span></h2><ul class="ne-ul"><li id="ue0d90691"><a href="https://leetcode-cn.com/problems/reverse-linked-list/" data-href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/reverse-linked-list/</span></a></li></ul><h3 id="onjU3"><span class="ne-text">问题描述</span></h3><p id="9017fce1dfd655319ba1ee74af5e5d77" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603193588776-6539785f-f52d-494b-b7a1-2bc6cebf1e60.png" width="362.5" id="YFQAP" class="ne-image"></p><h3 id="3x1H8"><span class="ne-text">问题思路</span></h3><ol class="ne-ol"><li id="8e9865640e4179ed60cda8425dd1c7d5"><strong><span class="ne-text">利用外部空间：</span></strong><span class="ne-text">将所给链表存到ArryList里面或者是新的链表里面，然后再反转动态数组就可以了。</span></li><li id="243204d6df5dc3c4a2970de3d704c420"><strong><span class="ne-text">快慢指针</span></strong><span class="ne-text"></span></li><li id="33dc470dda2ef16930e214739c03046d"><strong><span class="ne-text">递归解法</span></strong><span class="ne-text"></span></li></ol><h3 id="VZKxU"><span class="ne-text">代码实现</span></h3><h4 id="rIxIY"><span class="ne-text">js</span></h4><pre data-language="javascript" id="KRYiq" class="ne-codeblock language-javascript">/**<ul><li><p>Definition for singly-linked list.</p></li><li><p>function ListNode(val, next) {</p></li><li><pre><code>this.val = (val===undefined ? 0 : val)</code></pre></li><li><pre><code>this.next = (next===undefined ? null : next)</code></pre></li><li><p>}<br>*/<br>/**</p></li><li><p>@param {ListNode} head</p></li><li><p>@return {ListNode}<br>*/<br>var reverseList = function(head) {<br>let prev = null;<br>let curr = head;<br>while (curr) {<br>const next = curr.next;<br>curr.next = prev;<br>prev = curr;<br>curr = next;<br>}<br>return prev;<br>};</pre><h4 id="GjwCF"><span class="ne-text">递归实现</span></h4><pre data-language="java" id="RC4l4" class="ne-codeblock language-java">/**</p></li><li><p>public class ListNode {</p></li><li><pre><code>int val;</code></pre></li><li><pre><code>ListNode next;</code></pre></li><li><pre><code>ListNode(int x) &#123; val = x; &#125;</code></pre></li><li><p>}<br>*/</pre><pre data-language="java" id="QW3m9" class="ne-codeblock language-java">// 避免陷入死循环<br>if (head == null || head.next == null) return head;<br>ListNode newHead = reverseList(head.next); //此处递归，找到最后一个节点了<br>head.next.next = head; //重新指定节点指向（有两个 next，注意少写）<br>head.next = null; //将最初的节点指向空<br>return newHead; //返回新的“倒置”头节点</pre><h4 id="C3tj2"><span class="ne-text" style="color: #000000; background-color: #FADB14">快慢指针</span></h4><pre data-language="java" id="JZGgE" class="ne-codeblock language-java">class Solution {<br>public ListNode reverseList(ListNode head) {<br>// 避免陷入死循环<br>if (head == null || head.next == null) return head;</p><pre><code>    ListNode newHead = null;    while (head != null)&#123;        ListNode tmp = head.next;        head.next = newHead;        newHead = head;        head = tmp;    &#125;    return newHead;&#125;</code></pre><p>}</pre><h2 id="FAX8v"></h2></div></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📎线结构：链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法复杂度</title>
      <link href="/blog/veggl2/"/>
      <url>/blog/veggl2/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法综述 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法分析与设计课程综述</title>
      <link href="/blog/eq2l1v/"/>
      <url>/blog/eq2l1v/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="07a77b38bab82dba78fc31ec93fac579" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="b1a9b3ae24de01da833226532bde31de" class="ne-p"><span class="ne-text">算法分析与设计两门课程的学习笔记</span></p></div><h2 id="rU8fV"><span class="ne-text">形式化定义</span></h2><p id="c3a072660e4f55234ffea419e05f1207" class="ne-p" style="text-indent: 2em"><span class="ne-text">对于一个问题，将其进行科学的分析研究，就需要对其进行更加严谨的形式化定义，其形式就类似于数学建模过程中的构建出</span><strong><span class="ne-text">数学模型</span></strong><span class="ne-text">一样，对其进行问题的抽象化提取，以及合理的公式化，就比如“0-1背包”问题中：</span></p><p id="f63087dccbff79d0c562199ad315640f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597354257-45eba2b3-641c-433a-8732-9b6c11a16061.png" width="532.5" id="FfSoK" class="ne-image"></p><p id="81f5f466bb1673277f4c783982b45396" class="ne-p"><br></p><h2 id="AHjIH"><span class="ne-text">判定性问题</span></h2><p id="8da3e850ab67d48d57ee4a44b5fcf917" class="ne-p"><span class="ne-text">类似于数学建模当中</span><strong><span class="ne-text">模型的求解</span></strong><span class="ne-text">，在给定模型以及约束条件的情况下求出符合该约束条件下的模型解：</span></p><p id="bfe8e49a8319845c5b0dec84d0805be0" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597489691-e0d838af-003e-404e-8a40-5145d2fefbad.png" width="484.5" id="ZMrl3" class="ne-image"></p><p id="cf7e19aa10a4c9f4c986dc76433260b3" class="ne-p"><br></p><h2 id="6Bf6i"><span class="ne-text">例子：Euclid-GCD问题</span></h2><p id="ufaffbb0b" class="ne-p"><span class="ne-text">问题描述</span></p><p id="2b0bd3adab947ea6df5e9b9054faffc6" class="ne-p"><span class="ne-text">将每个整数分解为素因子的积，找出公共的素因子，它们的积即是GCD</span></p><p id="u3610fd1a" class="ne-p"><span class="ne-text">问题思路</span></p><p id="2aa5e9833be129f16b160223aa008628" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599360897754-ab7b7684-5565-471b-aece-1725b39196bb.png" width="395" id="zBWoT" class="ne-image"></p><p id="u6243f6f6" class="ne-p"><span class="ne-text">代码实现</span></p><pre data-language="java" id="k62y6" class="ne-codeblock language-java">package com.wztlink1013.al.EuclidGCD;<p>import java.util.Scanner;</p><p>public class Main {<br>public static void main(String args[]){<br>Scanner input = new Scanner(System.in);</p><pre><code>    System.out.println(&quot;请输入两个大于零的自然数：&quot;);    int a = input.nextInt();    int b = input.nextInt();    GCD(a,b);    System.out.println(a + &quot;和&quot; + b + &quot;两个数的GCD值为：&quot; + GCD(a,b));&#125;public static int GCD(int i, int j)&#123;    int r;    while (j != 0)&#123;        r = i%j;        i = j;        j = r;        System.out.println(&quot;a=&quot;+i+&quot;；b=&quot;+j+&quot;；r=&quot;+r);    &#125;    return i;&#125;</code></pre><p>}</p><p></pre><p id="bf411c85a6f59a31f84ebbd861e193de" class="ne-p"><br></p><p id="0ed8cce25eb9272b76b389ae29130c72" class="ne-p"><br></p><p id="c25c5404378b4c9b4ba086a3fdc9201f" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法综述 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1/15/18. 两/三/四数之和🔖数组🔖多指针🔖暴力</title>
      <link href="/blog/dq9vp6/"/>
      <url>/blog/dq9vp6/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="VS1b5"><span class="ne-text">1. 两数之和</span></h3><p id="u8b3df82f" class="ne-p"><a href="https://leetcode.cn/problems/two-sum/" data-href="https://leetcode.cn/problems/two-sum/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode.cn/problems/two-sum/</span></a></p><pre data-language="javascript" id="jYcHB" class="ne-codeblock language-javascript">/**<ul><li>@param {number[]} nums</li><li>@param {number} target</li><li>@return {number[]}<br>*/<br>var twoSum = function(nums, target) {<br>let result = []<br>for (let i = 0; i&lt;nums.length; i++) {<br>for (let j = i+1; j&lt;nums.length; j++) {<br>if (nums[i]+nums[j]===target) {<br>result = [i,j]<br>break<br>}<br>}<br>}<br>return result<br>};</pre><p id="u4f1299f7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652967530657-b60f0c75-a67f-4415-85e9-36c3f6ea89d0.png" width="685.8333060807663" id="u3349df16" class="ne-image"></p><h3 id="TwjW2"><span class="ne-text">15. 三数之和</span></h3><ul class="ne-ul"><li id="uc8771cb6"><a href="https://leetcode-cn.com/problems/3sum/" data-href="https://leetcode-cn.com/problems/3sum/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/3sum/</span></a></li></ul><pre data-language="javascript" id="OCssi" class="ne-codeblock language-javascript">/**</li><li>@param {number[]} nums</li><li>@return {number[][]}<br>*/<br>var threeSum = function(nums) {<br>let result = []<br>let arr = nums.sort((a, b) =&gt; {return a - b})<br>for (let i = 0; i&lt;arr.length; i++) {<br>if (i&gt;0 &amp;&amp; arr[i] === arr[i-1]) continue<br>for (let j = i+1; j&lt;arr.length; j++) {<br>if (j&gt;i+1 &amp;&amp; arr[j] === arr[j-1]) continue<br>for (let k = j+1; k&lt;arr.length; k++) {<br>if (arr[i]+arr[j]+arr[k] === 0) {<br>if (k&gt;j+1 &amp;&amp; arr[k] === arr[k-1]) {<br>k++<br>continue<br>}<br>result.push([arr[i], arr[j], arr[k]])<br>}<br>}<br>}<br>}<br>return result<br>};</pre><p id="u90c86df0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652966701635-7130309a-dd69-4cb7-93fc-3a2f0ddffa65.png" width="735.8333040939449" id="ub4f4d5d1" class="ne-image"></p><p id="u0f508055" class="ne-p"><span class="ne-text">5%……我裂开……思路还是 for 暴力循环，但是和上面的耗时过长做了一个先把数组排序的操作。</span></p><p id="uef360e05" class="ne-p"><span class="ne-text"></span></p><p id="ua3a58832" class="ne-p"><span class="ne-text">感觉肯定是有简单的方法的…</span></p><p id="uaf28f9ae" class="ne-p"><span class="ne-text">但肯定都是定一移二的操作</span></p><p id="ude1a341b" class="ne-p"><br></p><h3 id="lw8nH"><span class="ne-text">18. 四数之和</span></h3><ul class="ne-ul"><li id="u5db38256"><span class="ne-text"></span><a href="https://leetcode.cn/problems/4sum/" data-href="https://leetcode.cn/problems/4sum/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode.cn/problems/4sum/</span></a></li></ul><pre data-language="javascript" id="S8z3m" class="ne-codeblock language-javascript">/**</li><li>@param {number[]} nums</li><li>@param {number} target</li><li>@return {number[][]}<br>*/<br>var fourSum = function(nums, target) {<br>let result = []<br>let arr = nums.sort((a, b) =&gt; {return a - b})<br>for (let i = 0; i&lt;arr.length; i++) {<br>if (i&gt;0 &amp;&amp; arr[i] == arr[i-1]) continue<br>for (let j = i+1; j&lt;arr.length; j++) {<br>if (j&gt;i+1 &amp;&amp; arr[j] == arr[j-1]) continue<br>for (let k = j+1; k&lt;arr.length; k++) {<br>if (k&gt;j+1 &amp;&amp; arr[k] == arr[k-1]) continue<br>for (let l = k+1; l&lt;arr.length; l++) {<br>if (arr[i]+arr[j]+arr[k]+arr[l]===target) {<br>if (l&gt;k+1 &amp;&amp; arr[l] === arr[l-1]) {<br>l++<br>continue<br>}<br>result.push([arr[i],arr[j],arr[k],arr[l]])<br>}<br>}<br>}<br>}<br>}<br>return result<br>};</pre><p id="u9f98182c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653017507005-019cf789-c92c-4510-a8fa-a7ccbd00fc1c.png" width="647.4999742706627" id="u56d5290b" class="ne-image"></p></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/blog/ef1q5c/"/>
      <url>/blog/ef1q5c/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="22eb6e7402146143bb2eec8c91969cee" class="ne-p"><span class="ne-text">类似C++里面的模板</span></p><ul style="margin: 0; padding-left: 23px"><li id="ee4362dddf1a7a080c9d882c8ade010c"><span class="ne-text">定义的时候就是直接在后面加上<E>，比如： </span><code class="ne-code"><span class="ne-text">public class ArrayList<E></span></code><span class="ne-text"> </span></li><li id="e19fe7f167fcc159934b8e0e6bbe54fc"><span class="ne-text">使用就是 </span><code class="ne-code"><span class="ne-text">private E[] array</span></code><span class="ne-text"> ;</span></li></ul><h2 id="tQE4C"></h2><h2 id="7MhZG"></h2><p id="05efe278d6899c3db53044e2effc732d" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA动态数组设计</title>
      <link href="/blog/bx5ouf/"/>
      <url>/blog/bx5ouf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="IHGHb"><span class="ne-text">接口设计</span></h3><pre data-language="java" id="5nBTl" class="ne-codeblock language-java">public int size(); // 返回动态数组元素个数<p>public boolean isEmpty(); // 是否为空<br>public boolean contains(E element); // 是否包含某个元素<br>public void add(E element); // 在数组尾部添加元素<br>public E get(int index); // 返回 index 位置对应的元素<br>public E set(int index, E element); // 设置/更换 index 位置上的值<br>public void add (int index, E element); // 在 index 位置上添加元素<br>public E remove(int index); // 移除 index 位置上的值<br>public int indexOf(E element); // 查看元素的位置<br>public void clear(); // 清空动态数组所有元素</pre><h3 id="yhped"><span class="ne-text">private 设计</span></h3><pre data-language="java" id="sJ0PL" class="ne-codeblock language-java">// 元素的数量<br>private int size;<br>// 所有的元素<br>private E[] elements;</p><p>private static final int DEFAULT_CAPACITY = 10;<br>private static final int ELEMENT_NOT_FOUND = -1;</p><p>/**<br>_ 保证要有 capacity 的容量<br>_ @param capacity<br>*/<br>private void ensureCapacity(int capacity) {<br>int oldCapacity = elements.length;<br>if (oldCapacity &gt;= capacity) return;</p><pre><code>// 新容量为旧容量的1.5倍int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);E[] newElements = (E[]) new Object[newCapacity];for (int i = 0; i &lt; size; i++) &#123;    newElements[i] = elements[i];&#125;elements = newElements;System.out.println(oldCapacity + &quot;扩容为&quot; + newCapacity);</code></pre><p>}</p><p>private void outOfBounds(int index) {<br>throw new IndexOutOfBoundsException(“Index:” + index + “, Size:” + size);<br>}</p><p>private void rangeCheck(int index) {<br>if (index &lt; 0 || index &gt;= size) {<br>outOfBounds(index);<br>}<br>}</p><p>private void rangeCheckForAdd(int index) {<br>if (index &lt; 0 || index &gt; size) {<br>outOfBounds(index);<br>}<br>}</pre><h3 id="UCaGc"><span class="ne-text">构造函数设计</span></h3><pre data-language="java" id="sKVoN" class="ne-codeblock language-java">public ArrayList(int capaticy) {<br>capaticy = (capaticy < DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capaticy;<br>elements = (E[]) new Object[capaticy];<br>}</p><p>public ArrayList() {<br>this(DEFAULT_CAPACITY);<br>}</pre><h3 id="BtPzG"><span class="ne-text">重写输出</span></h3><pre data-language="java" id="58KBo" class="ne-codeblock language-java">@Override<br>public String toString() {<br>// size=3, [99, 88, 77]<br>StringBuilder string = new StringBuilder();<br>string.append("size=").append(size).append(", [");<br>for (int i = 0; i < size; i++) {<br>if (i != 0) {<br>string.append(", ");<br>}</p><pre><code>    string.append(elements[i]);    //            if (i != size - 1) &#123;    //                string.append(&quot;, &quot;);    //            &#125;&#125;string.append(&quot;]&quot;);return string.toString();</code></pre><p>}</pre><p id="uf7239e17" class="ne-p"><span class="ne-text">22</span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA链表设计</title>
      <link href="/blog/nkn2os/"/>
      <url>/blog/nkn2os/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="87ed5342"><span class="ne-text">LinkedList和ArrayList的设计</span></h2><p id="u138158d0" class="ne-p"><br></p><p id="uec8e29a0" class="ne-p"><br></p><div class="ne-quote"><p id="06b3dd2f95b4188a76d895dc7d174e4f" class="ne-p"><span class="ne-text" style="color: #F5222D">同时设计LinkedList和ArrayList</span></p></div><ul class="ne-ul"><li id="57803a540903fc07605b8f82b8c92064"><strong><span class="ne-text">LinkedList</span></strong><span class="ne-text">不需要构造函数</span></li><li id="bc16b24596092dadd91267c5f6b7b794"><strong><span class="ne-text">ArrayList</span></strong><span class="ne-text">需要，后者需要一个容量的初始化。</span></li></ul><p id="094c1b843afa0d090e6c14fb0948ce50" class="ne-p"><br></p><p id="ff0c850e3ddf6f7d3e965268398eb025" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603191040309-0ed4b536-89c0-449d-85cc-e763afcb73ea.png" width="278.5" id="NZYUa" class="ne-image"></p><h3 id="9cXZd"><span class="ne-text">接口List设计</span></h3><div class="ne-quote"><p id="19863c3bb1cb0b3ed277ef3db37ea991" class="ne-p"><span class="ne-text">只用来</span><strong><span class="ne-text">声明对外接口</span></strong><span class="ne-text">，不能声明</span></p></div><pre data-language="java" id="4qE9A" class="ne-codeblock language-java">package com.wztlink1013.ds.linkedlist;<p>/**</p><ul><li>fun：实现 ArrayList 和 LinkedList 的接口</li><li>*/</li></ul><p>public interface List<E> {<br>static final int ELEMENT_NOT_FOUND = -1;</p><pre><code>/** * 元素的数量[抽象类中实现] * @return */int size();/** * 是否为空[抽象类中实现] * @return */boolean isEmpty();/** * 是否包含某个元素[抽象类中实现] * @param element * @return */boolean contains(E element);/** * 添加元素到尾部[抽象类中实现] * @param element */void add(E element);/** * 清除所有元素[实现类中实现] */void clear();/** * 获取index位置的元素[实现类中实现] * @param index * @return */E get(int index);/** * 设置index位置的元素[实现类中实现] * @param index * @param element * @return 原来的元素ֵ */E set(int index, E element);/** * 在index位置插入一个元素[实现类中实现] * @param index * @param element */void add(int index, E element);/** * 删除index位置的元素[实现类中实现] * @param index * @return */E remove(int index);/** * 查看元素的索引[实现类中实现] * @param element * @return */int indexOf(E element);</code></pre><p>}</p><p></pre><h3 id="SyVsT"><span class="ne-text">抽象类AbstractList设计</span></h3><div class="ne-quote"><p id="074137348dfb83ac851f92e3410c4d2b" class="ne-p"><span class="ne-text">放ArrayList和LinkedList的公共代码</span></p><ul class="ne-ul"><li id="bdc02f7dd192704b4f61a9702ec8910e"><strong><span class="ne-text">实现List接口类</span></strong><span class="ne-text">的共同代码</span></li><li id="c6aa6536ec4a4d325c86ece9d1eb3efa"><span class="ne-text">ArrayList和LinkedList都用得到但是不对外公开的代码</span></li></ul><p id="f18b25c51383375495aa35bafcf41c32" class="ne-p"><span class="ne-text">声明抽象类abstract，就意味着可以不用全部实现接口List里面的所有方法</span></p></div><pre data-language="java" id="Eh9BM" class="ne-codeblock language-java">package com.wztlink1013.ds.linkedlist;</p><p>/**</p><ul><li>fun：放 ArrayList 和 LinkedList 公共代码的抽象类（父类）</li><li>*/</li></ul><p>public abstract class AbstractList<E> implements List<E> {</p><pre><code>protected int size;/** * 元素的数量 * @return */public int size() &#123;    return size;&#125;/** * 是否为空 * @return */public boolean isEmpty() &#123;    return size == 0;&#125;/** * 是否包含某个元素 * @param element * @return */public boolean contains(E element) &#123;    return indexOf(element) != ELEMENT_NOT_FOUND;&#125;/** * 添加元素到尾部 * @param element */public void add(E element) &#123;    add(size, element);&#125;/** * 下面三个是ArrayList和LinkedList两个实现类中的公共代码 * */protected void outOfBounds(int index) &#123;    throw new IndexOutOfBoundsException(&quot;Index:&quot; + index + &quot;, Size:&quot; + size);&#125;protected void rangeCheck(int index) &#123;    if (index &lt; 0 || index &gt;= size) &#123;        outOfBounds(index);    &#125;&#125;protected void rangeCheckForAdd(int index) &#123;    if (index &lt; 0 || index &gt; size) &#123;        outOfBounds(index);    &#125;&#125;</code></pre><p>}</p><p></pre><h3 id="LHnfr"><span class="ne-text" style="color: #000000">ArrayList设计</span></h3><pre data-language="java" id="WvNpC" class="ne-codeblock language-java">package com.wztlink1013.ds.linkedlist;</p><p>/**<br>_fun：实现动态数组<br>_/<br>@SuppressWarnings(“unchecked”)<br>public class ArrayList<E> extends AbstractList<E> {<br>private E[] elements;</p><pre><code>private static final int DEFAULT_CAPACITY = 10;public ArrayList(int capaticy) &#123;    capaticy = (capaticy &lt; DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capaticy;    elements = (E[]) new Object[capaticy];&#125;public ArrayList() &#123;    this(DEFAULT_CAPACITY);&#125;@Overridepublic void clear() &#123;    for (int i = 0; i &lt; size; i++) &#123;        elements[i] = null;    &#125;    size = 0;&#125;@Overridepublic E get(int index) &#123;    rangeCheck(index);    return elements[index];&#125;@Overridepublic E set(int index, E element) &#123;    rangeCheck(index);    E old = elements[index];    elements[index] = element;    return old;&#125;@Overridepublic void add(int index, E element) &#123;    rangeCheckForAdd(index);    ensureCapacity(size + 1);    for (int i = size; i &gt; index; i--) &#123;        elements[i] = elements[i - 1];    &#125;    elements[index] = element;    size++;&#125;@Overridepublic E remove(int index) &#123;    rangeCheck(index);    E old = elements[index];    for (int i = index + 1; i &lt; size; i++) &#123;        elements[i - 1] = elements[i];    &#125;    elements[--size] = null;    return old;&#125;@Overridepublic int indexOf(E element) &#123;    if (element == null) &#123;  // 1        for (int i = 0; i &lt; size; i++) &#123;            if (elements[i] == null) return i;        &#125;    &#125; else &#123;        for (int i = 0; i &lt; size; i++) &#123;            if (element.equals(elements[i])) return i; // n        &#125;    &#125;    return ELEMENT_NOT_FOUND;&#125;/** * 保证要有capacity的容量 * @param capacity */private void ensureCapacity(int capacity) &#123;    int oldCapacity = elements.length;    if (oldCapacity &gt;= capacity) return;    // 新容量为旧容量的1.5倍    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    E[] newElements = (E[]) new Object[newCapacity];    for (int i = 0; i &lt; size; i++) &#123;        newElements[i] = elements[i];    &#125;    elements = newElements;    System.out.println(oldCapacity + &quot;扩容为&quot; + newCapacity);&#125;@Overridepublic String toString() &#123;    // size=3, [99, 88, 77]    StringBuilder string = new StringBuilder();    string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);    for (int i = 0; i &lt; size; i++) &#123;        if (i != 0) &#123;            string.append(&quot;, &quot;);        &#125;        string.append(elements[i]);    &#125;    string.append(&quot;]&quot;);    return string.toString();&#125;/** * 新添加功能 */public int search(E element)&#123;    for (int i = 0;i&lt;size;i++)&#123;        if (element == elements[i])&#123;            return i;        &#125;    &#125;    return ELEMENT_NOT_FOUND;&#125;</code></pre><p>}</p><p></pre><p id="eef65beb7cc29a45fc39ce651b8ed461" class="ne-p"><br></p><h3 id="DCY67"><span class="ne-text">LinkedList设计</span></h3><pre data-language="java" id="mtOUT" class="ne-codeblock language-java">package com.wztlink1013.ds.linkedlist;</p><p>/**<br>_fun：链表的实现<br>_/<br>@SuppressWarnings(“unchecked”)<br>public class LinkedList<E> extends AbstractList<E> {<br>private Node<E> first;<br>private Node<E> last;</p><pre><code>private static class Node&lt;E&gt; &#123;    E element;    Node&lt;E&gt; prev;    Node&lt;E&gt; next;    public Node(E element, Node&lt;E&gt; next) &#123;        this.element = element;        this.next = next;    &#125;&#125;@Overridepublic void clear() &#123;    size = 0;    first = null;    last = null;&#125;@Overridepublic E get(int index) &#123;    return node(index).element;&#125;@Overridepublic E set(int index, E element) &#123;    Node&lt;E&gt; node = node(index);    E old = node.element;    node.element = element;    return old;&#125;@Overridepublic void add(int index, E element) &#123;    if (index == 0)&#123;        first = new Node&lt;&gt;(element, first);    &#125; else &#123;        Node&lt;E&gt; prev = node(index - 1);        prev.next = new Node&lt;&gt;(element, prev.next);    &#125;    size++;&#125;@Overridepublic E remove(int index) &#123;</code></pre><p>// Node<E> node = first;<br>// if (index == 0) {<br>// first = first.next;<br>// } else {<br>// Node<E> prev = node(index -1);<br>// node = prev.next;<br>// prev.next = node.next;<br>// }<br>rangeCheck(index);</p><pre><code>    Node&lt;E&gt; node = node(index);    Node&lt;E&gt; prev = node.prev;    Node&lt;E&gt; next = node.next;    if (prev == null) &#123; // index == 0        first = next;    &#125; else &#123;        prev.next = next;    &#125;    if (next == null) &#123; // index == size - 1        last = prev;    &#125; else &#123;        next.prev = prev;    &#125;    size--;    return node.element;&#125;@Overridepublic int indexOf(E element) &#123;    if (element == null) &#123;        Node&lt;E&gt; node = first;        for (int i = 0; i &lt; size; i++) &#123;            if (node.element == null) return i;            node = node.next;        &#125;    &#125; else &#123;        Node&lt;E&gt; node = first;        for (int i = 0; i &lt; size; i++) &#123;            if (element.equals(node.element)) return i;            node = node.next;        &#125;    &#125;    return ELEMENT_NOT_FOUND;&#125;/** * 获取index位置对应的节点对象 * @param index * @return */private Node&lt;E&gt; node(int index) &#123;    rangeCheck(index);    if (index &lt; (size &gt;&gt; 1)) &#123;        Node&lt;E&gt; node = first;        for (int i = 0; i &lt; index; i++) &#123;            node = node.next;        &#125;        return node;    &#125; else &#123;        Node&lt;E&gt; node = last;        for (int i = size - 1; i &gt; index; i--) &#123;            node = node.prev;        &#125;        return node;    &#125;&#125;@Overridepublic String toString() &#123;    StringBuilder string = new StringBuilder();    string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);    Node&lt;E&gt; node = first;    for (int i = 0; i &lt; size; i++) &#123;        if (i != 0) &#123;            string.append(&quot;, &quot;);        &#125;        string.append(node);        node = node.next;    &#125;    string.append(&quot;]&quot;);    return string.toString();&#125;</code></pre><p>}</pre><h2 id="mAZyd"></h2></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA配置Tomcat</title>
      <link href="/blog/fgh5bc/"/>
      <url>/blog/fgh5bc/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="iLgZj"><span class="ne-text">一、Tomcat的下载</span></h2><p id="7a017bd8e8e57ed7be8af467a3d07a18" class="ne-p"><br></p><h3 id="7730a6e8"><span class="ne-text">正常下载并安装</span></h3><div class="ne-quote"><p id="37d154ed957326ba548647ad42228a35" class="ne-p"><span class="ne-text">！！！在此之前默认读者下载且配置好了jdk环境</span></p></div><p id="15ceaa3f3b21e4713261d096377b5934" class="ne-p"><br></p><ul class="ne-ul"><li id="372f8734116240546215c7df0d9eacfd" style="text-align: center"><span class="ne-text">进入该官网</span><a href="https://imgconvert.csdnimg.cn/aHR0cDovL3RvbWNhdC5hcGFjaGUub3JnLw?x-oss-process=image/format,png" data-href="https://imgconvert.csdnimg.cn/aHR0cDovL3RvbWNhdC5hcGFjaGUub3JnLw?x-oss-process=image/format,png" target="_blank" class="ne-link"><span class="ne-text">下载页面</span></a><span class="ne-text"><p></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914511-a035ba93-0b7a-450b-b391-5d1452435ca7.png" width="461" id="f42cV" class="ne-image"></li><li id="55cfb4a6606ba8f6b0a73fcc56f5c98d" style="text-align: center"><span class="ne-text">下载并解压到自己的相应盘区，再进入下图文件夹检验是否成功<br></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914448-2ef2e1a1-2966-4d35-8bfe-82162aa1588b.png" width="431" id="vyTkc" class="ne-image"></li><li id="c3ea57144edfc0f341cfe8df78cd3800" style="text-align: center"><span class="ne-text">点击第二个框不出现闪退情况则证明成功<br></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914507-87063aec-884a-4180-b124-568478d81bc0.png" width="425" id="rgrop" class="ne-image"></li><li id="0ad6bc125416a42078cb0cb477710091" style="text-align: center"><span class="ne-text">浏览器进入端口</span><a href="http://localhost:8080/" data-href="http://localhost:8080/" target="_blank" class="ne-link"><span class="ne-text">http://localhost:8080/</span></a><span class="ne-text">上述配置成功则表明成功<br></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914624-248148e3-3f5f-45ca-ad93-c063216a7aff.png" width="429" id="N7Pg6" class="ne-image"></li></ul><p id="ba972926e91f7f3b2b7564248dc1d242" class="ne-p"><br></p><h3 id="7ae41c7b"><span class="ne-text">过程中可能会出现的问题</span></h3><p id="b6e60141a96a1c1634bce1c1ff9592ee" class="ne-p"><br></p><ul class="ne-ul"><li id="a7e7087f9b895988e7e3a9ed0d1f5f5b"><span class="ne-text">点击 startup.bat 文件出现闪退<br></span><span class="ne-text">电脑中 java jdk 有无（JAVA_HOME）</span></li><li id="5f157a19d26ef621428854de8c6cf303"><span class="ne-text">端口被占用<br></span><span class="ne-text">进入 Tomcat 文件夹下的 conf 文件下的 server.xml 文件，用记事本查找 8080，下面复制一个新的初始端口<br></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914513-8083bc6e-4c6f-436e-b0b0-98d3d70b9dea.png" width="557" id="Z1QuJ" class="ne-image"></li></ul><p id="1f1a86b0108f014bb2e9e3214fe382c7" class="ne-p"><br></p><h2 id="87228d3a"><span class="ne-text">二、IDEA 配置 Tomcat</span></h2><p id="68e90f88b89a55ffd97870ade37c6d8b" class="ne-p"><br></p><h3 id="224e2ccd"><span class="ne-text">配置</span></h3><p id="1ae705a5c75e9821bdad0220bcf24c69" class="ne-p"><br></p><ul class="ne-ul"><li id="4306f37ec643ec27c61edd7104c1f9e6"><span class="ne-text">新建一个项目<br></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914503-6a4bf3f9-0e92-4bd3-bcde-e65af73510b8.png" width="1457" id="SyJXG" class="ne-image"></li><li id="39cefd027174599aebe9a86e1e89ae75"><span class="ne-text">编写 head/body 待会测试用<br></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914719-36f4cef3-db7c-4bd9-a43a-5c92f0afead2.png" width="1842" id="FdDQj" class="ne-image"></li><li id="1eb675b1324051082529b7e54556b7a4"><span class="ne-text">相关配置<br></span><span class="ne-text">进入配置页面</span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914684-a3f47ea5-50df-450f-935d-f9ec086bc2cb.png" width="1842" id="e3y51" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914511-d1b72498-32cb-4868-8758-34fb3de3e798.png" width="1343" id="W5tPZ" class="ne-image"><span class="ne-text"><br></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914585-5e3362d9-db50-4bdb-8640-f3a2f630bbbf.png" width="1343" id="mQrTR" class="ne-image"></li></ul><p id="65be47269fa48a821e6b44f572f9ec99" class="ne-p"><br></p><h3 id="9c484867"><span class="ne-text">运行测试</span></h3><p id="051dc1bc2615045f6ff8356943d3488b" class="ne-p"><br></p><p id="0926fcb9fe467ded67acdf5d3f1537b8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914608-c71c5263-ae91-472f-b760-cc3fbd78b81c.png" width="1842" id="hHket" class="ne-image"></p><p id="fca4efa535dada10c3d2838d542abdff" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914608-14ca2925-9dd2-4cfd-9399-597c08094743.png" width="1836" id="L3XOo" class="ne-image"></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对谷歌BERT模型的思考</title>
      <link href="/blog/mssoff/"/>
      <url>/blog/mssoff/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B1%2C0%2C0%2C0%5D%2C%5B1%2C0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h2 data-lake-id="QmMzl" id="QmMzl" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;"><span>why？</span></h2><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="ec3bb7405bd7550ef75e1f43c383194c" id="ec3bb7405bd7550ef75e1f43c383194c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>BERT 可以用来干什么？</span></p></blockquote><p data-lake-id="23fbdb616f0d31557fc0272925a08c03" id="23fbdb616f0d31557fc0272925a08c03" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c82cd921db9953498d69a5ebfed46291" id="c82cd921db9953498d69a5ebfed46291" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>处理这种非结构化的数据以及之前学习到的情感分析</span></p><p data-lake-id="552845ea0ca3ed757de48705c950835a" id="552845ea0ca3ed757de48705c950835a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ede620a9eeba128e8744d65d197be635" id="ede620a9eeba128e8744d65d197be635" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>BERT 可以用于问答系统，情感分析，垃圾邮件过滤，命名实体识别，文档聚类等任务中，作为这些任务的基础设施即语言模型，</span></p><p data-lake-id="e764cf4f661a88ce43217a7f9e73c915" id="e764cf4f661a88ce43217a7f9e73c915" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="SoIfy" id="SoIfy" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;"><span>what？</span></h2><p data-lake-id="750137749eeb8445f5a750d2e948f4fc" id="750137749eeb8445f5a750d2e948f4fc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>是一个自然语言处理模型</span></p><p data-lake-id="14e39690420b1775312001f022312241" id="14e39690420b1775312001f022312241" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>提出了“训练词向量”概念，这是独特之处</span></p><p data-lake-id="fb23f27ed98d0439bfc1a3c65991a3af" id="fb23f27ed98d0439bfc1a3c65991a3af" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="196aef9c54ed8b55a864d421c3affea0" id="196aef9c54ed8b55a864d421c3affea0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>BERT 利用了 Transformer 的 encoder 部分。</span></strong></p><p data-lake-id="86fd545c660e9a6889a7dfefa31e1a63" id="86fd545c660e9a6889a7dfefa31e1a63" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>BERT 的创新点在于它将双向 Transformer 用于语言模型，</span></strong></p><p data-lake-id="befa81a632ce3c61445c15128fa41d50" id="befa81a632ce3c61445c15128fa41d50" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>之前的模型是从左向右输入一个文本序列，或者将 left-to-right 和 right-to-left 的训练结合起来。实验的结果表明，双向训练的语言模型对语境的理解会比单向的语言模型更深刻，Transformer 是一种注意力机制，可以学习文本中单词之间的上下文关系的。Transformer 的原型包括两个独立的机制，一个 encoder 负责接收文本作为输入，一个 decoder 负责预测任务的结果。BERT 的目标是生成语言模型，所以只需要 encoder 机制。Transformer 的 encoder 是一次性读取整个文本序列，而不是从左到右或从右到左地按顺序读取，这个特征使得模型能够基于单词的两侧学习，相当于是一个双向的功能。 Transformer 的 encoder 部分，输入是一个 token 序列，先对其进行 embedding 称为向量，然后输入给神经网络，输出是大小为 H 的向量序列，每个向量对应着具有相同索引的 token。当我们在训练语言模型时，有一个挑战就是要定义一个预测目标，很多模型在一个序列中预测下一个单词，“The child came home from ___”双向的方法在这样的任务中是有限制的，为了克服这个问题，BERT 使用两个策略:</span></p><h3 data-lake-id="PGVlb" id="PGVlb" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;"><span>Masked LM (MLM)</span></h3><p data-lake-id="0ee04d459d5b3c3dc4fa2a6c770cd12a" id="0ee04d459d5b3c3dc4fa2a6c770cd12a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>论文中介绍了一种新技术叫做 Masked LM（MLM），在这个技术出现之前是无法进行双向语言模型训练的。在将单词序列输入给 BERT 之前，每个序列中有 15％ 的单词被 [MASK] token 替换。 然后模型尝试基于序列中其他未被 mask 的单词的上下文来预测被掩盖的原单词。</span></p><p data-lake-id="59ad2945651a517229be802fad20586f" id="59ad2945651a517229be802fad20586f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="5e11775ccadeae7fe2e76420dcbfdea1" id="5e11775ccadeae7fe2e76420dcbfdea1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这样就需要：</span></p><ul class="lake-list" data-lake-id="8c7ed3a6330fd908d0f1f447da832f18_ul_0" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="1d7c69f17e4e3d51480cc39c25489780" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>在 encoder 的输出上添加一个分类层</span></li><li data-lake-id="29e80f48b8b6677bcfc9cd1e6ab76069" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>用嵌入矩阵乘以输出向量，将其转换为词汇的维度</span></li><li data-lake-id="852de69aa7e6fc0ef176ef97941b4c14" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>用 softmax 计算词汇表中每个单词的概率</span></li></ul><p data-lake-id="e7423df12dc3f78076db3b90884ce5a6" id="e7423df12dc3f78076db3b90884ce5a6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="6bf72040d7b344f5b61fa736b4457dfc" id="6bf72040d7b344f5b61fa736b4457dfc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>BERT 的损失函数只考虑了 mask 的预测值，忽略了没有掩蔽的字的预测。这样的话，模型要比单向模型收敛得慢，不过结果的情境意识增加了。</span></p><p data-lake-id="615fc7a3da7d7b28434e75a86a6feed3" id="615fc7a3da7d7b28434e75a86a6feed3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="04c8c4500374f0fe342ab27acfa02378" id="04c8c4500374f0fe342ab27acfa02378" style="text-align: left; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>eg：my dog is hairy</span></strong></p><ul data-lake-id="09f4cf3a75546f17ed3a193a946d3c40_ul_1" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="496115badd4393942914d31debfb699e"><span>有80%的概率用“[mask]”标记来替换——my dog is [MASK]</span></li><li data-lake-id="349a2c6494ddbcca7de20b70ebe7b826"><span>有10%的概率用随机采样的一个单词来替换——my dog is apple</span></li><li data-lake-id="f6a32b7016ecd937ba3851dc4e477ee8"><span>有10%的概率不做替换——my dog is hairy</span></li></ul><h3 data-lake-id="89DVm" id="89DVm" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;"><span>Next Sentence Prediction (NSP)</span></h3><p data-lake-id="75e65e079964114273708a308f723c12" id="75e65e079964114273708a308f723c12" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>在 BERT 的训练过程中，模型接收成对的句子作为输入，并且预测其中第二个句子是否在原始文档中也是后续句子。在训练期间，50％ 的输入对在原始文档中是前后关系，另外 50％ 中是从语料库中随机组成的，并且是与第一句断开的。为了帮助模型区分开训练中的两个句子，输入在进入模型之前要按以下方式进行处理：</span></p><p data-lake-id="33027e6a488dc7c4a68d923794c2f552" id="33027e6a488dc7c4a68d923794c2f552" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><ul class="lake-list" data-lake-id="6d0a401c8bb2d48b070cce9f584db5c9_ul_2" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="540700a6986c2c94c03c58d4f1d6ee73" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>在第一个句子的开头插入 [CLS] 标记，在每个句子的末尾插入 [SEP] 标记。</span></li><li data-lake-id="bd720e6295fc2ea40133ee1c0bf0d8c9" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>将表示句子 A 或句子 B 的一个句子 embedding 添加到每个 token 上。</span></li><li data-lake-id="d41c0a90ff6a24f0751e06eaf0b76f12" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>给每个 token 添加一个位置 embedding，来表示它在序列中的位置。</span></li><li data-lake-id="17c3fc6224d25dbbce673c8eb4af22c7" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>为了预测第二个句子是否是第一个句子的后续句子，用下面几个步骤来预测：</span></li><li data-lake-id="f2f91655eda5e3968c23da52d4185e45" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>整个输入序列输入给 Transformer 模型</span></li><li data-lake-id="bb780f1f3ebc46947923155094495131" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>用一个简单的分类层将 [CLS] 标记的输出变换为 2×1 形状的向量</span></li><li data-lake-id="3d20f16be54396b5896fd49c755d7ac7" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>用 softmax 计算 IsNextSequence 的概率</span></li></ul><p data-lake-id="b89a08c9e01239cdf586fae257b063ed" id="b89a08c9e01239cdf586fae257b063ed" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="22124aeac3683100b16b15985885efd9" id="22124aeac3683100b16b15985885efd9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>在训练 BERT 模型时，Masked LM 和 Next Sentence Prediction 是一起训练的，目标就是要最小化两种策略的组合损失函数。</span></p><h2 data-lake-id="EkXye" id="EkXye" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;"><span>how？</span></h2><p data-lake-id="79f6188d4282c40c16ed6aff02fadf39" id="79f6188d4282c40c16ed6aff02fadf39" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>BERT 可以用于各种NLP任务，只需在核心模型中添加一个层.</span></p><p data-lake-id="26b59c6f69d7ee7d2df66f86de875eff" id="26b59c6f69d7ee7d2df66f86de875eff" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>例如：</span></p><ul class="lake-list" data-lake-id="6accca962a7aedb3ce49c489ef714cfd_ul_3" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="0e6fe1a94b8968aff7e52ed6f92a7f3a" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>在分类任务中，例如情感分析等，只需要在 Transformer 的输出之上加一个分类层</span></li><li data-lake-id="d08b109a55e20e3bcb68ef55f591e4e3" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>在问答任务（例如SQUAD v1.1）中，问答系统需要接收有关文本序列的 question，并且需要在序列中标记 answer。 可以使用 BERT 学习两个标记 answer 开始和结尾的向量来训练Q＆A模型。</span></li><li data-lake-id="385d7efda04fdaacc41cbd46c063b79c" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>在命名实体识别（NER）中，系统需要接收文本序列，标记文本中的各种类型的实体（人员，组织，日期等）。 可以用 BERT 将每个 token 的输出向量送到预测 NER 标签的分类层。</span></li></ul><p data-lake-id="834b34a0a59600348c97c2712968d078" id="834b34a0a59600348c97c2712968d078" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="83250b8e71dd4b733e4b46c63f63a637" id="83250b8e71dd4b733e4b46c63f63a637" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]银行家算法</title>
      <link href="/blog/kc645t/"/>
      <url>/blog/kc645t/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="V9yxn"><span class="ne-text">一、银行家算法</span></h2><p id="1cdb67fe575acdd8dff6bdb9071e29c8" class="ne-p"><strong><span class="ne-text">功能：避免死锁</span></strong></p><div class="ne-quote"><p id="eb42c5817ebe3f45a7934aff9cf5e8ef" class="ne-p"><span class="ne-text">在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。</span></p></div><p id="u788edfa5" class="ne-p"><span class="ne-text"></span></p><h2 id="ji5xK"><span class="ne-text">二、代码实现</span></h2><pre data-language="cpp" id="NAIsL" class="ne-codeblock language-cpp">#include <iostream><p>using namespace std;<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br>/_ 定义全局变量 <em>/<br>const int x = 50, y = 50; /</em> x 为进程个数 y 为资源种类数 <em>/<br>int Available[y]; /</em> 各资源可利用的数量 <em>/<br>int Allocation[x][y]; /</em> 各进程当前已分配的资源数量 <em>/<br>int Max[x][y]; /</em> 各进程对各类资源的最大需求数 <em>/<br>int Need[x][y]; /</em> 尚需多少资源 <em>/<br>int Request[y]; /</em> 申请多少资源 <em>/<br>int Work[y]; /</em> 工作向量，表示系统可提供给进程继续运行所需的各类资源数量 <em>/<br>int Finish[x]; /</em> 表示系统是否有足够的资源分配给进程，1 为是 <em>/<br>int p[x]; /</em> 存储安全序列 <em>/<br>int i, j; /</em> i 表示进程，j 表示资源 <em>/<br>int n, m; /</em> n 为进程 i 的数量,m 为资源 j 种类数 <em>/<br>int l = 0; /</em> l 用来记录有几个进程是 Finish[i]=1 的，当 l=n 是说明系统状态是安全的 <em>/<br>int counter = 0; /</em> 记数器,记录可执行的进程数 <em>/<br>/</em> 函数声明 <em>/<br>void chushihua(); /</em> 初始化函数 _/</p><p>void safe(); /_ 安全性算法 _/</p><p>void show(); /_ 函数 show,输出当前状态 _/</p><p>void bank(); /_ 银行家算法 _/</p><p>void jieshu(); /_ 结束函数 _/</p><p>void chushihua()<br>{<br>cout &lt;&lt; “输入进程的数量: “; /_ 从此开始输入有关数据 <em>/<br>cin &gt;&gt; n;<br>cout &lt;&lt; “输入资源种类数: “;<br>cin &gt;&gt; m;<br>cout &lt;&lt; endl &lt;&lt; “输入各种资源当前可用的数量( “ &lt;&lt; m &lt;&lt; “ 种): “ &lt;&lt; endl;<br>for ( j = 0; j &lt; m; j++ ) /_ m 为资源数 _/<br>{<br>cout &lt;&lt; “输入资源 “ &lt;&lt; j &lt;&lt; “ 可利用的数量 Available[“ &lt;&lt; j &lt;&lt; “]: “;<br>cin &gt;&gt; Available[j]; /</em> 输入数字的过程 <em>/<br>Work[j] = Available[j]; /</em> 初始化 Work[j]，它的初始值就是当前可用的资源数 <em>/<br>}<br>cout &lt;&lt; endl &lt;&lt; “输入各进程当前已分配的资源数量 Allocation[“ &lt;&lt; n &lt;&lt; “][“ &lt;&lt; m &lt;&lt; “]: “ &lt;&lt; endl;<br>for ( i = 0; i &lt; n; i++ ) /_ n 为进程数 _/<br>{<br>for ( j = 0; j &lt; m; j++ ) /_ m 为资源数 _/<br>{<br>cout &lt;&lt; “ 输入进程 “ &lt;&lt; i &lt;&lt; “ 当前已分配的资源 “ &lt;&lt; j &lt;&lt; “ 数量: “;<br>cin &gt;&gt; Allocation[i][j];<br>}<br>cout &lt;&lt; endl;<br>Finish[i] = 0; /_ 初始化 Finish[i] _/<br>}<br>cout &lt;&lt; endl &lt;&lt; “输入各进程对各类资源的最大需求 Max[“ &lt;&lt; n &lt;&lt; “][“ &lt;&lt; m &lt;&lt; “]: “ &lt;&lt; endl;<br>for ( i = 0; i &lt; n; i++ ) /_ n 为进程数 _/<br>{<br>for ( j = 0; j &lt; m; j++ ) /_ m 为资源数 _/<br>{<br>cout &lt;&lt; “ 输入进程 “ &lt;&lt; i &lt;&lt; “ 对资源 “ &lt;&lt; j &lt;&lt; “ 的最大需求数: “;<br>cin &gt;&gt; Max[i][j];<br>if ( Max[i][j] &gt;= Allocation[i][j] ) /</em> 若最大需求大于已分配，则计算需求量 <em>/<br>Need[i][j] = Max[i][j] - Allocation[i][j];<br>else<br>Need[i][j] = 0; /</em> Max 小于已分配的时候，此类资源已足够不需再申请 _/<br>}<br>cout &lt;&lt; endl;<br>}<br>cout &lt;&lt; endl &lt;&lt; “初始化完成” &lt;&lt; endl;<br>}</p><p>/_ 安全性算法函数 <em>/<br>void safe()<br>{<br>l = 0; /</em> l 用来记录有几个进程是 Finish[i]=1 的，当 l=n 是说明系统状态是安全的 <em>/<br>for ( i = 0; i &lt; n; i++ ) /_ n 为进程数 _/<br>{<br>if ( Finish[i] == 0 )<br>{ /_ 逐个查找 Finish[i]==0 的进程 条件一 _/<br>counter = 0; /_ 记数器,记录有多少个进程已经执行 _/<br>for ( j = 0; j &lt; m; j++ ) /_ m 为资源数 _/<br>{<br>if ( Work[j] &gt;= Need[i][j] )<br>counter = counter + 1; /</em> 可用大于需求，记数，该进程可以执行 <em>/<br>}<br>if ( counter == m ) /</em> i 进程的每类资源都符合 Work[j]&gt;=Need[i][j] 条件二 <em>/<br>{<br>p[l] = i; /</em> 存储安全序列 <em>/<br>Finish[i] = 1; /</em> i 进程标志为可分配 <em>/<br>for ( j = 0; j &lt; m; j++ )<br>Work[j] = Work[j] + Allocation[i][j]; /</em> 释放资源 <em>/<br>l = l + 1; /</em> 记数,现在有 l 个进程是安全的，当 l=n 时说明满足安全序列 <em>/<br>i = -1; /</em> 从第一个进程开始继续寻找满足条件一二的进程 _/<br>}<br>}<br>}<br>}</p><p>/_ 显示当前状态函数 <em>/<br>void show() /</em> 函数 show,输出当前资源分配情况 <em>/<br>{<br>int i, j; /</em> 局部变量，i 表示进程，j 表示资源 <em>/<br>int All[y]; /</em> 各种资源的总数量 <em>/<br>int L1; /</em> 局部变量 L1 <em>/<br>cout &lt;&lt; “当前的状态为：” &lt;&lt; endl;<br>cout &lt;&lt; “各种资源的总数量:” &lt;&lt; endl;<br>for ( j = 0; j &lt; m; j++ ) /</em> m 为资源数 <em>/<br>{<br>cout &lt;&lt; “ 资源” &lt;&lt; j &lt;&lt; “: “;<br>All[j] = Available[j]; /</em> 总数量=可用的+已分配的 <em>/<br>for ( i = 0; i &lt; n; i++ ) /</em> n 为进程数 <em>/<br>All[j] += Allocation[i][j];<br>cout &lt;&lt; All[j] &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl &lt;&lt; “当前各种资源可用的量为(available):” &lt;&lt; endl;<br>for ( j = 0; j &lt; m; j++ ) /</em> m 为资源数 <em>/<br>cout &lt;&lt; “ 资源” &lt;&lt; j &lt;&lt; “: “ &lt;&lt; Available[j] &lt;&lt; “ “;<br>cout &lt;&lt; endl &lt;&lt; “各进程所需的最大资源量(Max): “ &lt;&lt; endl;<br>for ( i = 0; i &lt; m; i++ ) /</em> m 为资源数 <em>/<br>{<br>cout &lt;&lt; “ 资源” &lt;&lt; i &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl;<br>for ( L1 = 0; L1 &lt; n; L1++ ) /</em> n 为进程数 <em>/<br>{<br>cout &lt;&lt; “进程” &lt;&lt; L1 &lt;&lt; “: “;<br>for ( j = 0; j &lt; m; j++ )<br>cout &lt;&lt; Max[L1][j] &lt;&lt; “ “;<br>cout &lt;&lt; endl;<br>}<br>cout &lt;&lt; endl &lt;&lt; “各进程已经得到的资源量(allocation): “ &lt;&lt; endl;<br>for ( i = 0; i &lt; m; i++ ) /</em> m 为资源数 <em>/<br>{<br>cout &lt;&lt; “ 资源” &lt;&lt; i &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl;<br>for ( L1 = 0; L1 &lt; n; L1++ ) /</em> n 为进程数 <em>/<br>{<br>cout &lt;&lt; “进程” &lt;&lt; L1 &lt;&lt; “: “;<br>for ( j = 0; j &lt; m; j++ )<br>cout &lt;&lt; Allocation[L1][j] &lt;&lt; “ “;<br>cout &lt;&lt; endl;<br>}<br>cout &lt;&lt; endl &lt;&lt; “各进程还需要的资源量(need):” &lt;&lt; endl;<br>for ( i = 0; i &lt; m; i++ ) /</em> m 为资源数 _/<br>{<br>cout &lt;&lt; “ 资源” &lt;&lt; i &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl;<br>for ( L1 = 0; L1 &lt; n; L1++ )<br>{<br>cout &lt;&lt; “进程” &lt;&lt; L1 &lt;&lt; “: “;<br>for ( j = 0; j &lt; m; j++ )<br>cout &lt;&lt; Need[L1][j] &lt;&lt; “ “;<br>cout &lt;&lt; endl;<br>}<br>}</p><p>/_ 银行家算法函数 <em>/<br>void bank()<br>{<br>cout &lt;&lt; endl &lt;&lt; “进程申请分配资源：” &lt;&lt; endl;<br>int k = 0; /_ 用于输入进程编号 _/<br>bool r = false; /_ 初值为假，输入 Y 继续申请则置为真 _/<br>do /_ 输入请求 _/<br>{<br>cout &lt;&lt; “输入申请资源的进程(0-“ &lt;&lt; n - 1 &lt;&lt; “): “;<br>cin &gt;&gt; k; /</em> 进程编号 <em>/<br>cout &lt;&lt; endl;<br>while ( k &gt; n - 1 ) /</em> 输入错误处理 <em>/<br>{<br>cout &lt;&lt; endl &lt;&lt; “无该进程号，重新输入：” &lt;&lt; endl;<br>cout &lt;&lt; endl &lt;&lt; “输入申请资源的进程(0–” &lt;&lt; n - 1 &lt;&lt; “): “;<br>cin &gt;&gt; k; /</em> 进程编号 <em>/<br>cout &lt;&lt; endl;<br>}<br>cout &lt;&lt; endl &lt;&lt; “输入该进程申请各类资源的数量: “ &lt;&lt; endl;<br>for ( j = 0; j &lt; m; j++ ) /_ m 为资源数 _/<br>{<br>do /_ do……while 循环判断申请输入的情况 _/<br>{<br>cout &lt;&lt; “进程 “ &lt;&lt; k &lt;&lt; “ 申请资源[“ &lt;&lt; j &lt;&lt; “]的数量:”;<br>cin &gt;&gt; Request[j]; /</em> 输入请求进程数 <em>/<br>cout &lt;&lt; endl;<br>if ( Request[j] &gt; Need[k][j] ) /</em> 申请大于需求量时出错，提示重新输入 cout&lt;&lt;”申请量大于需要量!”&lt;&lt;endl; <em>/<br>{<br>cout &lt;&lt; “申请的资源” &lt;&lt; j &lt;&lt; “的数量为” &lt;&lt; Request[j] &lt;&lt; “,大于进程” &lt;&lt; k &lt;&lt; “对该资源需求量” &lt;&lt; Need[k][j] &lt;&lt; “。” &lt;&lt; endl;<br>cout &lt;&lt; “重新输入!” &lt;&lt; endl;<br>}<br>/_ 先判断是否申请大于需求量，再判断是否申请大于可利用量 _/<br>else if ( Request[j] &gt; Available[j] ) /</em> 申请大于可利用量， 应该阻塞等待 <em>/<br>{<br>cout &lt;&lt; “\n 没有那么多资源，目前可利用资源” &lt;&lt; j &lt;&lt; “数量为” &lt;&lt; Available[j] &lt;&lt; “,本次申请不成功，进程等待!” &lt;&lt; endl;<br>Finish[k] = 0; /_ 该进程等待 _/<br>goto error; /_ goto 语句跳转，结束本次申请 _/<br>}<br>}<br>while ( Request[j] &gt; Need[k][j] ); /</em> Request[j]&gt;Available[j] <em>/<br>}<br>/</em> 改变 Available、Allocation、Need 的值 _/<br>for ( j = 0; j &lt; m; j++ ) /_ m 为资源数 _/<br>{<br>Available[j] = Available[j] - Request[j]; /_ 可用的资源数=可用的资源数-请求分配的资源数 _/<br>Allocation[k][j] = Allocation[k][j] + Request[j]; /_ 已分配的资源数=已分配的资源数+请求的资源数 _/<br>Need[k][j] = Need[k][j] - Request[j]; /_ 还需要的资源数=还需要的资源数-请求的资源数 _/<br>Work[j] = Available[j];<br>}<br>safe(); /_ 调用安全性算法函数，判断当前状态的安全性 _/<br>if ( l &lt; n ) /_ l 用来记录有几个进程是 Finish[i]=1 的，当 l=n 是说明系统状态是安全的 _/<br>{<br>l = 0;<br>cout &lt;&lt; “\n 试分配后,状态不安全,所以不予分配!恢复原状态” &lt;&lt; endl;<br>/_ 恢复数据 _/<br>for ( j = 0; j &lt; m; j++ ) /_ m 为资源数 _/<br>{<br>Available[j] = Available[j] + Request[j];<br>Allocation[k][j] = Allocation[k][j] - Request[j];<br>Need[k][j] = Need[k][j] + Request[j];<br>Work[j] = Available[j];<br>}<br>for ( i = 0; i &lt; n; i++ ) /_ n 为进程数 _/<br>Finish[i] = 0; /_ 进程均置为未分配状态 _/<br>}else { /_ l=n，即所有的 Finish[i]=1,每一个进程均能执行 _/<br>l = 0; /_ 判断标志 _/<br>cout &lt;&lt; “\n 申请资源成功!!!” &lt;&lt; endl;<br>for ( j = 0; j &lt; m; j++ ) /_ m 为资源数 _/<br>{<br>if ( Need[k][j] == 0 )<br>;<br>else { /_有一种资源还没全部申请到，则该进程不可执行，不能释放拥有的资源 _/<br>l = 1; /_ 置 l 为 1，作为判断标志 _/<br>break;<br>}<br>}<br>if ( l != 1 ) /_ 进程可以执行，则释放该进程的所有资源 _/<br>{<br>for ( j = 0; j &lt; m; j++ ) /_ m 为资源数 _/<br>{<br>Available[j] = Available[j] + Allocation[k][j];<br>Allocation[k][j] = 0;<br>}<br>cout &lt;&lt; “该进程已得到所有需求资源，执行后将释放其所有拥有资源！” &lt;&lt; endl;<br>}<br>l = 0; /_ 归零 _/<br>cout &lt;&lt; “\n 安全的状态!” &lt;&lt; endl;<br>cout &lt;&lt; “安全序列为: “;<br>cout &lt;&lt; endl &lt;&lt; “进程” &lt;&lt; “(“ &lt;&lt; p[0] &lt;&lt; “)”; /_ 输出安全序列，考虑显示格式，先输出第一个 _/<br>Finish[0] = 0;<br>for ( i = 1; i &lt; n; i++ )<br>{<br>cout &lt;&lt; “==&gt;&gt;” &lt;&lt; “进程” &lt;&lt; “(“ &lt;&lt; p[i] &lt;&lt; “)”;<br>Finish[i] = 0; /_ 所有进程置为未分配状态 _/<br>}<br>cout &lt;&lt; endl &lt;&lt; endl;<br>}<br>show(); /_ 显示当前状态 _/<br>error: /_ 申请大于可利用量， 应该阻塞等待,结束本次资源申请，GOTO 语句跳转至此 _/<br>cout &lt;&lt; endl &lt;&lt; “是否继续申请资源(y/n)或（Y/N）?”;<br>char* b = new char; /* 输入 y/n，判断是否继续申请 &lt;&lt;endl */<br>cin &gt;&gt; b;<br>cout &lt;&lt; endl;<br>cout &lt;&lt; “——————————————-“ &lt;&lt; endl &lt;&lt; endl;<br>cout &lt;&lt; endl;<br>if ( *b == ‘y’ || <em>b == ‘Y’ )<br>r = true; /</em> 继续申请 */<br>else{<br>r = false; /*不继续申请 <em>/<br>jieshu(); /</em> 调用结束函数 */<br>}<br>}<br>while ( r == true );<br>}</p><p>/_ 结束函数 _/<br>void jieshu()<br>{<br>cout &lt;&lt; endl &lt;&lt; endl;<br>cout &lt;&lt; “\t\t 演示计算完毕” &lt;&lt; endl;<br>cout &lt;&lt; endl &lt;&lt; endl;<br>}</p><p>/_ 主函数 _/<br>int main()<br>{<br>cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; “\t\t\t\t 模拟银行家算法” &lt;&lt; endl &lt;&lt; endl;<br>chushihua(); /_ 初始化函数调用 _/<br>cout &lt;&lt; endl;<br>show(); /_ 输出当前状态 _/<br>safe(); /_ 判断当前状态的安全性 _/<br>if ( l &lt; n ) /_ l 在 safe 中是用来记录安全的进程的个数的 _/<br>{<br>cout &lt;&lt; “\n 当前状态不安全，拒绝申请！” &lt;&lt; endl;<br>cout &lt;&lt; endl;<br>return(0);<br>}else {<br>int i; /_ 局部变量 _/<br>l = 0;<br>cout &lt;&lt; endl &lt;&lt; “\n 当前的状态是安全的!安全序列为:” &lt;&lt; endl;<br>cout &lt;&lt; “进程” &lt;&lt; “(“ &lt;&lt; p[0] &lt;&lt; “)”; /_ 输出安全序列 _/<br>for ( i = 1; i &lt; n; i++ )<br>cout &lt;&lt; “-&gt;&gt;” &lt;&lt; “进程” &lt;&lt; “(“ &lt;&lt; p[i] &lt;&lt; “)”;<br>for ( i = 0; i &lt; n; i++ )<br>Finish[i] = 0; /_ 所有进程置为未分配状态 _/<br>cout &lt;&lt; endl;<br>}<br>bank(); /_ 调用银行家算法函数 _/<br>cout &lt;&lt; “\t\t 演示计算完毕” &lt;&lt; endl;<br>return(0);<br>}</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 其他算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node环境+Hexo环境的搭建</title>
      <link href="/blog/yo1xhz/"/>
      <url>/blog/yo1xhz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="f060265e624c0d01ab491c2fec245665" class="ne-p"><span class="ne-text">前言：搭建node环境，在此基础上安装hexo模块以搭建个人静态网站。</span></p></div><h2 id="44703baa"><span class="ne-text">一、环境安装与配置</span></h2><h3 id="4ae46e8c"><span class="ne-text">Node的下载与安装</span></h3><ul class="ne-ul"><li id="u176f5000"><span class="ne-text">下载</span><a href="https://nodejs.org/en/" data-href="https://nodejs.org/en/" target="_blank" class="ne-link"><span class="ne-text">Node.js</span></a></li></ul><ul class="ne-ul"><li id="u847758e1"><strong><span class="ne-text">设置模块的安装路径，不然会默认在C盘，不好管理，也占系统盘存储空间</span></strong></li></ul><div class="ne-quote"><p id="u2e97cde0" class="ne-p"><span class="ne-text" style="color: #121212">nodejs 文件夹中新建两个空文件夹 node_cache、node_global</span></p></div><pre data-language="powershell" id="T8LXZ" class="ne-codeblock language-powershell">npm config set prefix "D:\nodejs\node_global"<p>npm config set cache “D:\nodejs\node_cache”</pre><p id="217386aba664ecd5edc826f36bc5811f" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624969463695-0751b555-3284-469d-9a94-d721eb6c2ff7.png" width="720" id="u454edc1a" class="ne-image"></p><ul class="ne-ul"><li id="ub5841fdb" style="text-align: left"><span class="ne-text">环境变量的配置</span></li></ul><div class="ne-quote"><p id="u4c2a9030" class="ne-p" style="text-align: left"><span class="ne-text">需要用到的路径</span></p><p id="u97a3a00c" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #121212">D:\nodejs\node_global\node_modules</span></p><p id="ucccdceb9" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #121212">D:\nodejs\node_global</span></p></div><p id="50146f55c53350f4ecec4c7f3a987355" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624969533021-b8d200d6-eb5e-44f1-8e7c-f62914d05bb2.png" width="849" id="u26c06f0e" class="ne-image"></p><h3 id="NhJgb"><span class="ne-text">安装 Hexo </span></h3><pre data-language="bash" id="MAuDX" class="ne-codeblock language-bash">npm install -g hexo-cli</pre><p id="ueada9bc9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624970023639-a627549b-bd0f-4ca6-ad98-448cda506627.png" width="720" id="u95259d87" class="ne-image"></p><div class="ne-quote"><p id="ue2925ab7" class="ne-p"><span class="ne-text">同时也可以看到全局所安装的模块在刚刚设定的路径下面</span></p></div><p id="ub21f8446" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624970066364-8a42b037-868e-4e72-9644-1ed15b81b482.png" width="269.5" id="ucbce49f7" class="ne-image"></p><h3 id="00656b27"><span class="ne-text">申请 GitHub Pages</span></h3><p id="00d5e938438121689335709c7746f95d" class="ne-p"><span class="ne-text">在 github 上申请 github pages，在账户下创建一个仓库名为 </span><code class="ne-code"><span class="ne-text">wztlink1013.github.io</span></code><span class="ne-text">的仓库，则这个仓库下的 main 分支下的前端代码就会被发布成成网页（必须要由 index.html 文件）。</span></p><div class="ne-quote"><p id="d0222dc488fe23029d35b9e9f5dc63f7" class="ne-p"><span class="ne-text">访问：</span><a href="https://wztlink1013.github.io/" data-href="https://wztlink1013.github.io/" target="_blank" class="ne-link"><span class="ne-text">https://wztlink1013.github.io</span></a></p></div><h2 id="8becaf52"><span class="ne-text">二、搭建博客</span></h2><h3 id="a5dab729"><span class="ne-text">创建并初始化文件夹</span></h3><div class="ne-quote"><p id="c3ac13c119756e60c9e926f0c12386ab" class="ne-p"><span class="ne-text">这里面所有文件就相当于所搭建博客网页所有源文件</span></p></div><p id="2326be445612db35ebd03719bcb69dc6" class="ne-p"><span class="ne-text">进入文件夹输入</span></p><pre data-language="bash" id="pZnbW" class="ne-codeblock language-bash">hexo init</pre><p id="9bf91bad5a2319fd16358cb4848911f9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616727001925-a02dabbf-4792-492e-bf5d-fed01a85eafc.png" width="947" id="WSl3w" class="ne-image"></p><p id="2d478cdf57ebf409d10d175ee41372b3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616727028761-75106936-43e9-4879-9c25-4596074efc43.png" width="947" id="omNqC" class="ne-image"></p><ul class="ne-ul"><li id="u2365d2f6"><span class="ne-text">文件夹下个文件的功能</span></li></ul><pre data-language="plain" id="a3a3afb8" class="ne-codeblock language-plain">node_modules：各种插件的安装文件夹<br>scaffolds：模板文件夹（new 的对象的模板）<br>source：资源文件夹<br>themes：主题文件夹（相当于“衣裳”）<br>_config.yml：站点配置文件<br>package.json：应用程序的信息</pre><p id="420f9776d5e40ebb3bc49dba6fa2dea7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616727087774-de9b7013-31f1-4f4b-8018-4dc47b46d075.png" width="960" id="Hho9g" class="ne-image"></p><p id="2039efb3c1ffc3646c05a8928ea57688" class="ne-p"><br></p><h3 id="c5609495"><span class="ne-text">相关命令</span></h3><pre data-language="bash" id="85b561e1" class="ne-codeblock language-bash">hexo clean #清除缓存，网页正常情况下可以忽略此条命令<br>hexo n "博客名称" # hexo new "博客名称"<br>hexo p # hexo publish<br>hexo g # hexo generate # 生成静态网页<br>hexo s # hexo server # 启动服务预览；Hexo 会监视文件变动并自动更新，无须重启服务器。<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP<br>hexo d # hexo deploy # 部署<br>hexo deploy --message "哈哈，hexo deploy --message 双引号内容就可以提交 commit 信息了"</pre><p id="5a9e07991240f620638af3d1cd022415" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C/C++遗忘知识总结</title>
      <link href="/blog/uakfgc/"/>
      <url>/blog/uakfgc/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="67e08bf60a7cfacfbb8c4052e2207871" class="ne-p"><span class="ne-text"></span></p><div data-type="info" class="ne-alert"><p id="4c7db9327d0913fd8a6a2ace42d9147b" class="ne-p"><span class="ne-text">相当于记个流水帐了~菜鸡永远没有对任何知识都会的时候</span></p></div><p id="6d7ec2fd06fbaecb8e255afc1a37f01c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1618304475795-4149058a-4d7c-49b6-8956-e22568cb4888.gif" width="218" id="qc35J" class="ne-image"></p><h2 id="51ycv"><span class="ne-text">C指针</span></h2><p id="fe0c7c9940c211b668231edb786f465d" class="ne-p"><span class="ne-text">相关概念的理解容易混淆，记住之前学习理解的一个准则！</span><code class="ne-code"><span class="ne-text">*p 的理解意义就是p 所指向的那个东西</span></code></p><ul class="ne-ul"><li id="bb3eb5d3bc35c5d6903a9a061b3e4ecd"><span class="ne-text">取地址符 </span><code class="ne-code"><span class="ne-text">&</span></code><span class="ne-text"> </span></li><li id="62f95a3a5290178ef3014814ac01e852"><span class="ne-text">解引用运算符 </span><code class="ne-code"><span class="ne-text">*</span></code><span class="ne-text"> </span></li></ul><div class="ne-quote"><p id="53738e97dc2d9cf4535fc5b1e8796bb4" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="2672231334543f9f4afce57ff5d2e4b5"><a href="https://blog.csdn.net/soonfly/article/details/51131141" data-href="https://blog.csdn.net/soonfly/article/details/51131141" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/soonfly/article/details/51131141</span></a></li></ul><p id="5fdee32c1d2d23ca527b0a0e3f03293d" class="ne-p"><span class="ne-text">* 有3个用途</span></p><p id="34ad2adec1bf20f86371daee5f520aaf" class="ne-p"><span class="ne-text">1. 乘号（Multiply）： 2*3 就是6</span></p><p id="86eed2b389d6d469bbc049cccd9c9dff" class="ne-p"><span class="ne-text">2. 声明指针（Pointer Statement）： int a =5; int* ptr=&a;就是声明变量a是5，把a的地址附到指针ptr上</span></p><p id="4a2090c015d624cddee6d8fb820093a7" class="ne-p"><span class="ne-text">3. 解引用 （Dereference）： *ptr 单独拿出来就是找出 ptr指针指向的值，按照第二点的说法就是5. </span></p><p id="8e6f31b52e16a3501484d737cdf0eff2" class="ne-p"><span class="ne-text">&叫做取地址符号</span></p><p id="e1c6edd61c6e97358be76e8037a3d20a" class="ne-p"><span class="ne-text">• 一般指针只能接受一个内存地址而不能接受一个值</span></p><p id="dd88659bafe8f78eb1df3dfbd4b2de03" class="ne-p"><span class="ne-text">• int a =5; int* ptr=a;就是错误的，指针不能接受一个值</span></p><p id="e90cb6d514707ddb743b35a622d58347" class="ne-p"><span class="ne-text">• int a =5; int* ptr=&a;才对，把a的地址给指针ptr</span></p><p id="38b65fa2d86abe387f7b5c0fe66a7f43" class="ne-p"><span class="ne-text">指针理解的话你可以这么想。</span></p><p id="5502ae354a57a74024c7b64fcc8eaabc" class="ne-p"><span class="ne-text">你问我书在哪。我说在书架第一层。</span></p><p id="4714f9a4cc8d2c2a7d850833106baa12" class="ne-p"><span class="ne-text">你问我书在哪。我说在那个桌子上的纸条上写着位置。这样的话那个纸条就是指针。</span></p><p id="ae3b732f456aeee776c46ad3eee3fbf3" class="ne-p"><span class="ne-text">纸条上写着，书在书架第一层，这就是地址，他并不是书的实体</span></p><p id="237aff462c974bc1cfe6447a87739d58" class="ne-p"><span class="ne-text">真正的书在书架第一层，顺着地址去找吧</span></p></div><h2 id="9d99bbbf"><span class="ne-text">C结构体</span></h2><h3 id="z86QD"><span class="ne-text">一些概念</span></h3><div class="ne-quote"><ul class="ne-ul"><li id="d1765bfb6d06c10f21c7014f39941e62"><span class="ne-text">结构体:构造（定义新的数据类型）</span></li><li id="efc3c5b1e5a95051c641ef77b8cc52bb"><span class="ne-text">结构体变量:定义（两种）；结构体变量访问结构体里面的成员：</span><code class="ne-code"><span class="ne-text">.</span></code><span class="ne-text">；指针访问成员的时候</span><code class="ne-code"><span class="ne-text">-></span></code></li><li id="b5c26d68531331694fe7229e8608fcfd"><span class="ne-text">结构体数组：变量很多</span></li><li id="5c1bb0304ccf530c82320b29bc12a50c"><span class="ne-text">结构体指针：指向结构体变量的指针，定义：</span><code class="ne-code"><span class="ne-text">struct Student *p</span></code><span class="ne-text">；指向结构体数组的指针</span></li></ul></div><ul class="ne-ul"><li id="71d14417540589cb4879c6a9f576e411"><span class="ne-text">C里面的</span><strong><span class="ne-text">结构体、共用体、枚举体</span></strong><span class="ne-text">根据这几类来构造新的数据类型，比如链表的初始实现，就是利用指针和结构体来实现</span></li><li id="ec15cbc229cf94352200ecef4e216f4f"><strong><span class="ne-text">typedef</span></strong><span class="ne-text">给结构体制定新的类型名  eg：计数专用变量</span><code class="ne-code"><span class="ne-text">typedef int Count</span></code></li></ul><h3 id="k01wR"><span class="ne-text">单链表的存储结构</span></h3><p id="17c2f0384e632317fcf803860ee866c4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616502801770-db341786-acc5-4024-966b-8793c339cc89.png" width="494.5" id="C1xSN" class="ne-image"></p><p id="25b850048759a9e061612cc535a1790c" class="ne-p"><span class="ne-text">上面的代码可以分解为：</span></p><pre data-language="cpp" id="tISNW" class="ne-codeblock language-cpp">typedef struct LNode LNode;         //将结构体类型struct LNode重命名为LNode<p>typedef struct LNode *LinkList; //将 struct LNode *重命名为 LinkList</pre><p id="865af01bee2b75a80b16f792cab36b9a" class="ne-p"><br></p><div class="ne-quote"><p id="b855a25b780b0279264580a610b36641" class="ne-p"><span class="ne-text">创建的时候，可以有下面三种方法</span></p><p id="8cdfabb8f1a8a036898bffe14e7697dd" class="ne-p"><span class="ne-text">【L 是指向结构体类型（struct LNode 型）指针变量】</span></p></div><ol class="ne-ol"><li id="9e5a715bd579c72ae9ae9a4f58176c2a"><span class="ne-text">LinkList L; </span></li><li id="e326d19f83319b427fb6b370eddddd7f"><span class="ne-text">struct LNode * L</span></li><li id="7173c9458fbaf788bd5794741e60c140"><span class="ne-text">LNode *L = new LNode;</span></li></ol><p id="14736ef7af51e46ed8c9c81b265e631f" class="ne-p"><span class="ne-text" style="color: #4D4D4D; font-size: 16px">只不过是用第 1 种方式创建更加简单，</span><span class="ne-text">具体的使用，new 的时候一般使用前者，定义一个该类型变量的时候一般用后者</span></p><p id="980dd05e1ac6353ccbc803dd39bb8b95" class="ne-p"><br></p><p id="1e840869837fd9966bd8cdaa9bd595c6" class="ne-p"><span class="ne-text">LinkList L；理解：一个结构体变量的指针就是该结构体变量所占据的内存段的起始地址，而我定义的是 LinkList 而不是 int，只是和计算机说明我需要的内存不一样了这种作用</span></p><p id="f2cb48f92634a846edf03d1a43600089" class="ne-p"><span class="ne-text" style="color: #4D4D4D; font-size: 16px"></span></p><p id="5f2cbc958c2139a89b32a6d4cca0b09f" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/GRoads/article/details/104155255" data-href="https://blog.csdn.net/GRoads/article/details/104155255" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/GRoads/article/details/104155255</span></a></p><h2 id="419ebc43"><span class="ne-text">C++的函数参数引用&amp;理解</span></h2><p id="7cc49998b1370db36bea506d4e759ec3" class="ne-p"><span class="ne-text">在学习单链表的时候，编写前插法的函数，函数参数传递的是&amp;L 而不是*L，这个相关知识的解释，参考这个帖子</span><a href="https://fishc.com.cn/thread-98021-1-1.html" data-href="https://fishc.com.cn/thread-98021-1-1.html" target="_blank" class="ne-link"><span class="ne-text">https://fishc.com.cn/thread-98021-1-1.html</span></a><span class="ne-text">，里面的榜首答案下图这么一句话</span></p><p id="8f530b1c09d55f86025485d72befda37" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616504219420-872367f1-be2c-4afe-89e5-12ecbfe817dc.png" width="829" id="WlGM3" class="ne-image"></p><ul class="ne-ul"><li id="742be92a48a50262c0a7c8ae157cff63"><span class="ne-text">函数传递&amp;：为引用参数，传递给引用于传递指针的效果是一样的，【只是个别名，不是取值！！】</span><a href="https://blog.csdn.net/weibo1230123/article/details/78910179" data-href="https://blog.csdn.net/weibo1230123/article/details/78910179" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/weibo1230123/article/details/78910179</span></a></li><li id="921afbb19819ae1f580f32c198c2a283"><span class="ne-text">代码实操以下</span></li></ul><p id="a5f96fb6c792a7616ed296343243b524" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616504292045-802c3bc2-ebbc-49aa-8764-7852def70548.png" width="377.5" id="cHiQv" class="ne-image"></p><p id="38f6858eb112651311de60217a7dcde8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616504341193-3d82d795-ebab-42c9-bc2c-3b6f0fe04e2e.png" width="427" id="H6SrY" class="ne-image"></p><p id="b5b2124d24a5f6a247509d8e7312e59a" class="ne-p"><span class="ne-text">图 1 是可以运行的，图 2 不可以（传递错误的格式）</span></p><p id="f3ea05b6555d9da08da917027b1c7759" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616504560727-4aacc3bb-139a-46be-aafb-5ba50bbae0b3.png" width="531" id="Y5Ioe" class="ne-image"></p><p id="6cebf9ae5aa7c0687bec91caf8263783" class="ne-p"><span class="ne-text">函数参数的传递，还要好好再复习复习……</span></p><h2 id="o2Z0x"><span class="ne-text">类 C 中 new、delete</span></h2><p id="e0d887f1be6eac510cf730e18aca18eb" class="ne-p"><span class="ne-text">在数据结构课程里面的类 C 语言里面，new、delete 分别为在内存中分配/释放空间</span></p><h2 id="T3UgL"><span class="ne-text">C++值 STL</span></h2><h3 id="U5dxH"><span class="ne-text">vector</span></h3><ul class="ne-ul"><li id="480bbb9d0e672da3fff6452dc69aa3d9"><span class="ne-text">函数模板</span></li><li id="5141ab7cf02123b3972b56e8f0e66a60"><span class="ne-text">类模板<br></span><span class="ne-text">STL 概述当中，vector 容器，顺序容器：向量 vector、列表 list、双端队列 deque</span></li></ul><div class="ne-quote"><p id="045a23a63cadcd0ebdadacb2876753f8" class="ne-p"><a href="https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html" data-href="https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html</span></a></p></div><h2 id="fPtfg"><span class="ne-text" style="color: #444444">C 之#define</span></h2><p id="44548c1b7c301856ed5c6bc5d432b6b9" class="ne-p"><span class="ne-text" style="color: #444444; font-size: 14px">C 语言中，可以用 #define 定义一个标识符来表示一个常量。其特点是：</span><span class="ne-text" style="color: #B22222; font-size: 14px">定义的标识符不占内存，只是一个临时的符号，预编译后这个符号就不存在了</span><span class="ne-text" style="color: #444444; font-size: 14px">。</span></p><p id="8672ef02e17ec401a068b87b74583dbe" class="ne-p"><br></p><p id="90beba95a8af2036675861d6042c4a28" class="ne-p"><span class="ne-text" style="color: #008000; font-size: 14px">预编译</span><span class="ne-text" style="color: #444444; font-size: 14px">又叫</span><span class="ne-text" style="color: #008000; font-size: 14px">预处理</span><span class="ne-text" style="color: #444444; font-size: 14px">。</span><span class="ne-text" style="color: #B22222; font-size: 14px">预编译不是编译，而是编译前的处理。这个操作是在正式编译之前由系统自动完成的。</span></p><ul class="ne-ul"><li id="50151bba3e3b7def1aa641331a065930"><a href="http://c.biancheng.net/view/187.html" data-href="http://c.biancheng.net/view/187.html" target="_blank" class="ne-link"><span class="ne-text">http://c.biancheng.net/view/187.html</span></a></li></ul><p id="5ca2028ad68d7599f6b9e73030d22730" class="ne-p"><br></p><ul class="ne-ul"><li id="58a5d293ab2f35f06261d38697641ca1"><span class="ne-text">const 定义常量</span></li><li id="c49f64a50e65bbf680fb29eb9007cfaf"><span class="ne-text">之前 C 语言里面用的是宏定义#define Π 3.1415927，但是宏定义有时候太“死板”</span></li></ul><h2 id="2zw9a"><span class="ne-text">C++头文件</span></h2><div data-type="info" class="ne-alert"><ul class="ne-ul"><li id="ffe7efa9366c2f1984c0427e0c5159ec"><span class="ne-text">C 语言中的头文件以.h 后缀，C++中头文件不加后缀。</span></li><li id="aeee0c5f08d489c840abf1edb39310f8"><span class="ne-text">C 语言中的 string.h 头文件，C++用 cstring，</span></li><li id="f03ff47e40cd02c6988e9d01fe22813e"><span class="ne-text">C 语言中的 math 头文件，C++使用 cmath 头文件</span></li></ul><p id="6f073a6314cc15cc46bcc13d83f6c681" class="ne-p"><br></p><p id="41000e3a824319b4af8ac0d2ee874693" class="ne-p"><span class="ne-text">这不只是形式上的改变，其实现也有所不同。</span></p></div><p id="a492ba3ec1f53ba2958a9fdca18b2cbb" class="ne-p"><br></p><h3 id="0WKhV"><span class="ne-text">using namespace std;</span></h3><p id="5aec11683d87524d1ca84b43a9aa3654" class="ne-p"><span class="ne-text">C++标准库中所有标识符并定义于一个名为 std 的命名空间中，std 称为标准命名空间（standard，标准的）。</span></p><h3 id="ZtzRE"><span class="ne-text">iostream</span></h3><p id="270a58b0ccaea3d56696f7850a5ed9f4" class="ne-p"><span class="ne-text">C++中的输入、输出头文件 iostream</span></p><p id="b22abc89ae022a3e7e8d5d095f093673" class="ne-p"><span class="ne-text">i ——input 输入</span></p><p id="10c87288b0d974618b0399bfebb0a383" class="ne-p"><span class="ne-text">o ——output 输出</span></p><p id="56c5514adbd9844f99d3547e378f20d3" class="ne-p"><span class="ne-text">stream —— 流</span></p><h3 id="2csm2"><span class="ne-text">iomanip</span></h3><table id="EsEEx" class="ne-table" style="width: 610px"><tbody><tr style="height: 33px"><td width="220"><p id="88a99ea41343b05ed265c393dd388bbd" class="ne-p" style="text-align: center"><span class="ne-text">操作符</span></p></td><td width="390"><p id="98181e6d96315c945283697d3f049619" class="ne-p" style="text-align: center"><span class="ne-text">功能</span></p></td></tr><tr style="height: 45px"><td width="220"><p id="822844c83fba1f8e176ce5add4631295" class="ne-p" style="text-align: center"><span class="ne-text">setfill(char c)</span></p></td><td width="390"><p id="f2875fcf32508579d7a583bfb6374728" class="ne-p" style="text-align: justify"><span class="ne-text" style="color: black; font-size: 22px">设置以</span><span class="ne-text" style="color: black; font-size: 22px">c</span><span class="ne-text" style="color: black; font-size: 22px">表示的填充字符</span></p></td></tr><tr style="height: 45px"><td width="220"><p id="d79aeda26d1f86fb6c3814b5949d4b3b" class="ne-p" style="text-align: center"><span class="ne-text">setprecision(int n)</span></p></td><td width="390"><p id="1e7609e62fa9c25c6cb791722f7dab7e" class="ne-p" style="text-align: justify"><span class="ne-text" style="color: black; font-size: 22px">设置以</span><span class="ne-text" style="color: black; font-size: 22px">n</span><span class="ne-text" style="color: black; font-size: 22px">表示的数值精度</span></p></td></tr><tr style="height: 33px"><td width="220"><p id="7ac89c1b0ef6160dde3bcad59f275b8d" class="ne-p" style="text-align: center"><span class="ne-text">setw(int n)</span></p></td><td width="390"><p id="48bbe218aa41d923e8387daa215cd690" class="ne-p" style="text-align: justify"><span class="ne-text" style="color: black; font-size: 22px">设置以 n 表示的域宽</span></p></td></tr></tbody></table><pre data-language="cpp" id="RRaW4" class="ne-codeblock language-cpp">#include <iostream><br>#include <iomanip><br>#include <cmath><br>using namespace std;</p><p>int main(){<br>double num=sqrt(3.0);<br>for (int i = 0; i &lt; 6; i++){<br>cout &lt;&lt;”当精度为”&lt;&lt;i&lt;&lt;”时：”&lt;&lt;setprecision(i)&lt;&lt;num&lt;&lt;endl;//设置不同的精度<br>}<br>cout &lt;&lt; “当前 cout 精度为：” &lt;&lt;cout.precision() &lt;&lt; endl;<br>cout &lt;&lt; “当前域宽：” &lt;&lt;cout.width() &lt;&lt; endl;<br>cout &lt;&lt; “==================================”<br>&lt;&lt; “\n”;<br>cout &lt;&lt;setw(7)&lt;&lt;num &lt;&lt; endl; //默认是右对齐<br>cout &lt;&lt; “当前填充字符：” &lt;&lt; endl;<br>cout&lt;&lt;setfill(‘*‘) &lt;&lt;setw(10)&lt;&lt;num &lt;&lt; endl; //setfill()函数可以直接插入流中<br>return 0;<br>}</p><p></pre><p id="67712d42bd5edc22fb79c6b7a14e9df7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621218267138-b3d7bcad-1567-4448-9839-e339c6bcb922.png" width="360" id="YmhV9" class="ne-image"></p><ul class="ne-ul"><li id="8328b5e1fc7b88dc61cc5bd8a7b6efed"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/akof1314/article/details/4625888" data-href="https://blog.csdn.net/akof1314/article/details/4625888" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/akof1314/article/details/4625888</span></a></li></ul><h3 id="eFy46"><span class="ne-text">✨bits/stdc++.h</span></h3><ul class="ne-ul"><li id="e82fbd3af961e04838d2e69e25bbc4ce"><span class="ne-text">万能头文件：几乎包含所有的可用到的C++库函数</span></li><li id="ba26eb4c224023f214cb902ccfa6692f"><span class="ne-text">缺点</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="1fd81b33caa328693545ed0043882bb5"><span class="ne-text">编译时间慢，具有不可移植的问题，很多编译器和oj不支持，虽然现在noip支持了…</span></li><li id="2fee56dfc1ba16f6da3995e1cdb6e46b"><span class="ne-text">如果你用了bits/stdc++.h，那么你很大几率就会用using namespace std;而不是using std::cin; using std::cout;这样的。这会导致你的某些变量或函数已经被包含了而你不知道（关键字作为函数名）</span></li><li id="6db837e628d81110557f347fc4d592fe"><span class="ne-text">还有很重要的一点，就是用bits很占内存，某些卡内存的题根本用不了</span></li></ul></ul><ul class="ne-ul"><li id="89835c59e2e985c3b932fb27dd95a34f"><span class="ne-text">具体头文件内容</span></li></ul><pre data-language="cpp" id="mzbMZ" class="ne-codeblock language-cpp">// C++ includes used for precompiling -<em>- C++ -</em>-</p><p>// Copyright (C) 2003-2013 Free Software Foundation, Inc.<br>//<br>// This file is part of the GNU ISO C++ Library.  This library is free<br>// software; you can redistribute it and/or modify it under the<br>// terms of the GNU General Public License as published by the<br>// Free Software Foundation; either version 3, or (at your option)<br>// any later version.</p><p>// This library is distributed in the hope that it will be useful,<br>// but WITHOUT ANY WARRANTY; without even the implied warranty of<br>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br>// GNU General Public License for more details.</p><p>// Under Section 7 of GPL version 3, you are granted additional<br>// permissions described in the GCC Runtime Library Exception, version<br>// 3.1, as published by the Free Software Foundation.</p><p>// You should have received a copy of the GNU General Public License and<br>// a copy of the GCC Runtime Library Exception along with this program;<br>// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<br>// &lt;Licenses - GNU Project - Free Software Foundation&gt;.</p><p>/** @file stdc++.h</p><ul><li> This is an implementation file for a precompiled header.</li><li>/</li></ul><p>// 17.4.1.2 Headers</p><p>// C<br>#ifndef _GLIBCXX_NO_ASSERT<br>#include <cassert><br>#endif<br>#include <cctype><br>#include <cerrno><br>#include <cfloat><br>#include <ciso646><br>#include <climits><br>#include <clocale><br>#include <cmath><br>#include <csetjmp><br>#include <csignal><br>#include <cstdarg><br>#include <cstddef><br>#include <cstdio><br>#include <cstdlib><br>#include <cstring><br>#include <ctime></p><p>#if __cplusplus &gt;= 201103L<br>#include <ccomplex><br>#include <cfenv><br>#include <cinttypes><br>#include <cstdalign><br>#include <cstdbool><br>#include <cstdint><br>#include <ctgmath><br>#include <cwchar><br>#include <cwctype><br>#endif</p><p>// C++<br>#include <algorithm><br>#include <bitset><br>#include <complex><br>#include <deque><br>#include <exception><br>#include <fstream><br>#include <functional><br>#include <iomanip><br>#include <ios><br>#include <iosfwd><br>#include <iostream><br>#include <istream><br>#include <iterator><br>#include <limits><br>#include <list><br>#include <locale><br>#include <map><br>#include <memory><br>#include <new><br>#include <numeric><br>#include <ostream><br>#include <queue><br>#include <set><br>#include <sstream><br>#include <stack><br>#include <stdexcept><br>#include <streambuf><br>#include <string><br>#include <typeinfo><br>#include <utility><br>#include <valarray><br>#include <vector></p><p>#if __cplusplus &gt;= 201103L<br>#include <array><br>#include <atomic><br>#include <chrono><br>#include <condition_variable><br>#include <forward_list><br>#include <future><br>#include <initializer_list><br>#include <mutex><br>#include <random><br>#include <ratio><br>#include <regex><br>#include <scoped_allocator><br>#include <system_error><br>#include <thread><br>#include <tuple><br>#include <typeindex><br>#include <type_traits><br>#include <unordered_map><br>#include <unordered_set><br>#endif</pre><p id="97f8165b5a3956ac5048e81fae71667e" class="ne-p"><span class="ne-text">C++</span></p><h2 id="ReJeb"><span class="ne-text">【大一C和C++笔记】</span></h2><p id="7af6b9c1c75c2f66a7f719ecc18f8851" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="ef60fdfa17ed709a6e549c2c96c94e9c" class="ne-p"><span class="ne-text">当时在OneNote的一些小记</span></p></div><p id="68ada53a1f93f1298e075a75dcf5fba2" class="ne-p"><br></p><h3 id="GscrZ"><span class="ne-text">C常用字符函数</span></h3><p id="64b64d2ad079fdda80fbd32b3afc1a36" class="ne-p"><span class="ne-text"> </span></p><p id="a382b6b642296befa9c1264f9ede5215" class="ne-p"><span class="ne-text">Printf()</span></p><p id="98bf251bc1a674355131abe6c7da3d9f" class="ne-p"><span class="ne-text">Scanf()</span></p><p id="62137e0e25bab3b229d15dc562b7ac3f" class="ne-p"><span class="ne-text">Putchar()</span></p><p id="c32b42f41eb04686673a8fd27b305bee" class="ne-p"><span class="ne-text">Getchar()</span></p><p id="9c9c5df76124ca7e35f177aea8371baa" class="ne-p"><span class="ne-text">Puts(str)</span></p><p id="c5b494286fab05e744caf7a590efeeca" class="ne-p"><span class="ne-text">Gets(str)</span></p><p id="ddf6c274761b268a5c519ed7ef2af13c" class="ne-p"><span class="ne-text">Strcat(str1,str2)：连接字符串</span></p><p id="77ff234766fbce470f781f2f7774cf1a" class="ne-p"><span class="ne-text">复制函数：将str2复制给str1</span></p><p id="e59ce8a742f3dc555ba72530acdeb7a7" class="ne-p"><span class="ne-text">Strcpy(str1,str2)</span></p><p id="fdb30d360356c9d39841847625c02440" class="ne-p"><span class="ne-text">在C++里面会报错</span></p><p id="c1d35b02ad624a80d7b48f8c4faf788b" class="ne-p"><span class="ne-text">    解决①：将函数strcpy改成strcpy_s,中间加一个参数——复制的长度</span></p><p id="39296429b8ccb2e5ff1adb53b20140d0" class="ne-p"><span class="ne-text"> </span></p><p id="26cfdcccf0ef06b007e77c04f42f920f" class="ne-p"><span class="ne-text">Strncpy(str1,str2,n)：复制函数，将str2的前n个字符复制给str1</span></p><p id="d5664de620ffb55fb34279dfeaf211f4" class="ne-p"><span class="ne-text">Strlen(str)：检测str的字符串长度</span></p><p id="74a4c95fe38644ceea308bcb605e39e2" class="ne-p"><span class="ne-text">Fopen(文件名，使用文件方式）</span></p><p id="686241d18ae7ddb6fc86c2d416ba68cc" class="ne-p"><span class="ne-text">fclose（文件指针）</span></p><p id="edd61a04a35dbdf495fa8081d42d2a87" class="ne-p"><br></p><h3 id="w0KlJ"><span class="ne-text">I/O改进</span></h3><ul class="ne-ul"><li id="d4628833a4b1679e371aae2c6c691c2c"><span class="ne-text">scanf===cin&gt;&gt; &gt;&gt;endl;</span></li><li id="da66da384035e3b7a2bdedd863c64f8d"><span class="ne-text">Print===cout&lt;&lt; &lt;&lt;endl;</span></li><li id="f7d7d68b88fcc4dd294978c4a3cff970"><span class="ne-text">换行符：endl 和 “\n”</span></li></ul><h3 id="kGoPT"><span class="ne-text">类和对象</span></h3><p id="589170fc5e5cd9631945f12a37e4b88d" class="ne-p"><span class="ne-text">类的形式？</span></p><p id="af80291bb23e82186f8df0b5152dd3db" class="ne-p"><span class="ne-text">Class wuzutao</span></p><p id="561e36aea521749971c338abca67a2e9" class="ne-p"><span class="ne-text">{</span></p><p id="db82741fde0d8b439118d4405f7d63e1" class="ne-p"><span class="ne-text">private：</span></p><p id="2ecc49d85d163094dc1d8f7e8d1d5867" class="ne-p"><br></p><pre data-language="plain" id="e62fed70" class="ne-codeblock language-plain">    public：</p><pre><code>protect：</code></pre><p>}；<br>数据成员<br>成员函数：<br>    类内实现=和普通函数的实现一样<br>    类外实现=void Date：：Display（）{}</pre><p id="3bc5b604a54f0c74362259ac49694d25" class="ne-p"><br></p><p id="656b0a5e2a1b09887053d66151c4ac78" class="ne-p"><span class="ne-text">类定义对象？</span></p><p id="3e8c35312172b97afc005b2258c557ac" class="ne-p"><span class="ne-text">①花括号内定义</span></p><p id="8aeb26b926cb5ea068a108dd7602e1c2" class="ne-p"><span class="ne-text">②花括号外定义</span></p><p id="d26f136ae749f77977878223a4c2027b" class="ne-p"><br></p><p id="1406e91a94b5aff767e691c26d99f36b" class="ne-p"><span class="ne-text">访问对象？</span></p><p id="9a0e900cc7e9a6c2632bbbe8a0176458" class="ne-p"><span class="ne-text">访问的是类内的成员</span></p><p id="e5704bfc4d5f5629e17635a59d4dbb7e" class="ne-p"><span class="ne-text">①圆点访问形式</span></p><p id="70c128f1088632fa45f657b30e379205" class="ne-p"><span class="ne-text">②指针访问形式</span></p><p id="821877274380e995d387ff010703f52c" class="ne-p"><br></p><p id="f22aace15a5b40bcb79405dda1ec77da" class="ne-p"><span class="ne-text">this指针？</span></p><p id="84a6bb1cd76344b395b8372e4a74d3f8" class="ne-p"><span class="ne-text">每个成员函数都会有一个特殊的隐含指针——this指针。</span></p><p id="484b6a7a9cb0bcbd331e006d8317156b" class="ne-p"><span class="ne-text">调用形式：cout&lt;&lt;this&lt;year&lt;day&lt;&lt;endl;</span></p><p id="10bfe802c7e6f51e7c02770a94f252a8" class="ne-p"><br></p><p id="48698c70dc5a5dff498e841253c22d84" class="ne-p"><strong><span class="ne-text">构造函数和析构函数</span></strong></p><p id="1e4f386c85cbfba45aeef0dfda743097" class="ne-p"><span class="ne-text">构造函数的作用就是适当地给类进行初始化的作用</span></p><p id="52fda6fe5b8046f18be9fbbb2b2cf89a" class="ne-p"><span class="ne-text">无参数的构造函数</span></p><p id="142ff04b6b77ad986130d7ff9c664524" class="ne-p"><span class="ne-text">带参数的构造函数</span></p><p id="944bdca6c2fb088e7066ed79d4cbfbe0" class="ne-p"><span class="ne-text"> </span></p><p id="914a175212b6158656849bb369b0d38a" class="ne-p"><span class="ne-text">拷贝构造函数，这里不是太懂！</span></p><p id="4987984bd65d13beb8a21d2c3c085973" class="ne-p"><span class="ne-text">拷贝构造函数声明</span></p><p id="d00a70e20cfbdf04c9ad64710d4c229a" class="ne-p"><span class="ne-text">拷贝构造函数定义和实现</span></p><p id="8c19e813b7e8f71dd27a8f010de2e4b1" class="ne-p"><span class="ne-text"> </span></p><p id="24ba2cc1833a8e12607e3c6923524f69" class="ne-p"><span class="ne-text">析构函数</span></p><p id="5baf7a64503989bda36307a1e47c0688" class="ne-p"><span class="ne-text">一般默认，如果自己写的话就是</span></p><p id="2c589c6bbe11028c7a236f53ceeb066c" class="ne-p"><span class="ne-text" style="text-decoration: underline">析构函数的声明：</span></p><p id="cf73c55c41048022280c9cb139e25cbc" class="ne-p"><span class="ne-text"><del></span><span class="ne-text">类名（）；</span></p><p id="d8f58369c6fcbb19b572067dba806308" class="ne-p"><span class="ne-text" style="text-decoration: underline">析构函数的定义和实现：</span></p><p id="a810f2a26e898e9ba5043568cc195072" class="ne-p"><span class="ne-text">类名：：</span><span class="ne-text"></del></span><span class="ne-text">类名（）</span><span class="ne-text">{</span><span class="ne-text">……</span><span class="ne-text">}</span></p><p id="8e1e71fb9355fe249e323c499bd0b134" class="ne-p"><span class="ne-text"></span></p><h3 id="KcS3M"><span class="ne-text">数据的共享和保护</span></h3><p id="5d9778e68bc61c3fce43a85f4e3858d8" class="ne-p"><strong><span class="ne-text">数据共享static</span></strong></p><ol class="ne-ol"><li id="a0aac2ce035f89879774a2b81910298a"><span class="ne-text">静态数据成员<br></span><span class="ne-text">声明：static 数据类型 静态数据成员名；<br></span><span class="ne-text">初始化在类结束和类中函数实现的中间<br></span><span class="ne-text">之后访问（通过类名/对象名来访问）：<br></span><span class="ne-text">私有的静态成员只能通过间接的方式来访问===静态成员函数<br></span><span class="ne-text">对象名.公有静态成员变量名<br></span><span class="ne-text">对象名::公有静态成员变量名</span></li><li id="cc703b49f1efe178f9363a0e5a5aaea2"><span class="ne-text">静态成员函数<br></span><span class="ne-text">没有this指针<br></span><span class="ne-text">声明：static 返回值类型 静态成员函数名（形参表）<br></span><span class="ne-text">之后访问（通过类名/对象名来访问）：<br></span><span class="ne-text">类名::静态成员函数名（实参表）<br></span><span class="ne-text">类名.静态成员函数名（实参表）</span></li></ol><p id="ab1ab0d853067d4d1868eb25c62f1613" class="ne-p"><strong><span class="ne-text">数据保护const</span></strong></p><ol class="ne-ol"><li id="7e1e8ba2ba362ee483ba134992f22b71"><span class="ne-text">常数据成员<br></span><span class="ne-text">有些时候，希望不用全局变量，因为这样不好移植，所以用到const场数据类型，相当于每次用不同场合用到这个类，都是这些用到这些固定的数据<br></span><span class="ne-text">一般结合static来避免数据赘余<br></span><span class="ne-text">eg：类Circle中<br></span><span class="ne-text">定义：const double PI；<br></span><span class="ne-text">初始化只能在构造函数后面的初始化列表中：Circle （double r=0）：PI（3.1415926）</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="16efbf2301904d3ab7a2947dd492209e"><span class="ne-text">常成员函数<br></span><span class="ne-text">只访问类中的数据而不修改类中的数据成员，最好用到常成员函数<br></span><span class="ne-text">eg：只访问类中的半径<br></span><span class="ne-text">声明：Double GetRadius（）const；<br></span><span class="ne-text">实现：double Circle：：GetRadius（）const{……}</span></li><li id="9edebba565af7a4ecd14de8c277f560b"><span class="ne-text">常对象<br></span><span class="ne-text">所定义的常对象p1在之后就不会被改变了<br></span><span class="ne-text">形式：const Person p1（17，“wu”）；</span></li></ol></ol><p id="77fa8a497ceee03a9c8ba16faa2a631c" class="ne-p" style="margin-left: 2em"><br></p><p id="96d4968e4f7fce6503427244f879f0d7" class="ne-p" style="margin-left: 2em"><br></p><h3 id="IcXSd"><span class="ne-text">类和类之间的关系</span></h3><p id="98e2d89fb19f51515d4d26734163d309" class="ne-p"><strong><span class="ne-text">类的组合</span></strong></p><p id="786c1cd5601038ccad92ee21ea056907" class="ne-p"><span class="ne-text">直观：</span><span class="ne-text">B</span><span class="ne-text">类中有</span><span class="ne-text">A</span><span class="ne-text">类定义的对象</span></p><p id="e798f3d873f80f3df1b8a252b0c2fbb4" class="ne-p"><span class="ne-text"> </span></p><p id="810a7518fb82c99cb4fe4f35ca35fdce" class="ne-p"><span class="ne-text">构造函数的顺序：</span></p><p id="eb51d1f203ce1efe4307151fe78efe76" class="ne-p"><span class="ne-text">对象成员的构造函数</span></p><p id="74d3a419ca2730249beed48442b0cd32" class="ne-p"><span class="ne-text">自身的构造函数</span></p><p id="9c9b3a40442a376cdc11af1550166469" class="ne-p"><span class="ne-text"> </span></p><p id="c22d51a1ed297f4a7b2682fca7814c84" class="ne-p"><span class="ne-text">构造函数有参数的时候：</span></p><p id="98fa9d7e9410489a0e437c0d02743791" class="ne-p"><span class="ne-text">怎么个表现形式呢？</span></p><p id="0349e66e3e90afb809979b11ffeb3fc3" class="ne-p"><strong><span class="ne-text">B</span></strong><strong><span class="ne-text">类中</span></strong><strong><span class="ne-text">B</span></strong><strong><span class="ne-text">的构造函数后面带有</span></strong><strong><span class="ne-text">A</span></strong><strong><span class="ne-text">类在</span></strong><strong><span class="ne-text">B</span></strong><strong><span class="ne-text">类中所定义的对象</span></strong><strong><span class="ne-text">，这个对象的参数用做左边</span></strong><strong><span class="ne-text">B</span></strong><strong><span class="ne-text">类构造函数的参数、</span></strong></p><p id="5b0ac855ff20990756e091cd54e2ab80" class="ne-p"><br></p><p id="35114f94260a19065dacde4c0bd36d2b" class="ne-p"><strong><span class="ne-text" style="color: #F5222D">类的依赖</span></strong></p><p id="2120cdba3907f458b2be589a6a28b0f8" class="ne-p"><span class="ne-text">赌徒和骰子，这就是一种依赖关系，如果用组合关系的话，就会影响到生命周期问题</span></p><p id="3ad63c77c1f535e1e895afbe7fa5f53b" class="ne-p"><span class="ne-text"> </span></p><p id="b0d2528755215f90af93003525b9ae24" class="ne-p"><span class="ne-text">Class </span><span class="ne-text">🎲</span><span class="ne-text">{}</span><span class="ne-text">；</span></p><p id="45736a566870db39d0b2f388773f5ebc" class="ne-p"><span class="ne-text">Class </span><span class="ne-text">🕵️‍♂️</span></p><p id="60de9abc3576b20020434de45c18dd26" class="ne-p"><span class="ne-text">{</span></p><p id="6e4d277170e48e9a7d3fd6791870a4c6" class="ne-p"><span class="ne-text">public</span><span class="ne-text">：</span></p><p id="8207342bb80b58fcc89574dab05fe8b3" class="ne-p"><span class="ne-text">Void play</span><span class="ne-text">（</span><span class="ne-text">🎲</span><span class="ne-text">1</span><span class="ne-text">，</span><span class="ne-text">🎲</span><span class="ne-text">2</span><span class="ne-text">，</span><span class="ne-text">🎲</span><span class="ne-text">3</span><span class="ne-text">）</span></p><p id="ef5452fed63dc615964d2df2dc931e33" class="ne-p"><span class="ne-text">{</span><span class="ne-text">……</span><span class="ne-text">}</span></p><p id="01f5cf56b9805a1a6ace3d918a2e307b" class="ne-p"><span class="ne-text">}</span><span class="ne-text">；</span></p><p id="5b11ad7340a9de6e18ed9974cdf940e2" class="ne-p"><strong><span class="ne-text" style="color: #F5222D">类的继承和派生</span></strong></p><p id="98ac0f5108d1a6221ffc86822f21336e" class="ne-p"><span class="ne-text">一、派生类的定义：</span></p><p id="384b69dd62e3dec7a4d75b8a78bd89db" class="ne-p"><span class="ne-text">父类</span><span class="ne-text">class Base{}</span></p><p id="4c3c3deedeec76bd438a7339821003f6" class="ne-p"><span class="ne-text">派生子类：单一继承</span><span class="ne-text">class Derived</span><span class="ne-text">：</span><span class="ne-text">public Base{}</span><span class="ne-text">；</span></p><p id="3b3e896a3854b0463e93b0379323af6b" class="ne-p"><span class="ne-text">多重继承</span><span class="ne-text">Class Derived</span><span class="ne-text">：</span><span class="ne-text">public Base1</span><span class="ne-text">，</span><span class="ne-text">pretect Base2{}</span><span class="ne-text">；</span></p><p id="cddaa48af29d232be3e2539249edca8b" class="ne-p"><span class="ne-text">继承的类型：</span></p><p id="cb07b91742f05b2d9a390a2acda093b2" class="ne-p"><span class="ne-text">单一继承：只有一个基类</span></p><p id="be57b54cb87cc33e58e885376f5c98eb" class="ne-p"><span class="ne-text">多重继承：有多个基类</span></p><p id="4df0ab886a06ba25553f120a41a1f6a0" class="ne-p"><span class="ne-text"> </span></p><p id="d83f7578f73bc0fa78a4abe4059bc55c" class="ne-p"><span class="ne-text">继承方式：</span></p><p id="fcce92249b7460260ee1dc8f5ea1d618" class="ne-p"><span class="ne-text">private</span><span class="ne-text">继承：所有的数据成员都为子类的的私有成员</span></p><p id="283441ba5cdb5555dae73b5130db3cf9" class="ne-p"><span class="ne-text">public</span><span class="ne-text">继承：父类的数据类型怎样，在子类类型不变</span></p><p id="ebd29994eda1c8fb5fc84668678babc5" class="ne-p"><span class="ne-text">protect</span><span class="ne-text">继承：所有的数据成员和成员函数都为字类的保护成员</span></p><p id="24f217697f287063ba79860299650ce6" class="ne-p"><span class="ne-text">ps</span><span class="ne-text">：①父类的</span><span class="ne-text">private</span><span class="ne-text">数据成员和成员函数不能被子类所继承</span></p><p id="bdc3648f0724694c3016cee7b8fd96cf" class="ne-p"><span class="ne-text">②一般很少用</span><span class="ne-text">protect</span><span class="ne-text">和</span><span class="ne-text">private</span><span class="ne-text">两种继承，因为两种改变了之前基类的访问属性，限制了这些的进一步派生，所以很少使用</span></p><p id="deb43f5da363790a96f3ed9e0c9073cf" class="ne-p"><span class="ne-text"> </span></p><p id="1dcfd9ee92488af32d16befb423d4360" class="ne-p"><span class="ne-text">二、派生类的构造和析构</span></p><p id="ae12bca60ea6731d45a1e79bf654c01a" class="ne-p"><span class="ne-text">构造和析构的调用顺序：</span></p><p id="592215823025cde0bc1e00d9dfe1f318" class="ne-p"><span class="ne-text">①所有虚基类的构造函数</span></p><p id="36cafbfc8fd89185a82efd335cbd8a55" class="ne-p"><span class="ne-text">②基类的构造函数</span></p><p id="51f264f053728bcb1fc048251935c564" class="ne-p"><span class="ne-text">③对象成员的构造函数</span></p><p id="2497479d3300cee2d1875c50c7b6ce9a" class="ne-p"><span class="ne-text">④自身派生类的构造函数</span></p><p id="da494451850f90cbc9168a4a21cee947" class="ne-p"><span class="ne-text">ps</span><span class="ne-text">：析构函数的调用顺序则正好相反、</span></p><p id="f79cb136e1b42eb5d6d091eb8c9d4315" class="ne-p"><span class="ne-text">虚基类保证调用一次构造函数。两个子类都有同一个基类的虚基类继承，构造函数只调用一次</span></p><p id="32b1e6b8317cd019ef219f86f0d4ab48" class="ne-p"><span class="ne-text">带参数的构造函数：</span></p><p id="6e1dd6b5fc891c2b352302c7fa9ac2a5" class="ne-p"><span class="ne-text">子类里面，构造函数的初始化要连带着基类的构造函数的初始化</span></p><p id="b2eee0eb655fe153e93c7479910100eb" class="ne-p"><span class="ne-text">eg</span><span class="ne-text">：</span><span class="ne-text">classA(int a,int b,int c):classB(a*2),classC(a,b){}</span></p><p id="0c7c8bd48fc4cd2e1e11b690e7eefe65" class="ne-p"><span class="ne-text"> </span></p><p id="3197ab6ab1ce831cb094780d874c4b52" class="ne-p"><span class="ne-text">三、同名冲突和解决方案</span></p><p id="1c77a501b36888b67586ca075f329ca5" class="ne-p"><span class="ne-text">解决①双冒号法：：</span></p><p id="5aea5f35f2ece42bb6b1621065368194" class="ne-p"><span class="ne-text">基类和子类当中有相同名字的数据成员和成员函数，</span></p><p id="48aac120f4a7006e033b06367ff26bbe" class="ne-p"><span class="ne-text">访问的时候：相同的名字：：数据成员</span><span class="ne-text">/</span><span class="ne-text">成员函数</span></p><p id="1836f06387b659546c48cc89e68a3746" class="ne-p"><span class="ne-text">解决②定义虚基类</span><span class="ne-text">virtual</span></p><p id="f883bfe022e48ba13675efa7184299e4" class="ne-p"><span class="ne-text">eg</span><span class="ne-text">：</span><span class="ne-text">class furniture{}</span><span class="ne-text">；</span></p><p id="90b7cf4bcf3c85dac20dbb1a0373ded7" class="ne-p"><span class="ne-text">Class sofa </span><span class="ne-text">：</span><span class="ne-text">virtual public furniture{}</span><span class="ne-text">；</span></p><p id="a731e7cd0e1fb2c091dbad3843780f3a" class="ne-p"><span class="ne-text">Class bed</span><span class="ne-text">：</span><span class="ne-text">virtual public furniture{}</span><span class="ne-text">；</span></p><p id="b4f2f06c32ffc21d3bf94737451bbcfe" class="ne-p"><span class="ne-text">Class sofabed</span><span class="ne-text">：</span><span class="ne-text">public sofa</span><span class="ne-text">，</span><span class="ne-text">public bed{}</span><span class="ne-text">；</span></p><p id="b462943b523c2abae01625e219b3eff8" class="ne-p"><span class="ne-text"> </span></p><p id="7e03fcbe8dfa104ab6182fbc7f335003" class="ne-p"><span class="ne-text">四、赋值兼容规则</span></p><h3 id="ErDXB"><span class="ne-text">主函数</span></h3><p id="1c4b0382dec30a4caf7a522f1a1a9dbf" class="ne-p"><span class="ne-text">主函数main()是程序的入口，每个程序都需要一个主函数。主函数返回值为int型。</span></p><p id="d80befa739da1067f0c8e41f32a6c81e" class="ne-p"><span class="ne-text">int main()</span></p><p id="6443c7ea6fbb4e429bc64e51cc87fda6" class="ne-p"><span class="ne-text">{</span></p><p id="1056b6a00cb45ba5b5340ea0ea50305d" class="ne-p"><span class="ne-text">    cout&lt;&lt;”hello,world!”&lt;&lt;endl;</span></p><p id="12bb5062573d55001cfdb78fd0a82118" class="ne-p"><span class="ne-text">    return 0;</span></p><p id="b3c87eeb90698c2de59e4d4d0fb8d7d2" class="ne-p"><span class="ne-text">}  </span></p><p id="b7dbb41ea44b1fbda81092556f904f1c" class="ne-p"><span class="ne-text">注意：程序末尾返回0</span></p><h3 id="9Ylus"><span class="ne-text"> </span></h3></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git多账号同设备部署总结</title>
      <link href="/blog/uke79e/"/>
      <url>/blog/uke79e/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="fb67b043"><span class="ne-text">部署多个github+coding等账号</span></h2><p id="84d69f1e9506ec3aa5fd417e7280b2d5" class="ne-p"><br></p><h3 id="32ae35ec"><span class="ne-text">思路</span></h3><p id="ea54fe62ae4f310895f44953314ddfc9" class="ne-p"><br></p><p id="f00605b0827a7fa6d528de3d5f48d498" class="ne-p"><span class="ne-text">好处：一台设备可以使用多个github账号/github+coding等等多平台托管/搭建两个静态博客</span></p><p id="20a9696410385bce48d028ae64f074e1" class="ne-p"><br></p><p id="2b87b99c0eb3f3f7ccee0e30d3cdc9d4" class="ne-p"><span class="ne-text">取消全局用户配置（每建立一个新文件夹，需要输入使用账号），建立多个ssh密匙（如果是github账号+coding账号+gitee账号等）</span></p><p id="b50355fbc8094874b3de931c131eb867" class="ne-p"><br></p><p id="73e0219f7080cfc92d3a5d94fed2a8e7" class="ne-p"><span class="ne-text">SSH的公钥是GitHub连接本地仓库和远程仓库的标识，一个公钥只能对应一个GitHub账户，一个相同的公钥不能上传到不同的GitHub账户</span></p><p id="41d2e17aa725384e76d2cb8a97a7587a" class="ne-p"><br></p><p id="57ed1f1388860025c6e03c2bc20ef84a" class="ne-p"><span class="ne-text">一台电脑，可以生成多对公私钥，可以通过配置，将不同的公钥上传到不同的GitHub账号，那么就不存在单个公钥绑定多个GitHub账号的情况存在了</span></p><p id="0533e1fbc3a1087484bc097c7e81934b" class="ne-p"><br></p><h3 id="5e2376c3"><span class="ne-text">多密匙生成</span></h3><p id="5d3ba53379e2115d3885f3461473430f" class="ne-p"><br></p><ul class="ne-ul"><li id="de478b027839c255ebd57dac23f193b9"><span class="ne-text">先进来该文件夹（忽略图片上写的字）<p></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490897-11718be6-6492-4ead-a739-1c92af25c648.png" width="1215" id="rIi3X" class="ne-image"></li><li id="7c00259532719c7626e599e775371f89"><span class="ne-text">创建新密匙方法一（首选）</span></li></ul><p id="72972c835a3b78baa4997a661fc37cc4" class="ne-p"><br></p><p id="1a8ff91c68644220d8c1fb7aa8232ab6" class="ne-p"><code class="ne-code"><span class="ne-text">ssh-keygen -t rsa -f ~/.ssh/这里是新密钥名称 -C "这里是你的邮箱"</span></code></p><p id="52eeef5cacb242ce628692008823aa25" class="ne-p"><br></p><p id="327dab9a078fe3d4837d878282f7b2b1" class="ne-p"><span class="ne-text">注意区别新密钥名称和旧密钥名称，不要相同！！</span></p><p id="07c6e9952cf15c610ae5cb0643f05dd1" class="ne-p"><br></p><ul class="ne-ul"><li id="fab83884386f42d4fb6b6791891d094f"><span class="ne-text">创建新密匙方法二</span></li></ul><p id="783c24a3fedecb77a77d77319149391c" class="ne-p"><br></p><p id="32dff8ccf55fa662a985843411d41939" class="ne-p"><span class="ne-text">输入这个：</span><code class="ne-code"><span class="ne-text">ssh-keygen -t rsa -C "这里是你的邮箱"</span></code></p><p id="bd472c715d8f127ae71ec1e975e57182" class="ne-p"><br></p><p id="a42e4c437e250fb58ce9123a8b49587d" class="ne-p"><span class="ne-text">出现这两句：</span></p><p id="971f78fef5df65240f73006aebacef94" class="ne-p"><code class="ne-code"><span class="ne-text">Generating public/private rsa key pair.</span></code></p><p id="907ed5e1ce0f826d6843019c5259515c" class="ne-p"><br></p><p id="6ce0e867e6b2d3328477a30ec64cab8b" class="ne-p"><code class="ne-code"><span class="ne-text">Enter file in which to save the key (/c/Users/you/.ssh/id_rsa):</span></code></p><p id="1c4d06d8209229a284a1ea83572ad902" class="ne-p"><br></p><p id="3938c8db081599069efae73cd4dd03f0" class="ne-p"><span class="ne-text">注意此时需要你输入新密钥的名称，同样要注意区别新密钥名称和旧密钥名称，不要相同，之后再两次回车。</span></p><p id="a24b5eafa327a3cd206f3ecc695b44df" class="ne-p"><br></p><h3 id="61cc6367"><span class="ne-text">配置 config</span></h3><p id="9dcc3f90dbe792bcf889b166d8b2e8d8" class="ne-p"><br></p><p id="a4d695be592ddb56c680463fcc92074c" class="ne-p"><span class="ne-text">.ssh 根文件夹下没有 config 文件，需要新建</span></p><p id="4e039ab3754bc1b51145b7e0a879c301" class="ne-p"><br></p><ul class="ne-ul"><li id="b0d22308a546867b12830d5ecaec8c04"><span class="ne-text">新建 config 文件方法一</span></li></ul><p id="3ff7dcebefaf81ca3db1bca10e19b790" class="ne-p"><br></p><p id="0172cf94b63c25ab01df6f140c5eab82" class="ne-p"><span class="ne-text">在.ssh 根路径下键入该命令</span><code class="ne-code"><span class="ne-text">touch config</span></code></p><p id="ec3a5c096253adb1b792c4d8c33bc1b4" class="ne-p"><br></p><ul class="ne-ul"><li id="31a00b8f3af45b20b2f7464c64c2a25d"><span class="ne-text">新建 config 文件方法二</span></li></ul><p id="2cb1606c83fd91cf545d323a4cd85b47" class="ne-p"><br></p><p id="2d42872b2a76ab0f6345702e1013f19a" class="ne-p"><span class="ne-text">记事本新建文件 config 文件！！没有后缀</span></p><p id="20b8491c87201ed6905f3c1b42af36c3" class="ne-p"><br></p><ul class="ne-ul"><li id="aa0bf1ef802fb89cd7f6d55a8de38337"><span class="ne-text">输入内容</span></li></ul><p id="3b8d69f3aae7d208d4a7ffc7c3c4387a" class="ne-p"><br></p><pre data-language="plain" id="e7c7a00e" class="ne-codeblock language-plain">#第一个账号，默认使用的账号，不用做任何更改<br>Host github.com<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/id_rsa #第二个新账号，#"xxxxxx"为前缀名，可以任意设置，要记住，后面需要用到<br>Host xxxxxx.github.com<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/这里是你创建的新密钥的名称</pre><p id="642a0e34c8fb2d86baa9ca6b5f4ff6e7" class="ne-p"><br></p><pre data-language="plain" id="4ec43bf3" class="ne-codeblock language-plain"># one(<a href="mailto:&#111;&#110;&#x65;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;">&#111;&#110;&#x65;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;</a>)<br>Host one.github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa_one<br>User one</p><h1 id="two-116-119-111-64-103-x6d-97-x69-108-x2e-x63-x6f-109"><a href="#two-116-119-111-64-103-x6d-97-x69-108-x2e-x63-x6f-109" class="headerlink" title="two(&#116;&#119;&#111;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;)"></a>two(<a href="mailto:&#116;&#119;&#111;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;">&#116;&#119;&#111;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;</a>)</h1><p>Host two.github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>IdentityFile <del>/.ssh/id*rsa_two<br>User two</pre><p id="4d5784308268a307d6c9a860eaa9be9f" class="ne-p"><br></p><pre data-language="plain" id="30f97382" class="ne-codeblock language-plain">Host myhost（这里是自定义的 host 简称，以后连接远程服务器就可以用命令 ssh myhost）<br>HostName 主机名可用 ip 也可以是域名(如:github.com 或者 bitbucket.org)<br>Port 服务器 open-ssh 端口（默认：22,默认时一般不写此行）<br>PreferredAuthentications 配置登录时用什么权限认证--可设为 publickey,password publickey,keyboard-interactive 等<br>IdentityFile 证书文件路径（如</del>/.ssh/id_rsa**)<br>User 登录用户名(如：git)</pre><p id="439c4095aebbebb99b1720a4215c1763" class="ne-p"><br></p><p id="f02b6197965358da0100ab69c19a8628" class="ne-p"><span class="ne-text">每个账号单独配置一个 Host，每个 Host 要取一个别名，一般为每个 Host 主要配置 HostName 和 IdentityFile 两个属性，配置完保存即可。</span></p><p id="bb61705f22c20443679af330bf1163b0" class="ne-p"><br></p><p id="7c2809cd6d14752b903d8aa3e99ed63c" class="ne-p"><span class="ne-text">Host 的名字可以自定义名字，不过这个会影响 git 相关命令，例如：Host mygithub 这样定义的话，使用命令 git clone git@mygithub:PopFisher/AndroidRotateAnim.git，git@后面紧跟的名字改为 mygithub</span></p><p id="cde10c2c6854a82ee860ba6851354407" class="ne-p"><br></p><div class="ne-quote"><p id="19ad9f09b817634a332a87625cb32841" class="ne-p"><strong><span class="ne-text">mine</span></strong></p><p id="cd645c268c2271bb8ffeb91dfafff22f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490639-fd51b09d-c037-4fdb-bad3-e2e1d56d7aed.png" width="999" id="uEqZT" class="ne-image"></p></div><p id="99bcaa1e5ffd5db28aa259b0706e8e7a" class="ne-p"><br></p><h3 id="530a9d85"><span class="ne-text">部署 SSH key</span></h3><p id="888e315bdee9ca333594fff8fa432aff" class="ne-p"><br></p><p id="cdc1b113b91df2c8bcf5868834141c91" class="ne-p"><span class="ne-text">将根文件夹下的</span><code class="ne-code"><span class="ne-text">wztlink1013.pub</span></code><span class="ne-text">文件复制到 github 上，coding/gitee 类似</span></p><p id="5ebb897316771936fc3c2eaa1de25fc5" class="ne-p"><br></p><p id="baeeaf76c863612c9717d334c507c74d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490332-674f64ec-d09e-4351-a3cd-dbebc15a3a32.png" width="1839" id="P7hWK" class="ne-image"></p><p id="b7f90ece5dde7ad6e5f6febc9a121a44" class="ne-p"><span class="ne-text">title 可以随便填</span></p><p id="e5bd9b7f3c85fe1f4399de4693f564b6" class="ne-p"><br></p><h3 id="70c59940"><span class="ne-text">清缓存，添 agent</span></h3><p id="5a7567aac6f5d86b192b62b32e074751" class="ne-p"><br></p><p id="dd59aeb08546be538fe010aed4cddb46" class="ne-p"><span class="ne-text">在根目录下</span></p><p id="7bba79da380a12883486cf9c004b6ea3" class="ne-p"><br></p><pre data-language="plain" id="5cd1375e" class="ne-codeblock language-plain">ssh-add -D<br>ssh-add xxxxxx #旧密钥名称，一般是 id_rsa<br>ssh-add xxxxxx #新创建的密钥名称</pre><p id="4669abed1bbdc01087c573a676f18446" class="ne-p"><br></p><p id="b4c61c754b5f8ea3a769f5e1c4842ae5" class="ne-p"><span class="ne-text">如果执行以上命令出现错误：</span><code class="ne-code"><span class="ne-text">Could not open a connection to your authentication agent.</span></code><span class="ne-text">，那么就需要先执行</span><code class="ne-code"><span class="ne-text">ssh-agent bash</span></code><span class="ne-text">，再执行以上命令</span></p><p id="03525d0831255645f7e80844657465e9" class="ne-p"><br></p><h3 id="b644b124"><span class="ne-text">验证是否配置成功</span></h3><p id="496dd64d2fe810ec12ed81369517c521" class="ne-p"><br></p><p id="f612bfcc5041326c149c8aad14857da5" class="ne-p"><span class="ne-text">一下第一个是之前默认的 github 账号，默认即可，第二个是添加的</span></p><p id="cc473f1603bd6892a603ef84683d6358" class="ne-p"><br></p><pre data-language="plain" id="4f148343" class="ne-codeblock language-plain">ssh -T <a href="mailto:&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#111;&#109;">&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#111;&#109;</a><br>ssh -T <a href="mailto:&#103;&#105;&#116;&#x40;&#x78;&#120;&#x78;&#x78;&#x78;&#120;&#120;&#x2e;&#x67;&#x69;&#116;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#109;">&#103;&#105;&#116;&#x40;&#x78;&#120;&#x78;&#x78;&#x78;&#120;&#120;&#x2e;&#x67;&#x69;&#116;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#109;</a></pre><p id="a0a045df0fbb1e1cd1cdab40a7ad7f41" class="ne-p"><br></p><p id="859795e16c81c6140a4d3a46644178cb" class="ne-p"><span class="ne-text">出现</span><code class="ne-code"><span class="ne-text">Hi 你的用户名! You've successfully authenticated, but GitHub does not provide shell access.</span></code><span class="ne-text">则成功。</span></p><p id="bbfe5332646c3eb64894a14a06513857" class="ne-p"><br></p><h3 id="ecff77a8"><span class="ne-text">使用</span></h3><p id="dec4e567985ba7c6daa83dd7efd4d7aa" class="ne-p"><br></p><ul class="ne-ul"><li id="1f5b251ade45d2df4286fec0c31f9aad"><span class="ne-text">取消全局用户名和邮箱配置（如果已经设置了全局的话）</span></li></ul><p id="49fc33402e1c55ebe1dbe86b84df93a9" class="ne-p"><br></p><pre data-language="plain" id="7b1970ec" class="ne-codeblock language-plain">git config --global --unset user.name<br>git config --global --unset user.email</pre><p id="64c6fe7685f68ecac8a58b46e3ed2660" class="ne-p"><br></p><ul class="ne-ul"><li id="478d7951053c5209ae32960170a2d6a6"><span class="ne-text">clone</span></li></ul><p id="3cf89497aa39505bf781974bac162fb3" class="ne-p"><br></p><p id="abac6dfad45fcd2015180f8dcb97afcf" class="ne-p"><span class="ne-text">原来：</span><code class="ne-code"><span class="ne-text">git clone <a href="mailto:&#103;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#104;&#117;&#x62;&#46;&#x63;&#x6f;&#109;">&#103;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#104;&#117;&#x62;&#46;&#x63;&#x6f;&#109;</a>: wztlink1013/learngit.git</span></code></p><p id="685853d5e013a258ebd6ea4463478b56" class="ne-p"><br></p><p id="d6eddf455dad8ad8d750ba0d6fad3874" class="ne-p"><span class="ne-text">现在：</span></p><p id="bca65a7f7725db91e4f694b2b03ceb10" class="ne-p"><br></p><pre data-language="plain" id="fea1ac4c" class="ne-codeblock language-plain">git clone <a href="mailto:&#103;&#105;&#x74;&#64;&#119;&#x7a;&#116;&#108;&#105;&#x6e;&#x6b;&#x31;&#48;&#x31;&#51;&#46;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#x2e;&#99;&#x6f;&#x6d;">&#103;&#105;&#x74;&#64;&#119;&#x7a;&#116;&#108;&#105;&#x6e;&#x6b;&#x31;&#48;&#x31;&#51;&#46;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#x2e;&#99;&#x6f;&#x6d;</a>: wztlink1013/learngit.git<br>git clone <a href="mailto:&#x67;&#105;&#116;&#x40;&#x74;&#119;&#105;&#x63;&#101;&#110;&#97;&#109;&#101;&#46;&#103;&#105;&#x74;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#109;">&#x67;&#105;&#116;&#x40;&#x74;&#119;&#105;&#x63;&#101;&#110;&#97;&#109;&#101;&#46;&#103;&#105;&#x74;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#109;</a>: twicename/learngit.git</pre><p id="db59368126eecb6ba239c5a2a7abbfcb" class="ne-p"><br></p><ul class="ne-ul"><li id="42ed0027e20be9ba6800985e1a73e010"><span class="ne-text">单独为每个 repo 设置 用户名/邮箱【以文件夹为单位】</span></li></ul><p id="8ddaefb655b7fa3508bfbe72b7573b4f" class="ne-p"><br></p><pre data-language="plain" id="53d49e91" class="ne-codeblock language-plain">git config user.name "wztlink1013"<br>git config user.email "<a href="mailto:&#x32;&#53;&#x35;&#x30;&#51;&#55;&#52;&#56;&#x31;&#53;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;">&#x32;&#53;&#x35;&#x30;&#51;&#55;&#52;&#56;&#x31;&#53;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;</a>"</p><p>git config user.name “twicename”<br>git config user.email “<a href="mailto:&#49;&#50;&#x33;&#52;&#x35;&#54;&#55;&#x38;&#57;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;">&#49;&#50;&#x33;&#52;&#x35;&#54;&#55;&#x38;&#57;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;</a>“</pre><p id="5238a03b67081fbc36b2f3d912731e38" class="ne-p"><br></p><p id="037ff2827c1c5cc7f40818c8512eb0b0" class="ne-p"><span class="ne-text">如果报错：</span><code class="ne-code"><span class="ne-text">fatal: not in a git directory</span></code><span class="ne-text">，说明没有进入.git 目录下，具体路径：其中.git 目录是隐藏的，需要你设置隐藏目录可见</span></p><p id="ef8fd1c012bb835caf90d934b0df5824" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490310-1580343b-946c-4d67-a063-d5cd11bc6136.png" width="925" id="oPGRx" class="ne-image"></p><p id="7845e79f636dc900adbb5fb34b968e0b" class="ne-p"><br></p><p id="20cfea0ff85a401eaafe36ac836fabc4" class="ne-p"><span class="ne-text">执行</span><code class="ne-code"><span class="ne-text">git config --list</span></code><span class="ne-text">查看设置是否成功</span></p><p id="ff40e24211446f3703a820455043b979" class="ne-p"><br></p><h2 id="1808d429"><span class="ne-text">参考资料</span></h2><p id="8965ca6c3881f5c06a19f8fc0bc85445" class="ne-p"><br></p><ul class="ne-ul"><li id="8f39cdcf32806689a60e8772a903db52"><a href="https://github.com/guobinhit/cg-blog/blob/master/articles/github/README.md" data-href="https://github.com/guobinhit/cg-blog/blob/master/articles/github/README.md" target="_blank" class="ne-link"><span class="ne-text">史上最简单的 GitHub 教程</span></a></li><li id="b0eb734e49841990fe45436f6bbd2007"><a href="https://www.itrhx.com/2019/01/18/A16-deploy-two-or-more-hexo-blogs/" data-href="https://www.itrhx.com/2019/01/18/A16-deploy-two-or-more-hexo-blogs/" target="_blank" class="ne-link"><span class="ne-text">一台电脑使用两个/多个 GitHub 账号部署两个/多个 Hexo 博客</span></a></li></ul><ul class="ne-ul"><li id="c31f2191a7ffba5d8c03dba199597bba"><a href="https://blog.csdn.net/u013716535/article/details/78621775" data-href="https://blog.csdn.net/u013716535/article/details/78621775" target="_blank" class="ne-link"><span class="ne-text">一台电脑两个 github 账号</span></a></li><li id="2ecf8b0cfe027ad095ba9f12f127bc05"><a href="https://blog.csdn.net/IT_xiao_bai/article/details/88563103" data-href="https://blog.csdn.net/IT_xiao_bai/article/details/88563103" target="_blank" class="ne-link"><span class="ne-text">一台电脑上的 git 同时使用两个 github 账户</span></a></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基本语法</title>
      <link href="/blog/ewt4nc/"/>
      <url>/blog/ewt4nc/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="2a6d98d92033574f2698ed8fe7fd0f79" class="ne-p"><br></p><div data-type="danger" class="ne-alert"><p id="f11422df3acf6c4995299675b04e020a" class="ne-p"><span class="ne-text">之前从OneNote转过来的笔记，暂未排版整理，日后整理……咕咕咕~</span></p></div><h2 id="cffLH"><span class="ne-text">一、基本语法</span></h2><p id="13f2ee330cde4024b9a14863a0c02d59" class="ne-p"><br></p><ol class="ne-ol"><li id="c4cd6d832be362df611f5dce18f8626d"><span class="ne-text">大事谷歌；小事百度【建立良好的编程式思维】</span></li><li id="ce9543acb2adc2e3fcd9164e07ece7cb"><span class="ne-text">PEP8中的一些良好约定【编程规范】</span></li><li id="f0de4a4ebb98ad3e6bf7c607b787f2d0"><span class="ne-text">字符串格式化：<p></span><span class="ne-text">print(‘%s–%d–%s’%(‘wuzutao’,20,’尼采般地抒情’))<br></span><span class="ne-text">a. %i 是什么格式的那啥？‘</span></li><li id="dfc4de496ee115d47599344719ebcebc"><span class="ne-text">强制性类型转换：类 C</span></li><li id="d79dee57ea7aef63ef67a5f00c96fc5c"><span class="ne-text">时间和日期：<br></span><span class="ne-text">from datetime import datetime<br></span><span class="ne-text">dt=datetime(2019,5,12,9,20)<br></span><span class="ne-text">print(dt.year,dt.month,dt.day)</span></li></ol><div class="ne-quote"><p id="02bd554fca20fb225a4e72be91a619c3" class="ne-p"><span class="ne-text">2019  5  12</span></p><p id="f2b14ab2ef15161d72d0e24e6035adc1" class="ne-p"><span class="ne-text">dt.strftime(‘%Y/%m/%d %H:%M’)</span></p><p id="9b0a90d51334f62664ef26f821109434" class="ne-p"><span class="ne-text">#datetime 格式转化为字符串</span></p><p id="3061771b0879cf438b497137f36e2c38" class="ne-p"><span class="ne-text">‘2019/05/12 09:20’</span></p><p id="5eb378169969bb96726f7789fcb48a50" class="ne-p"><span class="ne-text">datetime.strptime(‘20161203’, ‘%Y%m%d’)</span></p><p id="e960fa85b4cd49680920dd7b76eb8dde" class="ne-p"><span class="ne-text">#字符串转化为 datetime 格式</span></p><p id="cafdf3ff4cb9c23403fdd2eea587ff90" class="ne-p"><span class="ne-text">datetime.datetime(2016, 12, 3, 0, 0)</span></p></div><ol start="6" class="ne-ol"><li id="b9accde722e5e9b7c11eeacbdd0c5677"><span class="ne-text">pass 函数<br></span><span class="ne-text">def f():<br></span><span class="ne-text">    #TODO: test pass<br></span><span class="ne-text">    pass</span></li><li id="0af1b5d10cfd7648bbda61f023062fdd"><span class="ne-text">异常的处理<br></span><span class="ne-text">def test(x,y):<br></span><span class="ne-text">    try:<br></span><span class="ne-text">        print(y/x)<br></span><span class="ne-text">    except:<br></span><span class="ne-text">        print(‘输入的信息有误！’)</span></li></ol><div class="ne-quote"><p id="8cd1c8107f0d49039e383eb459f377cf" class="ne-p"><span class="ne-text">test(2,8)</span></p><p id="dfb9444e5b35fe91500e9f2bc6c70b25" class="ne-p"><span class="ne-text">test(‘e’,8)</span></p></div><ol start="8" class="ne-ol"><li id="6d1d70d45bb72197f01d18d95b136487"><span class="ne-text">range 和 range 的区别！！！</span></li><li id="5b1ba9bc6ce66b7602e3ddd319e784d8"><span class="ne-text">对象传递和拷贝【类似 C 语言中的指针】<br></span><span class="ne-text">#变量传递、列表传递和 C 类似<br></span><span class="ne-text">#深拷贝和浅拷贝<br></span><span class="ne-text">import copy<br></span><span class="ne-text">a = [[1, 2, 3], [4, 5, 6]]<br></span><span class="ne-text">b = a<br></span><span class="ne-text">c = copy.copy(a)<br></span><span class="ne-text">d = copy.deepcopy(a)<br></span><span class="ne-text">print (‘a-id:’,id(a))#id 相当于内存里面的地址<br></span><span class="ne-text">print (‘b-id:’,id(b))<br></span><span class="ne-text">print (‘c-id:’,id(c))<br></span><span class="ne-text">print (‘d-id:’,id(d))<br></span><span class="ne-text">a.append(15)<br></span><span class="ne-text">a[1][2] = 10<br></span><span class="ne-text">print (a)<br></span><span class="ne-text">print (b)<br></span><span class="ne-text">print (c)<br></span><span class="ne-text">print (d)</span></li></ol><div class="ne-quote"></div><ol start="9" class="ne-ol"><li id="cd0c1eff537f153f12d6bd7657864a8e"><span class="ne-text">a-id: 2171119139144<br></span><span class="ne-text">b-id: 2171119139144<br></span><span class="ne-text">c-id: 2171119848136<br></span><span class="ne-text">d-id: 2171119140744<br></span><span class="ne-text">[[1, 2, 3], [4, 5, 10], 15]<br></span><span class="ne-text">[[1, 2, 3], [4, 5, 10], 15]<br></span><span class="ne-text">[[1, 2, 3], [4, 5, 10]]<br></span><span class="ne-text">[[1, 2, 3], [4, 5, 6]]</span></li></ol><p id="c0388c341b9c4c7fcf9fdac344b8f4ed" class="ne-p"><br></p><h2 id="1d4ca41f"><span class="ne-text">二、数据结构</span></h2><p id="98fa019b4141affe9be259edd3b76b0d" class="ne-p"><br></p><h3 id="cda9f200"><span class="ne-text">元组</span></h3><p id="88f5b1a5f22d38724bb2e05985033fdc" class="ne-p"><br></p><pre data-language="plain" id="6dadb2eb" class="ne-codeblock language-plain"> ○ #转换为元组（list->tuple, string->tuple）<br>l = [1, 2, 3]<br>print (tuple(l))<br>str = ('Hello ChinaHadoop')<br>print (tuple(str)) >>>(1, 2, 3) ('H', 'e', 'l', 'l', 'o', ' ', 'C', 'h', 'i', 'n', 'a', 'H', 'a', 'd', 'o', 'o', 'p')<br>○ tup1 = (1, 2, 3) #嵌套元组:<br>tup2 = ((1, 2, 3), (4, 5))<br>print (tup2) #合并元组:<br>tup1 + tup2<br>○ #拆包<br>def test*1():<br>r=(2,4,5,32)<br>return r<br>a, b, *, f=test_1()<br>print(f) >>> 32<br>○ # 元组列表迭代<br>tuple_lst = [(1, 2), (3, 4), (5, 6)]<br>for x, y in tuple_lst:<br>print (x+y) >>>3 7 11<br>○ # 计数器<br>列表/元组.('需要查找里面的某个对象的个数')</pre><p id="76462e976ae949f07c383933dea1d20f" class="ne-p"><br></p><h3 id="3712972d"><span class="ne-text">列表</span></h3><p id="52397d22f8eda4950f62d0350593815b" class="ne-p"><br></p><pre data-language="plain" id="3db7ccb6" class="ne-codeblock language-plain"> ○ list 里面可以有不同类型的元素<br>○ #合并列表<br>lst_1=[352,2352,3,556]<br>lst_2=['gew','f'] >lst_3 = lst_1 + lst_2 >lst_1.extend(lst_2)<br>○ #sort 函数和 sorted 函数<br>list_1=[23,54,346,222,4,1]<br>print(list_1.sort()) #查查版本<br>print(sorted(list_1)) #sorted 是新起的一个列表<br>lst_6 = ['Welcome', 'to', 'Python', 'Data', 'Analysis', 'Course']<br>lst_6.sort()<br>print (lst_6)【!!!!打印出来是 none===查查版本】 >>>['Analysis', 'Course', 'Data', 'Python', 'Welcome', 'to']<br>lst_6.sort(key = len, reverse=True)<br>print (lst_6) >>>['Analysis', 'Welcome', 'Course', 'Python', 'Data', 'to']</pre><p id="da3ede3ec7d00bffbf805437da65ce49" class="ne-p"><br></p><h3 id="ad552573"><span class="ne-text">字典</span></h3><p id="127500d1d4e372dcb0d38356150e8a13" class="ne-p"><br></p><pre data-language="plain" id="cd93dd0c" class="ne-codeblock language-plain"> ○ #合并字典<br>dict1 = {1:'huhuhu'}<br>dict2 = {4: 'new1', 5: 'news'}<br>dict1.update(dict2)<br>○ #通过多个列表创建字典<br>dict_3 = {}<br>l1 = [32,543,6,2,7,4]<br>l2 = reversed(l1)<br>for i1, i2 in zip(l1, l2):<br>dict_3[i1] = i2<br>print (dict_3) >>>{32: 4, 543: 7, 6: 2, 2: 6, 7: 543, 4: 32}<br>'''hash 函数来判断某个对象是否可以做键'''<br>○ '''位置赋值；默认赋值；关键字赋值——format'''<br>'''遍历字典的方式变了：keys，values，items'''<br>天行九歌={'韩非':'逆鳞','卫庄':'鲨齿','盖聂':'渊虹'}<br>print(天行九歌)<br>for ren,jian in 天行九歌.items():<br>print('{}--{}'.format(ren,jian)) >>><br>{'韩非': '逆鳞', '卫庄': '鲨齿', '盖聂': '渊虹'}</pre><p id="595daa81a734ca97f30b3a6354c8e9d7" class="ne-p"><br></p><h3 id="508b37f1"><span class="ne-text">集合</span></h3><p id="d9dfa6f70259f8712e171ebfa1b7dab4" class="ne-p"><br></p><pre data-language="plain" id="fcf3301b" class="ne-codeblock language-plain"> ○ a1=[1,3,4,1,35,2352,75]<br>b1=[3,2352,24354,4332432,54]<br>a=set(a1)<br>b=set(b1)<br>print(a)<br>print(b)<br>a | b#并；a & b#交；a - b#呃。。。；a ^ b#呃。。。；<br>a.issubset(b)#判断子集 >>>False<br>a.issuperset(b)#判断父集 >>>False</pre><p id="dcbc8cb70c8377c710b4e39eb6c19317" class="ne-p"><br></p><h2 id="980d97e1"><span class="ne-text">三、高级特性</span></h2><p id="dc35503db2af0de529ea6a3d75050045" class="ne-p"><br></p><h3 id="55f730a2"><span class="ne-text">推导式</span></h3><p id="f4a5f201674c403e9e9a9eb0f6ebe529" class="ne-p"><br></p><pre data-language="plain" id="d075e8de" class="ne-codeblock language-plain"> ○ str_lst = ['Welcome', 'to', 'Python', 'Data', 'Analysis', 'Course']<br>result = [x.upper() for x in str_lst if len(x) > 4]<br>print (result) >>>['WELCOME', 'PYTHON', 'ANALYSIS', 'COURSE']</pre><p id="9959e1adf74c43f06bab44fce7efb820" class="ne-p"><br></p><h3 id="e436a373"><span class="ne-text">多函数模式</span></h3><p id="ad562de11eb3e12b689748381c550d5e" class="ne-p"><br></p><pre data-language="plain" id="8edfd751" class="ne-codeblock language-plain"> ○ str_lst = ['$1.123', ' $1123.454', '$899.12312']<br>def remove_space(str):<br>"""<br>remove space<br>"""<br>str_no_space = str.replace(' ', '')<br>return str_no_space<br>def remove_dollar(str):<br>"""<br>remove $<br>        """<br>        if '$' in str:<br>return str.replace('$', '')<br>else:<br>return str<br>def clean_str_lst(str_lst, operations):<br>"""<br>clean string list<br>"""<br>result = []<br>for item in str_lst:<br>for op in operations:<br>item = op(item)<br>result.append(item)<br>return result<br>clean_operations = [remove_space, remove_dollar]<br>result = clean_str_lst(str_lst, clean_operations)<br>print (result) >>>['1.123', '1123.454', '899.12312']</pre><p id="68031d523f9910737a129b3c77c00c00" class="ne-p"><br></p><h3 id="0153bdbc"><span class="ne-text">匿名函数</span></h3><p id="74520702090e791521c5344d24a46f24" class="ne-p"><br></p><pre data-language="plain" id="bed03228" class="ne-codeblock language-plain"> ○ str_lst = ['Welcome', 'to', 'Python', 'Data', 'Analysis', 'Course']<br>str_lst.sort(key=lambda x:len(x)) # sort by length<br>print (str_lst)<br>str_lst.sort(key=lambda x:x[-1]) # sort by the last letter<br>print (str_lst) >>><br>['to', 'Data', 'Python', 'Course', 'Welcome', 'Analysis']<br>['Data', 'Course', 'Welcome', 'Python', 'to', 'Analysis']</pre><p id="9f689cee4f71315c403549a284431542" class="ne-p"><br></p><h3 id="4c718d0b"><span class="ne-text">迭代器</span></h3><p id="c457fe224407fd8db023845a6f6c7255" class="ne-p"><br></p><pre data-language="plain" id="0591075d" class="ne-codeblock language-plain"> ○ def gen_test():<br>for i in range(3):<br>yield i</p><p> gen = gen_test() #此时不执行生成器<br>type(gen)<br>for i in gen:<br>print(i) #用意何在呢？？！！ &gt;&gt;&gt;0 1 2</pre><p id="5c766503d2641ad311a51230acc24879" class="ne-p"><br></p><h2 id="1a40e8f0"><span class="ne-text">四、常用函数</span></h2><p id="64efbb4171e43bcf92f7e4f0d7ad5ead" class="ne-p"><br></p><h3 id="5cee3ed5"><span class="ne-text">序列函数&amp;zip 使用</span></h3><p id="ca28b43b59718630dcae965003188e4b" class="ne-p"><br></p><pre data-language="plain" id="2b56cd06" class="ne-codeblock language-plain"> a. enumerate 函数<br>list_11 = ['Welcome', 'to', 'Python', 'Data', 'Analysis', 'Course']<br>for i, item in enumerate(lst_6):<br>print ('%i-%s' %(i, item)) >>><br>0-Analysis<br>1-Welcome<br>2-Course<br>3-Python<br>4-Data<br>5-to<br>str_dict = dict((i, item) for i, item in enumerate(list_11))<br>print (str_dict) >>>{0: 'Welcome', 1: 'to', 2: 'Python', 3: 'Data', 4: 'Analysis', 5: 'Course'}<br>b. zip 压缩<br>lst_6 = ['Welcome', 'to', 'Python', 'Data', 'Analysis', 'Course']<br>lst_8 = ['a', 'b', 'c']<br>zip_lst = zip(lst_6, lst_8)<br>print(list(zip_lst)) #方式一：直接转化为列表<br>print(dict(list(zip_lst))) #方式二：转化为字典<br>for i in zip_lst:<br>print (i) #方式三：直接遍历<br>解压：<br>print(*zip_lst)<br>print(lst_6)<br>c. reversed 逆序输出</pre><p id="140d9c7e372982ff13665cedffbb9a57" class="ne-p"><br></p><h3 id="1cf50330"><span class="ne-text">函数式编程</span></h3><p id="21b3eb55002a9cfee230597862b03235" class="ne-p"><br></p><pre data-language="plain" id="9e92f3e6" class="ne-codeblock language-plain"> a. #函数可以作为变量使用;也可以将函数作为参数使用<br>import math<br>def func_add(x, y, f):<br>"""<br>functional addition<br>"""<br>return f(x) + f(y)<br>print (func_add(4, 25, math.sqrt))<br>print (func_add(-4, 25, abs)) >>>7.0 29</pre><p id="03ef49ef206b95b185a3acb628933256" class="ne-p"><br></p><h3 id="cf808b2e"><span class="ne-text">map 和 reduce</span></h3><p id="e05e6015b3818ec2d1a7634653e64197" class="ne-p"><br></p><pre data-language="plain" id="d2c0a4b6" class="ne-codeblock language-plain"> a. '''map 函数'''<br>list_1=[1,4,9]<br>aaa = [x**2 for x in list_1]<br>print (aaa)<br>bbb = map(math.sqrt, aaa)<br>print (bbb) >>><br>[1, 16, 81]</pre><p id="a97905d34f851c154b2bd75325351007" class="ne-p"><br></p><p id="fa30fdc7b99a9b3413ee8f65edaa4c4a" class="ne-p"><span class="ne-text">&lt;map object at 0x000002145B2B77F0&gt;</span></p><p id="85fb5a3ddc05dd1c9f5683e39938e036" class="ne-p"><br></p><h3 id="cfecb9e9"><span class="ne-text">filter 函数</span></h3><p id="ac5a64340a2190ec87b513df48b927c7" class="ne-p"><br></p><pre data-language="plain" id="7ff82834" class="ne-codeblock language-plain"> a. 天行=['韩非','卫庄','张良','盖聂','逆鳞']<br>def fx(x):<br>y=['逆鳞']<br>if x in y:<br>return x<br>filtered_lst = filter(fx,天行)<br>print(天行)<br>print(list(filtered_lst)) #注意 python2 和 3 的区别，很多时候要区别出来列表等序列，加上 list 很有必要 >>><br>['韩非', '卫庄', '张良', '盖聂', '逆鳞']<br>['逆鳞']</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>apply函数和入口函数</title>
      <link href="/blog/hy14ic/"/>
      <url>/blog/hy14ic/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h2 id="246b9da3" data-lake-id="844f80aba1a839d18f00392f27755399" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">pandas之apply函数</h2><p data-lake-id="04c3207445a0fa8ec49851f401e3e515" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="codeblock" id="5847fdd6" data-language="plain"><div class="lake-codeblock-content" style="border: 1px solid rgb(232, 232, 232); max-width: 750px; color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: rgb(249, 249, 249);"><div class="CodeMirror-sizer" style="color: rgb(89, 89, 89); margin: 0px; padding: 16px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><pre class="cm-s-default" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">DataFrame.apply(func, axis=0, broadcast=False, raw=False, reduce=None, args=(), **kwds)</span></span></pre></div></div></div><p data-lake-id="7acd2f075bbdcc3918084199a7585cfb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="38780fb1ad5e0900eca50dd2e5b6a031" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">第一个参数，这个参数是函数，相当于C/C++的函数指针。</p><p data-lake-id="266650ba684d96742abe5720fda6ffb2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="08bbb10c326dd1ab87cc7e3a04ee7beb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">这个函数需要自己实现，函数的传入参数根据axis来定，比如axis = 1，就会把一行数据作为Series的数据</p><p data-lake-id="b6f158a06cfe2ca03a8585f09dc5ec72" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">结构传入给自己实现的函数中，我们在函数中实现对Series不同属性之间的计算，返回一个结果，则apply函数</p><p data-lake-id="a74f2b6e30c197bf9fd20da00386abaf" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">会自动遍历每一行DataFrame的数据，最后将所有结果组合成一个Series数据结构并返回。</p><p data-lake-id="b4455c7d90f49ccb5e39dabe91d631cc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 id="4bf0240c" data-lake-id="d41b572923476057a29f506409166c4e" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">if <strong>name</strong> == 'main'</h2><p data-lake-id="d8cba4b33333b2023dba924a13608091" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="70814379fb07d2a600c168602ef4a235" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><a href="https://zhuanlan.zhihu.com/p/34112508" target="_blank">参考：知乎用户</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>qrcode和myqr花式二维码</title>
      <link href="/blog/ro3p67/"/>
      <url>/blog/ro3p67/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="o04Pl"><span class="ne-text">一、官方文档</span></h2><p id="22f49c2d869c21f5dea0ff3f73ebbbef" class="ne-p"><a href="https://pypi.org/project/qrcode/" data-href="https://pypi.org/project/qrcode/" target="_blank" class="ne-link"><span class="ne-text">https://pypi.org/project/qrcode/</span></a></p><p id="51136b0b262d1382694cd480ee80bc44" class="ne-p"><a href="https://pypi.org/project/MyQR/" data-href="https://pypi.org/project/MyQR/" target="_blank" class="ne-link"><span class="ne-text">https://pypi.org/project/MyQR/</span></a></p><h2 id="045e782b"><span class="ne-text">二、下载包</span></h2><p id="bf430b601d035b96fa7ec8618ffb486d" class="ne-p"><br></p><p id="ae8e789952f0e5ee6f06a634e0c4ef73" class="ne-p"><span class="ne-text">pip install qrcode  #方法多，体量小</span></p><p id="a2246ccdf64f749c73b4a664b63eb5db" class="ne-p"><br></p><p id="a20fedc429c3810eb0b738bbec0fc21a" class="ne-p"><span class="ne-text">pip install myqr    #操作简单，功能强大</span></p><p id="8bca71033f49365a128b86ef3613f0e4" class="ne-p"><br></p><h2 id="dd4077aa"><span class="ne-text">三、代码</span></h2><p id="97ec651e48d286b5dced3be63fca9788" class="ne-p"><br></p><h3 id="6ef799f7"><span class="ne-text">qrcode一行字二维码</span></h3><p id="4a76cabfeaffb73b04126c636c7dd260" class="ne-p"><br></p><pre data-language="python" id="92d8e405" class="ne-codeblock language-python">import qrcode<p>qrcode.make(“不睡觉干嘛呢”).get_image().show() #设置 URL 必须添加 http://</pre><p id="90d8f3edb17610adee15dcc81d8f59ee" class="ne-p"><br></p><h3 id="6ef799f7-1"><span class="ne-text">qrcode 一行字二维码</span></h3><p id="6b21b559a6eec9276922d3b9fead3f9b" class="ne-p"><br></p><pre data-language="python" id="1f424315" class="ne-codeblock language-python">import qrcode</p><p>text = input(“输入文字或 URL：”)<br>img =qrcode.make(text)<br>img.save()                            #保存图片至本地目录，可以设定路径<br>img.show()</pre><p id="ed7556b5eb110f98fd4c55c438bbb372" class="ne-p"><br></p><h3 id="2915ed48"><span class="ne-text">qrcode 生成 logo 二维码</span></h3><p id="c551995531d4811dc8aea45b124a88af" class="ne-p"><br></p><pre data-language="python" id="9e7a0317" class="ne-codeblock language-python">from PIL import Image<br>import qrcode,os</p><p>def create_qrcode(url,qrcodename):<br>qr = qrcode.QRCode(<br>version=1, # 设置容错率为最高<br>error_correction=qrcode.ERROR_CORRECT_H, # 用于控制二维码的错误纠正程度<br>box_size=8, # 控制二维码中每个格子的像素数，默认为 10<br>border=1, # 二维码四周留白，包含的格子数，默认为 4<br>#image_factory=None, 保存在模块根目录的 image 文件夹下<br>#mask_pattern=None<br>)</p><pre><code>qr.add_data(url) # QRCode.add_data(data)函数添加数据qr.make(fit=True)  # QRCode.make(fit=True)函数生成图片img = qr.make_image()img = img.convert(&quot;RGBA&quot;) # 二维码设为彩色logo = Image.open(&#39;xx.jpg&#39;) # 传gif生成的二维码也是没有动态效果的w , h = img.sizelogo_w , logo_h = logo.sizefactor = 4   # 默认logo最大设为图片的四分之一s_w = int(w / factor)s_h = int(h / factor)if logo_w &gt; s_w or logo_h &gt; s_h:    logo_w = s_w    logo_h = s_hlogo = logo.resize((logo_w, logo_h), Image.ANTIALIAS)l_w = int((w - logo_w) / 2)l_h = int((h - logo_h) / 2)logo = logo.convert(&quot;RGBA&quot;)img.paste(logo, (l_w, l_h), logo)img.show()img.save(os.getcwd()+&#39;/&#39; + qrcodename + &#39;.png&#39;, quality=100)&lt;/pre&gt;&lt;p id=&quot;1cceb12f9d94fae140f68e18060de1ef&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;h3 id=&quot;68412b23&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;myqr动态二维码&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;8b4531183dec82761497329f38f5b2ee&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;pre data-language=&quot;plain&quot; id=&quot;ab8d3156&quot; class=&quot;ne-codeblock language-plain&quot;&gt;相关参数：words：二维码内容，链接或者句子version：二维码大小，范围为[1,40]level：二维码纠错级别，范围为&#123;L,M,Q,H&#125;，H为最高级，默认。picture：自定义二维码背景图，支持格式为 .jpg，.png，.bmp，.gif，默认为黑白色colorized：二维码背景颜色，默认为 False，即黑白色contrast：对比度，值越高对比度越高，默认为 1.0brightness：亮度，值越高亮度越高，默认为 1.0，值常和对比度相同save_name：二维码名称，默认为 qrcode.pngsave_dir：二维码路径，默认为程序工作路径&lt;/pre&gt;&lt;p id=&quot;56fd137fc8a2f287c0e0b04341f81231&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;pre data-language=&quot;python&quot; id=&quot;2873793f&quot; class=&quot;ne-codeblock language-python&quot;&gt;# 调用库</code></pre><p>from MyQR import myqr</p><h1 id="函数部分"><a href="#函数部分" class="headerlink" title="函数部分"></a>函数部分</h1><p>myqr.run( # 网址<br>words=’<a href="https://wztlink1013.com&/#39;">https://wztlink1013.com&#39;</a>, # 控制边长，范围是 1 到 40，数字越大边长越大，默认边长是取决于你输入的信息的长度和使用的纠错等级<br>version=5, # 控制纠错水平，范围是 L、M、Q、H，从左到右依次升高<br>level=’H’, # 将 QR 二维码图像与一张同目录下的图片相结合，此处设置该图片，可以是 gif<br>picture=’./input/girl.gif’, # 默认是黑白(False)，可以选择彩色(True)<br>colorized=True, # 调节图片的对比度，1.0 表示原始图片，更小的值表示更低对比度，更大反之。默认为 1.0。<br>contrast=1.0, # 调节图片的亮度，用法与 contrast 相同<br>brightness=1.0, # 输出文件名，格式可以是 jpg，png，bmp，gif<br>save_name=’girl.gif’,<br>save_dir=’./output’)</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/blog/eywygo/"/>
      <url>/blog/eywygo/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="1wZ8H"><span class="ne-text">一、面向对象思考</span></h2><p id="u7554e2f3" class="ne-p"><br></p><h3 id="s8rdr"><span class="ne-text">思想</span></h3><div class="ne-quote"><p id="211427836ec509f2622ec9d08aa8fedd" class="ne-p"><span class="ne-text">就像是手工设计动态数组、链表等数据结构一样，要用</span><strong><span class="ne-text">设计</span></strong><span class="ne-text">这个字眼去面向对象思考。</span></p><p id="d0dc6c5c0be539111fd0c276fbf15f8c" class="ne-p"><span class="ne-text">同时还要关注类与类之间的关系有关联、聚集、组合，在设计多个类的过程中要有这些意识</span></p></div><p id="405b7f8ebc4270cb7f0de4ac35865edc" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600086611076-d83aa284-7977-447d-9b25-0a0a67a12c3f.png" width="501.5" id="NWYR1" class="ne-image"></p><p id="6983c00ad0f82b0bcc139fafb2ababf7" class="ne-p" style="text-align: left"><span class="ne-text">就像是之前的数据结构课程一样，像那样就是面向过程，全都是写函数来实现操作</span></p><h3 id="BC2lr"><span class="ne-text">基本数据类型值及其包装类</span></h3><div class="ne-quote"><p id="49a4297fd4e58ddedfb232196eab45d5" class="ne-p"><span class="ne-text">都存在java.lang里面</span></p></div><p id="e83c85ae6c81425f659cf03bc66eb30b" class="ne-p"><span class="ne-text">Integer、Long、Float、Double、Boolean、Character、Short、Byte</span></p><p id="9df1f6ac5a301638ae38e27d810e2482" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600087287006-c480d8fd-a6b5-4be9-bc43-3023e9fa4a0c.png" width="494.5" id="fgi7A" class="ne-image"></p><div class="ne-quote"><p id="5507f7c0b5139313b32769fb46cb429f" class="ne-p"><span class="ne-text">基本数据类型和其对象化之后的包装类类型之间的自动转换</span></p></div><p id="c09f1b334dc8c713bf2d845ca2d826c7" class="ne-p"><code class="ne-code"><span class="ne-text">Integer intObject = new Integer (2);</span></code><span class="ne-text">  等价于 </span><code class="ne-code"><span class="ne-text">Integer intObject = 2;</span></code></p><div class="ne-quote"><p id="e52d16157e729e82227b20ba87df60a2" class="ne-p"><span class="ne-text">BigInteger 类和BigDeciml类用于表示任意大小和精度的整数或是二进制数</span></p></div><h2 id="l8hNI"><span class="ne-text">二、对象和类</span></h2><p id="5e6b7d98ed607486250e35c35f8fa6f0" class="ne-p"><br></p><h3 id="906a449b"><span class="ne-text">OOP阶梯图</span></h3><p id="bd0bc805dc8520df4ac2609a60ecbae6" class="ne-p"><br></p><div class="ne-quote"><p id="ac63916c9c34a07bce126c664303e837" class="ne-p"><span class="ne-text">“OOP阶梯图”—— 类的多个特性，同时以对象对基础</span></p></div><p id="cb43303427ae402236e24111d60148c6" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636493-3aecdbf5-1f94-4076-99dc-0ef0dac07331.png" width="396" id="YkXtT" class="ne-image"></p><p id="cfe7eefc15bdc987f6e2eb698d861c9f" class="ne-p"><br></p><h3 id="6565c177"><span class="ne-text">类的组成</span></h3><div class="ne-quote"><p id="39e74c9750afecf01becb77046505dc3" class="ne-p"><span class="ne-text">数据域、构造函数、方法（C++里面的说法是数据成员和成员函数）</span></p><p id="7a61a585ce490b7c9b158e085c036943" class="ne-p"><strong><span class="ne-text">类中不能存在可执行语句</span></strong></p></div><p id="102cc5587b09ef81aa956e8f131282e5" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636459-572d60ff-0740-4487-b3fd-9e2fa94b643f.png" width="482" id="pUnxB" class="ne-image"></p><h3 id="81b1781e"><span class="ne-text">构造函数</span></h3><ul class="ne-ul"><li id="06cff58237f450ecce68ebd23933e49c"><span class="ne-text">和类同名、重载、没有返回值</span></li></ul><p id="c2f2aaa51e26c816d02f8b7406dd516a" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636454-ce95b4aa-9966-4024-82ae-b7cc296097db.png" width="321" id="yocVH" class="ne-image"></p><ul class="ne-ul"><li id="325bf5bdc9feed420fb40831d8e87b03"><strong><span class="ne-text">构造函数初始化优先级</span></strong></li></ul><div class="ne-quote"><ol class="ne-ol"><li id="47da672e43499734e6b6ad8295930987"><span class="ne-text">静态成员变量初始化顺序高于非静态成员变量</span></li><li id="826ad49b485166e4ec8c28ed7b235c77"><span class="ne-text">成员变量的初始化顺序优于构造函数</span></li><li id="b90209d4e5c3c9456062aed4ef716193"><span class="ne-text">静态成员变量只初始化一次，就是第一次被访问的时候</span></li><li id="ca998545cd713ef6d259be26f4fd08ab"><span class="ne-text">存在多个静态成员变量的时候，按照次序依次执行</span></li></ol></div><p id="1b68705f1714689fc280c0f416cfbcba" class="ne-p"><br></p><p id="3c2dedb5b6e7c347e41935af7452f6c0" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636495-c0c2fdf5-3919-475e-a2f7-a3888d97492d.png" width="441" id="sbHzG" class="ne-image"></p><p id="87d804df0e9be7ceeb1d31cf346dc9ef" class="ne-p"><br></p><pre data-language="java" id="5e7823a9" class="ne-codeblock language-java">Window(2)<p>Window(1)<br>Window(2)<br>Window(3)<br>House()<br>Window(33)<br>f()</pre><h3 id="d370f29b"><span class="ne-text">数据域的默认值</span></h3><p id="49b379390616d0b50433996d8a9cf833" class="ne-p"><br></p><div class="ne-quote"><p id="096b16213c564543e9f82bf86efc1ad3" class="ne-p"><strong><span class="ne-text">对于对象而言，不赋值也会有默认的</span></strong><span class="ne-text">。之前的数组就是如此</span></p></div><p id="f1740f26d8a822648591f52af737a335" class="ne-p"><br></p><p id="a097998937fee72fa15a01e8f1e3b07a" class="ne-p"><span class="ne-text">各个数据域按照之前的基本上的默认初值，如果是其他的类型，则空</span></p><h3 id="f16d08eb"><span class="ne-text">对象的创建和访问</span></h3><div class="ne-quote"><ol class="ne-ol"><li id="f635cd50459d9f5e863b48b757481fc4"><span class="ne-text">通过引用变量来访问对象，创建的类的对象被内存分配了内存空间，可以用引用变量来访问</span></li><li id="e7e70313f481026c64ae8c029f910136"><strong><span class="ne-text">对象类型都需要用 new 来新建</span></strong></li></ol></div><pre data-language="java" id="OtMgY" class="ne-codeblock language-java">ClassName objectRefVar = new ClassName();</p><p>Circle myCircle = new Circle();</pre><p id="9cef77f1626d6ebfe841f3b696a3702c" class="ne-p"><br></p><p id="261ea8a37dc6d09b9ced7d69deae7c0e" class="ne-p"><strong><span class="ne-text">使用成员变量和成员函数</span></strong></p><pre data-language="java" id="aAqT9" class="ne-codeblock language-java">mycircle.radius<br>mycircle.getArea()</pre><p id="755d9559751c63b4e7b954b6f9b748b9" class="ne-p"><br></p><p id="9980d246b4f314f805cb5af18c33fffa" class="ne-p"><strong><span class="ne-text">调用静态函数，动态函数需要在自己类下面调用自己的函数</span></strong></p><h3 id="DjjQL"><span class="ne-text">“炸宿舍”</span></h3><div class="ne-quote"><p id="7452cf4e0ec6614b911b97281df8e336" class="ne-p"><span class="ne-text">关于老师提出来的炸宿舍例子</span></p></div><p id="1bbc7a7ec0b97df1615374585302c6bb" class="ne-p"><br></p><p id="09ca8400bffa9d03f1c9ba0837e5f3a1" class="ne-p"><strong><span class="ne-text">对象间的赋值和基本类型的赋值，能改变的一定是基本数值类型，所谓的数组名抑或是对象名，都只是地址映射</span></strong></p><p id="a444ed3d5f4288bf76bb5926549f332a" class="ne-p"><br></p><h3 id="fbf314e8"><span class="ne-text">垃圾回收机制和 this</span></h3><pre data-language="java" id="S9trD" class="ne-codeblock language-java">System.gc(); // 提醒垃圾回收</pre><p id="dbb47a0cbce9893e04d546db3f6c14af" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600086346479-3cc546b6-dab8-4fc5-a352-8f2fb2ea8065.png" width="480" id="GZtwv" class="ne-image"></p><h3 id="749b9660"><span class="ne-text">静态变量、常量和方法</span></h3><div class="ne-quote"><p id="158734f34b1414b11f2a2a26930bf2b1" class="ne-p"><span class="ne-text">静态成员变量：静态成员变量可以被类的所有实例共享（比如计数变量用到）</span></p><p id="7bb2e66bfc0724af6e4fb145e239bff0" class="ne-p"><span class="ne-text">静态方法：不能访问类的实例成员</span></p><p id="6e1f2881172d329f1c465fd54d363e85" class="ne-p"><span class="ne-text">关于静态变量、静态方法、实例变量、实例方法</span></p></div><h3 id="3259401b"><span class="ne-text">可见性修饰符</span></h3><p id="b74fe4875219c7a9d279942c20c20d3c" class="ne-p"><br></p><p id="141c64de8b53347e49448ccb3f2d0953" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686637158-0b08a6a1-5cd8-4aac-9133-1ad101cc8a52.png" width="491" id="h729N" class="ne-image"></p><p id="4f64bca697a16b8c1598036796326608" class="ne-p"><br></p><h3 id="cf65091d"><span class="ne-text">“析构函数”</span></h3><p id="b874b4e9f4c91bd8c7c0b1607d6a56b2" class="ne-p"><br></p><pre data-language="java" id="db88ce23" class="ne-codeblock language-java">protected void finalize() throwsable {<br>super.finalize();<br>System.out.println("Person - finalize");<br>}</pre><p id="dd8fa05d8feab1cda081705a54904dd4" class="ne-p"><br></p><h3 id="94e0e403"><span class="ne-text">内部类</span></h3><p id="287ad1c49ac85b2113793cf19d6c1af1" class="ne-p"><br></p><p id="49907d7f616073980255671481afbfad" class="ne-p"><span class="ne-text">内部类只给该类使用（私有自己用，同时写静态的），就如 LinkedList 类的设计</span></p><h2 id="395285bb"></h2></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础知识</title>
      <link href="/blog/esofty/"/>
      <url>/blog/esofty/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="ql5Mg"><span class="ne-text">一、关于JAVA</span></h2><h3 id="ed9e5ca1"><span class="ne-text">Java和C和C++</span></h3><p id="ccd8e63159edceb17178c218367bc3f2" class="ne-p"><br></p><ol class="ne-ol"><li id="698cd8933b365e5b8cf4332b7f54f884"><span class="ne-text">c是面向过程的语言。c++和Java都是面向对象的。在c中没有类或者对象的概念。</span></li><li id="7aa0b30f75d6c7b94713e4b0ae4d68e6"><span class="ne-text">java运行在虚拟机上，号称与平台无关。也就是你开发的java程序无论是unix，linux还是windows都可以正常运行。但是实际上这是一个良好的愿望，实际跨平台时还会有各种各样的问题。c和c++都是直接编译成可执行文件，是否能跨平台主要看你用到的编译器特性是否有多平台支持。</span></li><li id="35663555ece757a13ba0160984cd967b"><span class="ne-text">因为c和c是直接编译成可执行文件，所以运行效率要比java高。至于c和c哪个更快，两种语言的拥趸已经吵了很多年。</span></li><li id="7ad027c5cbb2c8bde150fbefcfc1ada1"><span class="ne-text">java因为是运行在虚拟机上，不需要考虑内存管理和垃圾回收机制。也是就你可以声明一个对象而不用考虑释放他，虚拟机帮你做这事情。而c和c语言本身没有多少内存管理的概念，写c和c程序如果用到指针就一定要考虑内存申请和释放。内存泄漏是c和c++最头疼的问题。</span></li><li id="671344b8037dc8e5c03c14d4e149dbf3"><span class="ne-text">代码重用：java中有一个根类object，所有的类都是其子类，通过这种方式将容器和算法分离，实现一种操作作用于多种对象，提高代码重用。c中没有总根对象，但是c提供了另一个更强大的功能“模板”，同样高效地实现了一种操作作用于多种对象，提供了高效的代码重用方法。</span></li><li id="5a55af800fd882ca6767aced5e786e64"><span class="ne-text">数据结构：java内建了丰富的数据结构：列表，集合等等（很久没用java了，有些记不太清）。而c++则用“模板”同样提供了各种数据结构（容器）。</span></li><li id="4a85ea95f6665b68a74c91f296ebb8ef"><span class="ne-text">c语言在一些比较低层，和硬件打交道的地方用得比较多。另外很多开源软件由于unix/linux开发习惯也大多采用c来开发。Java是现在最流行的开发语言，c++比起java稍稍不那么流行一些，但是功能很强大。如能深入掌握，可以写出兼顾效率和美观的优秀代码。</span></li></ol><p id="539d215e3b4b6eb82efd60f12d42e3e9" class="ne-p"><br></p><h3 id="7a35a8d1"><span class="ne-text">多语言简略对比</span></h3><p id="b3de2788b6aa2da04eada8c990df7573" class="ne-p"><br></p><div class="ne-quote"><p id="0f32c20e39f4d4f82c95a88e719b5b89" class="ne-p"><strong><span class="ne-text">Ideas are cheap, show me the code</span></strong><span class="ne-text">  学到了，学到了~</span></p></div><p id="598300285116db515bbf9af11683f9cf" class="ne-p"><br></p><pre data-language="plain" id="73b81d74" class="ne-codeblock language-plain">代码块：python通过缩进来确定代码块<p>复数：java、python 有，C、Cplusplus 没有<br>python：相对于 java，python 就是 java 的压缩版本<br>包、接口、API：我觉得 java 也好，python 也好，正是因为这些模块组件化，才使得这些语言好很好的的健壮性</pre><p id="c73bade17b01fa82e1e94ced63400cdc" class="ne-p"><br></p><h2 id="0c1eaf47"><span class="ne-text">二、数据类型；运算符；表达式</span></h2><h3 id="3787f6af"><span class="ne-text">基本数据类型</span></h3><div class="ne-quote"><p id="7bda25f24a20dc222165486ea714bedc" class="ne-p"><span class="ne-text">常量、标识符和变量、数据类型</span></p></div><div class="ne-quote"><p id="3f2bc39d8d91deda8ece0b3d1a28fe73" class="ne-p"><strong><span class="ne-text">JAVA 中除了下面 8 种数据类型其他的都是以对象（或者说类的实例）存在的</span></strong></p></div><ul class="ne-ul"><li id="129972189685aac88a76a73a231d2c0f"><span class="ne-text">string：要熟悉常用的函数</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="c49a204e4968daffdceb6e354b31c99d"><span class="ne-text">length()：字符串的长度</span></li><li id="2a4f608990ed45be4166eef6351e0dc5"><span class="ne-text">charAt(i)：取字符串的第 i 个元素</span></li></ul></ul><ul class="ne-ul"><li id="f18c4c85809c8a56b0cf1459adf725d1"><span class="ne-text">boolean（java 中需要全部写出来）</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="03ea7bcc64dfab7902061fdcac00cd58"><code class="ne-code"><span class="ne-text">true</span></code></li><li id="dd94539ec68f3f034f1ba835aa609a22"><code class="ne-code"><span class="ne-text">false</span></code></li></ul></ul><ul class="ne-ul"><li id="310eb6ecb40ffc2639e36ea95f0e8995"><span class="ne-text">下面 6 中数值型数据类型</span></li></ul><p id="6bf32b47b37e76c47b7124d446ce83ac" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686524193-b62199d3-9dc6-4caa-a3c1-2484c7d6185c.png" width="418" id="dyqgY" class="ne-image"></p><p id="d071baed3a3c06a3d1b1245812c09732" class="ne-p"><br></p><h3 id="794caa2a"><span class="ne-text">运算符和表达式</span></h3><ul class="ne-ul"><li id="07bb8f6ea6cacc31dbc25707f4ad028e"><span class="ne-text">赋值语句，赋值表达式</span></li><li id="5871557d73ee3bef1d11f26ae90c7c79"><span class="ne-text">输入输出：</span><strong><span class="ne-text">输入输出，要有记得清除的空间，close 的意识！</span></strong></li></ul><pre data-language="java" id="00abfd55" class="ne-codeblock language-java">// 方式一<br>import java.util.Scanner;</p><p>Scanner input = new Scanner(System.in);<br>double radius = input.nextDouble();</p><p>// 方式二 : 好处就是避免项目工程中类当中重名的情况<br>java.util.Scanner input = new java.util.Scanner(System.in);<br>double radius = input.nextDouble();</pre><p id="73c8bc3c5ef4d3b679a4a2d1c62fcebf" class="ne-p"><br></p><ul class="ne-ul"><li id="594bd46047eafe0bce50530344cfc631"><span class="ne-text">数值运算符</span></li></ul><div class="ne-quote"><p id="4188bb7db8158fdbc3ab5c1b44130d37" class="ne-p"><span class="ne-text">+、-、*、/、%</span></p></div><ul class="ne-ul"><li id="26f0a7d86406433d6c6f3eb2de66f565"><span class="ne-text">逻辑运算符<br></span><code class="ne-code"><span class="ne-text">&&</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">||</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">!</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">^</span></code><span class="ne-text">(异或：相同才为假)<br></span><code class="ne-code"><span class="ne-text">&</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">|</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">^</span></code><span class="ne-text"> 位运算符：会先化成二进制对二进制码进行分析</span></li><li id="79c033ed8cd8d971c31a53628b12bd03"><span class="ne-text">运算符的优先级</span></li></ul><p id="76fce43108f5d07713aea62528878f86" class="ne-p" style="text-align: center"><span class="ne-text"><br></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523840-d1395ecf-7d3c-416b-8ce8-5d11a0e3f313.png" width="297" id="Dfenb" class="ne-image"></p><p id="4e2484b080566a8460f53f81b7c2e726" class="ne-p"><br></p><h2 id="f387966e"><span class="ne-text">三、程序三大基本结构</span></h2><h3 id="4ebeccc3"><span class="ne-text">顺序结构</span></h3><h3 id="f5dfe658"><span class="ne-text">选择结构</span></h3><p id="f3df1031e9e750bbc09d457e94306eb0" class="ne-p"><br></p><ul class="ne-ul"><li id="a74864ee35d748814a9978d33ed164fb"><span class="ne-text">if(){} else{}</span></li><li id="d67ed33cdd176ebff5d4b081b602078a"><span class="ne-text">switch</span></li></ul><pre data-language="java" id="tRAKO" class="ne-codeblock language-java">public class Test {<br>public static void main(String args[]){<br>//char grade = args[0].charAt(0);<br>char grade = 'C';</p><pre><code>  switch(grade)  &#123;     case &#39;A&#39; :        System.out.println(&quot;优秀&quot;);        break;     case &#39;B&#39; :     case &#39;C&#39; :        System.out.println(&quot;良好&quot;);        break;     case &#39;D&#39; :        System.out.println(&quot;及格&quot;);        break;     case &#39;F&#39; :        System.out.println(&quot;你需要再努力努力&quot;);        break;     default :        System.out.println(&quot;未知等级&quot;);  &#125;  System.out.println(&quot;你的等级是 &quot; + grade);</code></pre><p>}<br>}</pre><p id="20df002ac286d1a65c6ff264a236fa5d" class="ne-p"><br></p><ul class="ne-ul"><li id="ec491077ee36159093176d3e9ae161f1"><strong><span class="ne-text">条件表达式</span></strong></li></ul><pre data-language="java" id="w1TRB" class="ne-codeblock language-java">System.out.println((num % 2 == 0) ? "num is even" : "num is odd");</pre><p id="af4037f23ef3986f2c571bc3db38fcf9" class="ne-p"><br></p><h3 id="037bdbce"><span class="ne-text">循环结构</span></h3><p id="d372f90191d3d74a255dde2aedac4163" class="ne-p"><br></p><ul class="ne-ul"><li id="ee08897ac873410e9300bc7569b45ec3"><span class="ne-text">while () {}</span></li><li id="d8512ea8dfc3a064f68faa5729802615"><span class="ne-text">do {} while ();</span></li><li id="347a6524fd216b0a778b6cdbf75ef226"><span class="ne-text">for () {}</span></li><li id="0bd19a0fa33440fde83eb559d2a5c37d"><span class="ne-text">关于 break（跳出该级别的 for 循环）和 continue（后面的语句不读）</span></li><li id="ef433c6e5dddc34fba80796c61f8083c"><span class="ne-text">关于 return</span></li></ul><p id="75197706801d5d28b3cf8c0cfe18f787" class="ne-p" style="text-align: center"><span class="ne-text"><br></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523958-c57b6b4d-e802-44e1-adc6-276167476c3d.png" width="381" id="WHaFp" class="ne-image"></p><p id="50b9a37069d342a1704b2cc7764c966c" class="ne-p"><br></p><ul class="ne-ul"><li id="8a6329e12a0a08a3d17fd033ee825f5a"><span class="ne-text">关于</span><strong><span class="ne-text">增强的 for 循环</span></strong><span class="ne-text">，在模板章节，配合 vector 使用，并发控制，高效使用</span></li></ul><p id="4dd9deabe9dbc4a0655c5a3eec8ad92e" class="ne-p"><br></p><p id="8394e3fc9537c4a23cf62ef4f262d74b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523773-6d1af202-9aa9-4789-b931-b0671aac432f.png" width="369" id="FC64A" class="ne-image"></p><p id="de8e3ff4e2d542c742574aa65e577f9e" class="ne-p"><span class="ne-text">缺点：看不见索引</span></p><p id="56092ba7e99b6e92f177e0830e74599c" class="ne-p"><br></p><h2 id="99f0d0e9"><span class="ne-text">四、方法</span></h2><p id="ff7625673d51cecb746acb7b8256ce85" class="ne-p"><br></p><p id="0a3536a12e1c22b17f432e7af9a64a85" class="ne-p"><br></p><p id="3928816623d1f9c41a125fa458ab9b06" class="ne-p"><br></p><p id="e799a36524f375f624214a6036e80d97" class="ne-p"><br></p><p id="8f28be14aa85f36befc83eabd9cf2fd6" class="ne-p"><br></p><p id="8b936d0aebb99127b4a31a8031783e78" class="ne-p"><br></p><p id="ebb007c50670c35f910c78847b446a2f" class="ne-p"><br></p><p id="aaf1c2bc32229a445a537490725ad856" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习scikit-learn库的使用</title>
      <link href="/blog/wgv3ak/"/>
      <url>/blog/wgv3ak/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="5bee3f0f"><span class="ne-text">一、机器学习的一些概念</span></h2><h3 id="e2d6d0e3"><span class="ne-text">基本概念</span></h3><ul class="ne-ul"><li id="d2d782db5069f8dae8b6a1bff6271770"><span class="ne-text">特征：一组数据的多个属性</span></li><li id="1ae1f056eb066684a43e6d67b7844f01"><span class="ne-text">标签：人为指定特征</span></li><li id="7a50a4b66cab34d55eca1deb1c1ab1a3"><span class="ne-text">监督学习：就像分类（离散化的标签），回归（连续性的标签）、【“有标准答案”】</span></li><li id="2769fd3cae1a5e79bed5c3269bde5c65"><span class="ne-text">无监督学习：就像聚类【“无标准答案”】</span></li><li id="7581b3163cfaa24b8f99df504d81cd20"><strong><span class="ne-text">数据</span></strong><span class="ne-text">：是机器学习的命脉</span></li></ul><p id="0ceea112001075e31517062efafa3ad8" class="ne-p"><br></p><h3 id="ed38e053"><span class="ne-text">基本框架图</span></h3><p id="eb6bf04abe1d9f83c3ecca43f734d4bf" class="ne-p"><br></p><p id="250704e17a13248b5fb5b23d9d313a66" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686130909-116e16a4-e86a-46e0-93fb-ac0263257056.png" width="453" id="F2NI4" class="ne-image"></p><p id="7a9cfeb28d8dc025f7e248610c39d913" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686131288-431d8fe6-bf3f-4f3e-9986-9b282e9e2982.png" width="475" id="LzfkG" class="ne-image"></p><p id="73e4f1fcaf93d5eeedf210175c8ee3a9" class="ne-p"><br></p><h2 id="a72013d5"><span class="ne-text">二、机器学习的一些阶段/步骤</span></h2><p id="050e76919058cb184eb20ef48961b3b2" class="ne-p"><br></p><h3 id="cef7202b"><span class="ne-text">sklearn相关提及</span></h3><p id="1fafce44ffb6281355e9421dc94c9fc1" class="ne-p"><br></p><p id="9db7f6fb2b04cf93dcc8fa3728c6158f" class="ne-p"><a href="https://scikit-learn.org/stable/testimonials/testimonials.html" data-href="https://scikit-learn.org/stable/testimonials/testimonials.html" target="_blank" class="ne-link"><span class="ne-text">官网scikit-learn</span></a></p><p id="c843d200c3848ad05cc984f83a9d2e3f" class="ne-p"><br></p><ol class="ne-ol"><li id="9805e279fad9f4cd1b787cbb59e6a2bb"><span class="ne-text">包含聚类、分类、回归等算法<p></span><span class="ne-text">eg：随机森林、k-means、SVM 等</span></li><li id="db3038ecab25f3fc24d631311365ae13"><span class="ne-text">包含模型筛选、降维、预处理等算法</span></li><li id="54c678cfeb754645357efec91f999024"><span class="ne-text">要特别注意安装该包使用要注意的细节，具体参考上一篇博客</span></li></ol><p id="2e30cd945612807b08816b4cc33f5568" class="ne-p"><br></p><h3 id="f2bc4819"><span class="ne-text">sklearn 处理机器学习的一般化 sop</span></h3><p id="8022d1c4d586139cc725870d5eacff7c" class="ne-p"><br></p><ol class="ne-ol"><li id="f13ba218c28b3d269d775f7350a0850a"><strong><span class="ne-text">准备数据集</span></strong></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="c5c5f4fda83ea45f98d978991c87d3a3"><span class="ne-text">数据分析</span><span class="ne-text">:（利用 np.reshape()成二维(n_samples,n_features)）</span></li><li id="63a3e4964bdf56bcbc95035f6149e27c"><span class="ne-text">划分数据集：train_test_split()</span></li><li id="59ef378048ac74571cda7c44c98f3898"><span class="ne-text">特征工程：特征的提取、特征的归一化 nomalization</span></li></ul></ul><ol start="2" class="ne-ol"><li id="0c68cc70de7d4b52895bb74e612b045f"><strong><span class="ne-text">选择模型</span></strong></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="afc2714ef64987184b522ea6fa37a2a5"><span class="ne-text">根据不同场景选择合适的模型:</span><a href="https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html" data-href="https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html" target="_blank" class="ne-link"><span class="ne-text">scikit-learn 的模型选择路线图</span></a></li><li id="5d15b30fc6cf661cfbc37d0fb4566861"><span class="ne-text">分类、聚类、回归……</span></li></ul></ul><ol start="3" class="ne-ol"><li id="71e3de310907fb0a10e93040b9ccb56f"><span class="ne-text">在训练集上</span><strong><span class="ne-text">训练模型</span></strong><span class="ne-text">，并调整参数</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="9b9950c6e51e8c6ae10a2fbdd228def1"><span class="ne-text">经验选定参数</span></li><li id="aafbec39c5d8e67ed288bdb0265c67cc"><span class="ne-text">交叉验证确定最优的参数 cross validation</span></li></ul></ul><ol start="4" class="ne-ol"><li id="13143c01f4d80cb1698eafe8386a45c2"><span class="ne-text">在测试集上</span><strong><span class="ne-text">测试模型</span></strong></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="b54f8f021f312942ca8fa6b689cfae53"><span class="ne-text">predict 预测、score 真实值预测值评分、etc</span></li></ul></ul><ol start="5" class="ne-ol"><li id="2d1c2382fe82579fbe51e7f824f435d6"><strong><span class="ne-text">保存模型</span></strong></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="b50eab253057b56bb54f3b3dc5b2ddbd"><code class="ne-code"><span class="ne-text">import pickle</span></code></li></ul></ul><p id="4552fb1bc582283e48711dcd041031d1" class="ne-p"><br></p><h3 id="88197008"><span class="ne-text">主成分分析：将特征降维</span></h3><p id="0d3292eb853d31942b5cda713773fccd" class="ne-p"><br></p><ul class="ne-ul"><li id="be0894fecc9d50b0d38969bb4c9b4641"><span class="ne-text">统计学相关知识：方差（衡量在一个维度的偏差）、协方差（衡量一个维度是否对另一个维度有影响 cov（x，y））</span></li><li id="805bf986765a88e71efddbab8cffecf6"><span class="ne-text">线代相关知识：特征值、特征向量、协方差向量</span></li><li id="a4e955004f4587c2bd327f7dda04414f"><span class="ne-text">PCA</span></li></ul><p id="2d0a46eb2b25603e3431acc63be10047" class="ne-p"><br></p><p id="b8bfe4715d89bd2397f34a17fbc29673" class="ne-p"><a href="http://q5e49p23n.bkt.clouddn.com/scikit_pca.html" data-href="http://q5e49p23n.bkt.clouddn.com/scikit_pca.html" target="_blank" class="ne-link"><span class="ne-text">相关代码 html 页面</span></a></p><p id="14a0b4bf064d45461b9c269466566ec1" class="ne-p"><br></p><h2 id="c85531aa"><span class="ne-text">三、通过 scikit-learn 认识机器学习</span></h2><p id="b9f86893b1532af72bc0fa5deaf7a4c1" class="ne-p"><br></p><h3 id="c11d2053"><span class="ne-text">加载示例数据集</span></h3><p id="72b6c2ed2e671a5e099e132f46ea3a19" class="ne-p"><br></p><pre data-language="python" id="39188184" class="ne-codeblock language-python">from sklearn import datasets<br>iris = datasets.load_iris()#用 sklearn 自身配带的数据<br>digits = datasets.load_digits()</p><h1 id="C-Users-wztli-Anaconda3-pkgs-scikit-learn-0-21-3-py37h6288b17-0-Lib-site-packages-sklearn-datasets-data"><a href="#C-Users-wztli-Anaconda3-pkgs-scikit-learn-0-21-3-py37h6288b17-0-Lib-site-packages-sklearn-datasets-data" class="headerlink" title="C:\Users\wztli\Anaconda3\pkgs\scikit-learn-0.21.3-py37h6288b17_0\Lib\site-packages\sklearn\datasets\data"></a>C:\Users\wztli\Anaconda3\pkgs\scikit-learn-0.21.3-py37h6288b17_0\Lib\site-packages\sklearn\datasets\data</h1><h1 id="数据集在电脑中的位置-查看数据集"><a href="#数据集在电脑中的位置-查看数据集" class="headerlink" title="数据集在电脑中的位置# 查看数据集"></a>数据集在电脑中的位置</pre><p id="69e1a15bea11fdcf845239a8237db4c4" class="ne-p"><br></p><pre data-language="python" id="fe71e276" class="ne-codeblock language-python"># 查看数据集</h1><h1 id="iris"><a href="#iris" class="headerlink" title="iris"></a>iris</h1><p>print(iris.data[:5])<br>print(iris.data.shape)<br>print(iris.target_names)<br>print(iris.target)</pre><p id="2c82c2a79829d6250f8aae3e4415a676" class="ne-p"><br></p><pre data-language="python" id="6c1a82be" class="ne-codeblock language-python">[[5.1 3.5 1.4 0.2]<br> [4.9 3.  1.4 0.2]<br> [4.7 3.2 1.3 0.2]<br> [4.6 3.1 1.5 0.2]<br> [5.  3.6 1.4 0.2]]<br>(150, 4)<br>['setosa' 'versicolor' 'virginica']<br>[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1<br>1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2<br>2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2<br>2 2]</pre><p id="75fb5f18a8ca61a6d2f8d213b9a93ea0" class="ne-p"><br></p><pre data-language="python" id="76a6509c" class="ne-codeblock language-python"># digits<br>print(digits.data)<br>print(digits.data.shape)<br>print(digits.target_names)<br>print(digits.target)</pre><p id="c08e4f227e41ac1048417c7eba4443a6" class="ne-p"><br></p><pre data-language="python" id="ed329957" class="ne-codeblock language-python">[[0.  0.  5. ...  0.  0.  0.]<br> [ 0.  0.  0. ... 10.  0.  0.]<br> [ 0.  0.  0. ... 16.  9.  0.]<br> ...<br> [ 0.  0.  1. ...  6.  0.  0.]<br> [ 0.  0.  2. ... 12.  0.  0.]<br> [ 0.  0. 10. ... 12.  1.  0.]]<br>(1797, 64)<br>[0 1 2 3 4 5 6 7 8 9]<br>[0 1 2 ... 8 9 8]</pre><p id="6bb801e7672fafcf2402ad8b2eada8b9" class="ne-p"><br></p><h3 id="2e430784"><span class="ne-text">在训练集上训练模型</span></h3><p id="ea0bd901af9a5698d87611a8431800f7" class="ne-p"><br></p><pre data-language="python" id="0093a4fb" class="ne-codeblock language-python"># 手动划分训练集、测试集<br>n_test = 100 # 测试样本个数<br>train_X = digits.data[:-n_test, :]<br>train_y = digits.target[:-n_test]</p><p>test_X = digits.data[-n_test:, :]<br>y_true = digits.target[-n_test:]</pre><p id="4c84d82408c9a7607fdde54aab1c5fea" class="ne-p"><br></p><pre data-language="python" id="2f828cd8" class="ne-codeblock language-python"># 选择 SVM 模型<br>from sklearn import svm</p><p>svm_model = svm.SVC(gamma=0.001, C=100.)</p><h1 id="svm-model-svm-SVC-gamma-100-C-1"><a href="#svm-model-svm-SVC-gamma-100-C-1" class="headerlink" title="svm_model = svm.SVC(gamma=100., C=1.)"></a>svm_model = svm.SVC(gamma=100., C=1.)</h1><h1 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h1><p>svm_model.fit(train_X, train_y) #训练要放入两个参数：样本的特征数据，样本的标签</pre><p id="8966759209375247b0896c8e7ec13b52" class="ne-p"><br></p><pre data-language="python" id="d425e330" class="ne-codeblock language-python">SVC(C=100.0, cache_size=200, class_weight=None, coef0=0.0,<br>decision_function_shape='ovr', degree=3, gamma=0.001, kernel='rbf',<br>max_iter=-1, probability=False, random_state=None, shrinking=True,<br>tol=0.001, verbose=False)</pre><p id="3143848dcca4492177329a5a5bd3dd8b" class="ne-p"><br></p><pre data-language="python" id="b0f2ef5b" class="ne-codeblock language-python"># 选择 LR（逻辑回归）模型<br>from sklearn.linear_model import LogisticRegression</p><p>lr_model = LogisticRegression()</p><h1 id="训练模型-1"><a href="#训练模型-1" class="headerlink" title="训练模型"></a>训练模型</h1><p>lr_model.fit(train_X, train_y)</pre><p id="c24ae4e4bd254df0142100716c8430b4" class="ne-p"><br></p><pre data-language="python" id="268e3d8f" class="ne-codeblock language-python">C:\Users\wztli\Anaconda3\lib\site-packages\sklearn\linear_model\logistic.py:432: FutureWarning: Default solver will be changed to 'lbfgs' in 0.22. Specify a solver to silence this warning.<br>FutureWarning)<br>C:\Users\wztli\Anaconda3\lib\site-packages\sklearn\linear_model\logistic.py:469: FutureWarning: Default multi_class will be changed to 'auto' in 0.22. Specify the multi_class option to silence this warning.<br>"this warning.", FutureWarning)</p><p>LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,<br>intercept_scaling=1, l1_ratio=None, max_iter=100,<br>multi_class=’warn’, n_jobs=None, penalty=’l2’,<br>random_state=None, solver=’warn’, tol=0.0001, verbose=0,<br>warm_start=False)</pre><p id="b50e7f4b41f61ea572f7d7f4c695e57a" class="ne-p"><br></p><h3 id="fedce9bc"><span class="ne-text">在测试集上测试模型</span></h3><p id="4fa0e85e0eb9c3fcd97c3ac317840bbb" class="ne-p"><br></p><pre data-language="python" id="dd6817a7" class="ne-codeblock language-python">y_pred_svm = svm_model.predict(test_X)<br>y_pred_lr = lr_model.predict(test_X)</pre><p id="7cfc4933ab8163a87e6df6d42796f957" class="ne-p"><br></p><pre data-language="python" id="490d0d5b" class="ne-codeblock language-python"># 查看结果</p><h1 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h1><p>from sklearn.metrics import accuracy_score</p><p>#print ‘预测标签：’, y_pred<br>#print ‘真实标签：’, y_true</p><p>print(‘SVM 结果：’, accuracy_score(y_true, y_pred_svm))<br>print(‘LR 结果：’, accuracy_score(y_true, y_pred_lr))</pre><p id="c3283b91cc35ef6836bbf6f1e7e2b30f" class="ne-p"><br></p><pre data-language="python" id="46f01b6c" class="ne-codeblock language-python">SVM 结果： 0.98<br>LR 结果： 0.94</pre><p id="ae4787e0e9369132023f669d68bcff3a" class="ne-p"><br></p><h3 id="2368cbf8"><span class="ne-text">保存模型</span></h3><p id="711dfa9304a4069ee9c72dbaf8af9914" class="ne-p"><br></p><pre data-language="python" id="1b5ea740" class="ne-codeblock language-python">import pickle</p><p>with open(‘svm_model.pkl’, ‘wb’) as f:<br>pickle.dump(svm_model, f)</pre><p id="393f058aef4b4b4fce8c679b3ddeca2d" class="ne-p"><br></p><pre data-language="python" id="84f4c044" class="ne-codeblock language-python">import numpy as np</p><h1 id="重新加载模型进行预测"><a href="#重新加载模型进行预测" class="headerlink" title="重新加载模型进行预测"></a>重新加载模型进行预测</h1><p>with open(‘svm_model.pkl’, ‘rb’) as f:<br>model = pickle.load(f)</p><p>random_samples_index = np.random.randint(0, 1796, 5)<br>random_samples = digits.data[random_samples_index, :]<br>random_targets = digits.target[random_samples_index]</p><p>random_predict = model.predict(random_samples)</p><p>print(random_predict)<br>print(random_targets)</pre><p id="f22dffbb49c54ba3a3375c22a1e1780d" class="ne-p"><br></p><pre data-language="python" id="cdcf5a6d" class="ne-codeblock language-python">[2 2 1 3 8]<br>[2 2 1 3 8]</pre><p id="daa5b608f7016bc41e60043754db5b5b" class="ne-p"><br></p><p id="253af5b5a05a4f63bd2da5ada2ab7b42" class="ne-p"><br></p><h2 id="5ca8154b"><span class="ne-text">四、scikit-learn 入门</span></h2><p id="0e97c0d59899fdd888caa6fdaf4ac7b0" class="ne-p"><br></p><h3 id="15d049a5"><span class="ne-text">准备数据集</span></h3><p id="e87a310596dcc968db1d5ce53a065989" class="ne-p"><br></p><pre data-language="python" id="0f634997" class="ne-codeblock language-python">import numpy as np<br>from sklearn.model_selection import train_test_split</pre><p id="677abb17e30637609cf15d18fe4548bb" class="ne-p"><br></p><pre data-language="python" id="56603efa" class="ne-codeblock language-python">X = np.random.randint(0, 100, (10, 4))<br>y = np.random.randint(0, 4, 10)<br>y.sort()</p><p>print(‘样本：’)<br>print(X)<br>print(‘标签：’, y)</pre><p id="543b06ac3de2b0f9c100c41a0a5c2290" class="ne-p"><br></p><pre data-language="python" id="38df60c4" class="ne-codeblock language-python">样本：<br>[[43 43 18 78]<br> [74 24 42 37]<br> [36 69 84 47]<br> [70 62 77 30]<br> [87 38  3 96]<br> [68 67 24  7]<br> [66 36 72 72]<br> [12 94 87 72]<br> [66  5 92  6]<br> [41 59 60 91]]<br>标签： [0 0 0 2 2 2 2 3 3 3]</pre><p id="f5dd0524eabf3f9400602f9a46a7e5e8" class="ne-p"><br></p><pre data-language="python" id="b670cb91" class="ne-codeblock language-python"># 分割训练集、测试集</p><h1 id="random-state-确保每次随机分割得到相同的结果"><a href="#random-state-确保每次随机分割得到相同的结果" class="headerlink" title="random_state 确保每次随机分割得到相同的结果"></a>random_state 确保每次随机分割得到相同的结果</h1><p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=7)</p><p>print(‘训练集：’)<br>print(X_train)<br>print(y_train)</p><p>print(‘测试集：’)<br>print(X_test)<br>print(y_test)</pre><p id="48e56a34adc66c2e5c55c3c9d74fd27f" class="ne-p"><br></p><pre data-language="python" id="78c7804e" class="ne-codeblock language-python">训练集：<br>[[63 56  7 42]<br> [40 47 17 23]<br> [41 31 26  8]<br> [79 30 22 88]<br> [54 85 48 54]<br> [89 73 77 41]]<br>[0 1 1 0 1 1]<br>测试集：<br>[[3  0 42 86]<br> [42 96 83 38]<br> [33 45  8 37]<br> [ 1 44 75  7]]<br>[1 1 0 0]</pre><p id="6770977ecd10dd5d619ab1d28996764e" class="ne-p"><br></p><pre data-language="python" id="51aba882" class="ne-codeblock language-python"># 特征归一化<br>from sklearn import preprocessing</p><p>x1 = np.random.randint(0, 1000, 5).reshape(5,1)<br>x2 = np.random.randint(0, 10, 5).reshape(5, 1)<br>x3 = np.random.randint(0, 100000, 5).reshape(5, 1)</p><p>X = np.concatenate([x1, x2, x3], axis=1)<br>print(X)</pre><p id="85bc1e247acd1d16e6b704dd5da2a813" class="ne-p"><br></p><pre data-language="python" id="e006d96b" class="ne-codeblock language-python">[[353     4 27241]<br> [  999     4 34684]<br> [  911     4 78606]<br> [  310     6 44593]<br> [  817     9  6356]]</pre><p id="dc10186fca14068b5fe5986e09b9f92f" class="ne-p"><br></p><pre data-language="python" id="1d8e9453" class="ne-codeblock language-python">print(preprocessing.scale(X))</pre><p id="430c7a343ef9d25ac1541ef957180558" class="ne-p"><br></p><pre data-language="python" id="1190a7c9" class="ne-codeblock language-python">[[-1.12443958 -0.71443451 -0.46550183]<br> [ 1.11060033 -0.71443451 -0.15209341]<br> [ 0.80613669 -0.71443451  1.69736578]<br> [-1.27321159  0.30618622  0.26515287]<br> [ 0.48091416  1.83711731 -1.34492342]]</pre><p id="204053c1a3a2c98fa486d34865ead442" class="ne-p"><br></p><pre data-language="python" id="e44c6095" class="ne-codeblock language-python"># 生成分类数据进行验证 scale 的必要性<br>from sklearn.datasets import make_classification<br>import matplotlib.pyplot as plt<br>%matplotlib inline</p><p>X, y = make_classification(n_samples=300, n_features=2, n_redundant=0, n_informative=2,<br>random_state=25, n_clusters_per_class=1, scale=100)</p><p>plt.scatter(X[:,0], X[:,1], c=y)<br>plt.show()</pre><p id="df434115680152f8ffa701ec8283165a" class="ne-p"><br></p><p id="584acfcd9658a334d1253064bd0c0394" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686130636-3a18d8f2-51cb-4b04-8a0f-a40cf1d0b9b6.png" width="384" id="BKtnM" class="ne-image"></p><p id="15c96f58169f6c9d950cfa7e385d4eb4" class="ne-p"><br></p><pre data-language="python" id="9f7881f7" class="ne-codeblock language-python">from sklearn import svm</p><h1 id="注释掉以下这句表示不进行特征归一化"><a href="#注释掉以下这句表示不进行特征归一化" class="headerlink" title="注释掉以下这句表示不进行特征归一化"></a>注释掉以下这句表示不进行特征归一化</h1><p>X = preprocessing.scale(X)</p><p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=7)<br>svm_classifier = svm.SVC()<br>svm_classifier.fit(X_train, y_train)<br>svm_classifier.score(X_test, y_test)</pre><p id="cd9793129aa04ea0d6f6c35636421e24" class="ne-p"><br></p><pre data-language="python" id="b57502f9" class="ne-codeblock language-python">C:\Users\wztli\Anaconda3\lib\site-packages\sklearn\svm\base.py:193: FutureWarning: The default value of gamma will change from 'auto' to 'scale' in version 0.22 to account better for unscaled features. Set gamma explicitly to 'auto' or 'scale' to avoid this warning.<br>"avoid this warning.", FutureWarning)</p><p>0.25</pre><p id="64d401b7c2e36d9ed5539dd517136770" class="ne-p"><br></p><h3 id="a162534b"><span class="ne-text">训练模型</span></h3><p id="dd2ce1398f6117ba5ca42c6d622ed617" class="ne-p"><br></p><pre data-language="python" id="04ca9595" class="ne-codeblock language-python"># 回归模型<br>from sklearn import datasets</p><p>boston_data = datasets.load_boston()<br>X = boston_data.data<br>y = boston_data.target</p><p>print(‘样本：’)<br>print(X[:5, :])<br>print(‘标签：’)<br>print(y[:5])</pre><p id="a08b7063785f4dbcc5a662aaf1925f11" class="ne-p"><br></p><pre data-language="python" id="7dfbd578" class="ne-codeblock language-python">样本：<br>[[6.3200e-03 1.8000e+01 2.3100e+00 0.0000e+00 5.3800e-01 6.5750e+00<br>  6.5200e+01 4.0900e+00 1.0000e+00 2.9600e+02 1.5300e+01 3.9690e+02<br>  4.9800e+00]<br> [2.7310e-02 0.0000e+00 7.0700e+00 0.0000e+00 4.6900e-01 6.4210e+00<br>  7.8900e+01 4.9671e+00 2.0000e+00 2.4200e+02 1.7800e+01 3.9690e+02<br>  9.1400e+00]<br> [2.7290e-02 0.0000e+00 7.0700e+00 0.0000e+00 4.6900e-01 7.1850e+00<br>  6.1100e+01 4.9671e+00 2.0000e+00 2.4200e+02 1.7800e+01 3.9283e+02<br>  4.0300e+00]<br> [3.2370e-02 0.0000e+00 2.1800e+00 0.0000e+00 4.5800e-01 6.9980e+00<br>  4.5800e+01 6.0622e+00 3.0000e+00 2.2200e+02 1.8700e+01 3.9463e+02<br>  2.9400e+00]<br> [6.9050e-02 0.0000e+00 2.1800e+00 0.0000e+00 4.5800e-01 7.1470e+00<br>  5.4200e+01 6.0622e+00 3.0000e+00 2.2200e+02 1.8700e+01 3.9690e+02<br>  5.3300e+00]]<br>标签：<br>[24. 21.6 34.7 33.4 36.2]</pre><p id="98101aaad54eaf5ee059928edd05c11c" class="ne-p"><br></p><pre data-language="python" id="a90a7a03" class="ne-codeblock language-python"># 选择线性回顾模型<br>from sklearn.linear_model import LinearRegression</p><p>lr_model = LinearRegression()</pre><p id="c668aa03a5ba249b3a649e72af7cbe86" class="ne-p"><br></p><pre data-language="python" id="0b1239d4" class="ne-codeblock language-python">from sklearn.model_selection import train_test_split</p><h1 id="分割训练集、测试集"><a href="#分割训练集、测试集" class="headerlink" title="分割训练集、测试集"></a>分割训练集、测试集</h1><p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=7)</pre><p id="139269d9c14d92afa60662bf15cf4528" class="ne-p"><br></p><pre data-language="python" id="96137b34" class="ne-codeblock language-python"># 训练模型<br>lr_model.fit(X_train, y_train)</pre><p id="4fc615f05f90aba2d7cdc715364d250f" class="ne-p"><br></p><pre data-language="python" id="2321fe84" class="ne-codeblock language-python">LinearRegression(copy_X=True, fit_intercept=True, n_jobs=None, normalize=False)</pre><p id="251fef8ddb74a2c95c6fa6932b69b2d8" class="ne-p"><br></p><pre data-language="python" id="d29dc43a" class="ne-codeblock language-python"># 返回参数<br>lr_model.get_params()</pre><p id="eb617c84c76be9c4eec131f70e997ad9" class="ne-p"><br></p><pre data-language="python" id="5fdd5527" class="ne-codeblock language-python">{'copy_X': True, 'fit_intercept': True, 'n_jobs': None, 'normalize': False}</pre><p id="c42dc688472c0e2324aa698f31da80f7" class="ne-p"><br></p><pre data-language="python" id="f792d5ad" class="ne-codeblock language-python">lr_model.score(X_train, y_train)</pre><p id="2c7b205b5802cd82901cee3aabb5b120" class="ne-p"><br></p><pre data-language="python" id="undefined0.7598132492351114" class="ne-codeblock language-python">0.7598132492351114</pre><p id="03dd00659a65b34b00137f7b4f13a21c" class="ne-p"><br></p><pre data-language="python" id="815e97f6" class="ne-codeblock language-python">lr_model.score(X_test, y_test)</pre><p id="63ff02db23bd9fdb0ab22157b50127fd" class="ne-p"><br></p><pre data-language="python" id="undefined0.6693852753319398" class="ne-codeblock language-python">0.6693852753319398</pre><p id="d11e0df1150b9cc415330ed1897dc791" class="ne-p"><br></p><h3 id="95c01146"><span class="ne-text">交叉验证</span></h3><p id="e7d50bcfa04456167bf498f3906f048b" class="ne-p"><br></p><pre data-language="python" id="338e8c28" class="ne-codeblock language-python">from sklearn import datasets<br>from sklearn.model_selection import train_test_split, cross_val_score<br>from sklearn.neighbors import KNeighborsClassifier<br>import matplotlib.pyplot as plt<br>%matplotlib inline</p><p>iris = datasets.load_iris()<br>X = iris.data<br>y = iris.target</p><p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=10)</p><p>k_range = range(1, 31)<br>cv_scores = []<br>for n in k_range:<br>knn = KNeighborsClassifier(n)<br>scores = cross_val_score(knn, X_train, y_train, cv=10, scoring=’accuracy’) # 分类问题使用<br>#scores = cross_val_score(knn, X_train, y_train, cv=10, scoring=’neg_mean_squared_error’) # 回归问题使用<br>cv_scores.append(scores.mean())</p><p>plt.plot(k_range, cv_scores)<br>plt.xlabel(‘K’)<br>plt.ylabel(‘Accuracy’)<br>plt.show()</pre><p id="a0cded2f71f7aa3fa90d3eaadfecd803" class="ne-p"><br></p><p id="2c0277bb65360b70642be04d029190f5" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686130618-179a3dfa-9ffd-4f45-9cc2-d6f63e1ad2b9.png" width="392" id="uSgI0" class="ne-image"></p><p id="493f3ee2cd36e50d58098a4754934f4e" class="ne-p"><br></p><pre data-language="python" id="d9f66869" class="ne-codeblock language-python"># 选择最优的 K<br>best_knn = KNeighborsClassifier(n_neighbors=5)<br>best_knn.fit(X_train, y_train)<br>print(best_knn.score(X_test, y_test))<br>print(best_knn.predict(X_test))</pre><p id="53630747d5d6a54a8f8691293beb276a" class="ne-p"><br></p><pre data-language="python" id="140f5587" class="ne-codeblock language-python">0.96<br>[1 2 0 1 0 1 2 1 0 1 1 2 1 0 0 2 1 0 0 0 2 2 2 0 1 0 1 1 1 2 1 1 2 2 2 0 2<br>2 2 2 0 0 1 0 1 0 1 2 2 2]</pre><p id="1dade961417cd6d7c846d50bdce2ee94" class="ne-p"><br></p><span id="python-1"></span><p id="91ae545daa1b2a4b77f487c8256edd44" class="ne-p"><br></p><h2 id="tmokZ"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="658d75dd41d71405e20edf15c803b74d"><a href="https://github.com/wztlink1013/scikit-learn" data-href="https://github.com/wztlink1013/scikit-learn" target="_blank" class="ne-link"><span class="ne-text">scikit-learn 中文文档 github</span></a><span class="ne-text">文中链接为英文文档</span></li><li id="15a722080e24c81b2e413a8594541477"><a href="https://blog.csdn.net/Little_Fire/article/details/81062447" data-href="https://blog.csdn.net/Little_Fire/article/details/81062447" target="_blank" class="ne-link"><span class="ne-text">解释 iris 数据集</span></a></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ANN神经网络</title>
      <link href="/blog/apohu8/"/>
      <url>/blog/apohu8/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="5396595c"><span class="ne-text">一、基本结构</span></h2><div class="ne-quote"><p id="9ff676f1b1428f70651dd81351c918a9" class="ne-p"><span class="ne-text">神经网络基本结构</span></p><p id="9afe084d0c0f5d125454c00d8316ac2b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949882-81dbb96c-eafa-4294-aae3-242fd33fff2b.png" width="858" id="gahgJ" class="ne-image"></p><p id="000939a8cad93dc9132994c3242c46e0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685950067-4d0671d6-b294-4284-9eff-9409d230e91e.png" width="768" id="agJlv" class="ne-image"></p></div><p id="0645cf040cdcaf713e02b87ada120f01" class="ne-p"><br></p><div class="ne-quote"><p id="065eac867ac6742e31c641fd69006c49" class="ne-p"><span class="ne-text">何为深度学习？</span></p><p id="22ad9d9a288750336a81502235e0bdc8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949953-b8d95ff1-6384-4e59-b3d6-1f8151f08204.png" width="842" id="WSSoJ" class="ne-image"></p></div><p id="fc998640964f9078e4e2140f7fa8f381" class="ne-p"><br></p><h2 id="3b8ffd43"><span class="ne-text">二、感知器和激活函数</span></h2><p id="d9bfad8faec766177ed1b90e8b1d1d4f" class="ne-p"><br></p><div class="ne-quote"><p id="6c00d0e6fb4e76337fa07a0654b24320" class="ne-p"><span class="ne-text">感知器</span></p><p id="b390f6d32b37c46232883ec68642565e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949922-e9c76c57-f1c5-4ff1-af82-25c35a4005b1.png" width="802" id="eaX9r" class="ne-image"></p></div><p id="27156250e2f5ccb96ec3a468cbb26206" class="ne-p"><br></p><div class="ne-quote"><p id="efe4993581ab112af68216d3cfc36ddf" class="ne-p"><span class="ne-text">激活函数（其中w和x为向量点乘；b为偏置，w0）</span></p><p id="bb328765130737e96a0a2e05e5d8f36d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949961-18eeecb5-c82e-4f71-a543-9bd0c0f27043.png" width="836" id="LJZ0R" class="ne-image"></p></div><p id="7bfc817383b4942925b419c7ef868499" class="ne-p"><br></p><div class="ne-quote"><p id="f88afa39211585266699b85eed9d4938" class="ne-p"><span class="ne-text">激活函数的选择</span></p><p id="c0d9b184bc68ff2aa819c1d56400ad75" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685950003-072268a5-122d-4340-85d5-85eeb04236fe.png" width="861" id="DZqH3" class="ne-image"></p></div><p id="c692710e26bc6f3e43ad120dc80e6160" class="ne-p"><br></p><h2 id="a96c723f"><span class="ne-text">三、感知器的训练</span></h2><p id="899625be1fe26e9be99b2cc902920d4d" class="ne-p"><br></p><p id="87529d7d3344062aa2131512dac8e20d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685950698-fc03bb22-76e6-4328-9a6b-ee2168250fec.png" width="872" id="jRv0N" class="ne-image"></p><p id="071952e49355376deb91bdb4df4a66f3" class="ne-p"><br></p><h2 id="8a01797f"><span class="ne-text">四、简单代码实现</span></h2><p id="2bfb8ab8673378a709be5c94953bd7bb" class="ne-p"><br></p><pre data-language="python" id="9ec822d7" class="ne-codeblock language-python">from functools import reduce<p>class Perceptron(object):<br>‘’’<br>构造函数的初始化<br>‘’’<br>def <strong>init</strong>(self,input<em>num,activator):<br>‘’’<br>构造函数的初始化<br>‘’’<br>self.activator = activator<br>self.weights = [0.0 for * in range(input_num)]<br>self.bias = 0.0<br>def <strong>str</strong>(self):<br>‘’’<br>打印学习后的权重值和偏置项<br>‘’’<br>return ‘weights\t:%s\nbias\t:%f\n’ %(self.weights,self.bias)<br>def predict(self,input_vec):<br>‘’’<br>输入向量，输出感知器的计算结果<br>‘’’<br>return self.activator(<br>reduce(lambda a,b: a+b,<br>list(map(lambda x,w: x</em>w,<br>input_vec,self.weights)<br>),0.0)+self.bias)<br>def train(self,input_vecs,labels,iteration,rate):<br>‘’’<br>输入训练数据：一组向量、与每个向量对应的 label；以及训练轮数、学习率<br>‘’’<br>for i in range(iteration):<br>self._one_iteration(input_vecs,labels,rate)<br>def _one_iteration(self,input_vecs,labels,rate):<br>‘’’<br>迭代，把所有的训练数据过一遍<br>‘’’<br>samples = zip(input_vecs,labels)<br>for (input_vec,label) in samples:<br>output = self.predict(input_vec)<br>self._update_weights(input_vec,output,label,rate)<br>def _update_weights(self,input_vec,output,label,rate):<br>‘’’<br>按照感知器规则更新权重<br>‘’’<br>delta = label - output<br>self.weights = map(<br>lambda x, w:w+rate<em>delta</em>x,<br>input_vec,self.weights)<br>self.weights = list(self.weights)<br>self.bias += rate*delta<br>def f(x):<br>‘’’<br>定义激活函数<br>‘’’<br>return 1 if x&gt;0 else 0<br>def get_training_dataset():<br>‘’’<br>训练数据<br>‘’’<br>input_vecs = [[1,1],[0,0],[1,0],[0,1]]<br>labels = [1,0,0,0]<br>return input_vecs,labels<br>def train_and_perceptron():<br>‘’’<br>训练感知器<br>‘’’<br>p = Perceptron(2,f)<br>input_vecs,labels = get_training_dataset()<br>p.train(input_vecs,labels,10,0.1)<br>return p</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>and_perception = train_and_perceptron()<br>print(and_perception)<br>print(‘1 and 1 = %d’ % and_perception.predict([1,1]))<br>print(‘0 and 0 = %d’ % and_perception.predict([0,0]))<br>print(‘1 and 0 = %d’ % and_perception.predict([1,0]))<br>print(‘0 and 1 = %d’ % and_perception.predict([0,1]))</pre><p id="c000e4c215a32dd9babffd762600a81c" class="ne-p"><br></p><div class="ne-quote"><p id="48138431c23bb5cded564b12e3891d08" class="ne-p"><span class="ne-text">运行结果：</span></p><p id="9f488a9d49c8ac409e5b9b2a45ae23f7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949806-ba54dca5-89a6-474a-809c-0b0238184755.png" width="536" id="KN2eh" class="ne-image"></p></div></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]操作系统核心知识点</title>
      <link href="/blog/spobqi/"/>
      <url>/blog/spobqi/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><ul class="ne-ul"><li id="78c70b8dd6e7969e68cc2270cf0b875c"><span class="ne-text">本文转载自：</span><a href="https://www.cnblogs.com/cxuanBlog/p/13297199.html" data-href="https://www.cnblogs.com/cxuanBlog/p/13297199.html" target="_blank" class="ne-link"><span class="ne-text">5万字、97 张图总结操作系统核心知识点 - 程序员cxuan - 博客园</span></a></li></ul></div><div class="ne-quote"><ul class="ne-ul"><li id="f1f3650356a7da2355a3c9411b72ce03"><span class="ne-text">部分内容自行添加</span></li></ul></div><p id="e09cae7512bb1e7e65e0b987a5ca3c8a" class="ne-p"><br></p><p id="931bb607447da06d6f3bed0cd017ed4c" class="ne-p"><span class="ne-text">这不是一篇教你如何创建一个操作系统的文章，相反，这是一篇指导性文章，教你从几个方面来理解操作系统。首先你需要知道你为什么要看这篇文章以及为什么要学习操作系统。</span></p><h2 id="61749910"><span class="ne-text">搞清楚几个问题</span></h2><p id="cd8943ed3bdff3713c416af18dcb5bc9" class="ne-p"><br></p><p id="25252fec79848d7bbc0a038fde638496" class="ne-p"><span class="ne-text">首先你要搞明白你学习操作系统的目的是什么？操作系统的重要性如何？学习操作系统会给我带来什么？下面我会从这几个方面为你回答下。</span></p><p id="8b7d10816f8e53284531845daf551ca3" class="ne-p"><br></p><p id="e6f1da87c780159f3f7de45053402efa" class="ne-p"><span class="ne-text">操作系统也是一种软件，但是操作系统是一种非常复杂的软件。操作系统提供了几种抽象模型</span></p><p id="8c1a07ee6be4f495dd752ea6d4f3b020" class="ne-p"><br></p><ul class="ne-ul"><li id="217f42e4058efed81e8bad4607e4acfd"><span class="ne-text">文件：对 I/O 设备的抽象</span></li><li id="22715eb1c834fc55bf11ecf2484d0865"><span class="ne-text">虚拟内存：对程序存储器的抽象</span></li></ul><ul class="ne-ul"><li id="205178dc0bcb920fd8c85c7c3b010b77"><span class="ne-text">进程：对一个正在运行程序的抽象</span></li><li id="d622cbce3a4c328a2322c48ec279ab56"><span class="ne-text">虚拟机：对整个操作系统的抽象</span></li></ul><p id="657df5130cb382aef2c3c6c91108272c" class="ne-p"><br></p><p id="e59e93c8b78c17b38240227d505e21cc" class="ne-p"><span class="ne-text">这些抽象和我们的日常开发息息相关。搞清楚了操作系统是如何抽象的，才能培养我们的抽象性思维和开发思路。</span></p><p id="49e331b04cc221ab606f3858c8793691" class="ne-p"><br></p><p id="a96f950d10e2e4820afcebed6cf4e11a" class="ne-p"><span class="ne-text">很多问题都和操作系统相关，操作系统是解决这些问题的基础。如果你不学习操作系统，可能会想着从框架层面来解决，那是你了解的还不够深入，当你学习了操作系统后，能够培养你的全局性思维。</span></p><p id="ce485e2ee746cb7a676b02e43c98539b" class="ne-p"><br></p><p id="ec2f957b8d14b5f67e2d5112d8c194f2" class="ne-p"><span class="ne-text">学习操作系统我们能够有效的解决</span><code class="ne-code"><span class="ne-text">并发</span></code><span class="ne-text">问题，并发几乎是互联网的重中之重了，这也从侧面说明了学习操作系统的重要性。</span></p><p id="b149befad325016fc7e10b44f43be20d" class="ne-p"><br></p><p id="30f71f05e85cb30d12e23064ca8a482b" class="ne-p"><span class="ne-text">学习操作系统的重点不是让你从头制造一个操作系统，而是告诉你</span><strong><span class="ne-text">操作系统是如何工作的</span></strong><span class="ne-text">，能够让你对计算机底层有所了解，打实你的基础。</span></p><p id="08806088071147ea10f99421320d32a2" class="ne-p"><br></p><p id="58b941ab309d9181cde3a97a32dc6d0f" class="ne-p"><span class="ne-text">相信你一定清楚什么是编程</span></p><p id="f44e3319e6f321d74f1c7f6d708cc27b" class="ne-p"><br></p><p id="ce7a48bbdff10a0f0748d43a4fee9e90" class="ne-p"><strong><span class="ne-text">Data structures + Algorithms = Programming</span></strong></p><p id="175f4024cc2c962517efb5997682de75" class="ne-p"><br></p><p id="f80de5c67c6431f2afbd24dbb2aee176" class="ne-p"><span class="ne-text">操作系统内部会涉及到众多的数据结构和算法描述，能够让你了解算法的基础上，让你编写更优秀的程序。</span></p><p id="5986e2d6bb54fb966e95673f071c0621" class="ne-p"><br></p><p id="0ed49e5e0331cad434e0b8915d4b5cdc" class="ne-p"><span class="ne-text">我认为可以把计算机比作一栋楼</span></p><p id="8c2a4868810afe3b9525b76e29ed5d78" class="ne-p"><br></p><p id="1988bafa6f22a0fcc069c82a692373b7" class="ne-p"><span class="ne-text">计算机的底层相当于就是楼的根基，计算机应用相当于就是楼的外形，而操作系统就相当于是告诉你大楼的构造原理，编写高质量的软件就相当于是告诉你构建一个稳定的房子。</span></p><p id="7014f45e7cc9e806853372bde37b2cfd" class="ne-p"><br></p><h2 id="5e0a7a49"><span class="ne-text">认识操作系统</span></h2><p id="60374c1e79cb4d4843a09fd94637d612" class="ne-p"><br></p><p id="e93269cf41ced53553d81ffb79f9eb8d" class="ne-p"><span class="ne-text">在了解操作系统前，你需要先知道一下什么是计算机系统：现代计算机系统由</span><strong><span class="ne-text">一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成的系统</span></strong><span class="ne-text">。这些都属于</span><code class="ne-code"><span class="ne-text">硬件</span></code><span class="ne-text">的范畴。我们程序员不会直接和这些硬件打交道，并且每位程序员不可能会掌握所有计算机系统的细节。</span></p><p id="65640a6ae74714a11395c1618a7fc89d" class="ne-p"><br></p><p id="3b4307743edbac97da76c836b32da301" class="ne-p"><span class="ne-text">所以计算机科学家在硬件的基础之上，安装了一层软件，这层软件能够根据用户输入的指令达到控制硬件的效果，从而满足用户的需求，这样的软件称为 </span><code class="ne-code"><span class="ne-text">操作系统</span></code><span class="ne-text">，它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型。也就是说，操作系统相当于是一个中间层，为用户层和硬件提供各自的借口，屏蔽了不同应用和硬件之间的差异，达到统一标准的作用。</span></p><p id="fd9511ee26ef4adfd5ce0d2019b4f14e" class="ne-p"><br></p><p id="17ca944a6947bc0c3d6a5de1a9445a06" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829342-133c5955-ce6b-4c7a-9b0e-74e4a24c0f14.png" width="698" id="ahwEU" class="ne-image"></p><p id="6b6913492663205e0e2997de2b4a2e49" class="ne-p"><br></p><p id="f876d76748832add56dda94beed6921e" class="ne-p"><span class="ne-text">上面一个操作系统的简化图，最底层是硬件，硬件包括</span><strong><span class="ne-text">芯片、电路板、磁盘、键盘、显示器</span></strong><span class="ne-text">等我们上面提到的设备，在硬件之上是软件。大部分计算机有两种运行模式：</span><code class="ne-code"><span class="ne-text">内核态</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">用户态</span></code><span class="ne-text">，软件中最基础的部分是</span><code class="ne-code"><span class="ne-text">操作系统</span></code><span class="ne-text">，它运行在 </span><code class="ne-code"><span class="ne-text">内核态</span></code><span class="ne-text"> 中。操作系统具有硬件的访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在 </span><code class="ne-code"><span class="ne-text">用户态</span></code><span class="ne-text"> 下。</span></p><p id="ebbba497f9d6ba190aa46822d3e0cc7a" class="ne-p"><br></p><p id="d02cfd23d8b7a7af003461286a9cda5e" class="ne-p"><span class="ne-text">在大概了解到操作系统之后，我们先来认识一下硬件都有哪些</span></p><p id="05876b94be1f5d0bd06294890520ce08" class="ne-p"><br></p><h2 id="7f56845d"><span class="ne-text">计算机硬件</span></h2><p id="cce8b5dc91c592c0a00cafe91abb32e9" class="ne-p"><br></p><p id="01ff293d3d3a521947f1a8dd38dcb947" class="ne-p"><span class="ne-text">计算机硬件是计算机的重要组成部分，其中包含了 5 个重要的组成部分：</span><strong><span class="ne-text">运算器、控制器、存储器、输入设备、输出设备</span></strong><span class="ne-text">。</span></p><p id="47deb5600e522c817edbe7abbee25e00" class="ne-p"><br></p><ul class="ne-ul"><li id="23c0ff48cfcf83bd619a8d1744e4fb5c"><code class="ne-code"><span class="ne-text">运算器</span></code><span class="ne-text">：运算器最主要的功能是对数据和信息进行加工和运算。它是计算机中执行算数和各种逻辑运算的部件。运算器的基本运算包括加、减、乘、除、移位等操作，这些是由 </span><code class="ne-code"><span class="ne-text">算术逻辑单元(Arithmetic&logical Unit)</span></code><span class="ne-text"> 实现的。而运算器主要由算数逻辑单元和寄存器构成。</span></li><li id="fbc8179c7d070a8101707bce37bcf93c"><code class="ne-code"><span class="ne-text">控制器</span></code><span class="ne-text">：指按照指定顺序改变主电路或控制电路的部件，它主要起到了控制命令执行的作用，完成协调和指挥整个计算机系统的操作。控制器是由程序计数器、指令寄存器、解码译码器等构成。</span></li></ul><p id="e2a465bc1d98db155979301524d750b7" class="ne-p"><br></p><div class="ne-quote"><p id="68e4847b9cac4d5690f4fe3ddad81505" class="ne-p"><span class="ne-text">运算器和控制器共同组成了 CPU</span></p></div><p id="f40393f314f00082df3f5dac5390d54d" class="ne-p"><br></p><ul class="ne-ul"><li id="d14c467ef32e45959a85f7540068eec0"><code class="ne-code"><span class="ne-text">存储器</span></code><span class="ne-text">：存储器就是计算机的</span><code class="ne-code"><span class="ne-text">记忆设备</span></code><span class="ne-text">，顾名思义，存储器可以保存信息。存储器分为两种，一种是主存，也就是内存，它是 CPU 主要交互对象，还有一种是外存，比如硬盘软盘等。下面是现代计算机系统的存储架构</span></li><li id="0109b65dcc8a312766f7aff0577f9186"><code class="ne-code"><span class="ne-text">输入设备</span></code><span class="ne-text">：输入设备是给计算机获取外部信息的设备，它主要包括键盘和鼠标。</span></li></ul><ul class="ne-ul"><li id="9c9570d30438ade57fc34f62ed6f8d37"><code class="ne-code"><span class="ne-text">输出设备</span></code><span class="ne-text">：输出设备是给用户呈现根据输入设备获取的信息经过一系列的计算后得到显示的设备，它主要包括显示器、打印机等。</span></li></ul><p id="1dce3c1a02c140ec91fee67be8e36769" class="ne-p"><br></p><p id="835a282fa628ddcb34e19f76a5ef697a" class="ne-p"><span class="ne-text">这五部分也是冯诺伊曼的体系结构，它认为计算机必须具有如下功能：</span></p><p id="ad40a6a3aaf0578f66a2c4e20a5720ea" class="ne-p"><br></p><p id="2bbfd0566e38489f15096e54e9a0a614" class="ne-p"><span class="ne-text">把需要的程序和数据送至计算机中。必须具有长期记忆程序、数据、中间结果及最终运算结果的能力。能够完成各种算术、逻辑运算和数据传送等数据加工处理的能力。能够根据需要控制程序走向，并能根据指令控制机器的各部件协调操作。能够按照要求将处理结果输出给用户。</span></p><p id="e1452348578beeb6a16c16494dc88fe4" class="ne-p"><br></p><p id="02f40d52bf1660ca14fc7d9e3ef3826c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829342-9ed0fc8c-06fb-431d-8db6-2caaca0abc0f.png" width="721" id="qMDVd" class="ne-image"></p><p id="800c9b83462be50fcb8a3f3cdd6e3b94" class="ne-p"><br></p><p id="c4403308930ab6ac5ceca26c06a272c8" class="ne-p"><span class="ne-text">下面是一张 intel 家族产品图，是一个详细的计算机硬件分类，我们在根据图中涉及到硬件进行介绍</span></p><p id="5b37e26e7636153b562b485458fc5ef1" class="ne-p"><br></p><p id="e0fb51cbe771fc7ec497266795295f0e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829351-810b3b3e-2849-45d3-96c8-62280633f4a6.png" width="747" id="ZSJw7" class="ne-image"></p><p id="48dffd0496d4e7ac46311057c1da3964" class="ne-p"><br></p><ul class="ne-ul"><li id="4edfeb0a52189d8edd1c42763577ee9e"><code class="ne-code"><span class="ne-text">总线(Buses)</span></code><span class="ne-text">：在整个系统中运行的是称为总线的电气管道的集合，这些总线在组件之间来回传输字节信息。通常总线被设计成传送定长的字节块，也就是 </span><code class="ne-code"><span class="ne-text">字(word)</span></code><span class="ne-text">。字中的字节数（字长）是一个基本的系统参数，各个系统中都不尽相同。现在大部分的字都是 4 个字节（32 位）或者 8 个字节（64 位）。</span></li></ul><p id="8722f36b77845d4b9ad537bf6958cb52" class="ne-p"><br></p><p id="c153395442fe97613ef51a62e92903b8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829372-677cad04-111e-4904-a865-109bf7e95c9c.png" width="731" id="GR4Q2" class="ne-image"></p><p id="56abdc5d1e5b29b2c23b1d995808d341" class="ne-p"><br></p><ul class="ne-ul"><li id="314397e76b319606a6f50e9bc4e4d686"><code class="ne-code"><span class="ne-text">I/O 设备(I/O Devices)</span></code><span class="ne-text">：Input/Output 设备是系统和外部世界的连接。上图中有四类 I/O 设备：用于用户输入的键盘和鼠标，用于用户输出的显示器，一个磁盘驱动用来长时间的保存数据和程序。刚开始的时候，可执行程序就保存在磁盘上。<p></span><span class="ne-text">每个 I/O 设备连接 I/O 总线都被称为</span><code class="ne-code"><span class="ne-text">控制器(controller)</span></code><span class="ne-text"> 或者是 </span><code class="ne-code"><span class="ne-text">适配器(Adapter)</span></code><span class="ne-text">。控制器和适配器之间的主要区别在于封装方式。控制器是 I/O 设备本身或者系统的主印制板电路（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论组织形式如何，它们的最终目的都是彼此交换信息。</span></li><li id="5ed03e7dde30479bc8253a8f0657526c"><code class="ne-code"><span class="ne-text">主存(Main Memory)</span></code><span class="ne-text">，主存是一个</span><code class="ne-code"><span class="ne-text">临时存储设备</span></code><span class="ne-text">，而不是永久性存储，磁盘是 </span><code class="ne-code"><span class="ne-text">永久性存储</span></code><span class="ne-text"> 的设备。主存既保存程序，又保存处理器执行流程所处理的数据。从物理组成上说，主存是由一系列 </span><code class="ne-code"><span class="ne-text">DRAM(dynamic random access memory)</span></code><span class="ne-text"> 动态随机存储构成的集合。逻辑上说，内存就是一个线性的字节数组，有它唯一的地址编号，从 0 开始。一般来说，组成程序的每条机器指令都由不同数量的字节构成，C 程序变量相对应的数据项的大小根据类型进行变化。比如，在 Linux 的 x86-64 机器上，short 类型的数据需要 2 个字节，int 和 float 需要 4 个字节，而 long 和 double 需要 8 个字节。</span></li></ul><ul class="ne-ul"><li id="78a508a67b0570af15a3f2a6cd9321a0"><code class="ne-code"><span class="ne-text">处理器(Processor)</span></code><span class="ne-text">，</span><code class="ne-code"><span class="ne-text">CPU(central processing unit)</span></code><span class="ne-text"> 或者简单的处理器，是解释（并执行）存储在主存储器中的指令的引擎。处理器的核心大小为一个字的存储设备（或寄存器），称为</span><code class="ne-code"><span class="ne-text">程序计数器(PC)</span></code><span class="ne-text">。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。<br></span><span class="ne-text">从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器根据其指令集体系结构定义的指令模型进行操作。在这个模型中，指令按照严格的顺序执行，执行一条指令涉及执行一系列的步骤。处理器从程序计数器指向的内存中读取指令，解释指令中的位，执行该指令指示的一些简单操作，然后更新程序计数器以指向下一条指令。指令与指令之间可能连续，可能不连续（比如 jmp 指令就不会顺序读取）</span></li></ul><p id="3a4a2a641d1a1c2de5ad66377fca1a30" class="ne-p"><br></p><p id="954dbf0f9e583d9fe45125eabf87296d" class="ne-p"><span class="ne-text">下面是 CPU 可能执行简单操作的几个步骤</span></p><p id="0e7c003044e5b5185d07ad8a3a2b10dc" class="ne-p"><br></p><ul class="ne-ul"><li id="62092432619e0a8617a85dc65506af1f"><code class="ne-code"><span class="ne-text">加载(Load)</span></code><span class="ne-text">：从主存中拷贝一个字节或者一个字到内存中，覆盖寄存器先前的内容</span></li><li id="d70e3efbed128cede95336b4ab29b2c8"><code class="ne-code"><span class="ne-text">存储(Store)</span></code><span class="ne-text">：将寄存器中的字节或字复制到主存储器中的某个位置，从而覆盖该位置的先前内容</span></li></ul><ul class="ne-ul"><li id="34ef14e8474868fc664a6a7a93da783c"><code class="ne-code"><span class="ne-text">操作(Operate)</span></code><span class="ne-text">：把两个寄存器的内容复制到 </span><code class="ne-code"><span class="ne-text">ALU(Arithmetic logic unit)</span></code><span class="ne-text"> 。把两个字进行算术运算，并把结果存储在寄存器中，重写寄存器先前的内容。</span></li></ul><p id="b0921cf26e6a7ca068ba0fe5f7503a34" class="ne-p"><br></p><div class="ne-quote"><p id="24027a2585b5d271d4a70016b7d63879" class="ne-p"><span class="ne-text">算术逻辑单元（ALU）是对数字二进制数执行算术和按位运算的组合数字电子电路。</span></p></div><p id="8875ee2f15790a01020ed498f5331bbf" class="ne-p"><br></p><ul class="ne-ul"><li id="04e09f85f3b9c8a6b2b2cb9643a334b0"><code class="ne-code"><span class="ne-text">跳转(jump)</span></code><span class="ne-text">：从指令中抽取一个字，把这个字复制到</span><code class="ne-code"><span class="ne-text">程序计数器(PC)</span></code><span class="ne-text"> 中，覆盖原来的值</span></li></ul><p id="40564caba44243a15803ea8ea3df1185" class="ne-p"><br></p><h2 id="e5b00e3a"><span class="ne-text">进程和线程</span></h2><p id="89e59462cf5e42126bf7fd69ec455e43" class="ne-p"><br></p><p id="279db931dc6baec0f7e3d4b21b009845" class="ne-p"><span class="ne-text">关于进程和线程，你需要理解下面这张脑图中的重点</span></p><p id="cd6805c2765d2ea297065d329755927f" class="ne-p"><br></p><p id="1d9db861bcf8b6d42bd30feae4ef59ef" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829389-4c3de174-e023-4600-b910-b01112bd2f4c.png" width="734" id="tvXh9" class="ne-image"></p><p id="7b1432c8b72204ee4b825e861b12f98e" class="ne-p"><br></p><h2 id="f88522cf"><span class="ne-text">进程</span></h2><p id="558402d93b3b4cb15182048bf1d22ac0" class="ne-p"><br></p><p id="0989e50fff0d7132d77a4dc9d000527a" class="ne-p"><span class="ne-text">操作系统中最核心的概念就是 </span><code class="ne-code"><span class="ne-text">进程</span></code><span class="ne-text">，进程是对正在运行中的程序的一个抽象。操作系统的其他所有内容都是围绕着进程展开的。</span></p><p id="9858e22f7b813dbde0def60216102845" class="ne-p"><br></p><p id="c6c622877f50d6ecedc29825038afaef" class="ne-p"><span class="ne-text">在多道程序处理的系统中，CPU 会在</span><code class="ne-code"><span class="ne-text">进程</span></code><span class="ne-text">间快速切换，使每个程序运行几十或者几百毫秒。然而，严格意义来说，在某一个瞬间，CPU 只能运行一个进程，然而我们如果把时间定位为 1 秒内的话，它可能运行多个进程。这样就会让我们产生</span><code class="ne-code"><span class="ne-text">并行</span></code><span class="ne-text">的错觉。因为 CPU 执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪。所以，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得并行更加容易理解和分析。</span></p><p id="7ebadc22ea804dc3ce1f6cb4f1faa79a" class="ne-p"><br></p><h3 id="db1832c3"><span class="ne-text">进程模型</span></h3><p id="d840b450465be09e434df4a3dd9a3f21" class="ne-p"><br></p><p id="0f48d95b096b20bbe4d780741e4b7c54" class="ne-p"><span class="ne-text">一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟 CPU，但是实际情况是 CPU 会在各个进程之间进行来回切换。</span></p><p id="864056155c24e8395f096ca45cc118d3" class="ne-p"><br></p><p id="89fb82994d781ae23159ddf581f8535e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829609-9880b940-5163-45d4-8ef6-b559ab53b55d.png" width="455" id="XCIWa" class="ne-image"></p><p id="503dfc349a03926ac40238c181049013" class="ne-p"><br></p><p id="e44e9da7ec98c3c4fe1fdbf7978527ea" class="ne-p"><span class="ne-text">如上图所示，这是一个具有 4 个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化。</span></p><p id="8b5b1883046bf13d25c14fb35e4516bb" class="ne-p"><br></p><p id="bbcf34ef348ae4a397c45691442445a7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829415-2d4059be-d447-4abf-8e77-2df51d6cc6a1.png" width="647" id="CNsvU" class="ne-image"></p><p id="13790759d024503953e9acbb6b0b7ab3" class="ne-p"><br></p><p id="1df3a5508dff94ecadd151924567d3b5" class="ne-p"><span class="ne-text">在上图中，这 4 道程序被抽象为 4 个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</span></p><p id="ee92f5f090955049ed874d170f8164cb" class="ne-p"><br></p><p id="01f2e5a8184ecf5d05233123e72d116d" class="ne-p"><span class="ne-text">从下图我们可以看到，在观察足够长的一段时间后，所有的进程都运行了，</span><strong><span class="ne-text">但在任何一个给定的瞬间仅有一个进程真正运行</span></strong><span class="ne-text">。</span></p><p id="d183af70e6d683798bd87e78de114558" class="ne-p"><br></p><p id="c50a4b4a34d3cd79990b212d4fbfc543" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829611-a49b5e88-0d0e-42c3-a103-485b6e5c984b.png" width="578" id="Zm8OZ" class="ne-image"></p><p id="77943fe667db14d2a7a7af237a686d74" class="ne-p"><br></p><p id="04d2c0652dedc050608799739b401859" class="ne-p"><span class="ne-text">因此，当我们说一个 CPU 只能真正一次运行一个进程的时候，即使有 2 个核（或 CPU），</span><strong><span class="ne-text">每一个核也只能一次运行一个线程</span></strong><span class="ne-text">。</span></p><p id="5f3805e43ab58c9f9b1421c309983a93" class="ne-p"><br></p><p id="caa82774fc8116b9bb58bada934ea47c" class="ne-p"><span class="ne-text">由于 CPU 会在各个进程之间来回快速切换，所以每个进程在 CPU 中的运行时间是无法确定的。并且当同一个进程再次在 CPU 中运行时，其在 CPU 内部的运行时间往往也是不固定的。</span></p><p id="3833fb1e45d8a553449ff36ab59e4177" class="ne-p"><br></p><p id="802684c9e995650755383da022afcbb1" class="ne-p"><span class="ne-text">这里的关键思想是</span><code class="ne-code"><span class="ne-text">认识到一个进程所需的条件</span></code><span class="ne-text">，进程是某一类特定活动的总和，它有程序、输入输出以及状态。</span></p><p id="2d8841ff912ecc1480e38c0ace860c22" class="ne-p"><br></p><h3 id="ef174e29"><span class="ne-text">进程的创建</span></h3><p id="b69f4a48539edd2c438341715747400d" class="ne-p"><br></p><p id="34e9aef6755ca9dc3103ca25f2c1b94c" class="ne-p"><span class="ne-text">操作系统需要一些方式来创建进程。下面是一些创建进程的方式</span></p><p id="7f056f7e3d9ba5170e3d973201d6e577" class="ne-p"><br></p><ul class="ne-ul"><li id="5525a064edc2a71505894af900e9ae6d"><span class="ne-text">系统初始化（init）：启动操作系统时，通常会创建若干个进程。</span></li><li id="655f909b3a436f6c5d0b2f6ce577f1eb"><span class="ne-text">正在运行的程序执行了创建进程的系统调用（比如 fork）</span></li></ul><ul class="ne-ul"><li id="15f97be6f701a9d2e285ce067dcaa4f5"><span class="ne-text">用户请求创建一个新进程：在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的 UNIX 系统中运行 X，新进程将接管启动它的窗口。</span></li><li id="9cbc72a5195fe8f27a433e2cf1537410"><span class="ne-text">初始化一个批处理工作</span></li></ul><p id="734b1131d138309cb8f6e8751b24b0ca" class="ne-p"><br></p><p id="36bcfdf4e40be363d8ec64c87f794ea4" class="ne-p"><span class="ne-text">从技术上讲，在所有这些情况下，让现有流程执行流程是通过创建系统调用来创建新流程的。该进程可能是正在运行的用户进程，是从键盘或鼠标调用的系统进程或批处理程序。这些就是系统调用创建新进程的过程。该系统调用告诉操作系统创建一个新进程，并直接或间接指示在其中运行哪个程序。</span></p><p id="e244fe98d07fe53d8b8b074500bbdbf0" class="ne-p"><br></p><p id="90057922d3b14889ff144902ccb57016" class="ne-p"><span class="ne-text">在 UNIX 中，仅有一个系统调用来创建一个新的进程，这个系统调用就是 </span><code class="ne-code"><span class="ne-text">fork</span></code><span class="ne-text">。这个调用会创建一个与调用进程相关的副本。在 fork 后，一个父进程和子进程会有相同的</span><code class="ne-code"><span class="ne-text">内存映像</span></code><span class="ne-text">，相同的环境字符串和相同的打开文件。</span></p><p id="40b362f7c35397f6ed004f88fc15b256" class="ne-p"><br></p><p id="8ca0bc63e686352cfce2b4e04f846f34" class="ne-p"><span class="ne-text">在 Windows 中，情况正相反，一个简单的 Win32 功能调用 </span><code class="ne-code"><span class="ne-text">CreateProcess</span></code><span class="ne-text">，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有 10 个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。</span><strong><span class="ne-text">在 Windows 中，从一开始父进程的地址空间和子进程的地址空间就是不同的</span></strong><span class="ne-text">。</span></p><p id="c760fc897fd7f21d634e5d2c5ab8dd50" class="ne-p"><br></p><h3 id="24ee23f9"><span class="ne-text">进程的终止</span></h3><p id="2a356a15e9c85c0d5ea48bee53e3ee53" class="ne-p"><br></p><p id="a0bc37496955070caffd70767e9fccca" class="ne-p"><span class="ne-text">进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的</span></p><p id="1785949fd41d177bee8df659bfa2541e" class="ne-p"><br></p><ul class="ne-ul"><li id="aef294d171fb8cac4c656d092ad0efd6"><code class="ne-code"><span class="ne-text">正常退出(自愿的)</span></code><span class="ne-text"> ： 多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 </span><code class="ne-code"><span class="ne-text">exit</span></code><span class="ne-text"> ，在 Windows 中是 </span><code class="ne-code"><span class="ne-text">ExitProcess</span></code><span class="ne-text">。</span></li><li id="64851a07fdbb717aabe3e48e41e69418"><code class="ne-code"><span class="ne-text">错误退出(自愿的)</span></code><span class="ne-text">：比如执行一条不存在的命令，于是编译器就会提醒并退出。</span></li></ul><ul class="ne-ul"><li id="7cdd5fd1594ea716be38ce11cb3a10e2"><code class="ne-code"><span class="ne-text">严重错误(非自愿的)</span></code></li><li id="6babe1237002ef73948160629e13b605"><code class="ne-code"><span class="ne-text">被其他进程杀死(非自愿的)</span></code><span class="ne-text"> ： 某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 </span><code class="ne-code"><span class="ne-text">TerminateProcess</span></code><span class="ne-text">（注意不是系统调用）。</span></li></ul><p id="5bd73c750876718c6aca8ef216af6b54" class="ne-p"><br></p><h3 id="59a65ba2"><span class="ne-text">进程的层次结构</span></h3><p id="0bb47166b3c322ba29b0f204223d5fd0" class="ne-p"><br></p><p id="7f07789281882e50c0fc300b3ca03f9c" class="ne-p"><span class="ne-text">在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。</span></p><p id="829195fa901cce4553d63f442daebea8" class="ne-p"><br></p><h4 id="9a0a3bf9"><span class="ne-text">UNIX 进程体系</span></h4><p id="1c753e33d5a50d5c91e575f5f321a978" class="ne-p"><br></p><p id="71620443f7be78f9d927a3e3caee47a6" class="ne-p"><span class="ne-text">在 UNIX 中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号 kill 掉。整个操作系统中所有的进程都隶属于一个单个以 init 为根的进程树。</span></p><p id="dcf543e13cb6e080adafb4af20eb2588" class="ne-p"><br></p><p id="c4605dff5b082200add96857699ecbb3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829468-bff503cb-cf97-4853-aca3-35db5bb67312.png" width="615" id="TUggO" class="ne-image"></p><p id="3fa2c3bfabb4e38822ab985e931554cb" class="ne-p"><br></p><h4 id="5d016720"><span class="ne-text">Windows 进程体系</span></h4><p id="fb9194b7b563522aaf65f5e7877f5d9d" class="ne-p"><br></p><p id="45b7deda743f60e53beed2089b218a3c" class="ne-p"><span class="ne-text">相反，Windows 中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在 UNIX 中，进程不能剥夺其子进程的 </span><code class="ne-code"><span class="ne-text">进程权</span></code><span class="ne-text">。（这样看来，还是 Windows 比较</span><code class="ne-code"><span class="ne-text">渣</span></code><span class="ne-text">）。</span></p><p id="248c55e3f445201dd7dbeca56a3f9b00" class="ne-p"><br></p><h3 id="fe290ad3"><span class="ne-text">进程状态</span></h3><p id="ad4ee3dd92ab5c79b1c5cbc43c5a3dba" class="ne-p"><br></p><p id="4d829862b4033af7e64e431f9c777402" class="ne-p"><span class="ne-text">尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。当一个进程开始运行时，它可能会经历下面这几种状态</span></p><p id="a7817b1f61e8d565b373c264359e44f9" class="ne-p"><br></p><p id="c8b03ba9b3b2b9903b85c39e72dd8a91" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829472-6b2e277f-f4b9-4f38-805d-e9ac73f33129.png" width="734" id="nVHjc" class="ne-image"></p><p id="08028f8436803d51ec1e716d72fe2310" class="ne-p"><br></p><p id="82bce743c56b29faca92df0ac4052b5e" class="ne-p"><span class="ne-text">图中会涉及三种状态</span></p><p id="9f699dbeb42df9e8d0551ca5d9171c73" class="ne-p"><br></p><ol class="ne-ol"><li id="aec08485f34560a4b7b6abadb75ef79d"><code class="ne-code"><span class="ne-text">运行态</span></code><span class="ne-text">，运行态指的就是进程实际占用 CPU 时间片运行时</span></li><li id="381d58aae0b72332585ff6985de97c5e"><code class="ne-code"><span class="ne-text">就绪态</span></code><span class="ne-text">，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</span></li></ol><ol start="3" class="ne-ol"><li id="65a92d0ec3b2adb54401c8528d0e23b6"><code class="ne-code"><span class="ne-text">阻塞态</span></code><span class="ne-text">，除非某种外部事件发生，否则进程不能运行</span></li></ol><p id="081c0d4cc15fd01c6d95209ecec0c1e0" class="ne-p"><br></p><h3 id="27fe55d6"><span class="ne-text">进程的实现</span></h3><p id="92b3b630daddd7d1ddb5cf95b49e523c" class="ne-p"><br></p><p id="7837b0696feedfcbb97df8ce125c1217" class="ne-p"><span class="ne-text">操作系统为了执行进程间的切换，会维护着一张表，这张表就是 </span><code class="ne-code"><span class="ne-text">进程表(process table)</span></code><span class="ne-text">。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息。</span></p><p id="d3d512edb88e5511bf9ce1530b15e0f8" class="ne-p"><br></p><p id="650b4ebec7f6635f2b6ff4cc027a95fe" class="ne-p"><span class="ne-text">下面展示了一个典型系统中的关键字段</span></p><p id="023ffbba17dc27adc6ff1d21fb9e45cf" class="ne-p"><br></p><p id="abf3e59185ee55f8fe152e201cecaf06" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829487-6d8a6e92-d068-48a8-b5a0-9e5b74f9ab3f.png" width="749" id="Sr874" class="ne-image"></p><p id="4c8283b21ecd2b4d4d8121fed458946c" class="ne-p"><br></p><p id="4fe136f6a62abb9ab8066e3c6085988c" class="ne-p"><span class="ne-text">第一列内容与</span><code class="ne-code"><span class="ne-text">进程管理</span></code><span class="ne-text">有关，第二列内容与 </span><code class="ne-code"><span class="ne-text">存储管理</span></code><span class="ne-text">有关，第三列内容与</span><code class="ne-code"><span class="ne-text">文件管理</span></code><span class="ne-text">有关。</span></p><p id="93ffa9020d0b8573b25e9ad3d4211dbc" class="ne-p"><br></p><p id="6a6879f2608015b94561ab03cca29275" class="ne-p"><span class="ne-text">现在我们应该对进程表有个大致的了解了，就可以在对单个 CPU 上如何运行多个顺序进程的错觉做更多的解释。与每一 I/O 类相关联的是一个称作 </span><code class="ne-code"><span class="ne-text">中断向量(interrupt vector)</span></code><span class="ne-text"> 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程 3 正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这就是硬件所做的事情。然后软件就随即接管一切剩余的工作。</span></p><p id="d944c12bcb8d1fb777afe0c76b5d4dfe" class="ne-p"><br></p><p id="67925a50acf5cec75da68f7c4fa97604" class="ne-p"><span class="ne-text">当中断结束后，操作系统会调用一个 C 程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进程就绪，接着调用调度程序，决定随后运行哪个进程。然后将控制权转移给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行，下面显示了中断处理和调度的过程。</span></p><p id="e9c2e6a19d20c8e9d745ba1ede98bda0" class="ne-p"><br></p><ol class="ne-ol"><li id="bcfd5526252f62185fad5607256d5a21"><span class="ne-text">硬件压入堆栈程序计数器等</span></li><li id="7fe994f519b0faf5566db73640fc6be1"><span class="ne-text">硬件从中断向量装入新的程序计数器</span></li></ol><ol start="3" class="ne-ol"><li id="c934d43af74c443845b28312159ee1ac"><span class="ne-text">汇编语言过程保存寄存器的值</span></li><li id="82e923138b451b98f625e89cbd0b6bca"><span class="ne-text">汇编语言过程设置新的堆栈</span></li></ol><ol start="5" class="ne-ol"><li id="4f5334e81f1d5a5f1e64fda967d5fca0"><span class="ne-text">C 中断服务器运行（典型的读和缓存写入）</span></li><li id="94f7067d3f873488b2a017df5a72d5ce"><span class="ne-text">调度器决定下面哪个程序先运行</span></li></ol><ol start="7" class="ne-ol"><li id="eff3e73d42a5e05ab6c5e185f9a05120"><span class="ne-text">C 过程返回至汇编代码</span></li><li id="724b882cbe84a93d767c38842f66357b"><span class="ne-text">汇编语言过程开始运行新的当前进程</span></li></ol><p id="60ef497df3321edea7d108cdcc4053d3" class="ne-p"><br></p><p id="38f27f3718510227db767b00debb1939" class="ne-p"><span class="ne-text">一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</span></p><p id="51999800e2ccce806ac92346816458e4" class="ne-p"><br></p><h2 id="d276123c"><span class="ne-text">线程</span></h2><p id="9f602f2dc988af4bde245a6ccdf7ff13" class="ne-p"><br></p><p id="55772d1f565f2ecbfcfc09a8bc616c44" class="ne-p"><span class="ne-text">在传统的操作系统中，每个进程都有一个地址空间和一个控制线程。事实上，这是大部分进程的定义。不过，在许多情况下，经常存在同一地址空间中运行多个控制线程的情形，这些线程就像是分离的进程。下面我们就着重探讨一下什么是线程</span></p><p id="ea8fb1edc20cb64f1273a9310aa3751d" class="ne-p"><br></p><h3 id="b2c46474"><span class="ne-text">线程的使用</span></h3><p id="ab116c151e8ba219bf8ae6f68ab5ede4" class="ne-p"><br></p><p id="1ce2c19e90381851b1534560e92b51d3" class="ne-p"><span class="ne-text">或许这个疑问也是你的疑问，为什么要在进程的基础上再创建一个线程的概念，准确的说，这其实是进程模型和线程模型的讨论，回答这个问题，可能需要分三步来回答</span></p><p id="e8a5e2e598ab662e0607b58901d9758e" class="ne-p"><br></p><ul class="ne-ul"><li id="a68004fabbe64f1be4294491ce6943cc"><span class="ne-text">多线程之间会共享同一块地址空间和所有可用数据的能力，这是进程所不具备的</span></li><li id="c16d784bb6036482a74a4f2816dcd734"><span class="ne-text">线程要比进程</span><code class="ne-code"><span class="ne-text">更轻量级</span></code><span class="ne-text">，由于线程更轻，所以它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 10 - 100 倍。</span></li></ul><ul class="ne-ul"><li id="124456cced3a6934d0dbc4c8b6e588fa"><span class="ne-text">第三个原因可能是性能方面的探讨，如果多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度</span></li></ul><p id="969485792d07970e248a25c707ae81c3" class="ne-p"><br></p><h3 id="eb3f9151"><span class="ne-text">经典的线程模型</span></h3><p id="0f4cd5ac358f2cd5d9e6305faa1d2f19" class="ne-p"><br></p><p id="f4399e0137f899b35f0a99796f458cee" class="ne-p"><span class="ne-text">进程中拥有一个执行的线程，通常简写为 </span><code class="ne-code"><span class="ne-text">线程(thread)</span></code><span class="ne-text">。线程会有程序计数器，用来记录接着要执行哪一条指令；线程实际上 CPU 上调度执行的实体。</span></p><p id="9f6e4eaf1534a378bf8231492af63f4b" class="ne-p"><br></p><p id="cf636b0793325e7d330a7e6769b03700" class="ne-p"><span class="ne-text">下图我们可以看到三个传统的进程，每个进程有自己的地址空间和单个控制线程。每个线程都在不同的地址空间中运行</span></p><p id="90ee1e4c78f7c3f9bacfeddf50cce64c" class="ne-p"><br></p><p id="6caf3b47091b19d6f3453533334c3136" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829491-73cfd311-e3e5-4381-886b-f904f3c8ca5c.png" width="658" id="lfuB1" class="ne-image"></p><p id="8ba295dcb96dca3a3572f16973748711" class="ne-p"><br></p><p id="1644b4a344140948fb4c97c0bd2cd7df" class="ne-p"><span class="ne-text">下图中，我们可以看到有一个进程三个线程的情况。每个线程都在相同的地址空间中运行。</span></p><p id="a6c4bee1d01b8aa5be0eadc12cbe618b" class="ne-p"><br></p><p id="af6501c631d07365f00006589b930913" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829501-7e5370fc-b9ec-4804-a862-9c86e00bf231.png" width="640" id="uVJR7" class="ne-image"></p><p id="181be89a9207f89b1c00524cbbab1e00" class="ne-p"><br></p><p id="39810993b510056e76c4a3b570b37cd2" class="ne-p"><span class="ne-text">线程不像是进程那样具备较强的独立性。同一个进程中的所有线程都会有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于每个线程都可以访问进程地址空间内每个内存地址，</span><strong><span class="ne-text">因此一个线程可以读取、写入甚至擦除另一个线程的堆栈</span></strong><span class="ne-text">。线程之间除了共享同一内存空间外，还具有如下不同的内容</span></p><p id="e6b58ebee8ff091f855004f3afe8523d" class="ne-p"><br></p><p id="9cf3875d0759c13afa2efc6cbceea3c6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829530-1ce4e3bb-f3b4-4fae-bd6b-2a09cb86e2d3.png" width="583" id="GpbmQ" class="ne-image"></p><p id="5d5826853af545f770aa24d16ca10997" class="ne-p"><br></p><p id="33ecc512185771f5ff75d82ee58a1d69" class="ne-p"><span class="ne-text">上图左边的是同一个进程中</span><code class="ne-code"><span class="ne-text">每个线程共享</span></code><span class="ne-text">的内容，上图右边是</span><code class="ne-code"><span class="ne-text">每个线程</span></code><span class="ne-text">中的内容。也就是说左边的列表是进程的属性，右边的列表是线程的属性。</span></p><p id="ad5fb01708e084b0184f6e5dc56062b2" class="ne-p"><br></p><p id="1e26ec6c5f413fc1bd832038d6fce9ce" class="ne-p"><strong><span class="ne-text">线程之间的状态转换和进程之间的状态转换是一样的</span></strong><span class="ne-text">。</span></p><p id="7c1105577d60fc2e15dc30ee4592d372" class="ne-p"><br></p><p id="f4511cae93abe3026efa2cf3757360d5" class="ne-p"><span class="ne-text">每个线程都会有自己的堆栈，如下图所示</span></p><p id="8adbcedd049bb3edc3764bede487c847" class="ne-p"><br></p><p id="27f1bbcde67b84d60351835e8ce7750b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829586-41932660-4ab5-42e2-bbb1-bbd660b183f6.png" width="682" id="WnFPn" class="ne-image"></p><p id="0e816dfec54ca3e832073ef02dbeeb6b" class="ne-p"><br></p><h4 id="6632fae6"><span class="ne-text">线程系统调用</span></h4><p id="8626c74ea022a987992b0c1fbdb792b3" class="ne-p"><br></p><p id="eef4b592177acc7598b410c9dcbd2692" class="ne-p"><span class="ne-text">进程通常会从当前的某个单线程开始，然后这个线程通过调用一个库函数（比如 </span><code class="ne-code"><span class="ne-text">thread_create</span></code><span class="ne-text"> ）创建新的线程。线程创建的函数会要求指定新创建线程的名称。创建的线程通常都返回一个线程标识符，该标识符就是新线程的名字。</span></p><p id="699815b2cc0f7cb21f43b7de2be07cdf" class="ne-p"><br></p><p id="a7c9a0127beb8b9c706078fde4ff4ee2" class="ne-p"><span class="ne-text">当一个线程完成工作后，可以通过调用一个函数（比如 </span><code class="ne-code"><span class="ne-text">thread_exit</span></code><span class="ne-text">）来退出。紧接着线程消失，状态变为终止，不能再进行调度。在某些线程的运行过程中，可以通过调用函数例如 </span><code class="ne-code"><span class="ne-text">thread_join</span></code><span class="ne-text"> ，表示一个线程可以等待另一个线程退出。这个过程阻塞调用线程直到等待特定的线程退出。在这种情况下，线程的创建和终止非常类似于进程的创建和终止。</span></p><p id="f4a5500946aabb17ea44c2558f19c2ca" class="ne-p"><br></p><p id="9629c5ac74f429f3955418e20f72cec0" class="ne-p"><span class="ne-text">另一个常见的线程是调用 </span><code class="ne-code"><span class="ne-text">thread_yield</span></code><span class="ne-text">，它允许线程自动放弃 CPU 从而让另一个线程运行。这样一个调用还是很重要的，因为不同于进程，线程是无法利用时钟中断强制让线程让出 CPU 的。</span></p><p id="8fdc0d7830858c997bfd188739ed7afc" class="ne-p"><br></p><h3 id="b1d15c6e"><span class="ne-text">POSIX 线程</span></h3><p id="db401dc44303ec105e67be5c2fc389c4" class="ne-p"><br></p><p id="dfd97f521bd61893a8aeabdb0535fa87" class="ne-p"><code class="ne-code"><span class="ne-text">POSIX 线程 通常称为 pthreads</span></code><span class="ne-text">是一种独立于语言而存在的执行模型，以及并行执行模型。</span></p><p id="1bf64c399339628fb7957855f494f71f" class="ne-p"><br></p><p id="e49542eca979134cc9c9f75f2f329a24" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829568-3bded50a-8029-4644-9e42-c2c6ddf60ca1.png" width="639" id="ZELdp" class="ne-image"></p><p id="fe7cfff22c57936dee6dd54e80f17015" class="ne-p"><br></p><p id="c50783d2ba22cd47838f774866f90191" class="ne-p"><span class="ne-text">它允许程序控制时间上重叠的多个不同的工作流程。每个工作流程都称为一个线程，可以通过调用 POSIX Threads API 来实现对这些流程的创建和控制。可以把它理解为线程的标准。</span></p><p id="6ae632f03f369eff8d56f27dbe210647" class="ne-p"><br></p><div class="ne-quote"><p id="cd16084d7837c5073a2fa1c2189d0c10" class="ne-p"><span class="ne-text">POSIX Threads 的实现在许多类似且符合 POSIX 的操作系统上可用，例如 </span><strong><span class="ne-text">FreeBSD、NetBSD、OpenBSD、Linux、macOS、Android、Solaris</span></strong><span class="ne-text">，它在现有 Windows API 之上实现了</span><strong><span class="ne-text">pthread</span></strong><span class="ne-text">。</span></p><p id="4bb522cf8ceadf992cc37fe01affca2b" class="ne-p"><span class="ne-text">IEEE 是世界上最大的技术专业组织，致力于为人类的利益而发展技术。</span></p></div><table id="d6ca4def" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="uf5bca78d" class="ne-p"><span class="ne-text">线程调用</span></p></td><td width="375"><p id="u066f4fdf" class="ne-p"><span class="ne-text">描述</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u96230ab3" class="ne-p"><span class="ne-text">pthread_create</span></p></td><td width="375"><p id="uff601278" class="ne-p"><span class="ne-text">创建一个新线程</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ucb6f1a7c" class="ne-p"><span class="ne-text">pthread_exit</span></p></td><td width="375"><p id="u2c6ae04a" class="ne-p"><span class="ne-text">结束调用的线程</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u2219439b" class="ne-p"><span class="ne-text">pthread_join</span></p></td><td width="375"><p id="ub02eaf4e" class="ne-p"><span class="ne-text">等待一个特定的线程退出</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u2804c355" class="ne-p"><span class="ne-text">pthread_yield</span></p></td><td width="375"><p id="u60922575" class="ne-p"><span class="ne-text">释放 CPU 来运行另外一个线程</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u9eb11640" class="ne-p"><span class="ne-text">pthread_attr_init</span></p></td><td width="375"><p id="ue5ad1df6" class="ne-p"><span class="ne-text">创建并初始化一个线程的属性结构</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u1ea06b78" class="ne-p"><span class="ne-text">pthread_attr_destory</span></p></td><td width="375"><p id="ub04e7306" class="ne-p"><span class="ne-text">删除一个线程的属性结构</span></p></td></tr></tbody></table><p id="f6a1a765e184a87a3cf062bd79112ab3" class="ne-p"><br></p><p id="964bff2b1f299a8123c4564cf6c32159" class="ne-p"><span class="ne-text">所有的 Pthreads 都有特定的属性，每一个都含有标识符、一组寄存器（包括程序计数器）和一组存储在结构中的属性。这个属性包括堆栈大小、调度参数以及其他线程需要的项目。</span></p><p id="8557a0d1a9c2d19f43f23a025b5b1e9d" class="ne-p"><br></p><h3 id="15ab0a3d"><span class="ne-text">线程实现</span></h3><p id="5e3030d48820fc3f997c9fc07867d415" class="ne-p"><br></p><p id="bfec13543c9248ed01602aac8986d3b1" class="ne-p"><span class="ne-text">主要有三种实现方式</span></p><p id="6ca771c1e461f72989e0d3259a67f52e" class="ne-p"><br></p><ul class="ne-ul"><li id="7c27924bef969657528fcdaaa609f955"><span class="ne-text">在用户空间中实现线程；</span></li><li id="600f350c1424b2986a7804ec78dc04b3"><span class="ne-text">在内核空间中实现线程；</span></li></ul><ul class="ne-ul"><li id="edbb0a2cf6d6e63294285f0299dda3fc"><span class="ne-text">在用户和内核空间中混合实现线程。</span></li></ul><p id="4c6f55a17135de2b2291efc72cead4d1" class="ne-p"><br></p><p id="83eff6a3553c469021aa6db1dceec0d9" class="ne-p"><span class="ne-text">下面我们分开讨论一下</span></p><p id="9572d3617e09301baa3ee984f1c92f5c" class="ne-p"><br></p><h4 id="9f307c8e"><span class="ne-text">在用户空间中实现线程</span></h4><p id="42e095da41230932ab0833eed35e4a62" class="ne-p"><br></p><p id="95fe62305076810bbdbc0548d37541ba" class="ne-p"><span class="ne-text">第一种方法是把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。所有的这类实现都有同样的通用结构</span></p><p id="276d2eb1fdc4a41e4173ea11b35f5cc2" class="ne-p"><br></p><p id="7a5fa3aa9f73d81d2fb09d64a02e4f3b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829565-1733358e-dbe8-4e1e-ab32-50b95d98a6e3.png" width="599" id="uVF3u" class="ne-image"></p><p id="994599839f8a0493163453339bc36bf1" class="ne-p"><br></p><p id="eff4df6ded311edd97d79b039f96d79d" class="ne-p"><span class="ne-text">线程在运行时系统之上运行，运行时系统是管理线程过程的集合，包括前面提到的四个过程： pthread_create, pthread_exit, pthread_join 和 pthread_yield。</span></p><p id="9f01a3a063f4e73adb15e108ca6a7eea" class="ne-p"><br></p><h3 id="78ffb122"><span class="ne-text">在内核中实现线程</span></h3><p id="c1f41f5788707afdebb1adada6659535" class="ne-p"><br></p><p id="31823d31c3e4c8a1d3e9c4053e65166f" class="ne-p"><span class="ne-text">当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个系统调用，这个系统调用通过对线程表的更新来完成线程创建或销毁工作。</span></p><p id="70941018fd44652b5554c9be911f4bb4" class="ne-p"><br></p><p id="74b4ad9f0cf425a882479e7b9fccc210" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829600-91569966-c35c-4db1-858b-f7fcae7729c3.png" width="600" id="hh20v" class="ne-image"></p><p id="9be5d4ee6254ece2371dae576e1ce5ed" class="ne-p"><br></p><p id="ca2c3a358734c3ac5a68fd4da8a6f6d1" class="ne-p"><span class="ne-text">内核中的线程表持有每个线程的寄存器、状态和其他信息。这些信息和用户空间中的线程信息相同，但是位置却被放在了内核中而不是用户空间中。另外，内核还维护了一张进程表用来跟踪系统状态。</span></p><p id="5d51544c741cef09fd2074b01c87b917" class="ne-p"><br></p><p id="446a4e049bb4f8b4e6d08161a35277b5" class="ne-p"><span class="ne-text">所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 CPU 时间片（或者没有可运行的线程存在了）为止。</span></p><p id="15f0ff35b5546621cdfa2a7240307b67" class="ne-p"><br></p><h3 id="26e17fd6"><span class="ne-text">混合实现</span></h3><p id="b5ee17fce17b6cdbe43273512e22ecb9" class="ne-p"><br></p><p id="63976c7cc6bac642a93b4f69c61c73b7" class="ne-p"><span class="ne-text">结合用户空间和内核空间的优点，设计人员采用了一种</span><code class="ne-code"><span class="ne-text">内核级线程</span></code><span class="ne-text">的方式，然后将用户级线程与某些或者全部内核线程多路复用起来</span></p><p id="a817d6cedfd6372e5126592d084db2cd" class="ne-p"><br></p><p id="065866846bc241326c1231ae19b4e8c3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829624-481cc859-db6d-4516-8dc4-6ea9f958c022.png" width="647" id="z1E6R" class="ne-image"></p><p id="80cc0ff3caab76b5b04463be351d36e6" class="ne-p"><br></p><p id="46d3024237e6c858dddb4620413c3f9d" class="ne-p"><span class="ne-text">在这种模型中，编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。</span></p><p id="cafd9a2584fc98d82c47a69f4eb4a44a" class="ne-p"><br></p><h2 id="13747cb9"><span class="ne-text">进程间通信</span></h2><p id="89f23068c1d014c8ae7379c1ee4ff256" class="ne-p"><br></p><p id="ae233faa7b8916909e1f871f4d9ceb06" class="ne-p"><span class="ne-text">进程是需要频繁的和其他进程进行交流的。下面我们会一起讨论有关 </span><code class="ne-code"><span class="ne-text">进程间通信(Inter Process Communication, IPC)</span></code><span class="ne-text"> 的问题。大致来说，进程间的通信机制可以分为 6 种</span></p><p id="dfe97806c12fe7f893011f144d1a8165" class="ne-p"><br></p><p id="bc4ca741dee963edba6ac3cea886b95e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829616-22b9e251-36fa-4a65-8102-204b899c01ca.png" width="772" id="WxiTX" class="ne-image"></p><p id="13d5bccfbad5a2bc08c0ae4830359792" class="ne-p"><br></p><p id="2cc0c61db915799a3dab5663db6d75de" class="ne-p"><span class="ne-text">下面我们分别对其进行概述</span></p><p id="7666fa53af51829ddb54296233381012" class="ne-p"><br></p><h3 id="cf09c6fb"><span class="ne-text">信号 signal</span></h3><p id="f2d6f42f7be9db0ef2e31f6e6bec3b21" class="ne-p"><br></p><p id="f56f26bead6812e39ebd085c6282a029" class="ne-p"><span class="ne-text">信号是 UNIX 系统最先开始使用的进程间通信机制，因为 Linux 是继承于 UNIX 的，所以 Linux 也支持信号机制，通过向一个或多个进程发送</span><code class="ne-code"><span class="ne-text">异步事件信号</span></code><span class="ne-text">来实现，信号可以从键盘或者访问不存在的位置等地方产生；信号通过 shell 将任务发送给子进程。</span></p><p id="77a00de06ad8a313624bebd7197daab0" class="ne-p"><br></p><p id="c3a46e2f457eb12ac07b2735125ed640" class="ne-p"><span class="ne-text">你可以在 Linux 系统上输入 </span><code class="ne-code"><span class="ne-text">kill -l</span></code><span class="ne-text"> 来列出系统使用的信号，下面是我提供的一些信号</span></p><p id="b6d3f3b7ee125b00a6385d6a05e9c790" class="ne-p"><br></p><p id="c332f05576b8b21614e769f51765e046" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829652-e25e8aaa-523f-49e7-91a6-13af7872483a.png" width="736" id="iFTA7" class="ne-image"></p><p id="e94793bcd68a9f5383857361c260794e" class="ne-p"><br></p><p id="1e0b0c18d976e2cb412fe31f463b0b70" class="ne-p"><span class="ne-text">进程可以选择忽略发送过来的信号，但是有两个是不能忽略的：</span><code class="ne-code"><span class="ne-text">SIGSTOP</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">SIGKILL</span></code><span class="ne-text"> 信号。SIGSTOP 信号会通知当前正在运行的进程执行关闭操作，SIGKILL 信号会通知当前进程应该被杀死。除此之外，进程可以选择它想要处理的信号，进程也可以选择阻止信号，如果不阻止，可以选择自行处理，也可以选择进行内核处理。如果选择交给内核进行处理，那么就执行默认处理。</span></p><p id="f463e7202028da7ee34fa86439d2d0bc" class="ne-p"><br></p><p id="97307b7fc6bb2a3d3a6c7415c2d1a58f" class="ne-p"><span class="ne-text">操作系统会中断目标程序的进程来向其发送信号、在任何非原子指令中，执行都可以中断，如果进程已经注册了新号处理程序，那么就执行进程，如果没有注册，将采用默认处理的方式。</span></p><p id="f0d78f86dcc225fbef3bc7ca4b9c2eae" class="ne-p"><br></p><h3 id="79c52210"><span class="ne-text">管道 pipe</span></h3><p id="e581372206c587ee595cd8880c7fe68c" class="ne-p"><br></p><p id="7d6b1edbc43ab03cd76e374db13b3d79" class="ne-p"><span class="ne-text">Linux 系统中的进程可以通过建立管道 pipe 进行通信</span></p><p id="8ccfe4d2fc3be296206ee867a830076f" class="ne-p"><br></p><p id="e4d7d6e07cdeb822a190325504719442" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829658-0cfbf5f9-97b3-4972-8205-7953cdab82b7.png" width="729" id="UyA6r" class="ne-image"></p><p id="b1d8ec45d3bd885ef634b40206c6be13" class="ne-p"><br></p><p id="94564611bd47217e8819b4129456507f" class="ne-p"><span class="ne-text">在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止。shell 中的</span><code class="ne-code"><span class="ne-text">管线 pipelines</span></code><span class="ne-text"> 就是用管道实现的，当 shell 发现输出</span></p><p id="f6df0669510949bc580d81d8ca93eb12" class="ne-p"><br></p><pre data-language="null" id="8f337cd0" class="ne-codeblock language-null">sort <f | head</pre><p id="41e8a4181b2a6e81046de5357f803804" class="ne-p"><br></p><p id="b87e76fec29ab8fc296c13120144f137" class="ne-p"><span class="ne-text">它会创建两个进程，一个是 sort，一个是 head，sort，会在这两个应用程序之间建立一个管道使得 sort 进程的标准输出作为 head 程序的标准输入。sort 进程产生的输出就不用写到文件中了，如果管道满了系统会停止 sort 以等待 head 读出数据</span></p><p id="2dde603cd64cf50dcaf8d9d7df59a61f" class="ne-p"><br></p><p id="5e1bfd07d47f7ada8a6d809c79141d39" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829684-0f55014e-302f-4dbe-9ea8-9ee4d6c9fdeb.png" width="488" id="irplH" class="ne-image"></p><p id="5e74f9a53149c90944e0bad4389f82c3" class="ne-p"><br></p><p id="57493598a8059c5e29d760919d110090" class="ne-p"><span class="ne-text">管道实际上就是 </span><code class="ne-code"><span class="ne-text">|</span></code><span class="ne-text">，两个应用程序不知道有管道的存在，一切都是由 shell 管理和控制的。</span></p><p id="9135a0a2091dee1a4cfbf8c684405913" class="ne-p"><br></p><h3 id="72b83631"><span class="ne-text">共享内存 shared memory</span></h3><p id="b441fd0f50991bc8fbdb133ed2bfecc1" class="ne-p"><br></p><p id="5c9437460a98ec5c1b1963be737e891a" class="ne-p"><span class="ne-text">两个进程之间还可以通过共享内存进行进程间通信，其中两个或者多个进程可以访问公共内存空间。两个进程的共享工作是通过共享内存完成的，一个进程所作的修改可以对另一个进程可见(很像线程间的通信)。</span></p><p id="3b7e81fdce6f289a7b5b128d1c5890be" class="ne-p"><br></p><p id="84515a95f3770ad7ac1586bd0d382886" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829708-7158a6ec-203c-42aa-96bb-7946e3fb959a.png" width="659" id="WYSoT" class="ne-image"></p><p id="d4fb40df164d63a65f225277e42634fa" class="ne-p"><br></p><p id="caab3879748d4be435662e13c24b3335" class="ne-p"><span class="ne-text">在使用共享内存前，需要经过一系列的调用流程，流程如下</span></p><p id="c59ad6e8a32a354abe821f6b1d455495" class="ne-p"><br></p><ul class="ne-ul"><li id="eaf12986b718d744584491248cd9ad59"><span class="ne-text">创建共享内存段或者使用已创建的共享内存段</span><code class="ne-code"><span class="ne-text">(shmget())</span></code></li><li id="07722001603dcec1909ffeebbc9bbba5"><span class="ne-text">将进程附加到已经创建的内存段中</span><code class="ne-code"><span class="ne-text">(shmat())</span></code></li></ul><ul class="ne-ul"><li id="c08827f8c1685d8ec2163aebf19295b9"><span class="ne-text">从已连接的共享内存段分离进程</span><code class="ne-code"><span class="ne-text">(shmdt())</span></code></li><li id="8cd7c3fb9d858dcc81002e015465844d"><span class="ne-text">对共享内存段执行控制操作</span><code class="ne-code"><span class="ne-text">(shmctl())</span></code></li></ul><p id="8b6f722bbcdffe424e246ed3a95b9cec" class="ne-p"><br></p><h3 id="c4f8f8c1"><span class="ne-text">先入先出队列 FIFO</span></h3><p id="52767acac0b583fa16bd52993f2cff1a" class="ne-p"><br></p><p id="a66eca62deab14281ed14fd5255e4c7c" class="ne-p"><span class="ne-text">先入先出队列 FIFO 通常被称为 </span><code class="ne-code"><span class="ne-text">命名管道(Named Pipes)</span></code><span class="ne-text">，命名管道的工作方式与常规管道非常相似，但是确实有一些明显的区别。未命名的管道没有备份文件：操作系统负责维护内存中的缓冲区，用来将字节从写入器传输到读取器。一旦写入或者输出终止的话，缓冲区将被回收，传输的数据会丢失。相比之下，命名管道具有支持文件和独特 API ，命名管道在文件系统中作为设备的专用文件存在。当所有的进程通信完成后，命名管道将保留在文件系统中以备后用。命名管道具有严格的 FIFO 行为</span></p><p id="4c4130835544d2e4037541a399c00274" class="ne-p"><br></p><p id="518b30630e1757de83724356bf420c6f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829713-f872efe8-5031-4f02-89ad-8c8351a854c7.png" width="584" id="gHPi1" class="ne-image"></p><p id="64556edd5c72d351442d4c215bd78afa" class="ne-p"><br></p><p id="ad02a68ae4b9a278228e0e65be24c577" class="ne-p"><span class="ne-text">写入的第一个字节是读取的第一个字节，写入的第二个字节是读取的第二个字节，依此类推。</span></p><p id="cacfa57508b4cbca4112ae43dda31420" class="ne-p"><br></p><h3 id="cf4ddbc3"><span class="ne-text">消息队列 Message Queue</span></h3><p id="f3a9949035996a711f2acc9e1cb8a548" class="ne-p"><br></p><p id="502aac7079420863be2b507a816dad7f" class="ne-p"><span class="ne-text">一听到消息队列这个名词你可能不知道是什么意思，消息队列是用来描述内核寻址空间内的内部链接列表。可以按几种不同的方式将消息按顺序发送到队列并从队列中检索消息。每个消息队列由 IPC 标识符唯一标识。消息队列有两种模式，一种是</span><code class="ne-code"><span class="ne-text">严格模式</span></code><span class="ne-text">， 严格模式就像是 FIFO 先入先出队列似的，消息顺序发送，顺序读取。还有一种模式是 </span><code class="ne-code"><span class="ne-text">非严格模式</span></code><span class="ne-text">，消息的顺序性不是非常重要。</span></p><p id="76610295702efeb67524a09a51ca022c" class="ne-p"><br></p><h3 id="fbaf7bbe"><span class="ne-text">套接字 Socket</span></h3><p id="9f141557fe97223eea8773c539b9552a" class="ne-p"><br></p><p id="28af2f3a58533de88a523266b8f66673" class="ne-p"><span class="ne-text">还有一种管理两个进程间通信的是使用 </span><code class="ne-code"><span class="ne-text">socket</span></code><span class="ne-text">，socket 提供端到端的双相通信。一个套接字可以与一个或多个进程关联。就像管道有命令管道和未命名管道一样，套接字也有两种模式，套接字一般用于两个进程之间的网络通信，网络套接字需要来自诸如</span><code class="ne-code"><span class="ne-text">TCP（传输控制协议）</span></code><span class="ne-text">或较低级别</span><code class="ne-code"><span class="ne-text">UDP（用户数据报协议）</span></code><span class="ne-text">等基础协议的支持。</span></p><p id="8c6d6b235890be26598ba16ff7a067fe" class="ne-p"><br></p><p id="203016d407ce5eb34e08849dadb79d88" class="ne-p"><span class="ne-text">套接字有以下几种分类</span></p><p id="854024933d86bf7a4d7c66a6b9ea755a" class="ne-p"><br></p><ul class="ne-ul"><li id="d8b2232e1900fd6705f4245543d5376b"><code class="ne-code"><span class="ne-text">顺序包套接字(Sequential Packet Socket)</span></code><span class="ne-text">： 此类套接字为最大长度固定的数据报提供可靠的连接。此连接是双向的并且是顺序的。</span></li><li id="d95a76dd1ca1ff9e7882c7f123319b54"><code class="ne-code"><span class="ne-text">数据报套接字(Datagram Socket)</span></code><span class="ne-text">：数据包套接字支持双向数据流。数据包套接字接受消息的顺序与发送者可能不同。</span></li></ul><ul class="ne-ul"><li id="055798b0b774376247582b29b38e9e51"><code class="ne-code"><span class="ne-text">流式套接字(Stream Socket)</span></code><span class="ne-text">：流套接字的工作方式类似于电话对话，提供双向可靠的数据流。</span></li><li id="485881b289944fc9644438d0af5b2bab"><code class="ne-code"><span class="ne-text">原始套接字(Raw Socket)</span></code><span class="ne-text">： 可以使用原始套接字访问基础通信协议。</span></li></ul><p id="06fb91a72234b4c3fa8fe3c525213a6c" class="ne-p"><br></p><h2 id="b088138c"><span class="ne-text">调度</span></h2><p id="db46aa2e41d292eabf878a29ae6e1eb9" class="ne-p"><br></p><p id="ac80db1c477dc4d61938c67e1e24cf4e" class="ne-p"><span class="ne-text">当一个计算机是多道程序设计系统时，会频繁的有很多进程或者线程来同时竞争 CPU 时间片。当两个或两个以上的进程/线程处于就绪状态时，就会发生这种情况。如果只有一个 CPU 可用，那么必须选择接下来哪个进程/线程可以运行。操作系统中有一个叫做 </span><code class="ne-code"><span class="ne-text">调度程序(scheduler)</span></code><span class="ne-text"> 的角色存在，它就是做这件事儿的，该程序使用的算法叫做 </span><code class="ne-code"><span class="ne-text">调度算法(scheduling algorithm)</span></code><span class="ne-text"> 。</span></p><p id="1ff7123ceb621d6eaa21f166661d48b5" class="ne-p"><br></p><h3 id="3b22ed94"><span class="ne-text">调度算法的分类</span></h3><p id="0536eab6c3f4f86d8c9e1eb4c2caa9ce" class="ne-p"><br></p><p id="50c7a2aa3ff0a2a07aaaabc9d81745d1" class="ne-p"><span class="ne-text">毫无疑问，不同的环境下需要不同的调度算法。之所以出现这种情况，是因为不同的应用程序和不同的操作系统有不同的目标。也就是说，在不同的系统中，调度程序的优化也是不同的。这里有必要划分出三种环境</span></p><p id="df6c20d6e0a6232273f0d1601c76cabd" class="ne-p"><br></p><ul class="ne-ul"><li id="0d3206be3b8ae11db093294df323407e"><code class="ne-code"><span class="ne-text">批处理(Batch)</span></code><span class="ne-text"> : 商业领域</span></li><li id="e9309e368b52d8797ac81aed29cd060e"><code class="ne-code"><span class="ne-text">交互式(Interactive)</span></code><span class="ne-text"> ： 交互式用户环境</span></li></ul><ul class="ne-ul"><li id="efe0fd41056503e2ca46a96cc1fbf80a"><code class="ne-code"><span class="ne-text">实时(Real time)</span></code></li></ul><p id="630e123e440c743aa695a6f16637ef25" class="ne-p"><br></p><h3 id="cc6a2057"><span class="ne-text">批处理中的调度</span></h3><p id="337455c979553991e97c1bdf5f17b0ec" class="ne-p"><br></p><p id="abd9e19e95f4d0564da8037374dd3741" class="ne-p"><span class="ne-text">现在让我们把目光从一般性的调度转换为特定的调度算法。下面我们会探讨在批处理中的调度。</span></p><p id="7dc9c8578156af1d69a73bd6804b3cdf" class="ne-p"><br></p><h4 id="400c234c"><span class="ne-text">先来先服务</span></h4><p id="50d75b4163179fa5fa7fc840e8287dc1" class="ne-p"><br></p><p id="52ddec5249cbe7ff90aa61f7d024e8d0" class="ne-p"><span class="ne-text">最简单的非抢占式调度算法的设计就是 </span><code class="ne-code"><span class="ne-text">先来先服务(first-come,first-serverd)</span></code><span class="ne-text">。当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。</span></p><p id="16c8c47a7ed1c45b2de1234c1bb04c16" class="ne-p"><br></p><p id="95d765b412db9d37d883066bcc827d68" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829697-a9e6978f-5f26-4491-8a57-4691ea81546b.png" width="709" id="fZNys" class="ne-image"></p><p id="d04f25840bac9f45b0816d3340b83e6f" class="ne-p"><br></p><p id="366e0b92b10f32bf06f3957591c4d306" class="ne-p"><span class="ne-text">这个算法的强大之处在于易于理解和编程，在这个算法中，一个单链表记录了所有就绪进程。要选取一个进程运行，只要从该队列的头部移走一个进程即可；要添加一个新的作业或者阻塞一个进程，只要把这个作业或进程附加在队列的末尾即可。这是很简单的一种实现。</span></p><p id="c90bc0690170107bb9cc1bfcf44a1869" class="ne-p"><br></p><h4 id="6b3d276b"><span class="ne-text">最短作业优先</span></h4><p id="7ae3f2475901cff482d976aea0dcce3d" class="ne-p"><br></p><p id="468e7a05528290bbd0be1d2d98c139b5" class="ne-p"><span class="ne-text">批处理中，第二种调度算法是 </span><code class="ne-code"><span class="ne-text">最短作业优先(Shortest Job First)</span></code><span class="ne-text">，我们假设运行时间已知。例如，一家保险公司，因为每天要做类似的工作，所以人们可以相当精确地预测处理 1000 个索赔的一批作业需要多长时间。当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短优先作业算法</span></p><p id="bbea4d15d597e1b2dbbcb2ec89f4bb11" class="ne-p"><br></p><p id="a517b18d42d12e1b8a78a7509be7885f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829752-b3677366-5828-45be-9c62-d182dce0a26e.png" width="695" id="LgBd9" class="ne-image"></p><p id="f1c689fa90494cf32bd7f6aec4ba09af" class="ne-p"><br></p><div class="ne-quote"><p id="b6c055d28c6fdd14f00876b918817a67" class="ne-p"><span class="ne-text">需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。</span></p></div><p id="3a11d311f7f2e5161f91e1442bf04adc" class="ne-p"><br></p><h4 id="0333fbb6"><span class="ne-text">最短剩余时间优先</span></h4><p id="92ead72ad4d93735b706d26474e6a2e4" class="ne-p"><br></p><p id="de6d4308827fa52aa18b1fc1eb0c02db" class="ne-p"><span class="ne-text">最短作业优先的抢占式版本被称作为 </span><code class="ne-code"><span class="ne-text">最短剩余时间优先(Shortest Remaining Time Next)</span></code><span class="ne-text"> 算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。</span></p><p id="b3ae427a7dda06a6f658ab859d284ec9" class="ne-p"><br></p><h3 id="3741716d"><span class="ne-text">交互式系统中的调度</span></h3><p id="422ebaab9625add00d44934dd813586f" class="ne-p"><br></p><p id="5137e8748df6e262c0ad40bc23d1ac26" class="ne-p"><span class="ne-text">交互式系统中在个人计算机、服务器和其他系统中都是很常用的，所以有必要来探讨一下交互式调度</span></p><p id="b7b5379045dd5e6e2189718effe74ae0" class="ne-p"><br></p><h4 id="8bea3bc8"><span class="ne-text">轮询调度</span></h4><p id="c5e4cc242c8c1a6b1a380f5ffb966ab1" class="ne-p"><br></p><p id="26df182ec60081d548dae5cbd53321de" class="ne-p"><span class="ne-text">一种最古老、最简单、最公平并且最广泛使用的算法就是 </span><code class="ne-code"><span class="ne-text">轮询算法(round-robin)</span></code><span class="ne-text">。每个进程都会被分配一个时间段，称为</span><code class="ne-code"><span class="ne-text">时间片(quantum)</span></code><span class="ne-text">，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个 CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，就像下图中的 a，当一个进程用完时间片后就被移到队列的末尾，就像下图的 b。</span></p><p id="2a48ba8c954dab1a6cbe6acc552135f3" class="ne-p"><br></p><p id="ad704eaa039166852e0fd5cd8ee74b31" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829772-8a1f4a69-9934-4cf9-b1bd-80a69f410e13.png" width="724" id="Zwr0C" class="ne-image"></p><p id="a0dd0fcd6b9dfa625206206a78e03ac6" class="ne-p"><br></p><h4 id="88650772"><span class="ne-text">优先级调度</span></h4><p id="59456b117bfb3b8f23d61c02b4b66490" class="ne-p"><br></p><p id="2286b41a5fbc982ed667d87f5fb1518f" class="ne-p"><span class="ne-text">轮询调度假设了所有的进程是同等重要的。但事实情况可能不是这样。例如，在一所大学中的等级制度，首先是院长，然后是教授、秘书、后勤人员，最后是学生。这种将外部情况考虑在内就实现了</span><code class="ne-code"><span class="ne-text">优先级调度(priority scheduling)</span></code></p><p id="a4784b0754fc345730f6757657160021" class="ne-p"><br></p><p id="c011fa04b7f2812398f076cb4e99b1fd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829781-669962be-9966-4de1-be47-f3e9822459eb.png" width="678" id="Lt9Nc" class="ne-image"></p><p id="417688711448227baa00b80a4ddecb3f" class="ne-p"><br></p><p id="c6dc6554e74b480c52c7a694b6a90a73" class="ne-p"><span class="ne-text">它的基本思想很明确，每个进程都被赋予一个优先级，优先级高的进程优先运行。</span></p><p id="9121719585434ff2f0a1fca66a3e46d5" class="ne-p"><br></p><h4 id="edc1014b"><span class="ne-text">多级队列</span></h4><p id="6e60cd02590664c4b1a39db6543af092" class="ne-p"><br></p><p id="017210b6aad11b943d3912c5cffa57e5" class="ne-p"><span class="ne-text">最早使用优先级调度的系统是 </span><code class="ne-code"><span class="ne-text">CTSS(Compatible TimeSharing System)</span></code><span class="ne-text">。CTSS 在每次切换前都需要将当前进程换出到磁盘，并从磁盘上读入一个新进程。为 CPU 密集型进程设置较长的时间片比频繁地分给他们很短的时间要更有效（减少交换次数）。另一方面，如前所述，长时间片的进程又会影响到响应时间，解决办法是设置优先级类。属于最高优先级的进程运行一个时间片，次高优先级进程运行 2 个时间片，再下面一级运行 4 个时间片，以此类推。当一个进程用完分配的时间片后，它被移到下一类。</span></p><p id="bae603c7682382f7e3af58359797cb99" class="ne-p"><br></p><h4 id="9e5db475"><span class="ne-text">最短进程优先</span></h4><p id="d3fd5aec5606c3f51805ab6ba705c676" class="ne-p"><br></p><p id="c1612c156911dcadfd48e601dc6cff0a" class="ne-p"><span class="ne-text">最短进程优先是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。假设每个终端上每条命令的预估运行时间为 </span><code class="ne-code"><span class="ne-text">T0</span></code><span class="ne-text">，现在假设测量到其下一次运行时间为 </span><code class="ne-code"><span class="ne-text">T1</span></code><span class="ne-text">，可以用两个值的加权来改进估计时间，即</span><code class="ne-code"><span class="ne-text">aT0+ (1- 1)T1</span></code><span class="ne-text">。通过选择 a 的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当 a = 1/2 时，可以得到下面这个序列</span></p><p id="6769b00d23ae9769141733ed8b1fcd6d" class="ne-p"><br></p><p id="091226d35ecf107e9b32444780d14bcc" class="ne-p"><span class="ne-text">![image-20200220120452410](/Users/mr.l/Library/Application Support/typora-user-images/image-20200220120452410.png)</span></p><p id="c46a33578ba15bf3a896acf4a7439d4b" class="ne-p"><br></p><p id="b84ae544ee7149cb676643c21f7c4002" class="ne-p"><span class="ne-text">可以看到，在三轮过后，T0 在新的估计值中所占比重下降至 1/8。</span></p><p id="a1f413692778469baa56acbd5ffcf6d0" class="ne-p"><br></p><h4 id="5abf2b05"><span class="ne-text">保证调度</span></h4><p id="01ce9b320999207d18ddc9192f428dbc" class="ne-p"><br></p><p id="8a68e211434a7f5613ac4f8218909916" class="ne-p"><span class="ne-text">一种完全不同的调度方法是对用户做出明确的性能保证。一种实际而且容易实现的保证是：若用户工作时有 n 个用户登录，则每个用户将获得 CPU 处理能力的 1/n。类似地，在一个有 n 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 1/n 的 CPU 时间。</span></p><p id="bad28048c33e866f65513743c9071379" class="ne-p"><br></p><h4 id="6d170350"><span class="ne-text">彩票调度</span></h4><p id="1ec63cbf9f419d479434f9b178b91ee5" class="ne-p"><br></p><p id="c994c1728228b0f8690b76ebfde67d27" class="ne-p"><span class="ne-text">对用户进行承诺并在随后兑现承诺是一件好事，不过很难实现。但是存在着一种简单的方式，有一种既可以给出预测结果而又有一种比较简单的实现方式的算法，就是 </span><code class="ne-code"><span class="ne-text">彩票调度(lottery scheduling)</span></code><span class="ne-text">算法。</span></p><p id="7a64ea69d571753adc711f3065ec5eb9" class="ne-p"><br></p><p id="009f3b9dc6647cecef4e0f5e64e84e09" class="ne-p"><span class="ne-text">其基本思想是为进程提供各种系统资源（例如 CPU 时间）的彩票。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得该资源。在应用到 CPU 调度时，系统可以每秒持有 50 次抽奖，每个中奖者将获得比如 20 毫秒的 CPU 时间作为奖励。</span></p><p id="21e629b1eaa9fcd18efe030f5360b954" class="ne-p"><br></p><h4 id="f52d1789"><span class="ne-text">公平分享调度</span></h4><p id="454ce166479faf6b0bac6a5a1d950fc0" class="ne-p"><br></p><p id="3e7328aa85fbda7ea81e5451ecd63f55" class="ne-p"><span class="ne-text">到目前为止，我们假设被调度的都是各个进程自身，而不用考虑该进程的拥有者是谁。结果是，如果用户 1 启动了 9 个进程，而用户 2 启动了一个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90 % 的 CPU 时间，而用户 2 将之得到 10 % 的 CPU 时间。</span></p><p id="247ab6cb450a5c6c2432cec96ed7ec6e" class="ne-p"><br></p><p id="a8997400e66c5b2d256fccc7ea3776bf" class="ne-p"><span class="ne-text">为了阻止这种情况的出现，一些系统在调度前会把进程的拥有者考虑在内。在这种模型下，每个用户都会分配一些 CPU 时间，而调度程序会选择进程并强制执行。因此如果两个用户每个都会有 50% 的 CPU 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 CPU 份额。</span></p><p id="25cfa5c1dd3833edf698f7172bb0cd48" class="ne-p"><br></p><p id="8a2de1e6a6957d4a3a1cd8ddd4f15cf3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829805-f1649640-92c0-4cc0-9d11-d33091868df3.png" width="681" id="s6DG8" class="ne-image"></p><p id="a71b4648e92abc3a0a98e890305bbfc7" class="ne-p"><br></p><h3 id="e87fdf39"><span class="ne-text">实时系统中的调度</span></h3><p id="65e73472811dc36880ee811fac3bfc94" class="ne-p"><br></p><p id="2f7c753cdac04c87a34af91ae1219692" class="ne-p"><code class="ne-code"><span class="ne-text">实时系统(real-time)</span></code><span class="ne-text"> 是一个时间扮演了重要作用的系统。实时系统可以分为两类，</span><code class="ne-code"><span class="ne-text">硬实时(hard real time)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">软实时(soft real time)</span></code><span class="ne-text"> 系统，前者意味着必须要满足绝对的截止时间；后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。</span></p><p id="670523a1b5511e2dbbe7df30ea900b9d" class="ne-p"><br></p><p id="f974b8ccc4e8617c2d30cf67ec750345" class="ne-p"><span class="ne-text">实时系统中的事件可以按照响应方式进一步分类为</span><code class="ne-code"><span class="ne-text">周期性(以规则的时间间隔发生)</span></code><span class="ne-text">事件或 </span><code class="ne-code"><span class="ne-text">非周期性(发生时间不可预知)</span></code><span class="ne-text">事件。一个系统可能要响应多个周期性事件流，根据每个事件处理所需的时间，可能甚至无法处理所有事件。例如，如果有 m 个周期事件，事件 i 以周期 Pi 发生，并需要 Ci 秒 CPU 时间处理一个事件，那么可以处理负载的条件是</span></p><p id="d8cf2cf43fb9725d8547f64247372780" class="ne-p"><br></p><p id="0d5983b3ee8a785dc8f03c345ec7a943" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829813-d541b483-e6c2-4e61-b29d-faf9719ce83f.png" width="180" id="ufEZW" class="ne-image"></p><p id="97acdb638c547195b6ef846c1e51b89f" class="ne-p"><br></p><p id="ef8f27436da7fb3f3e483c323e3bf505" class="ne-p"><span class="ne-text">只有满足这个条件的实时系统称为</span><code class="ne-code"><span class="ne-text">可调度的</span></code><span class="ne-text">，这意味着它实际上能够被实现。一个不满足此检验标准的进程不能被调度，因为这些进程共同需要的 CPU 时间总和大于 CPU 能提供的时间。</span></p><p id="253e9dd88734332a7e277657f4bbe7aa" class="ne-p"><br></p><p id="84fb8043025bc72a7a331f4b2038fec9" class="ne-p"><span class="ne-text">下面我们来了解一下内存管理，你需要知道的知识点如下</span></p><p id="be344a47b1bc97136a272661dcae26ab" class="ne-p"><br></p><p id="08d4a9f1f09106f5567bc8cd8ce5f2ea" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829871-ad9be6cd-aa53-4acc-b245-5dd76199a6ba.png" width="742" id="qZ8YJ" class="ne-image"></p><p id="897f56e4266d6ddefb7a80f14fdc066f" class="ne-p"><br></p><h2 id="f8c25083"><span class="ne-text">地址空间</span></h2><p id="bde8f9f383388c601478c74a93453ac7" class="ne-p"><br></p><p id="ec6517c213e0ba8f57072f457233836a" class="ne-p"><span class="ne-text">如果要使多个应用程序同时运行在内存中，必须要解决两个问题：</span><code class="ne-code"><span class="ne-text">保护</span></code><span class="ne-text">和 </span><code class="ne-code"><span class="ne-text">重定位</span></code><span class="ne-text">。第一种解决方式是用</span><code class="ne-code"><span class="ne-text">保护密钥标记内存块</span></code><span class="ne-text">，并将执行过程的密钥与提取的每个存储字的密钥进行比较。这种方式只能解决第一种问题（破坏操作系统），但是不能解决多进程在内存中同时运行的问题。</span></p><p id="5a59697a4c5abbfa70470c3bd42ae884" class="ne-p"><br></p><p id="edaf48dfdb5c68281fed3d81ca91c83e" class="ne-p"><span class="ne-text">还有一种更好的方式是创造一个存储器抽象：</span><code class="ne-code"><span class="ne-text">地址空间(the address space)</span></code><span class="ne-text">。就像进程的概念创建了一种抽象的 CPU 来运行程序，地址空间也创建了一种抽象内存供程序使用。</span></p><p id="8b864388ad7cbe940f6df98cf8047f40" class="ne-p"><br></p><h4 id="dc58b76e"><span class="ne-text">基址寄存器和变址寄存器</span></h4><p id="688b9c8ffedbb24b760571665f734e30" class="ne-p"><br></p><p id="34958411ca47c301b7e17928791bbede" class="ne-p"><span class="ne-text">最简单的办法是使用</span><code class="ne-code"><span class="ne-text">动态重定位(dynamic relocation)</span></code><span class="ne-text">技术，它就是通过一种简单的方式将每个进程的地址空间映射到物理内存的不同区域。还有一种方式是使用基址寄存器和变址寄存器。</span></p><p id="aa38b2f5d51810e34c165ded7b78d47d" class="ne-p"><br></p><ul class="ne-ul"><li id="e880fdf6fcd3d032a4341180b8593207"><span class="ne-text">基址寄存器：存储数据内存的起始位置</span></li><li id="d832ace055abe375212e5ebc6c6de94c"><span class="ne-text">变址寄存器：存储应用程序的长度。</span></li></ul><p id="85d454c1417111a0069356a762f1ad16" class="ne-p"><br></p><p id="c96b02a131713a5288237b39959a7848" class="ne-p"><span class="ne-text">每当进程引用内存以获取指令或读取、写入数据时，CPU 都会自动将</span><code class="ne-code"><span class="ne-text">基址值</span></code><span class="ne-text">添加到进程生成的地址中，然后再将其发送到内存总线上。同时，它检查程序提供的地址是否大于或等于</span><code class="ne-code"><span class="ne-text">变址寄存器</span></code><span class="ne-text"> 中的值。如果程序提供的地址要超过变址寄存器的范围，那么会产生错误并中止访问。</span></p><p id="657477406dfb1d962867bf48ef305165" class="ne-p"><br></p><h3 id="4c736ad5"><span class="ne-text">交换技术</span></h3><p id="2fc583f502358c13597da6fff3de80fd" class="ne-p"><br></p><p id="8c95f9eaf3a6186e888348475003c367" class="ne-p"><span class="ne-text">在程序运行过程中，经常会出现内存不足的问题。</span></p><p id="ddf8522ed4c5cc50a55556b7984536bc" class="ne-p"><br></p><p id="8938c8e1fd6a3f0862e0a2c359b11055" class="ne-p"><span class="ne-text">针对上面内存不足的问题，提出了两种处理方式：最简单的一种方式就是</span><code class="ne-code"><span class="ne-text">交换(swapping)</span></code><span class="ne-text">技术，即把一个进程完整的调入内存，然后再内存中运行一段时间，再把它放回磁盘。空闲进程会存储在磁盘中，所以这些进程在没有运行时不会占用太多内存。另外一种策略叫做</span><code class="ne-code"><span class="ne-text">虚拟内存(virtual memory)</span></code><span class="ne-text">，虚拟内存技术能够允许应用程序部分的运行在内存中。下面我们首先先探讨一下交换</span></p><p id="3ad35936eb8cb28c5c2fa936042097bd" class="ne-p"><br></p><h4 id="7e402db3"><span class="ne-text">交换过程</span></h4><p id="4d79d791ebde11eac836417d99a83a32" class="ne-p"><br></p><p id="de4f76e258b0deaab8ec99cb01bfa6ef" class="ne-p"><span class="ne-text">下面是一个交换过程</span></p><p id="716222faf1c7f3ed190c4114812ce6f8" class="ne-p"><br></p><p id="6ccc90eceb94b75a14c9d216c722138a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829844-31f0d41e-db06-4f4a-86d4-15250999e2dd.png" width="724" id="PM0yA" class="ne-image"></p><p id="dc7cc2c39c8d3f304020512f8ff9b9bc" class="ne-p"><br></p><p id="996bc77c0dba2ac7b6d7396b4b5ca492" class="ne-p"><span class="ne-text">刚开始的时候，只有进程 A 在内存中，然后从创建进程 B 和进程 C 或者从磁盘中把它们换入内存，然后在图 d 中，A 被换出内存到磁盘中，最后 A 重新进来。因为图 g 中的进程 A 现在到了不同的位置，所以在装载过程中需要被重新定位，或者在交换程序时通过软件来执行；或者在程序执行期间通过硬件来重定位。基址寄存器和变址寄存器就适用于这种情况。</span></p><p id="85a1527560367b27f342301a635faa1d" class="ne-p"><br></p><p id="25bb57681bc250f1818434d7d35b4930" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829879-4fde9a55-0c36-4d7d-948a-49841539d0c8.png" width="696" id="SC4tr" class="ne-image"></p><p id="4acee99ad01bb62a54a2e2bd553446b8" class="ne-p"><br></p><p id="2d984474d589be5f5955c2ce294ec16e" class="ne-p"><span class="ne-text">交换在内存创建了多个 </span><code class="ne-code"><span class="ne-text">空闲区(hole)</span></code><span class="ne-text">，内存会把所有的空闲区尽可能向下移动合并成为一个大的空闲区。这项技术称为</span><code class="ne-code"><span class="ne-text">内存紧缩(memory compaction)</span></code><span class="ne-text">。但是这项技术通常不会使用，因为这项技术会消耗很多 CPU 时间。</span></p><p id="b28c8d2e8428888c6adf339dc61047f2" class="ne-p"><br></p><h3 id="6bbc8b2f"><span class="ne-text">空闲内存管理</span></h3><p id="6fd3637e0cb8f6d3d237425a70b8067f" class="ne-p"><br></p><p id="2050198cea7f2d6fa1fddd5ac13c4444" class="ne-p"><span class="ne-text">在进行内存动态分配时，操作系统必须对其进行管理。大致上说，有两种监控内存使用的方式</span></p><p id="79f8b96bcfca73171c3a49ff9cfbf205" class="ne-p"><br></p><ul class="ne-ul"><li id="e72421e316cd2ca7ca62cdeb089ee797"><code class="ne-code"><span class="ne-text">位图(bitmap)</span></code></li><li id="363344e59979446380ae415574aa7cd0"><code class="ne-code"><span class="ne-text">空闲列表(free lists)</span></code></li></ul><p id="b610fbf0037c478e4c50c66707220a71" class="ne-p"><br></p><h4 id="bcd570ff"><span class="ne-text">使用位图的存储管理</span></h4><p id="1b793a00e7d2c49c89beb25f52ff969b" class="ne-p"><br></p><p id="01106bad7b2d039f9d53f44c574b3c78" class="ne-p"><span class="ne-text">使用位图方法时，内存可能被划分为小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲， 1 表示占用（或者相反）。一块内存区域和其对应的位图如下</span></p><p id="f9fd09e0470dab41be4f170ebe495874" class="ne-p"><br></p><p id="d2fd7e81e8fd6d19e6bc81d1ea9dbb09" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829887-83af6188-e02c-4437-8739-40021e8a2957.png" width="734" id="uirOM" class="ne-image"></p><p id="6579c3b5ec2bf6680f8a53ad590b2b3f" class="ne-p"><br></p><p id="0bad0d7b6f984dfeb8fb7d633878dc75" class="ne-p"><code class="ne-code"><span class="ne-text">位图</span></code><span class="ne-text">提供了一种简单的方法在固定大小的内存中跟踪内存的使用情况，因为</span><strong><span class="ne-text">位图的大小取决于内存和分配单元的大小</span></strong><span class="ne-text">。这种方法有一个问题是，当决定为把具有 k 个分配单元的进程放入内存时，</span><code class="ne-code"><span class="ne-text">内容管理器(memory manager)</span></code><span class="ne-text"> 必须搜索位图，在位图中找出能够运行 k 个连续 0 位的串。在位图中找出制定长度的连续 0 串是一个很耗时的操作，这是位图的缺点。（可以简单理解为在杂乱无章的数组中，找出具有一大长串空闲的数组单元）</span></p><p id="eb3f59ae4a980fa5ed18835d708de977" class="ne-p"><br></p><h4 id="467e29df"><span class="ne-text">使用链表进行管理</span></h4><p id="0ba53562a3e5d7f756273229624888b1" class="ne-p"><br></p><p id="65daec3f55e2fb306b3bd1ea1f8ec09e" class="ne-p"><span class="ne-text">另一种记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表，段会包含进程或者是两个进程的空闲区域。可用上面的图 c </span><strong><span class="ne-text">来表示内存的使用情况</span></strong><span class="ne-text">。链表中的每一项都可以代表一个 </span><code class="ne-code"><span class="ne-text">空闲区(H)</span></code><span class="ne-text"> 或者是</span><code class="ne-code"><span class="ne-text">进程(P)</span></code><span class="ne-text">的起始标志，长度和下一个链表项的位置。</span></p><p id="7492aba8e2e2a0b00bddc1bba083dec4" class="ne-p"><br></p><p id="2f92da5d9f5567454cc1afc04526ce0b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829908-832c7960-d7cc-45fc-a029-b803b86a6bf9.png" width="695" id="ZQMqP" class="ne-image"></p><p id="f407fecb833a46515b987fd8965b5866" class="ne-p"><br></p><p id="0dbfeeb82b221eef296e1b1d55fac093" class="ne-p"><span class="ne-text">当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以为创建的进程（或者从磁盘中换入的进程）分配内存。我们先假设内存管理器知道应该分配多少内存，最简单的算法是使用 </span><code class="ne-code"><span class="ne-text">首次适配(first fit)</span></code><span class="ne-text">。内存管理器会沿着段列表进行扫描，直到找个一个足够大的空闲区为止。 除非空闲区大小和要分配的空间大小一样，否则将空闲区分为两部分，一部分供进程使用；一部分生成新的空闲区。首次适配算法是一种速度很快的算法，因为它会尽可能的搜索链表。</span></p><p id="750c592d1471e8b63a925fb723ea5093" class="ne-p"><br></p><p id="b4c3aa0ee2ac733daa864079298d1186" class="ne-p"><span class="ne-text">首次适配的一个小的变体是 </span><code class="ne-code"><span class="ne-text">下次适配(next fit)</span></code><span class="ne-text">。它和首次匹配的工作方式相同，只有一个不同之处那就是下次适配在每次找到合适的空闲区时就会记录当时的位置，以便下次寻找空闲区时从上次结束的地方开始搜索，而不是像首次匹配算法那样每次都会从头开始搜索。</span></p><p id="a21e47b580db1794269936af697ac5b6" class="ne-p"><br></p><p id="154349d0e6d25598125edd960c601f1a" class="ne-p"><span class="ne-text">另外一个著名的并且广泛使用的算法是 </span><code class="ne-code"><span class="ne-text">最佳适配(best fit)</span></code><span class="ne-text">。最佳适配会从头到尾寻找整个链表，找出能够容纳进程的最小空闲区。</span></p><p id="c0239fb5654f6172a04ffc454db60829" class="ne-p"><br></p><h2 id="84429675"><span class="ne-text">虚拟内存</span></h2><p id="a52e80a7a17362a2071a9ac3d43c6331" class="ne-p"><br></p><p id="a3b16b4a43fc377a78e20e68d2604a84" class="ne-p"><span class="ne-text">尽管基址寄存器和变址寄存器用来创建地址空间的抽象，但是这有一个其他的问题需要解决：</span><code class="ne-code"><span class="ne-text">管理软件的不断增大(managing bloatware)</span></code><span class="ne-text">。虚拟内存的基本思想是，每个程序都有自己的地址空间，这个地址空间被划分为多个称为</span><code class="ne-code"><span class="ne-text">页面(page)</span></code><span class="ne-text">的块。每一页都是连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，硬件会立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</span></p><p id="cfc9dd2da74bf0ac8eb66cdcb2922008" class="ne-p"><br></p><h3 id="3862626c"><span class="ne-text">分页</span></h3><p id="ad408dc123ddf88a8c25c2e8c88dae85" class="ne-p"><br></p><p id="4066a9b0016b34734e2fbf3e8f54723b" class="ne-p"><span class="ne-text">大部分使用虚拟内存的系统中都会使用一种 </span><code class="ne-code"><span class="ne-text">分页(paging)</span></code><span class="ne-text"> 技术。在任何一台计算机上，程序会引用使用一组内存地址。当程序执行</span></p><p id="d759b00624e8ef1625c86e6add1eddcb" class="ne-p"><br></p><pre data-language="assembly" id="d0a4f960" class="ne-codeblock language-assembly">MOV REG,1000</pre><p id="89add3c3374d8e28c840c7bccca4a7e5" class="ne-p"><br></p><p id="96c2f3af046d1e1074a249ed5b62d8d1" class="ne-p"><span class="ne-text">这条指令时，它会把内存地址为 1000 的内存单元的内容复制到 REG 中（或者相反，这取决于计算机）。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。</span></p><p id="d4405ed4f3767b04521138e8ae125763" class="ne-p"><br></p><p id="bb0d8776d1f68b804c2256cb8e6a8782" class="ne-p"><span class="ne-text">这些程序生成的地址被称为 </span><code class="ne-code"><span class="ne-text">虚拟地址(virtual addresses)</span></code><span class="ne-text"> 并形成</span><code class="ne-code"><span class="ne-text">虚拟地址空间(virtual address space)</span></code><span class="ne-text">，在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存中线上，读写操作都使用同样地址的物理内存。</span><strong><span class="ne-text">在使用虚拟内存时，虚拟地址不会直接发送到内存总线上</span></strong><span class="ne-text">。相反，会使用 </span><code class="ne-code"><span class="ne-text">MMU(Memory Management Unit)</span></code><span class="ne-text"> 内存管理单元把</span><strong><span class="ne-text">虚拟地址映射为物理内存地址</span></strong><span class="ne-text">，像下图这样</span></p><p id="7af393fea8b22c962a02bb238a51bfcf" class="ne-p"><br></p><p id="26978d8cd99d410a14326508c2a49c82" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829902-6db577d7-0921-4635-82f1-62f7fe723b48.png" width="710" id="DPfTF" class="ne-image"></p><p id="920e1606a09ad135a916cc1d8ea86734" class="ne-p"><br></p><p id="d01e804e8a33f6a675e0545fe9f7dde7" class="ne-p"><span class="ne-text">下面这幅图展示了这种映射是如何工作的</span></p><p id="5aceabff0e61c0d5d5d970315896fe1e" class="ne-p"><br></p><p id="70d3b873e0804fdcc75108174659a7b5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829922-b5a208d9-6807-4201-b95a-50c300ec3f1e.png" width="701" id="jEXGv" class="ne-image"></p><p id="b96f2dce14d08fbe8bbb54b56cb574bf" class="ne-p"><br></p><p id="dc3ab02bd9504ce5467860296b9a74d2" class="ne-p"><span class="ne-text">页表给出虚拟地址与物理内存地址之间的映射关系。每一页起始于 4096 的倍数位置，结束于 4095 的位置，所以 4K 到 8K 实际为 4096 - 8191 ，8K - 12K 就是 8192 - 12287</span></p><p id="bc7ed89c32cb3a181312532bc488d2e0" class="ne-p"><br></p><p id="a2f11223fc6e7fd34aab2e859e41b4f3" class="ne-p"><span class="ne-text">在这个例子中，我们可能有一个 16 位地址的计算机，地址从 0 - 64 K - 1，这些是</span><code class="ne-code"><span class="ne-text">虚拟地址</span></code><span class="ne-text">。然而只有 32 KB 的物理地址。所以虽然可以编写 64 KB 的程序，但是程序无法全部调入内存运行，在磁盘上必须有一个最多 64 KB 的程序核心映像的完整副本，以保证程序片段在需要时被调入内存。</span></p><p id="9596f00592eb949c69c63cbdb69b8643" class="ne-p"><br></p><h3 id="48de0fdd"><span class="ne-text">页表</span></h3><p id="857f37982ab15377827623d3d741445c" class="ne-p"><br></p><p id="3fa7e03ff8c37017d8d9354b20f1a7f6" class="ne-p"><span class="ne-text">虚拟页号可作为页表的索引用来找到虚拟页中的内容。由页表项可以找到页框号（如果有的话）。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成物理地址。</span></p><p id="b804d0484cc73b4e42e4c1a16cf433bf" class="ne-p"><br></p><p id="97e874b55d764de49c180df820f441ac" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829940-3af1fa95-4f53-459f-88e6-dc9540fc58fa.png" width="726" id="gDLPK" class="ne-image"></p><p id="7d73b7251105220113cfc0e95b4dae9e" class="ne-p"><br></p><p id="063ec3cf1870ce7283f1ec520bf8725e" class="ne-p"><span class="ne-text">因此，页表的目的是把虚拟页映射到页框中。从数学上说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。</span></p><p id="7c5451128fbe624fd69dc56c6324aa00" class="ne-p"><br></p><p id="ecc02083465bab9e94b190db907b78cf" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829970-f9085cee-e3ce-49a6-a175-31095f33b104.png" width="549" id="r6cAl" class="ne-image"></p><p id="f4cbe70227438afd44c6da369ae27783" class="ne-p"><br></p><p id="ecc882e5c8595768f3b9b1a82f95c800" class="ne-p"><span class="ne-text">通过这个函数可以把虚拟地址中的虚拟页转换为页框，从而形成物理地址。</span></p><p id="d5a128f20cf5882f3e7639970691078c" class="ne-p"><br></p><h4 id="ebc1ec9d"><span class="ne-text">页表项的结构</span></h4><p id="8580345f352bef3704c4f0cfb0671d79" class="ne-p"><br></p><p id="e0361fcd123e7c408a1410e6cc45439c" class="ne-p"><span class="ne-text">下面我们探讨一下页表项的具体结构，上面你知道了页表项的大致构成，是由页框号和在/不在位构成的，现在我们来具体探讨一下页表项的构成</span></p><p id="47984eb3ee2b2f2dfa132deed0eb8316" class="ne-p"><br></p><p id="cc5c2e897e5e7b5827cdd4c67abaaa77" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829994-5ecf9cda-4a6f-418e-b786-bf4a2a05e7c3.png" width="701" id="PVew4" class="ne-image"></p><p id="4cbaab2ba9647f14311ad1df919f070b" class="ne-p"><br></p><p id="a0482db6a2673a73d8ea3e3348c44e1e" class="ne-p"><span class="ne-text">页表项的结构是与机器相关的，但是不同机器上的页表项大致相同。上面是一个页表项的构成，不同计算机的页表项可能不同，但是一般来说都是 32 位的。页表项中最重要的字段就是</span><code class="ne-code"><span class="ne-text">页框号(Page frame number)</span></code><span class="ne-text">。毕竟，页表到页框最重要的一步操作就是要把此值映射过去。下一个比较重要的就是</span><code class="ne-code"><span class="ne-text">在/不在</span></code><span class="ne-text">位，如果此位上的值是 1，那么页表项是有效的并且能够被</span><code class="ne-code"><span class="ne-text">使用</span></code><span class="ne-text">。如果此值是 0 的话，则表示该页表项对应的虚拟页面</span><code class="ne-code"><span class="ne-text">不在</span></code><span class="ne-text">内存中，访问该页面会引起一个</span><code class="ne-code"><span class="ne-text">缺页异常(page fault)</span></code><span class="ne-text">。</span></p><p id="1538e61821a53e91fd6c621fea99050c" class="ne-p"><br></p><p id="07e2267978cae7258a9ac4111b0bfac6" class="ne-p"><code class="ne-code"><span class="ne-text">保护位(Protection)</span></code><span class="ne-text"> 告诉我们哪一种访问是允许的，啥意思呢？最简单的表示形式是这个域只有一位，</span><strong><span class="ne-text">0 表示可读可写，1 表示的是只读</span></strong><span class="ne-text">。</span></p><p id="cd5113de44f663e8dcda2e73383b485f" class="ne-p"><br></p><p id="2f956dc3258cb003ac6dc16c55871787" class="ne-p"><code class="ne-code"><span class="ne-text">修改位(Modified)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">访问位(Referenced)</span></code><span class="ne-text"> 会跟踪页面的使用情况。当一个页面被写入时，硬件会自动的设置修改位。修改位在页面重新分配页框时很有用。如果一个页面已经被修改过（即它是 </span><code class="ne-code"><span class="ne-text">脏</span></code><span class="ne-text"> 的），则必须把它写回磁盘。如果一个页面没有被修改过（即它是 </span><code class="ne-code"><span class="ne-text">干净</span></code><span class="ne-text">的），那么重新分配时这个页框会被直接丢弃，因为磁盘上的副本仍然是有效的。这个位有时也叫做 </span><code class="ne-code"><span class="ne-text">脏位(dirty bit)</span></code><span class="ne-text">，因为它反映了页面的状态。</span></p><p id="b79e431bca8c6a4061cff3e6e2cd7e33" class="ne-p"><br></p><p id="e4dfca25e9150ba09532a333d26042ad" class="ne-p"><code class="ne-code"><span class="ne-text">访问位(Referenced)</span></code><span class="ne-text"> 在页面被访问时被设置，不管是读还是写。这个值能够帮助操作系统在发生缺页中断时选择要淘汰的页。不再使用的页要比正在使用的页更适合被淘汰。这个位在后面要讨论的</span><code class="ne-code"><span class="ne-text">页面置换</span></code><span class="ne-text">算法中作用很大。</span></p><p id="3c02b4c632833430510ae67ff9ed4e16" class="ne-p"><br></p><p id="dbc93bd44ac1087b64e0b1d023ba34c3" class="ne-p"><span class="ne-text">最后一位用于禁止该页面被高速缓存，这个功能对于映射到设备寄存器还是内存中起到了关键作用。通过这一位可以禁用高速缓存。具有独立的 I/O 空间而不是用内存映射 I/O 的机器来说，并不需要这一位。</span></p><p id="befcfc4e20c5082a05f87de19bcd7503" class="ne-p"><br></p><h2 id="62ce86fe"><span class="ne-text">页面置换算法</span></h2><p id="dd4394f57b4886240b2c215cdd1e4631" class="ne-p"><br></p><p id="4f6a92a94c2e30c6050bfb462299a22b" class="ne-p"><span class="ne-text">下面我们就来探讨一下有哪些页面置换算法。</span></p><p id="a1b1f01ba8c41e23d328afe683dd334c" class="ne-p"><br></p><h3 id="62592cf3"><span class="ne-text">最优页面置换算法</span></h3><p id="0e512837e885309b4830226205348edd" class="ne-p"><br></p><p id="9213075cee522577cc3a7c72861ccedd" class="ne-p"><span class="ne-text">最优的页面置换算法的工作流程如下：在缺页中断发生时，这些页面之一将在下一条指令（包含该指令的页面）上被引用。其他页面则可能要到 10、100 或者 1000 条指令后才会被访问。每个页面都可以用在该页首次被访问前所要执行的指令数作为标记。</span></p><p id="60569c4b121798a3dfa3559723a85c22" class="ne-p"><br></p><p id="f652c71e4c322ab28275da1eef94b0bb" class="ne-p"><span class="ne-text">最优化的页面算法表明应该标记最大的页面。如果一个页面在 800 万条指令内不会被使用，另外一个页面在 600 万条指令内不会被使用，则置换前一个页面，从而把需要调入这个页面而发生的缺页中断推迟。计算机也像人类一样，会把不愿意做的事情尽可能的往后拖。</span></p><p id="933341d07fd0cb969e37b2921a21a1b4" class="ne-p"><br></p><p id="0b6aa11ee462069a41c30975c1369ec7" class="ne-p"><span class="ne-text">这个算法最大的问题时无法实现。当缺页中断发生时，操作系统无法知道各个页面的下一次将在什么时候被访问。这种算法在实际过程中根本不会使用。</span></p><p id="7cccf369523448e9ea1adb8b38b19c65" class="ne-p"><br></p><h3 id="f3900d0e"><span class="ne-text">最近未使用页面置换算法</span></h3><p id="84094ac7292da84c018fa4aa4de731a1" class="ne-p"><br></p><p id="48785f09a7c92dc9c6b7cb0413f2955c" class="ne-p"><span class="ne-text">为了能够让操作系统收集页面使用信息，大部分使用虚拟地址的计算机都有两个状态位，R 和 M，来和每个页面进行关联。</span><strong><span class="ne-text">每当引用页面（读入或写入）时都设置 R，写入（即修改）页面时设置 M</span></strong><span class="ne-text">，这些位包含在每个页表项中，就像下面所示</span></p><p id="893a0cfa909ed56729e771832bca703f" class="ne-p"><br></p><p id="a4c3f7d5b620ee72ed1f39cf3b0f2f9c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830000-886bdae7-531d-42ce-86c1-970d3c0fd287.png" width="644" id="GjVza" class="ne-image"></p><p id="d91a668fe44efebe3f6df1f790f756b6" class="ne-p"><br></p><p id="cd2436ef675270bdeb27defe9bb4a987" class="ne-p"><span class="ne-text">因为每次访问时都会更新这些位，因此由</span><code class="ne-code"><span class="ne-text">硬件</span></code><span class="ne-text">来设置它们非常重要。一旦某个位被设置为 1，就会一直保持 1 直到操作系统下次来修改此位。</span></p><p id="e7a4fdba97874bdf3ba1bbbcc25d17b6" class="ne-p"><br></p><p id="cc2fe27785e322231e1760788dacd2e8" class="ne-p"><span class="ne-text">如果硬件没有这些位，那么可以使用操作系统的</span><code class="ne-code"><span class="ne-text">缺页中断</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">时钟中断</span></code><span class="ne-text">机制来进行模拟。当启动一个进程时，将其所有的页面都标记为</span><code class="ne-code"><span class="ne-text">不在内存</span></code><span class="ne-text">；一旦访问任何一个页面就会引发一次缺页中断，此时操作系统就可以设置 </span><code class="ne-code"><span class="ne-text">R 位(在它的内部表中)</span></code><span class="ne-text">，修改页表项使其指向正确的页面，并设置为 </span><code class="ne-code"><span class="ne-text">READ ONLY</span></code><span class="ne-text"> 模式，然后重新启动引起缺页中断的指令。如果页面随后被修改，就会发生另一个缺页异常。从而允许操作系统设置 M 位并把页面的模式设置为 </span><code class="ne-code"><span class="ne-text">READ/WRITE</span></code><span class="ne-text">。</span></p><p id="1cdfab7830fe96b8bd64eba745fa4f54" class="ne-p"><br></p><p id="8dac468a9941b20f7d32592bf3233e15" class="ne-p"><span class="ne-text">可以用 R 位和 M 位来构造一个简单的页面置换算法：当启动一个进程时，操作系统将其所有页面的两个位都设置为 0。R 位定期的被清零（在每个时钟中断）。用来将最近未引用的页面和已引用的页面分开。</span></p><p id="6f7fbf64554353465ff29f99860787b3" class="ne-p"><br></p><p id="39bab2fdc8db36d5ebb838bbc9610a1e" class="ne-p"><span class="ne-text">当出现缺页中断后，操作系统会检查所有的页面，并根据它们的 R 位和 M 位将当前值分为四类：</span></p><p id="abc034f6c92699f9fbdd74ea4d336581" class="ne-p"><br></p><ul class="ne-ul"><li id="7f488d4df8b3c78c1612b6b90607a6ec"><span class="ne-text">第 0 类：没有引用 R，没有修改 M</span></li><li id="6e0da38d60df8303cdfb64d30e7ae9f9"><span class="ne-text">第 1 类：没有引用 R，已修改 M</span></li></ul><ul class="ne-ul"><li id="e52f9551f8862c020d85a689e7669461"><span class="ne-text">第 2 类：引用 R ，没有修改 M</span></li><li id="2098c1e2e0738f1af205e33bac18f3f8"><span class="ne-text">第 3 类：已被访问 R，已被修改 M</span></li></ul><p id="19ca51f0ab68b170e6b85ceff4a1422c" class="ne-p"><br></p><p id="55b6e4fc2dcc6d749c16ef21258bf769" class="ne-p"><span class="ne-text">尽管看起来好像无法实现第一类页面，但是当第三类页面的 R 位被时钟中断清除时，它们就会发生。时钟中断不会清除 M 位，因为需要这个信息才能知道是否写回磁盘中。清除 R 但不清除 M 会导致出现一类页面。</span></p><p id="19f438a3cf1ce096f4968e4f66c24d05" class="ne-p"><br></p><p id="3639cbe3d0887d2760c552159b6ac088" class="ne-p"><code class="ne-code"><span class="ne-text">NRU(Not Recently Used)</span></code><span class="ne-text"> 算法从编号最小的非空类中随机删除一个页面。此算法隐含的思想是，在一个时钟内（约 20 ms）淘汰一个已修改但是没有被访问的页面要比一个大量引用的未修改页面好，NRU 的主要优点是</span><strong><span class="ne-text">易于理解并且能够有效的实现</span></strong><span class="ne-text">。</span></p><p id="e69f0a756fab88cc1ab941d6eb5f0429" class="ne-p"><br></p><h3 id="ef992930"><span class="ne-text">先进先出页面置换算法</span></h3><p id="b54cfe45e7d8a2900b5ab6e37cac9c7d" class="ne-p"><br></p><p id="cedbd31bfca554665ded81b0817e03ff" class="ne-p"><span class="ne-text">另一种开销较小的方式是使用 </span><code class="ne-code"><span class="ne-text">FIFO(First-In,First-Out)</span></code><span class="ne-text"> 算法，这种类型的数据结构也适用在页面置换算法中。由操作系统维护一个所有在当前内存中的页面的链表，最早进入的放在表头，最新进入的页面放在表尾。在发生缺页异常时，会把头部的页移除并且把新的页添加到表尾。</span></p><p id="017b429504dba6c1df0a023aed81995c" class="ne-p"><br></p><h3 id="fbe44333"><span class="ne-text">第二次机会页面置换算法</span></h3><p id="dec3701d79739bc3cf2072c3170b98e4" class="ne-p"><br></p><p id="b0f6d433a3bf62769df7a29957f2f42f" class="ne-p"><span class="ne-text">我们上面学到的 FIFO 链表页面有个</span><code class="ne-code"><span class="ne-text">缺陷</span></code><span class="ne-text">，那就是出链和入链并不会进行 check </span><code class="ne-code"><span class="ne-text">检查</span></code><span class="ne-text">，这样就会容易把经常使用的页面置换出去，为了避免这一问题，我们对该算法做一个简单的修改：我们检查最老页面的 </span><code class="ne-code"><span class="ne-text">R 位</span></code><span class="ne-text">，如果是 0 ，那么这个页面就是最老的而且没有被使用，那么这个页面就会被立刻换出。如果 R 位是 1，那么就清除此位，此页面会被放在链表的尾部，修改它的装入时间就像刚放进来的一样。然后继续搜索。</span></p><p id="d6333e220f33af321d74ec854f04b55a" class="ne-p"><br></p><p id="089f8f24e153eee75e5e435a679afa1e" class="ne-p"><span class="ne-text">这种算法叫做 </span><code class="ne-code"><span class="ne-text">第二次机会(second chance)</span></code><span class="ne-text">算法，就像下面这样，我们看到页面 A 到 H 保留在链表中，并按到达内存的时间排序。</span></p><p id="a28bcb1486944b773b50fcf51df4749c" class="ne-p"><br></p><p id="fde6e179989ecc6f697670c740914dce" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830001-d17523cc-7d04-4aa5-9b91-7cb47cc26508.png" width="731" id="fCBHb" class="ne-image"></p><p id="57038d8271d2c901cbf3b2f205aa4536" class="ne-p"><br></p><p id="c231a3eb1c1ffe613e927adb3cc23dfc" class="ne-p"><span class="ne-text">a）按照先进先出的方法排列的页面；b）在时刻 20 处发生缺页异常中断并且 A 的 R 位已经设置时的页面链表。</span></p><p id="dfb82b03a7f6557807ac7332498453cc" class="ne-p"><br></p><p id="6071f4976010720b318f23a5435af7c9" class="ne-p"><span class="ne-text">假设缺页异常发生在时刻 20 处，这时最老的页面是 A ，它是在 0 时刻到达的。如果 A 的 R 位是 0，那么它将被淘汰出内存，或者把它写回磁盘（如果它已经被修改过），或者只是简单的放弃（如果它是未被修改过）。另一方面，如果它的 R 位已经设置了，则将 A 放到链表的尾部并且重新设置</span><code class="ne-code"><span class="ne-text">装入时间</span></code><span class="ne-text">为当前时刻（20 处），然后清除 R 位。然后从 B 页面开始继续搜索合适的页面。</span></p><p id="9254e5ee7d07b1644978e8fae8815ee4" class="ne-p"><br></p><p id="213128048d32400dc1be31f0854dccca" class="ne-p"><span class="ne-text">寻找第二次机会的是在最近的时钟间隔中未被访问过的页面。如果所有的页面都被访问过，该算法就会被简化为单纯的 </span><code class="ne-code"><span class="ne-text">FIFO 算法</span></code><span class="ne-text">。具体来说，假设图 a 中所有页面都设置了 R 位。操作系统将页面依次移到链表末尾，每次都在添加到末尾时清除 R 位。最后，算法又会回到页面 A，此时的 R 位已经被清除，那么页面 A 就会被执行出链处理，因此算法能够正常结束。</span></p><p id="006bfd0eee72f06883aeacf0049fb0e5" class="ne-p"><br></p><h3 id="77c3ba6e"><span class="ne-text">时钟页面置换算法</span></h3><p id="ad9e64b0208686171b28fcdaa3269f69" class="ne-p"><br></p><p id="6753b55523ed6e4fbb740e4d95f05fec" class="ne-p"><span class="ne-text">一种比较好的方式是把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面。如下图所示</span></p><p id="8ab484c60155725d209fbb22b51d2566" class="ne-p"><br></p><p id="52032f6515f4f45cee8fedf418227902" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830029-543aeeff-242c-4b6f-a9a4-87fa9b101280.png" width="669" id="Xw06o" class="ne-image"></p><p id="a537643cb2a9b195c3c6ed6460bb4427" class="ne-p"><br></p><p id="34c47bdd9eccecfd23ed6a6c98202f9e" class="ne-p"><span class="ne-text">当缺页错误出现时，算法首先检查表针指向的页面，如果它的 R 位是 0 就淘汰该页面，并把新的页面插入到这个位置，然后把表针向前移动一位；如果 R 位是 1 就清除 R 位并把表针前移一个位置。重复这个过程直到找到了一个 R 位为 0 的页面位置。了解这个算法的工作方式，就明白为什么它被称为 </span><code class="ne-code"><span class="ne-text">时钟(clokc)</span></code><span class="ne-text">算法了。</span></p><p id="2bb310c9d960a15e936ed5cd9874ca22" class="ne-p"><br></p><h3 id="a918bb5b"><span class="ne-text">最近最少使用页面置换算法</span></h3><p id="dcd37ab4af6b75e405921bbc1c037e68" class="ne-p"><br></p><p id="205663d914713ca94cf7dee4abb58f3b" class="ne-p"><span class="ne-text">在前面几条指令中频繁使用的页面和可能在后面的几条指令中被使用。反过来说，已经很久没有使用的页面有可能在未来一段时间内仍不会被使用。这个思想揭示了一个可以实现的算法：在缺页中断时，置换未使用时间最长的页面。这个策略称为 </span><code class="ne-code"><span class="ne-text">LRU(Least Recently Used)</span></code><span class="ne-text"> ，最近最少使用页面置换算法。</span></p><p id="7b1a47269ade45a6f9b444a5e67e2b4a" class="ne-p"><br></p><p id="9e365e147cef6fb0ce851d48e6498ae7" class="ne-p"><span class="ne-text">虽然 LRU 在理论上是可以实现的，但是从长远看来代价比较高。为了完全实现 LRU，会在内存中维护一个所有页面的链表，最频繁使用的页位于表头，最近最少使用的页位于表尾。困难的是在每次内存引用时更新整个链表。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常耗时的操作，即使使用</span><code class="ne-code"><span class="ne-text">硬件</span></code><span class="ne-text">来实现也是一样的费时。</span></p><p id="ce5addf295db9d862f1c198299520382" class="ne-p"><br></p><h3 id="3d8761a9"><span class="ne-text">用软件模拟 LRU</span></h3><p id="37d6bfe86f6fcc86a602d5597f75e357" class="ne-p"><br></p><p id="6061c314c4be9623fa92455e73227ba8" class="ne-p"><span class="ne-text">尽管上面的 LRU 算法在原则上是可以实现的，</span><strong><span class="ne-text">但是很少有机器能够拥有那些特殊的硬件</span></strong><span class="ne-text">。上面是硬件的实现方式，那么现在考虑要用</span><code class="ne-code"><span class="ne-text">软件</span></code><span class="ne-text">来实现 LRU 。一种可以实现的方案是 </span><code class="ne-code"><span class="ne-text">NFU(Not Frequently Used，最不常用)</span></code><span class="ne-text">算法。它需要一个软件计数器来和每个页面关联，初始化的时候是 0 。在每个时钟中断时，操作系统会浏览内存中的所有页，会将每个页面的 R 位（0 或 1）加到它的计数器上。这个计数器大体上跟踪了各个页面访问的频繁程度。当缺页异常出现时，则置换计数器值最小的页面。</span></p><p id="2a6159adb02ff3cc9bce97cd9579d42e" class="ne-p"><br></p><p id="a7be3c75d28420ac502d39512cf7dc74" class="ne-p"><span class="ne-text">只需要对 NFU 做一个简单的修改就可以让它模拟 LRU，这个修改有两个步骤</span></p><p id="a1f2097df3061d1fd3dbb757d747437f" class="ne-p"><br></p><ul class="ne-ul"><li id="4bbd7f83857962a0edf2928dd13577f4"><span class="ne-text">首先，在 R 位被添加进来之前先把计数器右移一位；</span></li><li id="4583a5fcd17a9fe4311405a164d135ef"><span class="ne-text">第二步，R 位被添加到最左边的位而不是最右边的位。</span></li></ul><p id="b2717e6278239c301fbc4d9e32bb5ba8" class="ne-p"><br></p><p id="6a60486aae78656f5b1415e75528cf92" class="ne-p"><span class="ne-text">修改以后的算法称为 </span><code class="ne-code"><span class="ne-text">老化(aging)</span></code><span class="ne-text"> 算法，下图解释了老化算法是如何工作的。</span></p><p id="0e45535a1d54c69288a3c65fdd3f9eda" class="ne-p"><br></p><p id="17f0818b86d3528d2d965e22f418a75b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830078-9cab6ac9-f2fa-4395-b8d5-57b61a80e6d3.png" width="747" id="kzyJK" class="ne-image"></p><p id="f34b569fc53d87a9b00b7727cfc529dd" class="ne-p"><br></p><p id="c81d065239846ddb58479859917fabc9" class="ne-p"><span class="ne-text">我们假设在第一个时钟周期内页面 0 - 5 的 R 位依次是 1，0，1，0，1，1，（也就是页面 0 是 1，页面 1 是 0，页面 2 是 1 这样类推）。也就是说，</span><strong><span class="ne-text">在 0 个时钟周期到 1 个时钟周期之间，0，2，4，5 都被引用了</span></strong><span class="ne-text">，从而把它们的 R 位设置为 1，剩下的设置为 0 。在相关的六个计数器被右移之后 R 位被添加到 </span><code class="ne-code"><span class="ne-text">左侧</span></code><span class="ne-text"> ，就像上图中的 a。剩下的四列显示了接下来的四个时钟周期内的六个计数器变化。</span></p><p id="499a1052524254f8661e3f408cf21aa3" class="ne-p"><br></p><div class="ne-quote"><p id="129f113f3de0adc28d4390fd9db25563" class="ne-p"><span class="ne-text">CPU 正在以某个频率前进，该频率的周期称为</span><code class="ne-code"><span class="ne-text">时钟滴答</span></code><span class="ne-text">或</span><code class="ne-code"><span class="ne-text">时钟周期</span></code><span class="ne-text">。一个 100Mhz 的处理器每秒将接收 100,000,000 个时钟滴答。</span></p></div><p id="eaca1a1c1cedd12caea8a55b7023c5df" class="ne-p"><br></p><p id="22915b2fc6fa12c8e3283015a6e73231" class="ne-p"><span class="ne-text">当缺页异常出现时，将</span><code class="ne-code"><span class="ne-text">置换（就是移除）</span></code><span class="ne-text">计数器值最小的页面。如果一个页面在前面 4 个时钟周期内都没有被访问过，那么它的计数器应该会有四个连续的 0 ，因此它的值肯定要比前面 3 个时钟周期内都没有被访问过的页面的计数器小。</span></p><p id="6ac140bf2daf5bfd92cfe42f2385f2ff" class="ne-p"><br></p><p id="dcf4a0b873c335c26afd35584ae48010" class="ne-p"><span class="ne-text">这个算法与 LRU 算法有两个重要的区别：看一下上图中的 </span><code class="ne-code"><span class="ne-text">e</span></code><span class="ne-text">，第三列和第五列</span></p><p id="b83cb567bda1ff21e9c305d5e47b6dc1" class="ne-p"><br></p><p id="67b39e8eb31df20830950dcf649331c2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830053-3463258f-69af-41f6-94ed-94a15761844e.png" width="763" id="BE7AZ" class="ne-image"></p><p id="0673d7e6e35f4f09d2394193508d2a05" class="ne-p"><br></p><h3 id="3b91d1a3"><span class="ne-text">工作集时钟页面置换算法</span></h3><p id="63abd06159f80e0e075790bb08d4ffed" class="ne-p"><br></p><p id="73bb03fe3aaa4adac274dc16a8d05404" class="ne-p"><span class="ne-text">当缺页异常发生后，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法还是比较浪费时间的。一个对基本工作集算法的提升是基于时钟算法但是却使用工作集的信息，这种算法称为</span><code class="ne-code"><span class="ne-text">WSClock(工作集时钟)</span></code><span class="ne-text">。由于它的实现简单并且具有高性能，因此在实践中被广泛应用。</span></p><p id="d58ba8b46f716fecbc53ecbc4210e48b" class="ne-p"><br></p><p id="3944528a9e5d2af730bcc21a6fcbc8ab" class="ne-p"><span class="ne-text">与时钟算法一样，所需的数据结构是一个以页框为元素的循环列表，就像下面这样</span></p><p id="01d5cdf75a341e23abd1d6d52c38226f" class="ne-p"><br></p><p id="a2e7cd58c23ca108b5363f7a00477f63" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830081-e96444ca-dda9-4c3f-9af5-e0db74d03a6f.png" width="705" id="tl5hI" class="ne-image"></p><p id="2d178410b1a9f1db6d542c7530824d29" class="ne-p"><br></p><p id="de674762efef1a1d31d2a2f9116a6360" class="ne-p"><span class="ne-text"> 工作集时钟页面置换算法的操作：a) 和 b) 给出 R = 1 时所发生的情形；c) 和 d) 给出 R = 0 的例子</span></p><p id="376ca02884d8a1d9619e3a218afdf8b0" class="ne-p"><br></p><p id="63fe0e0e76165313969aad9b5a52a257" class="ne-p"><span class="ne-text">最初的时候，该表是空的。当装入第一个页面后，把它加载到该表中。随着更多的页面的加入，它们形成一个环形结构。每个表项包含来自基本工作集算法的上次使用时间，以及 R 位（已标明）和 M 位（未标明）。</span></p><p id="7e3a6f2fed60f5194bfd204102e2952d" class="ne-p"><br></p><p id="957756ce70967b23ea6854a4f43d3a03" class="ne-p"><span class="ne-text">与时钟算法一样，在每个缺页异常时，首先检查指针指向的页面。如果 R 位被是设置为 1，该页面在当前时钟周期内就被使用过，那么该页面就不适合被淘汰。然后把该页面的 R 位置为 0，指针指向下一个页面，并重复该算法。该事件序列化后的状态参见图 b。</span></p><p id="660512e597b1be7f79759c859c5ad630" class="ne-p"><br></p><p id="3131acf40f8b8061433775a713b92569" class="ne-p"><span class="ne-text">现在考虑指针指向的页面 R = 0 时会发生什么，参见图 c，如果页面的使用期限大于 t 并且页面为被访问过，那么这个页面就不会在工作集中，并且在磁盘上会有一个此页面的副本。申请重新调入一个新的页面，并把新的页面放在其中，如图 d 所示。另一方面，如果页面被修改过，就不能重新申请页面，因为这个页面在磁盘上没有有效的副本。为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，算法继续对下一个页面进行操作。毕竟，有可能存在一个老的，没有被修改过的页面可以立即使用。</span></p><p id="259f8e1c415f1f342157b2c74fa8531d" class="ne-p"><br></p><p id="c3a7464fe9b882ee84c2133203efbc8f" class="ne-p"><span class="ne-text">原则上来说，所有的页面都有可能因为</span><code class="ne-code"><span class="ne-text">磁盘 I/O</span></code><span class="ne-text"> 在某个时钟周期内被调度。为了降低磁盘阻塞，需要设置一个限制，即最大只允许写回 n 个页面。一旦达到该限制，就不允许调度新的写操作。</span></p><p id="14bb94ec4633fd27809f92c905c5c4a0" class="ne-p"><br></p><p id="6b5f609cfef9d1be84780092687527ed" class="ne-p"><span class="ne-text">那么就有个问题，指针会绕一圈回到原点的，如果回到原点，它的起始点会发生什么？这里有两种情况：</span></p><p id="af605baae7a6291209d87aad111ebdde" class="ne-p"><br></p><ul class="ne-ul"><li id="be710c9c234ad6ebc9bb28abb8befd14"><span class="ne-text">至少调度了一次写操作</span></li><li id="1f5761b8fa6436255d40db750cdca12c"><span class="ne-text">没有调度过写操作</span></li></ul><p id="d327ffc3f06f2f92e3638b05eb18f99f" class="ne-p"><br></p><p id="f279a05a1c84ac5f4f42f1b687ca65e9" class="ne-p"><span class="ne-text">在第一种情况中，指针仅仅是不停的移动，寻找一个未被修改过的页面。由于已经调度了一个或者多个写操作，最终会有某个写操作完成，它的页面会被标记为未修改。置换遇到的第一个未被修改过的页面，这个页面不一定是第一个被调度写操作的页面，因为硬盘驱动程序为了优化性能可能会把写操作重排序。</span></p><p id="f975c09f26fb82689584d8824d592a03" class="ne-p"><br></p><p id="9a686c8455f99d36ff56e36cb6856304" class="ne-p"><span class="ne-text">对于第二种情况，所有的页面都在工作集中，否则将至少调度了一个写操作。由于缺乏额外的信息，最简单的方法就是置换一个未被修改的页面来使用，扫描中需要记录未被修改的页面的位置，如果不存在未被修改的页面，就选定当前页面并把它写回磁盘。</span></p><p id="22bc054ec4116393b13ced80f5f13f97" class="ne-p"><br></p><h3 id="88464125"><span class="ne-text">页面置换算法小结</span></h3><p id="c76fb75fa6f7d1c2e423f6396b4d785a" class="ne-p"><br></p><p id="a4a73b9727c0408ace20acf41c243df7" class="ne-p"><span class="ne-text">我们到现在已经研究了各种页面置换算法，现在我们来一个简单的总结，算法的总结归纳如下</span></p><table id="1b009b27" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u8155d1fa" class="ne-p"><span class="ne-text">算法</span></p></td><td width="375"><p id="ub91c6a44" class="ne-p"><span class="ne-text">注释</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u9675e649" class="ne-p"><span class="ne-text">最优算法</span></p></td><td width="375"><p id="ua39abb97" class="ne-p"><span class="ne-text">不可实现，但可以用作基准</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u394e510f" class="ne-p"><span class="ne-text">NRU(最近未使用) 算法</span></p></td><td width="375"><p id="uf3d6826a" class="ne-p"><span class="ne-text">和 LRU 算法很相似</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u26c74d8a" class="ne-p"><span class="ne-text">FIFO(先进先出) 算法</span></p></td><td width="375"><p id="u7ac53964" class="ne-p"><span class="ne-text">有可能会抛弃重要的页面</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ubd2f9fd7" class="ne-p"><span class="ne-text">第二次机会算法</span></p></td><td width="375"><p id="u74ec06bd" class="ne-p"><span class="ne-text">比 FIFO 有较大的改善</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ueb91d76a" class="ne-p"><span class="ne-text">时钟算法</span></p></td><td width="375"><p id="u34def58d" class="ne-p"><span class="ne-text">实际使用</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uff3a1852" class="ne-p"><span class="ne-text">LRU(最近最少)算法</span></p></td><td width="375"><p id="u5613a15a" class="ne-p"><span class="ne-text">比较优秀，但是很难实现</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u7a5e614f" class="ne-p"><span class="ne-text">NFU(最不经常食用)算法</span></p></td><td width="375"><p id="uc4d42f56" class="ne-p"><span class="ne-text">和 LRU 很类似</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u97c1197a" class="ne-p"><span class="ne-text">老化算法</span></p></td><td width="375"><p id="u1102fb4d" class="ne-p"><span class="ne-text">近似 LRU 的高效算法</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="udcc054bf" class="ne-p"><span class="ne-text">工作集算法</span></p></td><td width="375"><p id="u04210cf5" class="ne-p"><span class="ne-text">实施起来开销很大</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u9cb6c78e" class="ne-p"><span class="ne-text">工作集时钟算法</span></p></td><td width="375"><p id="uac13bd4a" class="ne-p"><span class="ne-text">比较有效的算法</span></p></td></tr></tbody></table><p id="95ce7ac6c96f2836c1da1058696564f2" class="ne-p"><br></p><ul class="ne-ul"><li id="706a0737a142822991e3b2d4119a9f68"><code class="ne-code"><span class="ne-text">最优算法</span></code><span class="ne-text">在当前页面中置换最后要访问的页面。不幸的是，没有办法来判定哪个页面是最后一个要访问的，</span><code class="ne-code"><span class="ne-text">因此实际上该算法不能使用</span></code><span class="ne-text">。然而，它可以作为衡量其他算法的标准。</span></li><li id="234dd392c4e9dd0ebf9e661f94d080f5"><code class="ne-code"><span class="ne-text">NRU</span></code><span class="ne-text"> 算法根据 R 位和 M 位的状态将页面氛围四类。从编号最小的类别中随机选择一个页面。NRU 算法易于实现，但是性能不是很好。存在更好的算法。</span></li></ul><ul class="ne-ul"><li id="c8f6c0a7d8a9df2355aa867a989f0b49"><code class="ne-code"><span class="ne-text">FIFO</span></code><span class="ne-text"> 会跟踪页面加载进入内存中的顺序，并把页面放入一个链表中。有可能删除存在时间最长但是还在使用的页面，因此这个算法也不是一个很好的选择。</span></li><li id="7fbec0a11e860f50edfed9e85c41b9f8"><code class="ne-code"><span class="ne-text">第二次机会</span></code><span class="ne-text">算法是对 FIFO 的一个修改，它会在删除页面之前检查这个页面是否仍在使用。如果页面正在使用，就会进行保留。这个改进大大提高了性能。</span></li></ul><ul class="ne-ul"><li id="ab0708a3d3cf4e9100075a87c9844641"><code class="ne-code"><span class="ne-text">时钟</span></code><span class="ne-text"> 算法是第二次机会算法的另外一种实现形式，时钟算法和第二次算法的性能差不多，但是会花费更少的时间来执行算法。</span></li><li id="416499a4e283e26c762f68ae643534cb"><code class="ne-code"><span class="ne-text">LRU</span></code><span class="ne-text"> 算法是一个非常优秀的算法，但是没有</span><code class="ne-code"><span class="ne-text">特殊的硬件(TLB)</span></code><span class="ne-text">很难实现。如果没有硬件，就不能使用 LRU 算法。</span></li></ul><ul class="ne-ul"><li id="0f2459808b7e2868c13dcbefd2ac7590"><code class="ne-code"><span class="ne-text">NFU</span></code><span class="ne-text"> 算法是一种近似于 LRU 的算法，它的性能不是非常好。</span></li><li id="f620cb928c9ef81c30cec4bd9400d7ce"><code class="ne-code"><span class="ne-text">老化</span></code><span class="ne-text"> 算法是一种更接近 LRU 算法的实现，并且可以更好的实现，因此是一个很好的选择</span></li></ul><ul class="ne-ul"><li id="69318a6d572af791c360d57906970f77"><span class="ne-text">最后两种算法都使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。</span><code class="ne-code"><span class="ne-text">WSClock</span></code><span class="ne-text"> 是另外一种变体，它不仅能够提供良好的性能，而且可以高效地实现。</span></li></ul><p id="d21cffc43ac7dcbfeeae73c897933787" class="ne-p"><br></p><p id="943b2ac9ccdf5bcd3ad85d6c44db2f03" class="ne-p"><span class="ne-text">总之，</span><strong><span class="ne-text">最好的算法是老化算法和 WSClock 算法</span></strong><span class="ne-text">。他们分别是基于 LRU 和工作集算法。他们都具有良好的性能并且能够被有效的实现。还存在其他一些好的算法，但实际上这两个可能是最重要的。</span></p><p id="70262061a374bbe6c590cdc622d20dd3" class="ne-p"><br></p><p id="318317ce1479c23add8291c2bdd17d4c" class="ne-p"><span class="ne-text">下面来聊一聊文件系统，你需要知道下面这些知识点</span></p><p id="54b70121bb60e581d442d6b45ec1f775" class="ne-p"><br></p><p id="0626228031f054313c8c68db9c55566d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830114-09f30aaf-25b8-44c3-992a-577e4c3a833c.png" width="721" id="MOs6Q" class="ne-image"></p><p id="68aa5203572adaa78a2cacc78c181478" class="ne-p"><br></p><h2 id="2a0c4740"><span class="ne-text">文件</span></h2><p id="0e1a4d0a2da43ff7a64f39e8a2ccc002" class="ne-p"><br></p><h3 id="42b5d073"><span class="ne-text">文件命名</span></h3><p id="39eaa5bb7eaee0059fc8f8ab050013c3" class="ne-p"><br></p><p id="ac843df76f1fa5996bb18f7b8f3abeff" class="ne-p"><span class="ne-text">文件是一种抽象机制，它提供了一种方式用来存储信息以及在后面进行读取。可能任何一种机制最重要的特性就是管理对象的命名方式。在创建一个文件后，它会给文件一个命名。当进程终止时，文件会继续存在，并且其他进程可以使用</span><code class="ne-code"><span class="ne-text">名称访问该文件</span></code><span class="ne-text">。</span></p><p id="7a4f2e6c93c769b7b830ce3a98164e0a" class="ne-p"><br></p><p id="1aa170f1d7914802b5f71c9fa09eea8c" class="ne-p"><span class="ne-text">文件命名规则对于不同的操作系统来说是不一样的，但是所有现代操作系统都允许使用 1 - 8 个字母的字符串作为合法文件名。</span></p><p id="549e424671eb70506667316221ea0b6a" class="ne-p"><br></p><p id="947a29553feb4fed91e398dd0b909941" class="ne-p"><span class="ne-text">某些文件区分大小写字母，而大多数则不区分。</span><code class="ne-code"><span class="ne-text">UNIX</span></code><span class="ne-text"> 属于第一类；历史悠久的 </span><code class="ne-code"><span class="ne-text">MS-DOS</span></code><span class="ne-text"> 属于第二类（顺便说一句，尽管 MS-DOS 历史悠久，但 MS-DOS 仍在嵌入式系统中非常广泛地使用，因此它绝不是过时的）；因此，UNIX 系统会有三种不同的命名文件：</span><code class="ne-code"><span class="ne-text">maria</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">Maria</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">MARIA</span></code><span class="ne-text"> 。在 MS-DOS ，所有这些命名都属于相同的文件。</span></p><p id="ca90743de49e769fc630a186e1284fae" class="ne-p"><br></p><p id="a406e7618fc08a6827c4aef95651a84b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830120-5ba4f13c-ee71-46f2-a110-e2eaf1dbf324.png" width="691" id="JHfwL" class="ne-image"></p><p id="afc97bceb18793a83e8a6d91c9533dfc" class="ne-p"><br></p><p id="6ae582e29691ea6d28dfb309f8a33d63" class="ne-p"><span class="ne-text">许多操作系统支持两部分的文件名，它们之间用 </span><code class="ne-code"><span class="ne-text">.</span></code><span class="ne-text"> 分隔开，比如文件名 </span><code class="ne-code"><span class="ne-text">prog.c</span></code><span class="ne-text">。原点后面的文件称为 </span><code class="ne-code"><span class="ne-text">文件扩展名(file extension)</span></code><span class="ne-text"> ，文件扩展名通常表示文件的一些信息。一些常用的文件扩展名以及含义如下图所示</span></p><table id="7f756c92" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u86bcac8e" class="ne-p"><span class="ne-text">扩展名</span></p></td><td width="375"><p id="u7fa179fd" class="ne-p"><span class="ne-text">含义</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u3c31ee67" class="ne-p"><span class="ne-text">bak</span></p></td><td width="375"><p id="ub1009dae" class="ne-p"><span class="ne-text">备份文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u8e21211b" class="ne-p"><span class="ne-text">c</span></p></td><td width="375"><p id="ub7814047" class="ne-p"><span class="ne-text">c 源程序文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u60b4b5ca" class="ne-p"><span class="ne-text">gif</span></p></td><td width="375"><p id="uc630794d" class="ne-p"><span class="ne-text">符合图形交换格式的图像文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u8fc5ed2b" class="ne-p"><span class="ne-text">hlp</span></p></td><td width="375"><p id="u4100d4e1" class="ne-p"><span class="ne-text">帮助文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u126c4c61" class="ne-p"><span class="ne-text">html</span></p></td><td width="375"><p id="u6d6dd5e8" class="ne-p"><span class="ne-text">WWW 超文本标记语言文档</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uaf121ed5" class="ne-p"><span class="ne-text">jpg</span></p></td><td width="375"><p id="ud8de46a6" class="ne-p"><span class="ne-text">符合 JPEG 编码标准的静态图片</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="udab5f881" class="ne-p"><span class="ne-text">mp3</span></p></td><td width="375"><p id="uaefb3290" class="ne-p"><span class="ne-text">符合 MP3 音频编码格式的音乐文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u6f6a8cf4" class="ne-p"><span class="ne-text">mpg</span></p></td><td width="375"><p id="u4e9b5a7a" class="ne-p"><span class="ne-text">符合 MPEG 编码标准的电影</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u17182b2f" class="ne-p"><span class="ne-text">o</span></p></td><td width="375"><p id="uba61755c" class="ne-p"><span class="ne-text">目标文件（编译器输出格式，尚未链接）</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uc827d007" class="ne-p"><span class="ne-text">pdf</span></p></td><td width="375"><p id="u490abaca" class="ne-p"><span class="ne-text">pdf 格式的文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u8deec9bc" class="ne-p"><span class="ne-text">ps</span></p></td><td width="375"><p id="u480b1c6a" class="ne-p"><span class="ne-text">PostScript 文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u3341c4b9" class="ne-p"><span class="ne-text">tex</span></p></td><td width="375"><p id="uef7e717f" class="ne-p"><span class="ne-text">为 TEX 格式化程序准备的输入文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u563e6d6d" class="ne-p"><span class="ne-text">txt</span></p></td><td width="375"><p id="u230821ad" class="ne-p"><span class="ne-text">文本文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u77e32004" class="ne-p"><span class="ne-text">zip</span></p></td><td width="375"><p id="u599395eb" class="ne-p"><span class="ne-text">压缩文件</span></p></td></tr></tbody></table><p id="c6ab14359737194a972479d8287c47a1" class="ne-p"><br></p><p id="4549bf524aabfd45c2fa83047348e305" class="ne-p"><span class="ne-text">在 UNIX 系统中，文件扩展名只是一种约定，操作系统并不强制采用。</span></p><p id="d4f6ff6d0e62a25ca2d68a7c83d9af63" class="ne-p"><br></p><h3 id="68d96662"><span class="ne-text">文件结构</span></h3><p id="e267d3840df18b33c8d7169b8089f9f5" class="ne-p"><br></p><p id="aab7d13a47a4100ca4968738f5dec9af" class="ne-p"><span class="ne-text">文件的构造有多种方式。下图列出了常用的三种构造方式</span></p><p id="05b429377a0f05d00edcba9ad1341ff3" class="ne-p"><br></p><p id="0eeb7da1658a82bc57977ae24dd2c8e8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830179-1cd3ea7b-cf21-432f-a8e4-c2d8f317e0ff.png" width="728" id="HSm1k" class="ne-image"></p><p id="66e04dd599052b4626cdb9aedfdd4ce2" class="ne-p"><br></p><p id="84f276b301ae3859ddde1903c0c2b706" class="ne-p"><span class="ne-text"> 三种不同的文件。 a) 字节序列 。b) 记录序列。c) 树</span></p><p id="0e82b2e8eb49dec1dc54c30359b708b0" class="ne-p"><br></p><p id="a970ad933a1746cea41087c5b928095b" class="ne-p"><span class="ne-text">上图中的 a 是一种无结构的字节序列，操作系统不关心序列的内容是什么，操作系统能看到的就是</span><code class="ne-code"><span class="ne-text">字节(bytes)</span></code><span class="ne-text">。其文件内容的任何含义只在用户程序中进行解释。UNIX 和 Windows 都采用这种办法。</span></p><p id="715200795b1099f573c996fc4f5ade2c" class="ne-p"><br></p><p id="e40d5e148ce0e55c7c15939cc5e60d7c" class="ne-p"><span class="ne-text">图 b 表示在文件结构上的第一部改进。在这个模型中，文件是具有固定长度记录的序列，每个记录都有其内部结构。 把文件作为记录序列的核心思想是：</span><strong><span class="ne-text">读操作返回一个记录，而写操作重写或者追加一个记录</span></strong><span class="ne-text">。第三种文件结构如上图 c 所示。在这种组织结构中，文件由一颗</span><code class="ne-code"><span class="ne-text">记录树</span></code><span class="ne-text">构成，记录树的长度不一定相同，每个记录树都在记录中的固定位置包含一个</span><code class="ne-code"><span class="ne-text">key</span></code><span class="ne-text"> 字段。这棵树按 key 进行排序，从而可以对特定的 key 进行快速查找。</span></p><p id="a3805c0b27de6eb1994037fb394c695d" class="ne-p"><br></p><h3 id="28b988ce"><span class="ne-text">文件类型</span></h3><p id="dd0277dd6c9510a4288d26904622fa34" class="ne-p"><br></p><p id="700a86aaacacb207860a5ef065bfc842" class="ne-p"><span class="ne-text">很多操作系统支持多种文件类型。例如，UNIX（同样包括 OS X）和 Windows 都具有常规的文件和目录。除此之外，UNIX 还具有</span><code class="ne-code"><span class="ne-text">字符特殊文件(character special file)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">块特殊文件(block special file)</span></code><span class="ne-text">。</span><code class="ne-code"><span class="ne-text">常规文件(Regular files)</span></code><span class="ne-text"> 是包含有用户信息的文件。用户一般使用的文件大都是常规文件，常规文件一般包括 </span><strong><span class="ne-text">可执行文件、文本文件、图像文件</span></strong><span class="ne-text">，从常规文件读取数据或将数据写入时，内核会根据文件系统的规则执行操作，是写入可能被延迟，记录日志或者接受其他操作。</span></p><p id="d803466fc9fe85690453543577916782" class="ne-p"><br></p><h3 id="2ca5dd51"><span class="ne-text">文件访问</span></h3><p id="1eea59f4629deed14c4bbefdb9ff560d" class="ne-p"><br></p><p id="b132fe515bd7dd759ef63c37eb082a61" class="ne-p"><span class="ne-text">早期的操作系统只有一种访问方式：</span><code class="ne-code"><span class="ne-text">序列访问(sequential access)</span></code><span class="ne-text">。在这些系统中，进程可以按照顺序读取所有的字节或文件中的记录，但是不能跳过并乱序执行它们。顺序访问文件是可以返回到起点的，需要时可以多次读取该文件。当存储介质是磁带而不是磁盘时，顺序访问文件很方便。</span></p><p id="2149db0b1f4aef60c803eb241beaceb9" class="ne-p"><br></p><p id="dce71c7fccbf2fc8964d659038be9e03" class="ne-p"><span class="ne-text">在使用磁盘来存储文件时，可以不按照顺序读取文件中的字节或者记录，或者按照关键字而不是位置来访问记录。这种能够以任意次序进行读取的称为</span><code class="ne-code"><span class="ne-text">随机访问文件(random access file)</span></code><span class="ne-text">。许多应用程序都需要这种方式。</span></p><p id="4f74717aa95a17e1fcd34889477b996a" class="ne-p"><br></p><p id="008ff964469f0ec53c27329344f05020" class="ne-p"><span class="ne-text">随机访问文件对许多应用程序来说都必不可少，例如，数据库系统。如果乘客打电话预定某航班机票，订票程序必须能够直接访问航班记录，而不必先读取其他航班的成千上万条记录。</span></p><p id="53807ed6cd70ab7d582f3dcdc0fc14c0" class="ne-p"><br></p><p id="af6c758e0caff2e1a559f009fefe473e" class="ne-p"><span class="ne-text">有两种方法可以指示从何处开始读取文件。第一种方法是直接使用 </span><code class="ne-code"><span class="ne-text">read</span></code><span class="ne-text"> 从头开始读取。另一种是用一个特殊的 </span><code class="ne-code"><span class="ne-text">seek</span></code><span class="ne-text"> 操作设置当前位置，在 seek 操作后，从这个当前位置顺序地开始读文件。UNIX 和 Windows 使用的是后面一种方式。</span></p><p id="8020d0101a5f3dcbb54621b955f23d0b" class="ne-p"><br></p><h3 id="0b81772b"><span class="ne-text">文件属性</span></h3><p id="8062f25c30a983560cb8b3e049ade111" class="ne-p"><br></p><p id="3b59c2728b8366a73b1922e7adf5feb0" class="ne-p"><span class="ne-text">文件包括文件名和数据。除此之外，所有的操作系统还会保存其他与文件相关的信息，如文件创建的日期和时间、文件大小。我们可以称这些为文件的</span><code class="ne-code"><span class="ne-text">属性(attributes)</span></code><span class="ne-text">。有些人也喜欢把它们称作 </span><code class="ne-code"><span class="ne-text">元数据(metadata)</span></code><span class="ne-text">。文件的属性在不同的系统中差别很大。文件的属性只有两种状态：</span><code class="ne-code"><span class="ne-text">设置(set)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">清除(clear)</span></code><span class="ne-text">。</span></p><p id="ff3234edb116466cf8feb1acf75da02b" class="ne-p"><br></p><h3 id="52cefcb2"><span class="ne-text">文件操作</span></h3><p id="1e779b7cc62a0d85bd60f607a32dfe08" class="ne-p"><br></p><p id="de771a10ee395dd67ec222bec5fdecb7" class="ne-p"><span class="ne-text">使用文件的目的是用来存储信息并方便以后的检索。对于存储和检索，不同的系统提供了不同的操作。以下是与文件有关的最常用的一些系统调用：</span></p><p id="c0724f0565ae49c0d6b6cc475b6ac846" class="ne-p"><br></p><ol class="ne-ol"><li id="504ecd73fd5ceecb12f3932e3f9b2ca1"><code class="ne-code"><span class="ne-text">Create</span></code><span class="ne-text">，创建不包含任何数据的文件。调用的目的是表示文件即将建立，并对文件设置一些属性。</span></li><li id="179ee01cd008860de8a7a253e9d18249"><code class="ne-code"><span class="ne-text">Delete</span></code><span class="ne-text">，当文件不再需要，必须删除它以释放内存空间。为此总会有一个系统调用来删除文件。</span></li></ol><ol start="3" class="ne-ol"><li id="328a4d096282ef0c9bd3f349be56947f"><code class="ne-code"><span class="ne-text">Open</span></code><span class="ne-text">，在使用文件之前，必须先打开文件。这个调用的目的是允许系统将属性和磁盘地址列表保存到主存中，用来以后的快速访问。</span></li><li id="7c85b0b657768dc1ce22864b71e5a08e"><code class="ne-code"><span class="ne-text">Close</span></code><span class="ne-text">，当所有进程完成时，属性和磁盘地址不再需要，因此应关闭文件以释放表空间。很多系统限制进程打开文件的个数，以此达到鼓励用户关闭不再使用的文件。磁盘以块为单位写入，关闭文件时会强制写入最后一</span><code class="ne-code"><span class="ne-text">块</span></code><span class="ne-text">，即使这个块空间内部还不满。</span></li></ol><ol start="5" class="ne-ol"><li id="50bfb078134ebd8dff44c5657d8994e7"><code class="ne-code"><span class="ne-text">Read</span></code><span class="ne-text">，数据从文件中读取。通常情况下，读取的数据来自文件的当前位置。调用者必须指定需要读取多少数据，并且提供存放这些数据的缓冲区。</span></li><li id="43384bb690645e13a262e1955f177b7a"><code class="ne-code"><span class="ne-text">Write</span></code><span class="ne-text">，向文件写数据，写操作一般也是从文件的当前位置开始进行。如果当前位置是文件的末尾，则会直接追加进行写入。如果当前位置在文件中，则现有数据被覆盖，并且永远消失。</span></li></ol><ol start="7" class="ne-ol"><li id="e3f6ff74f235e372c8bbf5609d277cd8"><code class="ne-code"><span class="ne-text">append</span></code><span class="ne-text">，使用 append 只能向文件末尾添加数据。</span></li><li id="b9c24d0c6b35e2bb0b54f846c2f3cbe2"><code class="ne-code"><span class="ne-text">seek</span></code><span class="ne-text">，对于随机访问的文件，要指定从何处开始获取数据。通常的方法是用 seek 系统调用把当前位置指针指向文件中的特定位置。seek 调用结束后，就可以从指定位置开始读写数据了。</span></li></ol><ol start="9" class="ne-ol"><li id="922b6108cf62d8263fbd88c8d5498241"><code class="ne-code"><span class="ne-text">get attributes</span></code><span class="ne-text">，进程运行时通常需要读取文件属性。</span></li><li id="8c8e3ceb23d3a616b99b8b941b08aa52"><code class="ne-code"><span class="ne-text">set attributes</span></code><span class="ne-text">，用户可以自己设置一些文件属性，甚至是在文件创建之后，实现该功能的是 set attributes 系统调用。</span></li></ol><ol start="11" class="ne-ol"><li id="e72eb2d85f14c3f7ac4d9fd59c6888b7"><code class="ne-code"><span class="ne-text">rename</span></code><span class="ne-text">，用户可以自己更改已有文件的名字，rename 系统调用用于这一目的。</span></li></ol><p id="a87343eaf9d3450efabef778da123d99" class="ne-p"><br></p><h2 id="767fa455"><span class="ne-text">目录</span></h2><p id="b9343aee17ca89896a9c0199f20a54f1" class="ne-p"><br></p><p id="3c356aca639851aa2446430e0cf3733e" class="ne-p"><span class="ne-text">文件系统通常提供</span><code class="ne-code"><span class="ne-text">目录(directories)</span></code><span class="ne-text"> 或者 </span><code class="ne-code"><span class="ne-text">文件夹(folders)</span></code><span class="ne-text"> 用于记录文件的位置，在很多系统中目录本身也是文件，下面我们会讨论关于文件，他们的组织形式、属性和可以对文件进行的操作。</span></p><p id="dff0717322930d1c24e5ab4609400092" class="ne-p"><br></p><h3 id="007929bd"><span class="ne-text">一级目录系统</span></h3><p id="34540bcb72c35b535e539c2292febbbb" class="ne-p"><br></p><p id="54065234453c67a62e92fdfbb18d6e66" class="ne-p"><span class="ne-text">目录系统最简单的形式是有一个能够包含所有文件的目录。这种目录被称为</span><code class="ne-code"><span class="ne-text">根目录(root directory)</span></code><span class="ne-text">，由于根目录的唯一性，所以其名称并不重要。在最早期的个人计算机中，这种系统很常见，部分原因是因为只有一个用户。下面是一个单层目录系统的例子</span></p><p id="608cd64c499251753f32da03fb38243a" class="ne-p"><br></p><p id="487deb8f9d390dd52747ae3a2d276448" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830155-ca95d416-207a-46d6-89dd-77c398a175d3.png" width="500" id="LyUcX" class="ne-image"></p><p id="45f33aa4b012163e958412625f737ea8" class="ne-p"><br></p><p id="888aed0ab34181e2ca6fdb1bf464feae" class="ne-p"><span class="ne-text"> 含有四个文件的单层目录系统</span></p><p id="6c96f97c55ea84f77c4863a07950cfa6" class="ne-p"><br></p><p id="06c45b31715829537869cc1e51ceae82" class="ne-p"><span class="ne-text">该目录中有四个文件。这种设计的优点在于简单，并且能够快速定位文件，毕竟只有一个地方可以检索。这种目录组织形式现在一般用于简单的嵌入式设备（如数码相机和某些便携式音乐播放器）上使用。</span></p><p id="05cc9579be20bd8d9cd8382cc614bdd7" class="ne-p"><br></p><h3 id="17225630"><span class="ne-text">层次目录系统</span></h3><p id="a2f4aec9d46fbfd0fca6e2d7fbefc82e" class="ne-p"><br></p><p id="7a7f44ac2994c611f0b66c4e87c0d70e" class="ne-p"><span class="ne-text">对于简单的应用而言，一般都用单层目录方式，但是这种组织形式并不适合于现代计算机，因为现代计算机含有成千上万个文件和文件夹。如果都放在根目录下，查找起来会非常困难。为了解决这一问题，出现了</span><code class="ne-code"><span class="ne-text">层次目录系统(Hierarchical Directory Systems)</span></code><span class="ne-text">，也称为</span><code class="ne-code"><span class="ne-text">目录树</span></code><span class="ne-text">。通过这种方式，可以用很多目录把文件进行分组。进而，如果多个用户共享同一个文件服务器，比如公司的网络系统，每个用户可以为自己的目录树拥有自己的私人根目录。这种方式的组织结构如下</span></p><p id="dbf72bf64d673a9ed4ac556da2b03fc5" class="ne-p"><br></p><p id="8fd241c376d25d675006401b0450d10d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830190-cdcd48b8-b7ca-4597-b41d-d61089e0250d.png" width="699" id="eyi1a" class="ne-image"></p><p id="595388086341aaf9ea0cc4f986c5f072" class="ne-p"><br></p><p id="1facfc7d32c49c743af569c6eac8ba13" class="ne-p"><span class="ne-text">根目录含有目录 A、B 和 C ，分别属于不同的用户，其中两个用户个字创建了</span><code class="ne-code"><span class="ne-text">子目录</span></code><span class="ne-text">。用户可以创建任意数量的子目录，现代文件系统都是按照这种方式组织的。</span></p><p id="9606d66d6cd5e0bfc4b92e125dce83ca" class="ne-p"><br></p><h3 id="26f36dea"><span class="ne-text">路径名</span></h3><p id="3c68cf4eceb1aebdebb0636d38b6d630" class="ne-p"><br></p><p id="20cf84ba39d49bdb319108dd01bd8f7c" class="ne-p"><span class="ne-text">当目录树组织文件系统时，需要有某种方法指明文件名。常用的方法有两种，第一种方式是每个文件都会用一个</span><code class="ne-code"><span class="ne-text">绝对路径名(absolute path name)</span></code><span class="ne-text">，它由根目录到文件的路径组成。</span></p><p id="7375343f1d5a3e86bc7693dec3e4e850" class="ne-p"><br></p><p id="1864d899922b43e08ec349f3b9185a11" class="ne-p"><span class="ne-text">另外一种指定文件名的方法是 </span><code class="ne-code"><span class="ne-text">相对路径名(relative path name)</span></code><span class="ne-text">。它常常和 </span><code class="ne-code"><span class="ne-text">工作目录(working directory)</span></code><span class="ne-text"> （也称作 </span><code class="ne-code"><span class="ne-text">当前目录(current directory)</span></code><span class="ne-text">）一起使用。用户可以指定一个目录作为当前工作目录。例如，如果当前目录是 </span><code class="ne-code"><span class="ne-text">/usr/ast</span></code><span class="ne-text">，那么绝对路径 </span><code class="ne-code"><span class="ne-text">/usr/ast/mailbox</span></code><span class="ne-text">可以直接使用 </span><code class="ne-code"><span class="ne-text">mailbox</span></code><span class="ne-text"> 来引用。</span></p><p id="4d86e51488f9e3357b3d1c7316d4d4ee" class="ne-p"><br></p><h3 id="20731fe2"><span class="ne-text">目录操作</span></h3><p id="72f0e76f51955e4fd5747f7f47125254" class="ne-p"><br></p><p id="5a42d88e3de5412699ce7ef46d8b0754" class="ne-p"><span class="ne-text">不同文件中管理目录的系统调用的差别比管理文件的系统调用差别大。为了了解这些系统调用有哪些以及它们怎样工作，下面给出一个例子（取自 UNIX）。</span></p><p id="40bbdad75c7cc6d07a2763e60ee386b6" class="ne-p"><br></p><ol class="ne-ol"><li id="b514136adfffb03de670ef5af862b47c"><code class="ne-code"><span class="ne-text">Create</span></code><span class="ne-text">，创建目录，除了目录项 </span><code class="ne-code"><span class="ne-text">.</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">..</span></code><span class="ne-text"> 外，目录内容为空。</span></li><li id="b11a83b53464bd86401aa01c73f5c27f"><code class="ne-code"><span class="ne-text">Delete</span></code><span class="ne-text">，删除目录，只有空目录可以删除。只包含 </span><code class="ne-code"><span class="ne-text">.</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">..</span></code><span class="ne-text"> 的目录被认为是空目录，这两个目录项通常不能删除</span></li></ol><ol start="3" class="ne-ol"><li id="963fdf6f08b50d63286bc505dffbf5fb"><code class="ne-code"><span class="ne-text">opendir</span></code><span class="ne-text">，目录内容可被读取。例如，未列出目录中的全部文件，程序必须先打开该目录，然后读其中全部文件的文件名。与打开和读文件相同，在读目录前，必须先打开文件。</span></li><li id="c74b7a45eea8a24a9f1c8549c7864719"><code class="ne-code"><span class="ne-text">closedir</span></code><span class="ne-text">，读目录结束后，应该关闭目录用于释放内部表空间。</span></li></ol><ol start="5" class="ne-ol"><li id="17dd041b9516a40a3358c45b1362d7ec"><code class="ne-code"><span class="ne-text">readdir</span></code><span class="ne-text">，系统调用 readdir 返回打开目录的下一个目录项。以前也采用 read 系统调用来读取目录，但是这种方法有一个缺点：程序员必须了解和处理目录的内部结构。相反，不论采用哪一种目录结构，readdir 总是以标准格式返回一个目录项。</span></li><li id="4f848d51acdd481545cb2cb86b2d4a9b"><code class="ne-code"><span class="ne-text">rename</span></code><span class="ne-text">，在很多方面目录和文件都相似。文件可以更换名称，目录也可以。</span></li></ol><ol start="7" class="ne-ol"><li id="edbace6607fb3be4e1b637a1dd9aa171"><code class="ne-code"><span class="ne-text">link</span></code><span class="ne-text">，链接技术允许在多个目录中出现同一个文件。这个系统调用指定一个存在的文件和一个路径名，并建立从该文件到路径所指名字的链接。这样，可以在多个目录中出现同一个文件。有时也被称为</span><code class="ne-code"><span class="ne-text">硬链接(hard link)</span></code><span class="ne-text">。</span></li><li id="2cc1cbbf1be79fb5e132a02d030c0afc"><code class="ne-code"><span class="ne-text">unlink</span></code><span class="ne-text">，删除目录项。如果被解除链接的文件只出现在一个目录中，则将它从文件中删除。如果它出现在多个目录中，则只删除指定路径名的链接，依然保留其他路径名的链接。在 UNIX 中，用于删除文件的系统调用就是 unlink。</span></li></ol><p id="885d73b5a39a7c004346a847d1440b8a" class="ne-p"><br></p><h2 id="f7f29532"><span class="ne-text">文件系统的实现</span></h2><p id="ec714890f3489b939201876f99912a34" class="ne-p"><br></p><h3 id="063a94b5"><span class="ne-text">文件系统布局</span></h3><p id="4a9f73122edec1e3f247798ed5bb6ed5" class="ne-p"><br></p><p id="861f46d91942e981cc98ea26967493e0" class="ne-p"><span class="ne-text">文件系统存储在</span><code class="ne-code"><span class="ne-text">磁盘</span></code><span class="ne-text">中。大部分的磁盘能够划分出一到多个分区，叫做</span><code class="ne-code"><span class="ne-text">磁盘分区(disk partitioning)</span></code><span class="ne-text"> 或者是</span><code class="ne-code"><span class="ne-text">磁盘分片(disk slicing)</span></code><span class="ne-text">。每个分区都有独立的文件系统，每块分区的文件系统可以不同。磁盘的 0 号分区称为 </span><code class="ne-code"><span class="ne-text">主引导记录(Master Boot Record, MBR)</span></code><span class="ne-text">，用来</span><code class="ne-code"><span class="ne-text">引导(boot)</span></code><span class="ne-text"> 计算机。在 MBR 的结尾是</span><code class="ne-code"><span class="ne-text">分区表(partition table)</span></code><span class="ne-text">。每个分区表给出每个分区由开始到结束的地址。</span></p><p id="0721c038245fb84b7719e05e8f622ff2" class="ne-p"><br></p><p id="9a6cf1225520c728351597ee0e399155" class="ne-p"><span class="ne-text">当计算机开始引 boot 时，BIOS 读入并执行 MBR。</span></p><p id="75737c56aefb3c7fffd13019a2a1d831" class="ne-p"><br></p><h4 id="740649ac"><span class="ne-text">引导块</span></h4><p id="79156822d8503698dc82e2138c609266" class="ne-p"><br></p><p id="3ff3214b74c0925029bca92abe9ea54e" class="ne-p"><span class="ne-text">MBR 做的第一件事就是</span><code class="ne-code"><span class="ne-text">确定活动分区</span></code><span class="ne-text">，读入它的第一个块，称为</span><code class="ne-code"><span class="ne-text">引导块(boot block)</span></code><span class="ne-text"> 并执行。引导块中的程序将加载分区中的操作系统。为了一致性，每个分区都会从引导块开始，即使引导块不包含操作系统。引导块占据文件系统的前 4096 个字节，从磁盘上的字节偏移量 0 开始。引导块可用于启动操作系统。</span></p><p id="cc963be5f996c475d719d40c4fa10893" class="ne-p"><br></p><p id="4eff089b1ed72dbedc26da706d2b576c" class="ne-p"><span class="ne-text">除了从引导块开始之外，磁盘分区的布局是随着文件系统的不同而变化的。通常文件系统会包含一些属性，如下</span></p><p id="418b125edcf82ba1123e87efba837f9e" class="ne-p"><br></p><p id="6e21b01c67c9de127bae097535ad2d34" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830178-416c1399-355d-4e11-aaad-360c3071d651.png" width="725" id="WO5Ij" class="ne-image"></p><p id="802ba5c7e2c81d6c079467b487a35ee2" class="ne-p"><br></p><p id="70b4cab1c421609e38e9318a8e29f8ed" class="ne-p"><span class="ne-text"> 文件系统布局</span></p><p id="bc19ea1c5561802b619f7862b16edf7e" class="ne-p"><br></p><h4 id="0f7ddcc2"><span class="ne-text">超级块</span></h4><p id="a899d94ff2d728d47e586dc99a20e67d" class="ne-p"><br></p><p id="87b2599a79fc028dca72250f4bb1b6c9" class="ne-p"><span class="ne-text">紧跟在引导块后面的是 </span><code class="ne-code"><span class="ne-text">超级块(Superblock)</span></code><span class="ne-text">，超级块 的大小为 4096 字节，从磁盘上的字节偏移 4096 开始。超级块包含文件系统的所有关键参数</span></p><p id="1476e552c3b10f8582475439b1afb325" class="ne-p"><br></p><ul class="ne-ul"><li id="e4948c5816657ad07b16d2106062394d"><span class="ne-text">文件系统的大小</span></li><li id="8d63325fca6fd5dd7c277423a3ee972d"><span class="ne-text">文件系统中的数据块数</span></li></ul><ul class="ne-ul"><li id="587353c806d7ddc766494832594e262c"><span class="ne-text">指示文件系统状态的标志</span></li><li id="cc7684fc661626e2319cfe80411a56cc"><span class="ne-text">分配组大小</span></li></ul><p id="2a9a7c180f2ee41597fc75f3099404ed" class="ne-p"><br></p><p id="e5bdce31d9d48389f4afd8a853074c25" class="ne-p"><span class="ne-text">在计算机启动或者文件系统首次使用时，超级块会被读入内存。</span></p><p id="cdfd564f630ad7e23f32c907e7be4764" class="ne-p"><br></p><h4 id="d1ac35a8"><span class="ne-text">空闲空间块</span></h4><p id="6c535e1a3405fed739b7db4477fcfe06" class="ne-p"><br></p><p id="e75d427462705c57bc53dcb068c3ec3f" class="ne-p"><span class="ne-text">接着是文件系统中</span><code class="ne-code"><span class="ne-text">空闲块</span></code><span class="ne-text">的信息，例如，可以用位图或者指针列表的形式给出。</span></p><p id="310d3be16358713f214a0b655e726d8f" class="ne-p"><br></p><p id="277b5380d1da751428660b1bcedfa5ff" class="ne-p"><strong><span class="ne-text">BitMap 位图或者 Bit vector 位向量</span></strong></p><p id="d4f7482f58816535906052b8e6a7d87e" class="ne-p"><br></p><p id="55cffd4813169a9f5d4e6c6b2c0e7ec4" class="ne-p"><span class="ne-text">位图或位向量是一系列位或位的集合，其中每个位对应一个磁盘块，该位可以采用两个值：0 和 1，0 表示已分配该块，而 1 表示一个空闲块。下图中的磁盘上给定的磁盘块实例（分配了绿色块）可以用 16 位的位图表示为：0000111000000110。</span></p><p id="0af159c768142dd2b260c453127538c0" class="ne-p"><br></p><p id="093caab837a37d141b3925293bf9714d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830202-8aab8dd3-4293-45ca-ab73-fdf893584edc.png" width="395" id="NJVi8" class="ne-image"></p><p id="8705f7dfac212aab78bf0ab7417d616e" class="ne-p"><br></p><p id="f331be17432c09b9a9f2000d393d383a" class="ne-p"><strong><span class="ne-text">使用链表进行管理</span></strong></p><p id="ae280515e910cb48e7500b5ab206df39" class="ne-p"><br></p><p id="a1ef494d8b253a9a5c23a588a613ec9b" class="ne-p"><span class="ne-text">在这种方法中，空闲磁盘块链接在一起，即一个空闲块包含指向下一个空闲块的指针。第一个磁盘块的块号存储在磁盘上的单独位置，也缓存在内存中。</span></p><p id="7161779eddc824e1d1133e5170bb19c8" class="ne-p"><br></p><p id="1e7553f5324ffb7c2a2dc274b3f94e7b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830218-bc0ef6e9-c0df-4495-9a7f-4bd5161d4bef.png" width="432" id="dvjrg" class="ne-image"></p><p id="63945d94feb7a4c5fb0b41b6083864f8" class="ne-p"><br></p><h4 id="4f0b14f4"><span class="ne-text">碎片</span></h4><p id="75254f59dc781b72e779b3fe96e7a629" class="ne-p"><br></p><p id="e541583744244097bd2f9fa7b3bb37c5" class="ne-p"><span class="ne-text">这里不得不提一个叫做</span><code class="ne-code"><span class="ne-text">碎片(fragment)</span></code><span class="ne-text">的概念，也称为片段。一般零散的单个数据通常称为片段。 磁盘块可以进一步分为固定大小的分配单元，片段只是在驱动器上彼此不相邻的文件片段。</span></p><p id="3f26e24c7f974df5bffef64b27e565d5" class="ne-p"><br></p><h4 id="inode"><span class="ne-text">inode</span></h4><p id="6fc1903ad5e0e3115581a601fdd7564b" class="ne-p"><br></p><p id="8363cd64eb86a68613f21c83f735a113" class="ne-p"><span class="ne-text">然后在后面是一个 </span><code class="ne-code"><span class="ne-text">inode(index node)</span></code><span class="ne-text">，也称作索引节点。它是一个数组的结构，每个文件有一个 inode，inode 非常重要，它说明了文件的方方面面。每个索引节点都存储对象数据的属性和磁盘块位置</span></p><p id="c4e25dd9c42034d98f8d6ead66069b73" class="ne-p"><br></p><p id="78b35dea2fbf0caa97c6a0e4d341729f" class="ne-p"><span class="ne-text">有一种简单的方法可以找到它们 </span><code class="ne-code"><span class="ne-text">ls -lai</span></code><span class="ne-text"> 命令。让我们看一下根文件系统：</span></p><p id="f73d13b715b79dd4b9d2a3973799f1b2" class="ne-p"><br></p><p id="23fc4b493a2a8cacfd956a7a12ea18fa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830231-757b0e6a-7a82-4ec8-9a1c-15b9999e0185.png" width="725" id="dyXmP" class="ne-image"></p><p id="7cdc062285235cfe9cc6d010d78172ec" class="ne-p"><br></p><p id="1a3a5b8a310886a6d1c3ee8aa40ca65a" class="ne-p"><span class="ne-text">inode 节点主要包括了以下信息</span></p><p id="0f214c2c872e0efbb561a09eee7fd193" class="ne-p"><br></p><ul class="ne-ul"><li id="4e0fc36ad25bba57c6c83faee15237e8"><span class="ne-text">模式/权限（保护）</span></li><li id="823d04a8b16ecce489446613644eb5f3"><span class="ne-text">所有者 ID</span></li></ul><ul class="ne-ul"><li id="36a513e2056edf128f901912bdd5844a"><span class="ne-text">组 ID</span></li><li id="546b99bab3f0efe6dd65374f82ea512f"><span class="ne-text">文件大小</span></li></ul><ul class="ne-ul"><li id="ca587e18e953730b595535a6d2c2a52e"><span class="ne-text">文件的硬链接数</span></li><li id="d902e80175e84a5d6d169458079df074"><span class="ne-text">上次访问时间</span></li></ul><ul class="ne-ul"><li id="c4df7d4c30aeed369984820d84d672ae"><span class="ne-text">最后修改时间</span></li><li id="4cf9ad6d8fd4f59667245e548904693e"><span class="ne-text">inode 上次修改时间</span></li></ul><p id="63d51221d1e89f15fef8cf8046b41c7f" class="ne-p"><br></p><p id="edba86612d73fee8953765e5d1e71604" class="ne-p"><span class="ne-text">文件分为两部分，索引节点和块。一旦创建后，每种类型的块数是固定的。你不能增加分区上 inode 的数量，也不能增加磁盘块的数量。</span></p><p id="bab0d6d8fdb7ade0c409c63b794198cd" class="ne-p"><br></p><p id="257f76d41594956d4e6f434c94fcd48f" class="ne-p"><span class="ne-text">紧跟在 inode 后面的是根目录，它存放的是文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件。</span></p><p id="07384bc2838ccc280811305a814ac5ae" class="ne-p"><br></p><h3 id="2fa1f996"><span class="ne-text">文件的实现</span></h3><p id="99b6ccd02eb7d36b23ac87b3d23be908" class="ne-p"><br></p><p id="520d4f89043e0d3ef94e335ae502c537" class="ne-p"><span class="ne-text">最重要的问题是记录各个文件分别用到了哪些磁盘块。不同的系统采用了不同的方法。下面我们会探讨一下这些方式。分配背后的主要思想是</span><code class="ne-code"><span class="ne-text">有效利用文件空间</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">快速访问文件</span></code><span class="ne-text"> ，主要有三种分配方案</span></p><p id="d5bcaa062d84a2587d7983f841a8bb43" class="ne-p"><br></p><ul class="ne-ul"><li id="bd6f72f15903e819e6825d6a4c7d5066"><span class="ne-text">连续分配</span></li><li id="73e9c7cdab99a93a7b5d1cff4ce5bee3"><span class="ne-text">链表分配</span></li></ul><ul class="ne-ul"><li id="6c8d5f5e0b3f6cbb9bedb283610e1607"><span class="ne-text">索引分配</span></li></ul><p id="272e01376fc108d16c05972efeddd7b6" class="ne-p"><br></p><h4 id="72b53a95"><span class="ne-text">连续分配</span></h4><p id="bb7d19bc0a00fea5cb03d6b986da98b5" class="ne-p"><br></p><p id="739ceabf45e4e532ceaee28804bd6747" class="ne-p"><span class="ne-text">最简单的分配方案是把每个文件作为一连串连续数据块存储在磁盘上。因此，在具有 1KB 块的磁盘上，将为 50 KB 文件分配 50 个连续块。</span></p><p id="57e7fce6afec06f7bac3cc1f758e706a" class="ne-p"><br></p><p id="f485071b361eacaef97f0d6bc93d38d0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830290-96589d90-fa12-43fb-a38a-8ece59db8fcd.png" width="708" id="DEFjo" class="ne-image"></p><p id="149d6540bff10fd348ccf39a548b4008" class="ne-p"><br></p><p id="ad710f4df53ff897f898e195d3474ef4" class="ne-p"><span class="ne-text"> 使用连续空间存储文件</span></p><p id="6e62bb3ca3c03233a13af4af40a1e434" class="ne-p"><br></p><p id="4409e41335edde0a0d4bead916ef1d10" class="ne-p"><span class="ne-text">上面展示了 40 个连续的内存块。从最左侧的 0 块开始。初始状态下，还没有装载文件，因此磁盘是空的。接着，从磁盘开始处（块 0 ）处开始写入占用 4 块长度的内存 A 。然后是一个占用 6 块长度的内存 B，会直接在 A 的末尾开始写。</span></p><p id="eb491f935999b43456e0680eb86056c0" class="ne-p"><br></p><p id="1dbb3a5ff9f7fb7ded0538273ec30ec5" class="ne-p"><span class="ne-text">注意每个文件都会在新的文件块开始写，所以如果文件 A 只占用了 </span><code class="ne-code"><span class="ne-text">3 又 1/2</span></code><span class="ne-text"> 个块，那么最后一个块的部分内存会被浪费。在上面这幅图中，总共展示了 7 个文件，每个文件都会从上个文件的末尾块开始写新的文件块。</span></p><p id="4d302f7f8ae1e2e3584289e94f7b7ee2" class="ne-p"><br></p><p id="ea5e53beccedfc7b48a72979c05ce798" class="ne-p"><span class="ne-text">连续的磁盘空间分配有两个优点。</span></p><p id="429ef5981f289b4d48278e8e51438334" class="ne-p"><br></p><ul class="ne-ul"><li id="07797a0fdd2cc4666f9a5e4a2b80175a"><span class="ne-text">第一，连续文件存储实现起来比较简单，只需要记住两个数字就可以：一个是第一个块的文件地址和文件的块数量。给定第一个块的编号，可以通过简单的加法找到任何其他块的编号。</span></li><li id="40dc07731b88d5bc4e9f39dbda642ece"><span class="ne-text">第二点是读取性能比较强，可以通过一次操作从文件中读取整个文件。只需要一次寻找第一个块。后面就不再需要寻道时间和旋转延迟，所以数据会以全带宽进入磁盘。</span></li></ul><p id="fb5eddf328615cd7b667cd0f76ed8064" class="ne-p"><br></p><p id="c211a55fb8333594f2910711c0080375" class="ne-p"><span class="ne-text">因此，连续的空间分配具有</span><code class="ne-code"><span class="ne-text">实现简单</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">高性能</span></code><span class="ne-text">的特点。</span></p><p id="226cf8984f3e14ad2f869b70b0ae3d25" class="ne-p"><br></p><p id="584d3adf6df424e0caad8d640306ac6f" class="ne-p"><span class="ne-text">不幸的是，连续空间分配也有很明显的不足。随着时间的推移，磁盘会变得很零碎。下图解释了这种现象</span></p><p id="beb6289ffd948b913ab42f89fc806491" class="ne-p"><br></p><p id="3ca05927b2bc30ed4efbcbe0009b626d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830262-ef7ce9d8-c4b9-488c-a2d3-48d7888ffe1f.png" width="700" id="AWBOd" class="ne-image"></p><p id="da80c0e171d6555b328959c948dd63da" class="ne-p"><br></p><p id="665c27cdd3d5d092fa41038401e02f09" class="ne-p"><span class="ne-text">这里有两个文件 D 和 F 被删除了。当删除一个文件时，此文件所占用的块也随之释放，就会在磁盘空间中留下一些空闲块。磁盘并不会在这个位置挤压掉空闲块，因为这会复制空闲块之后的所有文件，可能会有上百万的块，这个量级就太大了。</span></p><p id="516ce272d9891eb30c2670ca8fd9c815" class="ne-p"><br></p><h4 id="3d0c6331"><span class="ne-text">链表分配</span></h4><p id="b3b68de304c1d67898de10b8a645632c" class="ne-p"><br></p><p id="8ee621e84c761779bda7b9527721198f" class="ne-p"><span class="ne-text">第二种存储文件的方式是为每个文件构造磁盘块链表，每个文件都是磁盘块的链接列表，就像下面所示</span></p><p id="9d34cfd049bd058c018f3fbe6541ec1d" class="ne-p"><br></p><p id="4433a4082a45a23ee4f93af4c0102214" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830296-9199d50b-5e5b-43f4-a62b-dc0b1ef02d6d.png" width="739" id="UEy0O" class="ne-image"></p><p id="7f14e16ff0324beb9815b3ee276388d4" class="ne-p"><br></p><p id="308a2bb2be459b1d5455d81efb421ceb" class="ne-p"><span class="ne-text"> 以磁盘块的链表形式存储文件</span></p><p id="dc594ff5bca4f75526a34525758f6cf8" class="ne-p"><br></p><p id="60e8ab8b1ba0ea6828d0b8e832d4aabf" class="ne-p"><span class="ne-text">每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。如果上面这张图你看的不是很清楚的话，可以看看整个的链表分配方案</span></p><p id="f2cd47fbd794262b99b108f78818a186" class="ne-p"><br></p><p id="6d43d1117b2ffa2b376514a9bdfbb5c3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830272-99171e3f-0aae-4fa7-b127-e43f64daed7d.png" width="717" id="MV6v4" class="ne-image"></p><p id="a211e6d69c7bbfb39749b7bec6679328" class="ne-p"><br></p><p id="1763c1572bf74bab8443b0251b0cab48" class="ne-p"><span class="ne-text">与连续分配方案不同，这一方法可以充分利用每个磁盘块。除了最后一个磁盘块外，不会因为磁盘碎片而浪费存储空间。同样，在目录项中，只要存储了第一个文件块，那么其他文件块也能够被找到。</span></p><p id="f61320e6d20a47449e2034136f13b99e" class="ne-p"><br></p><p id="7c4e5c49d0f6e1ea08c9347e50f2d9cc" class="ne-p"><span class="ne-text">另一方面，在链表的分配方案中，尽管顺序读取非常方便，但是随机访问却很困难（这也是数组和链表数据结构的一大区别）。</span></p><p id="4dfa5bc9fab85a3f79ba645a4de63d55" class="ne-p"><br></p><p id="ff5cd3412028401a7eb6f6907edfe384" class="ne-p"><span class="ne-text">还有一个问题是，由于指针会占用一些字节，每个磁盘块实际存储数据的字节数并不再是 2 的整数次幂。虽然这个问题并不会很严重，但是这种方式降低了程序运行效率。许多程序都是以长度为 2 的整数次幂来读写磁盘，由于每个块的前几个字节被指针所使用，所以要读出一个完成的块大小信息，就需要当前块的信息和下一块的信息拼凑而成，因此就引发了查找和拼接的开销。</span></p><p id="5c501728e8545b3abf2ebd585e59e40a" class="ne-p"><br></p><h4 id="e7754cf3"><span class="ne-text">使用内存表进行链表分配</span></h4><p id="f55bd6034ba134163728e11d790728db" class="ne-p"><br></p><p id="fa31a2161c19438020b78c4e5edcff77" class="ne-p"><span class="ne-text">由于连续分配和链表分配都有其不可忽视的缺点。所以提出了使用内存中的表来解决分配问题。取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决上述链表的两个不足之处。下面是一个例子</span></p><p id="c62141cbec45e806125f66c6443b2cae" class="ne-p"><br></p><p id="5294fd0f6ea2c7bd340fe04e8f683dfe" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830309-8180ae56-d298-4224-a60b-d472bd7dff53.png" width="499" id="qB40I" class="ne-image"></p><p id="8a73dddf92c308f55531792c78bc4c17" class="ne-p"><br></p><p id="3231eff73ea3778fa27bf38cee3b7593" class="ne-p"><span class="ne-text">上图表示了链表形成的磁盘块的内容。这两个图中都有两个文件，文件 A 依次使用了磁盘块地址 </span><strong><span class="ne-text">4、7、 2、 10、 12</span></strong><span class="ne-text">，文件 B 使用了</span><strong><span class="ne-text">6、3、11 和 14</span></strong><span class="ne-text">。也就是说，文件 A 从地址 4 处开始，顺着链表走就能找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找到文件 B 的全部磁盘块。你会发现，这两个链表都以不属于有效磁盘编号的特殊标记（-1）结束。内存中的这种表格称为 </span><code class="ne-code"><span class="ne-text">文件分配表(File Application Table,FAT)</span></code><span class="ne-text">。</span></p><p id="679e35092915fc206d463659b3246031" class="ne-p"><br></p><h3 id="507a4c82"><span class="ne-text">目录的实现</span></h3><p id="229b6f0552c8dcf4c69d5168f63a9eeb" class="ne-p"><br></p><p id="8db380cc3bd619deb9e5ee87c2dcc678" class="ne-p"><span class="ne-text">文件只有打开后才能够被读取。在文件打开后，操作系统会使用用户提供的路径名来定位磁盘中的目录。目录项提供了查找文件磁盘块所需要的信息。根据系统的不同，提供的信息也不同，可能提供的信息是整个文件的磁盘地址，或者是第一个块的数量（两个链表方案）或 inode 的数量。不过不管用那种情况，目录系统的主要功能就是 </span><strong><span class="ne-text">将文件的 ASCII 码的名称映射到定位数据所需的信息上</span></strong><span class="ne-text">。</span></p><p id="c245ee3f18a5371b2e919276ff42e4d6" class="ne-p"><br></p><h3 id="7378a354"><span class="ne-text">共享文件</span></h3><p id="0d90e5167a61cad90103ab57542ccd79" class="ne-p"><br></p><p id="a010daa0deac86c6117411cf1b76ee1c" class="ne-p"><span class="ne-text">当多个用户在同一个项目中工作时，他们通常需要共享文件。如果这个共享文件同时出现在多个用户目录下，那么他们协同工作起来就很方便。下面的这张图我们在上面提到过，但是有一个更改的地方，就是 </span><strong><span class="ne-text">C 的一个文件也出现在了 B 的目录下</span></strong><span class="ne-text">。</span></p><p id="4ea8ea0f7dce1ab59600bb31b7fde121" class="ne-p"><br></p><p id="3f9712fc94bd87bc5bce05ab31700a90" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830321-b6391c5b-3b64-4089-9c4e-9a9afd09875c.png" width="743" id="wJKZ9" class="ne-image"></p><p id="1516e5428216ce2d70a3848a9e18d8b7" class="ne-p"><br></p><p id="84f511f5e2da2d65639ae5e4c5f08116" class="ne-p"><span class="ne-text">如果按照如上图的这种组织方式而言，那么 B 的目录与该共享文件的联系称为 </span><code class="ne-code"><span class="ne-text">链接(link)</span></code><span class="ne-text">。那么文件系统现在就是一个 </span><code class="ne-code"><span class="ne-text">有向无环图(Directed Acyclic Graph, 简称 DAG)</span></code><span class="ne-text">，而不是一棵树了。</span></p><p id="dedd40e6c19976b91159210337187cb3" class="ne-p"><br></p><h3 id="062d38ab"><span class="ne-text">日志结构文件系统</span></h3><p id="7d7ce6ffa46d0b80b05b4fa7cf88eb72" class="ne-p"><br></p><p id="0c348de3e61e1b6861d79e122967c6a9" class="ne-p"><span class="ne-text">技术的改变会给当前的文件系统带来压力。这种情况下，CPU 会变得越来越快，磁盘会变得越来越大并且越来越便宜（但不会越来越快）。内存容量也是以指数级增长。但是磁盘的寻道时间（除了固态盘，因为固态盘没有寻道时间）并没有获得提高。</span></p><p id="615e318cbe6ce685b317cedee5ce3166" class="ne-p"><br></p><p id="dc3ac711f3172e557139794ff56c713e" class="ne-p"><span class="ne-text">为此，</span><code class="ne-code"><span class="ne-text">Berkeley</span></code><span class="ne-text"> 设计了一种全新的文件系统，试图缓解这个问题，这个文件系统就是 </span><code class="ne-code"><span class="ne-text">日志结构文件系统(Log-structured File System, LFS)</span></code><span class="ne-text">。旨在解决以下问题。</span></p><p id="0c98bd5354523a99fdbae6022075672f" class="ne-p"><br></p><ul class="ne-ul"><li id="155a7907a5e3bdd0310a98218fdc334b"><span class="ne-text">不断增长的系统内存</span></li><li id="3b38564d520640464c2205c9486261b4"><span class="ne-text">顺序 I/O 性能胜过随机 I/O 性能</span></li></ul><ul class="ne-ul"><li id="32b086adb43b911b202b70e5aff36de8"><span class="ne-text">现有低效率的文件系统</span></li><li id="f7a37a133cbda2e36cf91ffdbee4d115"><span class="ne-text">文件系统不支持 RAID（虚拟化）</span></li></ul><p id="cf17037d9f08713ca3eeb4ace7b47ca8" class="ne-p"><br></p><p id="297fb6753d11f490d126e727b7c09c48" class="ne-p"><span class="ne-text">另一方面，当时的文件系统不论是 UNIX 还是 FFS，都有大量的随机读写（在 FFS 中创建一个新文件至少需要 5 次随机写），因此成为整个系统的性能瓶颈。同时因为 </span><code class="ne-code"><span class="ne-text">Page cache</span></code><span class="ne-text"> 的存在，作者认为随机读不是主要问题：随着越来越大的内存，大部分的读操作都能被 cache，因此 LFS 主要要解决的是减少对硬盘的随机写操作。</span></p><p id="1bad16ccaa3347ac4cfab1786828e972" class="ne-p"><br></p><p id="d005e77189b514affc9db35092a8db48" class="ne-p"><span class="ne-text">在这种设计中，inode 甚至具有与 UNIX 中相同的结构，但是现在它们分散在整个日志中，而不是位于磁盘上的固定位置。所以，inode 很定位。为了能够找到 inode ，维护了一个由 inode 索引的 </span><code class="ne-code"><span class="ne-text">inode map(inode 映射)</span></code><span class="ne-text">。表项 i 指向磁盘中的第 i 个 inode 。这个映射保存在磁盘中，但是也保存在缓存中，因此，使用最频繁的部分大部分时间都在内存中。</span></p><p id="a624918a0a3ce7dd4dc1ac14978eae8c" class="ne-p"><br></p><p id="268c06eaa913f22f2d46aba8d7868764" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830360-ead8d1cc-da6e-40bc-896b-4350498bf5c8.png" width="732" id="qxML0" class="ne-image"></p><p id="135f1d10729c89da15b349f4f1a6f674" class="ne-p"><br></p><p id="d3439b4c32b9a597fdf5c3f4980e183c" class="ne-p"><span class="ne-text">到目前为止，所有写入最初都缓存在</span><code class="ne-code"><span class="ne-text">内存</span></code><span class="ne-text">中，并且追加在</span><code class="ne-code"><span class="ne-text">日志末尾</span></code><span class="ne-text">，所有缓存的写入都定期在单个段中写入磁盘。所以，现在打开文件也就意味着用映射定位文件的索引节点。一旦 inode 被定位后，磁盘块的地址就能够被找到。所有这些块本身都将位于日志中某处的分段中。</span></p><p id="4deeb5cc8765dcdcffc2051d29dd889c" class="ne-p"><br></p><p id="1da2cd86f605c95cfd9b33b6424b03a8" class="ne-p"><span class="ne-text">真实情况下的磁盘容量是有限的，所以最终日志会占满整个磁盘空间，这种情况下就会出现没有新的磁盘块被写入到日志中。幸运的是，许多现有段可能具有不再需要的块。例如，如果一个文件被覆盖了，那么它的 inode 将被指向新的块，但是旧的磁盘块仍在先前写入的段中占据着空间。</span></p><p id="f7cc586edf59e28b51595cb2d99969e4" class="ne-p"><br></p><p id="b252ea9c8d9887d0749eca891ee9370a" class="ne-p"><span class="ne-text">为了处理这个问题，LFS 有一个</span><code class="ne-code"><span class="ne-text">清理(clean)</span></code><span class="ne-text">线程，它会循环扫描日志并对日志进行压缩。首先，通过查看日志中第一部分的信息来查看其中存在哪些索引节点和文件。它会检查当前 inode 的映射来查看 inode 否在在当前块中，是否仍在被使用。如果不是，该信息将被丢弃。如果仍然在使用，那么 inode 和块就会进入内存等待写回到下一个段中。然后原来的段被标记为空闲，以便日志可以用来存放新的数据。用这种方法，清理线程遍历日志，从后面移走旧的段，然后将有效的数据放入内存等待写到下一个段中。由此一来整个磁盘会形成一个大的</span><code class="ne-code"><span class="ne-text">环形缓冲区</span></code><span class="ne-text">，写线程将新的段写在前面，而清理线程则清理后面的段。</span></p><p id="d882117f7dd0d9016cd4efa5d88f836b" class="ne-p"><br></p><p id="4cb4c6428aac735024f7bd8e7b3df742" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830348-81e32c04-1184-4cdb-8403-2efeeb68787c.png" width="631" id="A4Ev0" class="ne-image"></p><p id="254c2fb97c081e7566ee59c417621dc6" class="ne-p"><br></p><h3 id="97a9825e"><span class="ne-text">日志文件系统</span></h3><p id="54c993a6b70774346a7e6a74670bd65d" class="ne-p"><br></p><p id="15ef008aa02d98f6108fd2b0045ad8ce" class="ne-p"><span class="ne-text">虽然日志结构系统的设计很优雅，但是由于它们和现有的文件系统不相匹配，因此还没有广泛使用。不过，从日志文件结构系统衍生出来一种新的日志系统，叫做</span><code class="ne-code"><span class="ne-text">日志文件系统</span></code><span class="ne-text">，它会记录系统下一步将要做什么的日志。微软的 </span><code class="ne-code"><span class="ne-text">NTFS</span></code><span class="ne-text"> 文件系统、Linux 的 </span><code class="ne-code"><span class="ne-text">ext3</span></code><span class="ne-text"> 就使用了此日志。 </span><code class="ne-code"><span class="ne-text">OS X</span></code><span class="ne-text"> 将日志系统作为可供选项。为了看清它是如何工作的，我们下面讨论一个例子，比如 </span><code class="ne-code"><span class="ne-text">移除文件</span></code><span class="ne-text"> ，这个操作在 UNIX 中需要三个步骤完成：</span></p><p id="542c202aaf8ebf265f4cb616c83eb215" class="ne-p"><br></p><ul class="ne-ul"><li id="67d6fbc0f368e73ec0ae0cd1ae302ca0"><span class="ne-text">在目录中删除文件</span></li><li id="a89a87cfde0f907da93ba98949232c61"><span class="ne-text">释放 inode 到空闲 inode 池</span></li></ul><ul class="ne-ul"><li id="9d7a41e6c40debc886ece1919154c122"><span class="ne-text">将所有磁盘块归还给空闲磁盘池。</span></li></ul><p id="0373ab5b606fbc4ea64ceb3e16560a81" class="ne-p"><br></p><h3 id="85c5a550"><span class="ne-text">虚拟文件系统</span></h3><p id="290a38b2c6595805459b83e5d9efd348" class="ne-p"><br></p><p id="fa0fd762b6f480ec670bc0caaa659d75" class="ne-p"><span class="ne-text">UNIX 操作系统使用一种 </span><code class="ne-code"><span class="ne-text">虚拟文件系统(Virtual File System, VFS)</span></code><span class="ne-text"> 来尝试将多种文件系统构成一个有序的结构。关键的思想是抽象出所有文件系统都共有的部分，并将这部分代码放在一层，这一层再调用具体文件系统来管理数据。下面是一个 VFS 的系统结构</span></p><p id="adaba32ebb0cc75090b68328c3028b7b" class="ne-p"><br></p><p id="a3c0af3bdad2c2390baf7ba0b99cc521" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830356-635b72b4-bcf2-434f-9719-c83b191da6cf.png" width="675" id="zWieH" class="ne-image"></p><p id="d59ed70f4605a2d10f29fbf5243a3add" class="ne-p"><br></p><p id="db2b2f4f03009dfb83d4c4702f1c8bce" class="ne-p"><span class="ne-text">还是那句经典的话，在计算机世界中，任何解决不了的问题都可以加个</span><code class="ne-code"><span class="ne-text">代理</span></code><span class="ne-text">来解决。所有和文件相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是标准的 </span><code class="ne-code"><span class="ne-text">POSIX 系统调用</span></code><span class="ne-text">，比如 open、read、write 和 seek 等。VFS 对用户进程有一个 </span><code class="ne-code"><span class="ne-text">上层</span></code><span class="ne-text"> 接口，这个接口就是著名的 POSIX 接口。</span></p><p id="b00daf97b264c2c2bbe03d1961ade40f" class="ne-p"><br></p><h2 id="9bc5cc8b"><span class="ne-text">文件系统的管理和优化</span></h2><p id="e52554121a51cb24a7d18cea51ff1273" class="ne-p"><br></p><p id="a457d363aece63ffafdc7a21b8ea5bda" class="ne-p"><span class="ne-text">能够使文件系统工作是一回事，能够使文件系统高效、稳定的工作是另一回事，下面我们就来探讨一下文件系统的管理和优化。</span></p><p id="7427320717087557ca6baac5f2f4e9e6" class="ne-p"><br></p><h3 id="36f7581f"><span class="ne-text">磁盘空间管理</span></h3><p id="2ddbfc7d676fa2fb7e22874efb2691cf" class="ne-p"><br></p><p id="72ecbbb431e26da743b3582748db5218" class="ne-p"><span class="ne-text">文件通常存在磁盘中，所以如何管理磁盘空间是一个操作系统的设计者需要考虑的问题。在文件上进行存有两种策略：</span><strong><span class="ne-text">分配 n 个字节的连续磁盘空间；或者把文件拆分成多个并不一定连续的块</span></strong><span class="ne-text">。在存储管理系统中，主要有</span><code class="ne-code"><span class="ne-text">分段管理</span></code><span class="ne-text">和 </span><code class="ne-code"><span class="ne-text">分页管理</span></code><span class="ne-text"> 两种方式。</span></p><p id="dd7036c30b5429f0012e299634b76e92" class="ne-p"><br></p><p id="67ddc9963643581de7e3a7a9dc7fc649" class="ne-p"><span class="ne-text">正如我们所看到的，按</span><code class="ne-code"><span class="ne-text">连续字节序列</span></code><span class="ne-text">存储文件有一个明显的问题，当文件扩大时，有可能需要在磁盘上移动文件。内存中分段也有同样的问题。不同的是，相对于把文件从磁盘的一个位置移动到另一个位置，内存中段的移动操作要快很多。因此，几乎所有的文件系统都把文件分割成固定大小的块来存储。</span></p><p id="344a106798ca8fae42c7928b5ec1fc77" class="ne-p"><br></p><h4 id="e30f1fa9"><span class="ne-text">块大小</span></h4><p id="38509e646d595c8ff6d9a8436e3eedaf" class="ne-p"><br></p><p id="547a3489e12fa9b51d40fb6441101da0" class="ne-p"><span class="ne-text">一旦把文件分为固定大小的块来存储，就会出现问题，块的大小是多少？按照</span><strong><span class="ne-text">磁盘组织方式，扇区、磁道和柱面显然都可以作为分配单位</span></strong><span class="ne-text">。在分页系统中，分页大小也是主要因素。</span></p><p id="eef07e9a93ba53842388a4f3930178df" class="ne-p"><br></p><p id="db7ed5c40d46b10feac962743c5d08dc" class="ne-p"><span class="ne-text">拥有大的块尺寸意味着每个文件，甚至 1 字节文件，都要占用一个柱面空间，也就是说小文件浪费了大量的磁盘空间。另一方面，小块意味着大部分文件将会跨越多个块，因此需要多次搜索和旋转延迟才能读取它们，从而降低了性能。因此，如果分配的块</span><code class="ne-code"><span class="ne-text">太大</span></code><span class="ne-text">会浪费</span><code class="ne-code"><span class="ne-text">空间</span></code><span class="ne-text">；分配的块</span><code class="ne-code"><span class="ne-text">太小</span></code><span class="ne-text">会浪费</span><code class="ne-code"><span class="ne-text">时间</span></code><span class="ne-text">。</span></p><p id="c2835cdef3fed7ded33775fbb7ca6297" class="ne-p"><br></p><h4 id="295e0480"><span class="ne-text">记录空闲块</span></h4><p id="edd1908809f46d895dc025e523270a52" class="ne-p"><br></p><p id="dd215e9d3aec5bd07fefcbb6ef543dc8" class="ne-p"><span class="ne-text">一旦指定了块大小，下一个问题就是怎样跟踪空闲块。有两种方法被广泛采用，如下图所示</span></p><p id="47accf180646908f7be85a16c3d72875" class="ne-p"><br></p><p id="96bc7041bf4c1a86d46bb5c63cefd992" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830365-86ca166a-5dd1-4e96-b9b4-2966e2d87565.png" width="753" id="CTgLy" class="ne-image"></p><p id="2051479c114a6b22e965758e8797badf" class="ne-p"><br></p><p id="ca2834028031ca00495c9ea1276d53aa" class="ne-p"><span class="ne-text">第一种方法是采用</span><code class="ne-code"><span class="ne-text">磁盘块链表</span></code><span class="ne-text">，链表的每个块中包含极可能多的空闲磁盘块号。对于 1 KB 的块和 32 位的磁盘块号，空闲表中每个块包含有 255 个空闲的块号。考虑 1 TB 的硬盘，拥有大概十亿个磁盘块。为了存储全部地址块号，如果每块可以保存 255 个块号，则需要将近 400 万个块。通常，空闲块用于保存空闲列表，因此存储基本上是空闲的。</span></p><p id="5f10f38fe901cd0eb895dbc49f3e37f0" class="ne-p"><br></p><p id="56b4758c79b155d6ba6436edeba4ba04" class="ne-p"><span class="ne-text">另一种空闲空间管理的技术是</span><code class="ne-code"><span class="ne-text">位图(bitmap)</span></code><span class="ne-text">，n 个块的磁盘需要 n 位位图。在位图中，空闲块用 1 表示，已分配的块用 0 表示。对于 1 TB 硬盘的例子，需要 10 亿位表示，即需要大约 130 000 个 1 KB 块存储。很明显，和 32 位链表模型相比，位图需要的空间更少，因为每个块使用 1 位。只有当磁盘快满的时候，链表需要的块才会比位图少。</span></p><p id="7e0bf942bbab56b06289c8725066eb20" class="ne-p"><br></p><h3 id="4facddb8"><span class="ne-text">磁盘配额</span></h3><p id="032a35f5bc36753dde6f1497ca87082d" class="ne-p"><br></p><p id="215d7a97d62c80293c9847906f762497" class="ne-p"><span class="ne-text">为了防止一些用户占用太多的磁盘空间，多用户操作通常提供一种</span><code class="ne-code"><span class="ne-text">磁盘配额(enforcing disk quotas)</span></code><span class="ne-text">的机制。系统管理员为每个用户分配</span><strong><span class="ne-text">最大的文件和块分配</span></strong><span class="ne-text">，并且操作系统确保用户不会超过其配额。我们下面会谈到这一机制。</span></p><p id="2ee4b6ff9b5bf884af9208e43d278aa6" class="ne-p"><br></p><p id="c20140937b0c58800dec7ed9cd67e95b" class="ne-p"><span class="ne-text">在用户打开一个文件时，操作系统会找到</span><code class="ne-code"><span class="ne-text">文件属性</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">磁盘地址</span></code><span class="ne-text">，并把它们送入内存中的打开文件表。其中一个属性告诉</span><code class="ne-code"><span class="ne-text">文件所有者</span></code><span class="ne-text">是谁。任何有关文件的增加都会记到所有者的配额中。</span></p><p id="b1cacad06963157173172584f9db8096" class="ne-p"><br></p><p id="3c665c8af9fb07bcf153caa4b682fe95" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830397-dc14e657-f7ce-4c0e-a2fc-dae37cdce37e.png" width="681" id="Oo3ow" class="ne-image"></p><p id="c7a9e9f8b0a5997c4e2a3e6dbc31775a" class="ne-p"><br></p><p id="43b46d497e9c436b2f556aa5c66e2c43" class="ne-p"><span class="ne-text"> 配额表中记录了每个用户的配额</span></p><p id="0f9f915845b742eeb1c89f50a592a657" class="ne-p"><br></p><p id="c5a0b6749f84d9c09a768bf537638a09" class="ne-p"><span class="ne-text">第二张表包含了每个用户当前打开文件的配额记录，即使是其他人打开该文件也一样。如上图所示，该表的内容是从被打开文件的所有者的磁盘配额文件中提取出来的。当所有文件关闭时，该记录被写回配额文件。</span></p><p id="1ee6d826e9a005489809f6cdbc1f74fd" class="ne-p"><br></p><p id="9e3b6aa356a538a1f623df8fbfee0caf" class="ne-p"><span class="ne-text">当在打开文件表中建立一新表项时，会产生一个指向所有者配额记录的指针。每次向文件中添加一个块时，文件所有者所用数据块的总数也随之增加，并会同时增加</span><code class="ne-code"><span class="ne-text">硬限制</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">软限制</span></code><span class="ne-text">的检查。可以超出软限制，但硬限制不可以超出。当已达到硬限制时，再往文件中添加内容将引发错误。同样，对文件数目也存在类似的检查。</span></p><p id="9dfa42d3b8bda31015aff60e6402447b" class="ne-p"><br></p><h3 id="448f0b53"><span class="ne-text">文件系统备份</span></h3><p id="ffdfb3c549d5e57f21be4e05a1a2db62" class="ne-p"><br></p><p id="113ba2fa14d2438cead2475b7b39a27e" class="ne-p"><span class="ne-text">做文件备份很耗费时间而且也很浪费空间，这会引起下面几个问题。首先，是要</span><strong><span class="ne-text">备份整个文件还是仅备份一部分呢</span></strong><span class="ne-text">？一般来说，只是备份特定目录及其下的全部文件，而不是备份整个文件系统。</span></p><p id="46fadd39621ab910d498dbceb75c70a5" class="ne-p"><br></p><p id="aa6bac235f93e3c65c678e094392adca" class="ne-p"><span class="ne-text">其次，对上次未修改过的文件再进行备份是一种浪费，因而产生了一种</span><code class="ne-code"><span class="ne-text">增量转储(incremental dumps)</span></code><span class="ne-text"> 的思想。最简单的增量转储的形式就是</span><code class="ne-code"><span class="ne-text">周期性</span></code><span class="ne-text">的做全面的备份，而每天只对增量转储完成后发生变化的文件做单个备份。</span></p><p id="bd26f462660acfa584c45424f992c0d3" class="ne-p"><br></p><p id="d7a48a9530c54662113424a7892a7643" class="ne-p"><span class="ne-text">稍微好一点的方式是只备份最近一次转储以来更改过的文件。当然，这种做法极大的缩减了转储时间，但恢复起来却更复杂，因为</span><strong><span class="ne-text">最近的全面转储先要全部恢复，随后按逆序进行增量转储</span></strong><span class="ne-text">。为了方便恢复，人们往往使用更复杂的转储模式。</span></p><p id="51edae20809214a4ee16554d2b0d6c6e" class="ne-p"><br></p><p id="fc00c1f85af8e54127292c60f1ce58f2" class="ne-p"><span class="ne-text">第三，既然待转储的往往是海量数据，那么在将其写入磁带之前对文件进行压缩就很有必要。但是，如果在备份过程中出现了文件损坏的情况，就会导致破坏压缩算法，从而使整个磁带无法读取。所以在备份前是否进行文件压缩需慎重考虑。</span></p><p id="48064cf8ac09f37c3e9fb90da4bd86f6" class="ne-p"><br></p><p id="eae33460e594d4ace436ad41cdee09bb" class="ne-p"><span class="ne-text">第四，对正在使用的文件系统做备份是很难的。如果在转储过程中要添加，删除和修改文件和目录，则转储结果可能不一致。因此，因为转储过程中需要花费数个小时的时间，所以有必要在晚上将系统脱机进行备份，然而这种方式的接受程度并不高。所以，人们修改了转储算法，记下文件系统的</span><code class="ne-code"><span class="ne-text">瞬时快照</span></code><span class="ne-text">，即复制关键的数据结构，然后需要把将来对文件和目录所做的修改复制到块中，而不是到处更新他们。</span></p><p id="30c5145da5c3daf19f6a6c121ac3cd34" class="ne-p"><br></p><p id="b0fcc685273d71a66e54ea23168256e7" class="ne-p"><span class="ne-text">磁盘转储到备份磁盘上有两种方案：</span><strong><span class="ne-text">物理转储和逻辑转储</span></strong><span class="ne-text">。</span><code class="ne-code"><span class="ne-text">物理转储(physical dump)</span></code><span class="ne-text"> 是从磁盘的 0 块开始，依次将所有磁盘块按照顺序写入到输出磁盘，并在复制最后一个磁盘时停止。这种程序的万无一失性是其他程序所不具备的。</span></p><p id="16f52d5c94af08b8399b7f00fde02baf" class="ne-p"><br></p><p id="a4280007245d6cde87091ae5723b514f" class="ne-p"><span class="ne-text">第二个需要考虑的是</span><strong><span class="ne-text">坏块的转储</span></strong><span class="ne-text">。制造大型磁盘而没有瑕疵是不可能的，所以也会存在一些</span><code class="ne-code"><span class="ne-text">坏块(bad blocks)</span></code><span class="ne-text">。有时进行低级格式化后，坏块会被检测出来并进行标记，这种情况的解决办法是用磁盘末尾的一些空闲块所替换。</span></p><p id="d3a520d2dc75e3c048f1f7be7a3b1521" class="ne-p"><br></p><p id="9e3a9f3c7ea68c671fba5541ec778315" class="ne-p"><span class="ne-text">然而，一些块在格式化后会变坏，在这种情况下操作系统可以检测到它们。通常情况下，它可以通过创建一个由所有坏块组成的</span><code class="ne-code"><span class="ne-text">文件</span></code><span class="ne-text">来解决问题，确保它们不会出现在空闲池中并且永远不会被分配。</span><strong><span class="ne-text">那么此文件是完全不可读的</span></strong><span class="ne-text">。如果磁盘控制器将所有的坏块重新映射，物理转储还是能够正常工作的。</span></p><p id="079669c0c544c835fd273273a33afdd7" class="ne-p"><br></p><p id="f5aa458d6a0327dcf235ab0f937d1e5b" class="ne-p"><span class="ne-text">Windows 系统有</span><code class="ne-code"><span class="ne-text">分页文件(paging files)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">休眠文件(hibernation files)</span></code><span class="ne-text"> 。它们在文件还原时不发挥作用，同时也不应该在第一时间进行备份。</span></p><p id="7cec7ef194f71a4845069c7b2467ba86" class="ne-p"><br></p><h3 id="7bf7e71c"><span class="ne-text">文件系统的一致性</span></h3><p id="82c29f8de3c1d8f9d3e3a242854aea5a" class="ne-p"><br></p><p id="95f468ed0b314583e7bb1b5d96463a0d" class="ne-p"><span class="ne-text">影响可靠性的一个因素是文件系统的一致性。许多文件系统读取磁盘块、修改磁盘块、再把它们写回磁盘。如果系统在所有块写入之前崩溃，文件系统就会处于一种</span><code class="ne-code"><span class="ne-text">不一致(inconsistent)</span></code><span class="ne-text">的状态。如果某些尚未写回的块是索引节点块，目录块或包含空闲列表的块，则此问题是很严重的。</span></p><p id="aa1b70a4eed4630530233add037539f3" class="ne-p"><br></p><p id="964d4c4e15c95803c23efa7ae10be9e2" class="ne-p"><span class="ne-text">为了处理文件系统一致性问题，大部分计算机都会有应用程序来检查文件系统的一致性。例如，UNIX 有 </span><code class="ne-code"><span class="ne-text">fsck</span></code><span class="ne-text">；Windows 有 </span><code class="ne-code"><span class="ne-text">sfc</span></code><span class="ne-text">，每当引导系统时（尤其是在崩溃后），都可以运行该程序。</span></p><p id="48ab85b18d500f6f09aae6694c153193" class="ne-p"><br></p><p id="f69a8abc58586e91d81d5e78464cf3d0" class="ne-p"><span class="ne-text">可以进行两种一致性检查：</span><strong><span class="ne-text">块的一致性检查和文件的一致性检查</span></strong><span class="ne-text">。为了检查块的一致性，应用程序会建立两张表，每个包含一个计数器的块，最初设置为 0 。第一个表中的计数器跟踪该块在文件中出现的次数，第二张表中的计数器记录每个块在空闲列表、空闲位图中出现的频率。</span></p><p id="6aef6c93e388526281d0ccfabc109e56" class="ne-p"><br></p><h3 id="1813df07"><span class="ne-text">文件系统性能</span></h3><p id="d3fb5bbd9e1d7c87c8abc3f98dad08fa" class="ne-p"><br></p><p id="1b317a6725a77f944c82f795f51802c4" class="ne-p"><span class="ne-text">访问磁盘的效率要比内存满的多，是时候又祭出这张图了</span></p><p id="e65e5e0ed7603e2c50058d08807f17fe" class="ne-p"><br></p><p id="1a1e743c356c1915686f30c85dd8837e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830422-af95403a-f195-4d9e-8125-0d05ec7651ff.png" width="711" id="oMNVY" class="ne-image"></p><p id="b50a79ed6fb74211ac37fdda653d5b8f" class="ne-p"><br></p><p id="859c470037440cdd28efa0d26f3ef0a6" class="ne-p"><span class="ne-text">从内存读一个 32 位字大概是 10ns，从硬盘上读的速率大概是 100MB/S，对每个 32 位字来说，效率会慢了四倍，另外，还要加上 5 - 10 ms 的寻道时间等其他损耗，如果只访问一个字，内存要比磁盘快百万数量级。所以磁盘优化是很有必要的，下面我们会讨论几种优化方式</span></p><p id="f08d65d53f1351340cdb0ecf65f4e735" class="ne-p"><br></p><h4 id="cdde49bb"><span class="ne-text">高速缓存</span></h4><p id="a88faf1cb721a77ececf2015cf53efa9" class="ne-p"><br></p><p id="7c675dc314d14c2ae799ed6640c9d2e9" class="ne-p"><span class="ne-text">最常用的减少磁盘访问次数的技术是使用 </span><code class="ne-code"><span class="ne-text">块高速缓存(block cache)</span></code><span class="ne-text"> 或者 </span><code class="ne-code"><span class="ne-text">缓冲区高速缓存(buffer cache)</span></code><span class="ne-text">。高速缓存指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。</span></p><p id="b17a6714b13a17563901344d07462477" class="ne-p"><br></p><p id="dc154ad0b420fd4f3673118cc516d2e6" class="ne-p"><span class="ne-text">管理高速缓存有不同的算法，常用的算法是：检查全部的读请求，查看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无须访问磁盘。如果检查块不再高速缓存中，那么首先把它读入高速缓存，再复制到所需的地方。之后，对同一个块的请求都通过</span><code class="ne-code"><span class="ne-text">高速缓存</span></code><span class="ne-text">来完成。</span></p><p id="c25b8162bb8c3e4f67a87ba9bac5a070" class="ne-p"><br></p><p id="6c386979476c9d66e19b2d612c66328f" class="ne-p"><span class="ne-text">高速缓存的操作如下图所示</span></p><p id="3d3a4d92696219f66d8742c69e570752" class="ne-p"><br></p><p id="24044650b0ba67c609c1fd504c6288be" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830486-9b7cd7d5-cd58-485e-8fb9-7c5f918fb69a.png" width="733" id="w4gdw" class="ne-image"></p><p id="e9c3294259bbd6241a38558088b3ebd6" class="ne-p"><br></p><p id="6eca2ec60272b982b11ff45c7220cf1c" class="ne-p"><span class="ne-text">由于在高速缓存中有许多块，所以需要某种方法快速确定所需的块是否存在。常用方法是将设备和磁盘地址进行散列操作，然后，在散列表中查找结果。具有相同散列值的块在一个链表中连接在一起（这个数据结构是不是很像 HashMap?），这样就可以沿着冲突链查找其他块。</span></p><p id="d484a308c97ec7ef8cadad561dd451b0" class="ne-p"><br></p><p id="de071a26c813ef0d71da3b2b2adce651" class="ne-p"><span class="ne-text">如果高速缓存</span><code class="ne-code"><span class="ne-text">已满</span></code><span class="ne-text">，此时需要调入新的块，则要把原来的某一块调出高速缓存，如果要调出的块在上次调入后已经被修改过，则需要把它写回磁盘。</span></p><p id="d2cb85bba04c34338b74daba699247a5" class="ne-p"><br></p><h4 id="66d87443"><span class="ne-text">块提前读</span></h4><p id="30c57914a283b1c14a9a70972a449fdc" class="ne-p"><br></p><p id="deeccda0a50582f53cf9c6007fc28d76" class="ne-p"><span class="ne-text">第二个明显提高文件系统的性能是，在需要用到块之前，试图</span><code class="ne-code"><span class="ne-text">提前</span></code><span class="ne-text">将其写入高速缓存，从而</span><code class="ne-code"><span class="ne-text">提高命中率</span></code><span class="ne-text">。许多文件都是顺序读取。如果请求文件系统在某个文件中生成块 k，文件系统执行相关操作并且在完成之后，会检查高速缓存，以便确定块 k + 1 是否已经在高速缓存。如果不在，文件系统会为 k + 1 安排一个预读取，因为文件希望在用到该块的时候能够直接从高速缓存中读取。</span></p><p id="8a69c495fe7bb783b79dbf75485864bc" class="ne-p"><br></p><p id="808c596082fdff6eaae697cd580903a8" class="ne-p"><span class="ne-text">当然，块提前读取策略只适用于实际顺序读取的文件。对随机访问的文件，提前读丝毫不起作用。甚至还会造成阻碍。</span></p><p id="5b78528d1ba45c2104816c3e8e709aff" class="ne-p"><br></p><h4 id="aa9dd989"><span class="ne-text">减少磁盘臂运动</span></h4><p id="d09f4491931761a8ce0444d664eebb7a" class="ne-p"><br></p><p id="fb7b8c5c382a9dee9c90ffe1a4934f58" class="ne-p"><span class="ne-text">高速缓存和块提前读并不是提高文件系统性能的唯一方法。另一种重要的技术是</span><strong><span class="ne-text">把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数</span></strong><span class="ne-text">。当写一个输出文件时，文件系统就必须按照要求一次一次地分配磁盘块。如果用位图来记录空闲块，并且整个位图在内存中，那么选择与前一块最近的空闲块是很容易的。如果用空闲表，并且链表的一部分存在磁盘上，要分配紧邻的空闲块就会困难很多。</span></p><p id="fb9ea860feeaa3264df8728b7749755f" class="ne-p"><br></p><h4 id="67e3ff13"><span class="ne-text">磁盘碎片整理</span></h4><p id="ba79cd85e1dad3bed9f2216b2b7253b1" class="ne-p"><br></p><p id="41c56da85159758040baae19181247c8" class="ne-p"><span class="ne-text">在初始安装操作系统后，文件就会被不断的创建和清除，于是磁盘会产生很多的碎片，在创建一个文件时，它使用的块会散布在整个磁盘上，降低性能。删除文件后，回收磁盘块，可能会造成空穴。</span></p><p id="b1d265b54391b9395004a22d89f3381d" class="ne-p"><br></p><p id="408e532833df6ecd00374e3714b691a6" class="ne-p"><span class="ne-text">磁盘性能可以通过如下方式恢复：移动文件使它们相互挨着，并把所有的至少是大部分的空闲空间放在一个或多个大的连续区域内。Windows 有一个程序 </span><code class="ne-code"><span class="ne-text">defrag</span></code><span class="ne-text"> 就是做这个事儿的。Windows 用户会经常使用它，SSD 除外。</span></p><p id="2b171a55d46f2e7b316bfa4dca7e1d30" class="ne-p"><br></p><p id="0a13d2e5ecaea758dd489d8b3f708327" class="ne-p"><span class="ne-text">磁盘碎片整理程序会在让文件系统上很好地运行。Linux 文件系统（特别是 ext2 和 ext3）由于其选择磁盘块的方式，在磁盘碎片整理上一般不会像 Windows 一样困难，因此很少需要手动的磁盘碎片整理。而且，固态硬盘并不受磁盘碎片的影响，事实上，在固态硬盘上做磁盘碎片整理反倒是多此一举，不仅没有提高性能，反而磨损了固态硬盘。所以碎片整理只会缩短固态硬盘的寿命。</span></p><p id="e7ebcf76e9e7e212ad0bcdf32a78971d" class="ne-p"><br></p><p id="89ca27714a847f6e1742fe7c23d34046" class="ne-p"><span class="ne-text">下面我们来探讨一下 I/O 流程问题。</span></p><p id="1cef0573f6ef4eb8042d81ad743c2c6e" class="ne-p"><br></p><p id="55fa1a1e6692073f30600efec9761a8f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830481-2693434c-6334-4f5a-a152-75454e91d275.png" width="752" id="Nh8lv" class="ne-image"></p><p id="dab506072acfbe1a65ea20b5d8f20187" class="ne-p"><br></p><h2 id="ccf866bd"><span class="ne-text">I/O 设备</span></h2><p id="fef21a68cfbbf3d40c8c42db7160f3fc" class="ne-p"><br></p><p id="a11a667a8e08d786f9df34bbf650bf3d" class="ne-p"><span class="ne-text">什么是 I/O 设备？I/O 设备又叫做输入/输出设备，它是人类用来和计算机进行通信的外部硬件。输入/输出设备能够向计算机</span><code class="ne-code"><span class="ne-text">发送数据（输出）</span></code><span class="ne-text">并从计算机</span><code class="ne-code"><span class="ne-text">接收数据（输入）</span></code><span class="ne-text">。</span></p><p id="c552565b432c8f2328937d605d16b55f" class="ne-p"><br></p><p id="36a413dde5afb50347686b041abb2194" class="ne-p"><code class="ne-code"><span class="ne-text">I/O 设备(I/O devices)</span></code><span class="ne-text">可以分成两种：</span><code class="ne-code"><span class="ne-text">块设备(block devices)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">字符设备(character devices)</span></code><span class="ne-text">。</span></p><p id="041f671ef3cc121c9abd0eb87bea40ce" class="ne-p"><br></p><h4 id="b0737d59"><span class="ne-text">块设备</span></h4><p id="85b0d1db3e51529ae28eb21531dbabc9" class="ne-p"><br></p><p id="6791ea347b3b675b23d8b71834de784d" class="ne-p"><span class="ne-text">块设备是一个能存储</span><code class="ne-code"><span class="ne-text">固定大小块</span></code><span class="ne-text">信息的设备，它支持</span><strong><span class="ne-text">以固定大小的块，扇区或群集读取和（可选）写入数据</span></strong><span class="ne-text">。每个块都有自己的</span><code class="ne-code"><span class="ne-text">物理地址</span></code><span class="ne-text">。通常块的大小在 512 - 65536 之间。所有传输的信息都会以</span><code class="ne-code"><span class="ne-text">连续</span></code><span class="ne-text">的块为单位。块设备的基本特征是每个块都较为对立，能够独立的进行读写。常见的块设备有 </span><strong><span class="ne-text">硬盘、蓝光光盘、USB 盘</span></strong></p><p id="b52171cdae8af1f376f27c40ad67ac26" class="ne-p"><br></p><p id="cf77f280837dfa3d5315eadc8011a27d" class="ne-p"><span class="ne-text">与字符设备相比，块设备通常需要较少的引脚。</span></p><p id="7ecf223db6465ee23234ff197ee6a09c" class="ne-p"><br></p><p id="7acf3702619a1520d671342f2aa55ce2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830476-de4c28f8-7881-487b-9bc3-11bf81770f23.png" width="700" id="pm6J2" class="ne-image"></p><p id="0e9ec415e4a41b3d94d858c66fadaad5" class="ne-p"><br></p><h4 id="4946a116"><span class="ne-text">块设备的缺点</span></h4><p id="f6b824a5b70558096a86b0e599ace532" class="ne-p"><br></p><p id="7e18a2c7272bc8e4a6f3a6ab2944d1e1" class="ne-p"><span class="ne-text">基于给定固态存储器的块设备比基于相同类型的存储器的字节寻址要慢一些，因为必须在块的开头开始读取或写入。所以，要读取该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃。要写入块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备。</span></p><p id="b56f0082d6f7228e3d6e2ccca060af64" class="ne-p"><br></p><h4 id="d4ea5237"><span class="ne-text">字符设备</span></h4><p id="029c7023153fa023483fe82decdea68f" class="ne-p"><br></p><p id="43cd71445d951e98def6564f4fb90e2f" class="ne-p"><span class="ne-text">另一类 I/O 设备是</span><code class="ne-code"><span class="ne-text">字符设备</span></code><span class="ne-text">。字符设备以</span><code class="ne-code"><span class="ne-text">字符</span></code><span class="ne-text">为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。常见的字符设备有 </span><strong><span class="ne-text">打印机、网络设备、鼠标、以及大多数与磁盘不同的设备</span></strong><span class="ne-text">。</span></p><p id="28e05ffc9309d60a2e6a8be0504cb2b6" class="ne-p"><br></p><p id="1613d0fe5c97aa26e6cc98547e4b3f5e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830510-e704b09f-ae66-45ce-bde4-66fd175dc769.png" width="703" id="ZC93B" class="ne-image"></p><p id="45829f5e3fd12814f44a925a42257add" class="ne-p"><br></p><h3 id="9881f730"><span class="ne-text">设备控制器</span></h3><p id="42cfb8373d43692de4cab682355d0267" class="ne-p"><br></p><p id="01c9dcd39c0617edea3fe8743f8387e7" class="ne-p"><span class="ne-text">设备控制器是处理 CPU 传入和传出信号的系统。设备通过插头和插座连接到计算机，并且插座连接到设备控制器。设备控制器从连接的设备处接收数据，并将其存储在控制器内部的一些</span><code class="ne-code"><span class="ne-text">特殊目的寄存器(special purpose registers)</span></code><span class="ne-text"> 也就是本地缓冲区中。</span></p><p id="e8d0510ece8b2837f0fe7c0812240fab" class="ne-p"><br></p><p id="c5350ce1c360c31d9f02ded8ad634464" class="ne-p"><span class="ne-text">每个设备控制器都会有一个应用程序与之对应，设备控制器通过应用程序的接口通过中断与操作系统进行通信。设备控制器是硬件，而设备驱动程序是软件。</span></p><p id="ee7e18cfd23f391533dba522b7fb2d17" class="ne-p"><br></p><h3 id="2b21e7c0"><span class="ne-text">内存映射 I/O</span></h3><p id="478fcce32a2fb12395f5979c573146eb" class="ne-p"><br></p><p id="de6bab2e6473dcb8f55d739b5d01be84" class="ne-p"><span class="ne-text">每个控制器都会有几个寄存器用来和 CPU 进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据，接收数据、开启或者关闭设备等。通过从这些寄存器中读取信息，操作系统能够知道设备的状态，是否准备接受一个新命令等。</span></p><p id="49d135f8526a65aa9126b14668ee49ed" class="ne-p"><br></p><p id="8c5d7f345d34f8b2c41baab490473318" class="ne-p"><span class="ne-text">为了控制</span><code class="ne-code"><span class="ne-text">寄存器</span></code><span class="ne-text">，许多设备都会有</span><code class="ne-code"><span class="ne-text">数据缓冲区(data buffer)</span></code><span class="ne-text">，来供系统进行读写。</span></p><p id="a5a4118b957e027328e237a6e1a992f3" class="ne-p"><br></p><p id="b2afa8b116e5e0ca2d07bb3a17bd3fa2" class="ne-p"><span class="ne-text">那么问题来了，CPU 如何与设备寄存器和设备数据缓冲区进行通信呢？存在两个可选的方式。第一种方法是，每个控制寄存器都被分配一个 </span><code class="ne-code"><span class="ne-text">I/O 端口(I/O port)</span></code><span class="ne-text">号，这是一个 8 位或 16 位的整数。所有 I/O 端口的集合形成了受保护的 I/O 端口空间，以便普通用户程序无法访问它（只有操作系统可以访问）。使用特殊的 I/O 指令像是</span></p><p id="765a4ca508a5115b78ed2925e14838d8" class="ne-p"><br></p><pre data-language="assembly" id="3877d554" class="ne-codeblock language-assembly">IN REG,PORT</pre><p id="d488b29580542c9583338320551ab3c6" class="ne-p"><br></p><p id="08ce542e0db8dcd660e9764cb17b670f" class="ne-p"><span class="ne-text">CPU 可以读取控制寄存器 PORT 的内容并将结果放在 CPU 寄存器 REG 中。类似的，使用</span></p><p id="862fabda27bff31f4481f0fbb1841f04" class="ne-p"><br></p><pre data-language="assembly" id="41a56928" class="ne-codeblock language-assembly">OUT PORT,REG</pre><p id="2af22811e69fd5e8ed8a16f28179a129" class="ne-p"><br></p><p id="bded26b72586207ef1db5725a5279922" class="ne-p"><span class="ne-text">CPU 可以将 REG 的内容写到控制寄存器中。大多数早期计算机，包括几乎所有大型主机，如 IBM 360 及其所有后续机型，都是以这种方式工作的。</span></p><p id="726bebd6ef6b472edc3181572bdfa656" class="ne-p"><br></p><p id="473bae0048dd7032999f2251d5a662b7" class="ne-p"><span class="ne-text">第二个方法是 PDP-11 引入的，它将</span><strong><span class="ne-text">所有控制寄存器映射到内存空间</span></strong><span class="ne-text">中。</span></p><p id="55f1ecf17cdddd5693acbda0af158993" class="ne-p"><br></p><h3 id="71380d9f"><span class="ne-text">直接内存访问</span></h3><p id="1cec9d2a2b4a37680ebefd6565e21175" class="ne-p"><br></p><p id="ce6e80a93dc12dcb9aa9d664ffadc5fa" class="ne-p"><span class="ne-text">无论一个 CPU 是否具有内存映射 I/O，它都需要寻址设备控制器以便与它们交换数据。CPU 可以从 I/O 控制器每次请求一个字节的数据，但是这么做会浪费 CPU 时间，所以经常会用到一种称为</span><code class="ne-code"><span class="ne-text">直接内存访问(Direct Memory Access)</span></code><span class="ne-text"> 的方案。为了简化，我们假设 CPU 通过单一的系统总线访问所有的设备和内存，该总线连接 CPU 、内存和 I/O 设备，如下图所示</span></p><p id="009027f46496d3f8f2bcb165a348c8df" class="ne-p"><br></p><p id="85b72b01debce0ace6ba07e6e9e6c0aa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830508-9d21c036-35f6-4f66-a119-b33cd2ebffa9.png" width="720" id="s3oNe" class="ne-image"></p><p id="fff67c6d75a8f701088870489a68703b" class="ne-p"><br></p><p id="b6f73292094a29c64c123bc26d8c3f35" class="ne-p"><span class="ne-text"> DMA 传送操作</span></p><p id="2e9984b3603d69feb8670dc2a1da4da7" class="ne-p"><br></p><p id="fa3070dc88798a6ad84f66d79849c409" class="ne-p"><span class="ne-text">现代操作系统实际更为复杂，但是原理是相同的。如果硬件有 </span><code class="ne-code"><span class="ne-text">DMA 控制器</span></code><span class="ne-text">，那么操作系统只能使用 DMA。有时这个控制器会集成到磁盘控制器和其他控制器中，但这种设计需要在每个设备上都装有一个分离的 DMA 控制器。单个的 DMA 控制器可用于向多个设备传输，这种传输往往同时进行。</span></p><p id="9872ff0e8287271e0167ad5fe4904890" class="ne-p"><br></p><h4 id="fb19257e"><span class="ne-text">DMA 工作原理</span></h4><p id="a03e5cbf85c29f2523e00aebff3be168" class="ne-p"><br></p><p id="83ad54a6486153ef6c842a3d2356ce33" class="ne-p"><span class="ne-text">首先 CPU 通过设置 DMA 控制器的寄存器对它进行编程，所以 DMA 控制器知道将什么数据传送到什么地方。DMA 控制器还要向磁盘控制器发出一个命令，通知它从磁盘读数据到其内部的缓冲区并检验校验和。当有效数据位于磁盘控制器的缓冲区中时，DMA 就可以开始了。</span></p><p id="988a05fc57bbc139ee60ade19db59775" class="ne-p"><br></p><p id="a747f027f15ed77d2cb1885a1e205177" class="ne-p"><span class="ne-text">DMA 控制器通过在总线上发出一个</span><code class="ne-code"><span class="ne-text">读请求</span></code><span class="ne-text">到磁盘控制器而发起 DMA 传送，这是第二步。这个读请求就像其他读请求一样，磁盘控制器并不知道或者并不关心它是来自 CPU 还是来自 DMA 控制器。通常情况下，要写的内存地址在总线的地址线上，所以当磁盘控制器去匹配下一个字时，它知道将该字写到什么地方。写到内存就是另外一个总线循环了，这是第三步。当写操作完成时，磁盘控制器在总线上发出一个应答信号到 DMA 控制器，这是第四步。</span></p><p id="07fa0e231d1e259cf61d47eec043f097" class="ne-p"><br></p><p id="5db6af288a1595b279c38f3dfc63fbe9" class="ne-p"><span class="ne-text">然后，DMA 控制器会增加内存地址并减少字节数量。如果字节数量仍然大于 0 ，就会循环步骤 2 - 步骤 4 ，直到字节计数变为 0 。此时，DMA 控制器会打断 CPU 并告诉它传输已经完成了。</span></p><p id="9e6195abe1061d23e1d4d22ae3d6afa8" class="ne-p"><br></p><h3 id="88738ca6"><span class="ne-text">重温中断</span></h3><p id="7c3f61ac5e50355d43deec6eb171c4b3" class="ne-p"><br></p><p id="48c3b8a5650e6a887fa2b72a2b529060" class="ne-p"><span class="ne-text">在一台个人计算机体系结构中，中断结构会如下所示</span></p><p id="95bd47e829d0671f561d6b370de02cea" class="ne-p"><br></p><p id="5dd6ab905cdc97ae2993d6f60bcc7ead" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830529-8f149c71-9817-4096-a8df-b613c0308a0c.png" width="719" id="iOWO2" class="ne-image"></p><p id="10d79c44f0beaa13fc3f7bbeb5749849" class="ne-p"><br></p><p id="601484c465041f9864201581aa71a5bd" class="ne-p"><span class="ne-text"> 中断是怎样发生的</span></p><p id="7c3e2170d94eae6e8bb1e7ed99cf48eb" class="ne-p"><br></p><p id="de5270978abbc6bac17d8b32c4827722" class="ne-p"><span class="ne-text">当一个 I/O 设备完成它的工作后，它就会产生一个中断（默认操作系统已经开启中断），它通过在总线上声明已分配的信号来实现此目的。主板上的中断控制器芯片会检测到这个信号，然后执行中断操作。</span></p><p id="d54426721eeb0af5700de3ec951f31f3" class="ne-p"><br></p><h4 id="a032d055"><span class="ne-text">精确中断和不精确中断</span></h4><p id="0373af03e43a5a5ef1859377c0c633d9" class="ne-p"><br></p><p id="91b406cc3a3758fb324eb8607af4e8f2" class="ne-p"><span class="ne-text">使机器处于良好状态的中断称为</span><code class="ne-code"><span class="ne-text">精确中断(precise interrupt)</span></code><span class="ne-text">。这样的中断具有四个属性：</span></p><p id="48b23acc0c3fe244343225c69bafd081" class="ne-p"><br></p><ul class="ne-ul"><li id="8fd4c3bc25c5fe2966bbd8a70be45152"><span class="ne-text">PC （程序计数器）保存在一个已知的地方</span></li><li id="9e17123cbba8fae7fe1a9991e2dd410d"><span class="ne-text">PC 所指向的指令之前所有的指令已经完全执行</span></li></ul><ul class="ne-ul"><li id="340dcd019fc2ddbb3832064d9c975248"><span class="ne-text">PC 所指向的指令之后所有的指令都没有执行</span></li><li id="65e37ac7f0148917395ea4dde0172c57"><span class="ne-text">PC 所指向的指令的执行状态是已知的</span></li></ul><p id="e4c96ab14cd240a871b7845132f1d548" class="ne-p"><br></p><p id="660407a271fb6d3cfc3717ddc6ee834d" class="ne-p"><span class="ne-text">不满足以上要求的中断称为 </span><code class="ne-code"><span class="ne-text">不精确中断(imprecise interrupt)</span></code><span class="ne-text">，不精确中断让人很头疼。上图描述了不精确中断的现象。指令的执行时序和完成度具有不确定性，而且恢复起来也非常麻烦。</span></p><p id="e3e336a043b7c00394ea46bfc5cfd46c" class="ne-p"><br></p><h2 id="bd465b75"><span class="ne-text">IO 软件原理</span></h2><p id="9805805a9a255a10c1f4cb4e0d0c05a7" class="ne-p"><br></p><h3 id="4d234768"><span class="ne-text">I/O 软件目标</span></h3><p id="f96764b4ab266d91c2222e0ddc8d698e" class="ne-p"><br></p><h4 id="e0ddd7b0"><span class="ne-text">设备独立性</span></h4><p id="fb7a0820cadbc5c77f90763e0c7b7ee1" class="ne-p"><br></p><p id="cae2b2b1223c280ab808cd070ae929d4" class="ne-p"><span class="ne-text">I/O 软件设计一个很重要的目标就是</span><code class="ne-code"><span class="ne-text">设备独立性(device independence)</span></code><span class="ne-text">。这意味着</span><strong><span class="ne-text">我们能够编写访问任何设备的应用程序，而不用事先指定特定的设备</span></strong><span class="ne-text">。</span></p><p id="d82bc7d1671e4c56ae19ad479cb3d7f2" class="ne-p"><br></p><p id="1d54ad5122b27da8853c8b013cd174a5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830529-e4825574-4e1c-43fa-adf0-519f0ea1c7f7.png" width="500" id="GdxNy" class="ne-image"></p><p id="f68ad4f4e9d3b73f17102d65ba3e55e8" class="ne-p"><br></p><h4 id="6a8bef7b"><span class="ne-text">错误处理</span></h4><p id="d1f2e4f1a31eed63e226fd56b6613183" class="ne-p"><br></p><p id="a7884712cfe85b529bebc4d2be5e0cf4" class="ne-p"><span class="ne-text">除了</span><code class="ne-code"><span class="ne-text">设备独立性</span></code><span class="ne-text">外，I/O 软件实现的第二个重要的目标就是</span><code class="ne-code"><span class="ne-text">错误处理(error handling)</span></code><span class="ne-text">。通常情况下来说，错误应该交给</span><code class="ne-code"><span class="ne-text">硬件</span></code><span class="ne-text">层面去处理。如果设备控制器发现了读错误的话，它会尽可能的去修复这个错误。如果设备控制器处理不了这个问题，那么设备驱动程序应该进行处理，设备驱动程序会再次尝试读取操作，很多错误都是偶然性的，如果设备驱动程序无法处理这个错误，才会把错误向上抛到硬件层面（上层）进行处理，很多时候，上层并不需要知道下层是如何解决错误的。</span></p><p id="9e170e1f0fd449f4dd2137e7394a5814" class="ne-p"><br></p><h4 id="11e7c14a"><span class="ne-text">同步和异步传输</span></h4><p id="53f8dc2f75dd7561fb001a400b5bc1e2" class="ne-p"><br></p><p id="3ac6b21c213e53b332d365fd3c462651" class="ne-p"><span class="ne-text">I/O 软件实现的第三个目标就是 </span><code class="ne-code"><span class="ne-text">同步(synchronous)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">异步(asynchronous，即中断驱动)</span></code><span class="ne-text">传输。这里先说一下同步和异步是怎么回事吧。</span></p><p id="6600d3b4dbf1a21ab257c236aaf74890" class="ne-p"><br></p><p id="8a81b17161a0891783a1e47bafccc87a" class="ne-p"><span class="ne-text">同步传输中数据通常以块或帧的形式发送。发送方和接收方在数据传输之前应该具有</span><code class="ne-code"><span class="ne-text">同步时钟</span></code><span class="ne-text">。而在异步传输中，数据通常以字节或者字符的形式发送，异步传输则不需要同步时钟，但是会在传输之前向数据添加</span><code class="ne-code"><span class="ne-text">奇偶校验位</span></code><span class="ne-text">。大部分</span><code class="ne-code"><span class="ne-text">物理 IO(physical I/O)</span></code><span class="ne-text"> 是异步的。物理 I/O 中的 CPU 是很聪明的，CPU 传输完成后会转而做其他事情，它和中断心灵相通，等到中断发生后，CPU 才会回到传输这件事情上来。</span></p><p id="13f056d30c7563c88922db85f5bfa65b" class="ne-p"><br></p><h4 id="beeaff4e"><span class="ne-text">缓冲</span></h4><p id="695396bd0e3da1432e28a9ec7ad67c44" class="ne-p"><br></p><p id="d694cf6a6b725b199182eab1999db6af" class="ne-p"><span class="ne-text">I/O 软件的最后一个问题是</span><code class="ne-code"><span class="ne-text">缓冲(buffering)</span></code><span class="ne-text">。通常情况下，从一个设备发出的数据不会直接到达最后的设备。其间会经过一系列的校验、检查、缓冲等操作才能到达。</span></p><p id="6d8f5e80ec7671a409b3349aeafa4e84" class="ne-p"><br></p><h4 id="f1ccad80"><span class="ne-text">共享和独占</span></h4><p id="c08f1179ba4ca61d0259277331999928" class="ne-p"><br></p><p id="431707a6eac38d978e9d7b60547c75ec" class="ne-p"><span class="ne-text">I/O 软件引起的最后一个问题就是共享设备和独占设备的问题。有些 I/O 设备能够被许多用户共同使用。一些设备比如磁盘，让多个用户使用一般不会产生什么问题，但是某些设备必须具有独占性，即只允许单个用户使用完成后才能让其他用户使用。</span></p><p id="bcb812bfa70e5469e62fda4e1664762d" class="ne-p"><br></p><p id="fdb189d5793fe92aaecbae65c33c9d60" class="ne-p"><span class="ne-text">一共有三种控制 I/O 设备的方法</span></p><p id="3ac081282b49c86ef8508659ef7bae3c" class="ne-p"><br></p><ul class="ne-ul"><li id="0b7a67c756d4dfb9d85b4a1e274e5cf8"><span class="ne-text">使用程序控制 I/O</span></li><li id="1d1393ce94ebf7d064d3f95fa243aac4"><span class="ne-text">使用中断驱动 I/O</span></li></ul><ul class="ne-ul"><li id="2280839d3c18c5d4110059dbf95d31b0"><span class="ne-text">使用 DMA 驱动 I/O</span></li></ul><p id="efc9fb3091302ca297ac8fd3ebf94a6f" class="ne-p"><br></p><h2 id="ad10edaf"><span class="ne-text">I/O 层次结构</span></h2><p id="62f867ad46d621ab0a552b8ce4d2a9fb" class="ne-p"><br></p><p id="68dfa1c9e4977f08396c1a2cfac6b2ee" class="ne-p"><span class="ne-text">I/O 软件通常组织成四个层次，它们的大致结构如下图所示</span></p><p id="7929e287e6be90fb05c7f6eda9e795c6" class="ne-p"><br></p><p id="3c94fa0cf4df1135075bdba9d69394e4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830546-fa05a772-fc02-4957-ba1d-1e5a82d78de2.png" width="733" id="la9lz" class="ne-image"></p><p id="367071aef5c7e0cb28661020c6ec67ea" class="ne-p"><br></p><p id="fa33c7104d42e131152f9d0133c0bd34" class="ne-p"><span class="ne-text">下面我们具体的来探讨一下上面的层次结构</span></p><p id="453f272b64d2fca31d28de214c7af40f" class="ne-p"><br></p><h3 id="6b8ce92c"><span class="ne-text">中断处理程序</span></h3><p id="969295b5c2e73885da41f57f47ef9de7" class="ne-p"><br></p><p id="c27f88832c6acafb20ddebaa70764997" class="ne-p"><span class="ne-text">在计算机系统中，中断就像女人的脾气一样无时无刻都在产生，中断的出现往往是让人很不爽的。中断处理程序又被称为</span><code class="ne-code"><span class="ne-text">中断服务程序</span></code><span class="ne-text"> 或者是 </span><code class="ne-code"><span class="ne-text">ISR(Interrupt Service Routines)</span></code><span class="ne-text">，它是最靠近硬件的一层。中断处理程序由硬件中断、软件中断或者是软件异常启动产生的中断，用于实现设备驱动程序或受保护的操作模式（例如系统调用）之间的转换。</span></p><p id="90650cff08428997dffa1476c683dc7d" class="ne-p"><br></p><p id="fb6ef6915c1d6c5b6dc560331811403c" class="ne-p"><span class="ne-text">中断处理程序负责处理中断发生时的所有操作，操作完成后阻塞，然后启动中断驱动程序来解决阻塞。通常会有三种通知方式，依赖于不同的具体实现</span></p><p id="ad18698c37cb1386d4706b9bbd1f4b18" class="ne-p"><br></p><ul class="ne-ul"><li id="d0bf3529fd768e31495ed16c17aff466"><span class="ne-text">信号量实现中：在信号量上使用 </span><code class="ne-code"><span class="ne-text">up</span></code><span class="ne-text"> 进行通知；</span></li><li id="270d701c94d64a8cac75bef7a1a8005c"><span class="ne-text">管程实现：对管程中的条件变量执行 </span><code class="ne-code"><span class="ne-text">signal</span></code><span class="ne-text"> 操作</span></li></ul><ul class="ne-ul"><li id="a5a1d1b1aca07b60a91e3c1ff266e036"><span class="ne-text">还有一些情况是发送一些消息</span></li></ul><p id="e31a7428eaec4de703b54c063801fb8d" class="ne-p"><br></p><h3 id="62e973ec"><span class="ne-text">设备驱动程序</span></h3><p id="72c1ffdc38a4bc2a1e7f08037f01f10f" class="ne-p"><br></p><p id="ff158f09e0c7d71bdd01b66caa4a81b7" class="ne-p"><span class="ne-text">每个连接到计算机的 I/O 设备都需要有某些特定设备的代码对其进行控制。这些提供 I/O 设备到设备控制器转换的过程的代码称为 </span><code class="ne-code"><span class="ne-text">设备驱动程序(Device driver)</span></code><span class="ne-text">。</span></p><p id="ec30527260057319b095d7f987af51b2" class="ne-p"><br></p><p id="c44d98b89a8cb33f62b8d0170aba3810" class="ne-p"><span class="ne-text">设备控制器的主要功能有下面这些</span></p><p id="a8ef9058a6e1d341ecda61b3859848f2" class="ne-p"><br></p><ul class="ne-ul"><li id="03e25f8eb054ac95ed4d49b5e64491fb"><span class="ne-text">接收和识别命令：设备控制器可以接受来自 CPU 的指令，并进行识别。设备控制器内部也会有寄存器，用来存放指令和参数</span></li><li id="9b58f4a82cbcbee09a8c32dbae5e5a4b"><span class="ne-text">进行数据交换：CPU、控制器和设备之间会进行数据的交换，CPU 通过总线把指令发送给控制器，或从控制器中并行地读出数据；控制器将数据写入指定设备。</span></li></ul><ul class="ne-ul"><li id="cee546a33ac12989b6ae397dd0e2575f"><span class="ne-text">地址识别：每个硬件设备都有自己的地址，设备控制器能够识别这些不同的地址，来达到控制硬件的目的，此外，为使 CPU 能向寄存器中写入或者读取数据，这些寄存器都应具有唯一的地址。</span></li><li id="663801b37deb964c633d23a86521b554"><span class="ne-text">差错检测：设备控制器还具有对设备传递过来的数据进行检测的功能。</span></li></ul><p id="186d2e5b3c69f4cc63090482bc71d034" class="ne-p"><br></p><p id="918cc521f50cf3d9e06f10a4209a52a2" class="ne-p"><span class="ne-text">在这种情况下，设备控制器会阻塞，直到中断来解除阻塞状态。还有一种情况是操作是可以无延迟的完成，所以驱动程序不需要阻塞。在第一种情况下，操作系统可能被中断唤醒；第二种情况下操作系统不会被休眠。</span></p><p id="4dc6d4e2af5d94415071e30bbf4dedd3" class="ne-p"><br></p><p id="1921ce376109381d2b798c1d0d33e21e" class="ne-p"><span class="ne-text">设备驱动程序必须是</span><code class="ne-code"><span class="ne-text">可重入</span></code><span class="ne-text">的，因为设备驱动程序会阻塞和唤醒然后再次阻塞。驱动程序不允许进行系统调用，但是它们通常需要与内核的其余部分进行交互。</span></p><p id="b14ceef4943a55f53f523e4cce258b4d" class="ne-p"><br></p><h3 id="e3bc39ca"><span class="ne-text">与设备无关的 I/O 软件</span></h3><p id="10f8fed94d32fc074de365780434ded0" class="ne-p"><br></p><p id="ebda650d821c17681ecaf27bac82b100" class="ne-p"><span class="ne-text">I/O 软件有两种，一种是我们上面介绍过的基于特定设备的，还有一种是</span><code class="ne-code"><span class="ne-text">设备无关性</span></code><span class="ne-text">的，设备无关性也就是不需要特定的设备。设备驱动程序与设备无关的软件之间的界限取决于具体的系统。下面显示的功能由设备无关的软件实现</span></p><p id="0738bab2eec34e7d51f649716df70129" class="ne-p"><br></p><p id="0f127c6454010b4bb99d4d0e7ed1f1ba" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830586-059b4da8-ea81-4a5a-b884-3377ca39d976.png" width="428" id="qRr1F" class="ne-image"></p><p id="5e72fbe3b21aa9f1140fb098efa4b1ce" class="ne-p"><br></p><p id="7d6498e221ca9dbc841a87b949759de7" class="ne-p"><span class="ne-text">与设备无关的软件的基本功能是对所有设备执行公共的 I/O 功能，并且向用户层软件提供一个统一的接口。</span></p><p id="2147c0bb4a536252e4e10fe043856497" class="ne-p"><br></p><h4 id="beeaff4e-1"><span class="ne-text">缓冲</span></h4><p id="70b3be0dccb8514110943a6e97648b17" class="ne-p"><br></p><p id="af82636aa6623d48560a80e60ca7a455" class="ne-p"><span class="ne-text">无论是对于块设备还是字符设备来说，缓冲都是一个非常重要的考量标准。缓冲技术应用广泛，但它也有缺点。如果数据被缓冲次数太多，会影响性能。</span></p><p id="14ca5e8726df30d891d845d39491b86f" class="ne-p"><br></p><h4 id="6a8bef7b-1"><span class="ne-text">错误处理</span></h4><p id="1bd1dadfd62e3af3a1173bcb759bfb94" class="ne-p"><br></p><p id="b09255dfe1fe9917fbddf39e9aa593de" class="ne-p"><span class="ne-text">在 I/O 中，出错是一种再正常不过的情况了。当出错发生时，操作系统必须尽可能处理这些错误。有一些错误是只有特定的设备才能处理，有一些是由框架进行处理，这些错误和特定的设备无关。</span></p><p id="965a674df58190d1b05557392745253b" class="ne-p"><br></p><p id="ee5331138dfc8e986ea7badf7ba49ce5" class="ne-p"><span class="ne-text">I/O 错误的一类是程序员</span><code class="ne-code"><span class="ne-text">编程</span></code><span class="ne-text">错误，比如还没有打开文件前就读流，或者不关闭流导致内存溢出等等。这类问题由程序员处理；另外一类是实际的 I/O 错误，例如向一个磁盘坏块写入数据，无论怎么写都写入不了。这类问题由驱动程序处理，驱动程序处理不了交给硬件处理，这个我们上面也说过。</span></p><p id="522aff626808aa1e8c176163d925a242" class="ne-p"><br></p><h4 id="4e16fdac"><span class="ne-text">设备驱动程序统一接口</span></h4><p id="b4d2e1f579a5150b9d5d256369497333" class="ne-p"><br></p><p id="26833baca0c0963e267e4649428f43be" class="ne-p"><span class="ne-text">我们在操作系统概述中说到，操作系统一个非常重要的功能就是屏蔽了硬件和软件的差异性，为硬件和软件提供了统一的标准，这个标准还体现在为设备驱动程序提供统一的接口，因为不同的硬件和厂商编写的设备驱动程序不同，所以如果为每个驱动程序都单独提供接口的话，这样没法搞，所以必须统一。</span></p><p id="bbde6811238d412e5b62ea43f1d18f97" class="ne-p"><br></p><h4 id="c74ca274"><span class="ne-text">分配和释放</span></h4><p id="4aba2ddd488b12a50616973441385c40" class="ne-p"><br></p><p id="dfe10ac47170d60e5e6d5d9b24b9c827" class="ne-p"><span class="ne-text">一些设备例如打印机，它只能由一个进程来使用，这就需要操作系统根据实际情况判断是否能够对设备的请求进行检查，判断是否能够接受其他请求，一种比较简单直接的方式是在特殊文件上执行 </span><code class="ne-code"><span class="ne-text">open</span></code><span class="ne-text">操作。如果设备不可用，那么直接 open 会导致失败。还有一种方式是不直接导致失败，而是让其阻塞，等到另外一个进程释放资源后，在进行 open 打开操作。这种方式就把选择权交给了用户，由用户判断是否应该等待。</span></p><p id="510e44b2f5b8f53eaa9a17d6fbf08d28" class="ne-p"><br></p><h4 id="5dae479a"><span class="ne-text">设备无关的块</span></h4><p id="cdbefea531e399d091ad67a9c010a18e" class="ne-p"><br></p><p id="97f7a0d77ba330bf8aa1481f43e9db01" class="ne-p"><span class="ne-text">不同的磁盘会具有不同的扇区大小，但是软件不会关心扇区大小，只管存储就是了。一些字符设备可以一次一个字节的交付数据，而其他的设备则以较大的单位交付数据，这些差异也可以隐藏起来。</span></p><p id="7c1bb67a7692b24f169e8ed1c7dd6425" class="ne-p"><br></p><h3 id="6d8fb3eb"><span class="ne-text">用户空间的 I/O 软件</span></h3><p id="22e1a0b547c5bcd83b395670c5dfbddf" class="ne-p"><br></p><p id="b44115534de48afe22f229f049c4dd3d" class="ne-p"><span class="ne-text">虽然大部分 I/O 软件都在内核结构中，但是还有一些在用户空间实现的 I/O 软件，凡事没有绝对。一些 I/O 软件和库过程在用户空间存在，然后以提供系统调用的方式实现。</span></p><p id="daf9ee811684e122a58c85cb4e3d1ab8" class="ne-p"><br></p><h2 id="ff4efcaf"><span class="ne-text">盘</span></h2><p id="f670bd979c27b25d4c7d4fc8220167b5" class="ne-p"><br></p><p id="46790dad61b28c8d412e582e4b59070a" class="ne-p"><span class="ne-text">盘可以说是硬件里面比较简单的构造了，同时也是最重要的。下面我们从盘谈起，聊聊它的物理构造</span></p><p id="6f9f8e17698ca692669e1ed2b80c6402" class="ne-p"><br></p><h3 id="6f7147b6"><span class="ne-text">盘硬件</span></h3><p id="881f0a078f484235fe35102fd05a5fcc" class="ne-p"><br></p><p id="410790e052c1df4a2afe5f919551a676" class="ne-p"><span class="ne-text">盘会有很多种类型。其中最简单的构造就是</span><code class="ne-code"><span class="ne-text">磁盘(magnetic hard disks)</span></code><span class="ne-text">， 也被称为 </span><code class="ne-code"><span class="ne-text">hard disk,HDD</span></code><span class="ne-text">等。磁盘通常与安装在磁臂上的磁头配对，磁头可将数据读取或者将数据写入磁盘，因此磁盘的读写速度都同样快。在磁盘中，数据是随机访问的，这也就说明可以通过任意的顺序来</span><code class="ne-code"><span class="ne-text">存储</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">检索</span></code><span class="ne-text">单个数据块，所以你可以在任意位置放置磁盘来让磁头读取，磁盘是一种</span><code class="ne-code"><span class="ne-text">非易失性</span></code><span class="ne-text">的设备，即使断电也能永久保留。</span></p><p id="7697974a6ae1d7204b416004062d2c44" class="ne-p"><br></p><h4 id="4f5537dd"><span class="ne-text">磁盘</span></h4><p id="a7ccf8203470d7449eecb013543925cd" class="ne-p"><br></p><p id="99c3228c34d08b56f9e4be97cf06b550" class="ne-p"><span class="ne-text">为了组织和检索数据，会将磁盘组织成特定的结构，这些特定的结构就是</span><strong><span class="ne-text">磁道、扇区和柱面</span></strong></p><p id="4aef88f0b558db891f24c06feed2859c" class="ne-p"><br></p><p id="1ffcc406a94d9db392fcc0964818d5f3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830596-8b2a7f11-b5c9-4a00-b0c9-436889b099a8.png" width="498" id="XlRJ3" class="ne-image"></p><p id="6b06d914be3bc7c54870e83b6c07bc5f" class="ne-p"><br></p><p id="37a4261fd1b90279efe2e7508794d558" class="ne-p"><span class="ne-text">磁盘被组织成柱面形式，每个盘用轴相连，每一个柱面包含若干磁道，每个磁道由若干扇区组成。软盘上大约每个磁道有 8 - 32 个扇区，硬盘上每条磁道上扇区的数量可达几百个，磁头大约是 1 - 16 个。</span></p><p id="97b0132a4dc0ae7ea912969bd55fd30b" class="ne-p"><br></p><p id="81575d25682d5751d39b94b88d20e861" class="ne-p"><span class="ne-text">对于磁盘驱动程序来说，一个非常重要的特性就是控制器是否能够同时控制两个或者多个驱动器进行磁道寻址，这就是</span><code class="ne-code"><span class="ne-text">重叠寻道(overlapped seek)</span></code><span class="ne-text">。对于控制器来说，它能够控制一个磁盘驱动程序完成寻道操作，同时让其他驱动程序等待寻道结束。控制器也可以在一个驱动程序上进行读写草哦做，与此同时让另外的驱动器进行寻道操作，但是软盘控制器不能在两个驱动器上进行读写操作。</span></p><p id="62b66fc124bdd060dc868e7aac33e6d7" class="ne-p"><br></p><h4 id="RAID"><span class="ne-text">RAID</span></h4><p id="ffaba10a54eaac5469b3370e3b57ec33" class="ne-p"><br></p><p id="06399267d1efd2f5ec1beb76f23a781c" class="ne-p"><span class="ne-text">RAID 称为 </span><code class="ne-code"><span class="ne-text">磁盘冗余阵列</span></code><span class="ne-text">，简称 </span><code class="ne-code"><span class="ne-text">磁盘阵列</span></code><span class="ne-text">。利用虚拟化技术把多个硬盘结合在一起，成为一个或多个磁盘阵列组，目的是提升性能或数据冗余。</span></p><p id="e603443b78b137065f5838e183e64ae6" class="ne-p"><br></p><p id="d99b54a84a692f29ff775f8d078930b0" class="ne-p"><span class="ne-text">RAID 有不同的级别</span></p><p id="006985b2d9a124508177b0fe9a97e3d8" class="ne-p"><br></p><ul class="ne-ul"><li id="fc7b26a623451b45652560652f0ce2dc"><span class="ne-text">RAID 0 - 无容错的条带化磁盘阵列</span></li><li id="608dcc8c4da9da1cc93901fce2f72bd4"><span class="ne-text">RAID 1 - 镜像和双工</span></li></ul><ul class="ne-ul"><li id="e2f271c87c776d795773644ce782a5be"><span class="ne-text">RAID 2 - 内存式纠错码</span></li><li id="b865a2f4bbc441c2d6c00230b77ba8a6"><span class="ne-text">RAID 3 - 比特交错奇偶校验</span></li></ul><ul class="ne-ul"><li id="ffd5c142e5fbb5f5caeb8ad4d2df93a9"><span class="ne-text">RAID 4 - 块交错奇偶校验</span></li><li id="b27145d5ca28e12929413d476ca9d1d4"><span class="ne-text">RAID 5 - 块交错分布式奇偶校验</span></li></ul><ul class="ne-ul"><li id="44edb52008f1699295a33a01674147e4"><span class="ne-text">RAID 6 - P + Q 冗余</span></li></ul><p id="e0dd1db8bb6fec97312e991f0c0702d6" class="ne-p"><br></p><h4 id="a0c9482b"><span class="ne-text">磁盘格式化</span></h4><p id="603ffce150e2fc1d987dcfd88ae12f0e" class="ne-p"><br></p><p id="2892a91ceec697d1af55116f4eed65ed" class="ne-p"><span class="ne-text">磁盘由一堆铝的、合金或玻璃的盘片组成，磁盘刚被创建出来后，没有任何信息。磁盘在使用前必须经过</span><code class="ne-code"><span class="ne-text">低级格式化(low-levvel format)</span></code><span class="ne-text">，下面是一个扇区的格式</span></p><p id="237635b0cde6098f7edf3d17b16c4fb5" class="ne-p"><br></p><p id="9eb9a9e1de2f4cd41c8c10489509b3f3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830611-1b106d56-fbdb-4e79-b2b5-e5bd2778a387.png" width="638" id="LU06a" class="ne-image"></p><p id="0c16920b767cb6ec4ea66f9992882f6b" class="ne-p"><br></p><p id="0666a317b3e567ada28b40a2ae4678b7" class="ne-p"><span class="ne-text">前导码相当于是标示扇区的开始位置，通常以位模式开始，前导码还包括</span><code class="ne-code"><span class="ne-text">柱面号</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">扇区号</span></code><span class="ne-text">等一些其他信息。紧随前导码后面的是数据区，数据部分的大小由低级格式化程序来确定。大部分磁盘使用 512 字节的扇区。数据区后面是 ECC，ECC 的全称是 </span><strong><span class="ne-text">error correction code</span></strong><span class="ne-text"> ，</span><code class="ne-code"><span class="ne-text">数据纠错码</span></code><span class="ne-text">，它与普通的错误检测不同，ECC 还可以用于恢复读错误。ECC 阶段的大小由不同的磁盘制造商实现。ECC 大小的设计标准取决于</span><strong><span class="ne-text">设计者愿意牺牲多少磁盘空间来提高可靠性</span></strong><span class="ne-text">，以及程序可以处理的 ECC 的复杂程度。通常情况下 ECC 是 16 位，除此之外，硬盘一般具有一定数量的备用扇区，用于替换制造缺陷的扇区。</span></p><p id="7528fe0235fd15d3595da91dcbfc864d" class="ne-p"><br></p><h3 id="760df63f"><span class="ne-text">磁盘臂调度算法</span></h3><p id="b6278a03e824428f665cec4c6e256f50" class="ne-p"><br></p><p id="03e011ea5a88d0387736e681d5ce4617" class="ne-p"><span class="ne-text">下面我们来探讨一下关于影响磁盘读写的算法，一般情况下，影响磁盘快读写的时间由下面几个因素决定</span></p><p id="314b5126105ededa2a365cf439adc99f" class="ne-p"><br></p><ul class="ne-ul"><li id="7462d9403fc3252905f5a028434ad7c1"><span class="ne-text">寻道时间 - 寻道时间指的就是将磁盘臂移动到需要读取磁盘块上的时间</span></li><li id="5f7257bc3d72ff601be446ec912b45ca"><span class="ne-text">旋转延迟 - 等待合适的扇区旋转到磁头下所需的时间</span></li></ul><ul class="ne-ul"><li id="2be1b7ef29e9defa9d00b39f69ec3494"><span class="ne-text">实际数据的读取或者写入时间</span></li></ul><p id="2b370356fac399fe05f109995162a179" class="ne-p"><br></p><p id="0dc67d0cf7fad6f14c4ad3b58f27915e" class="ne-p"><span class="ne-text">这三种时间参数也是磁盘寻道的过程。一般情况下，寻道时间对总时间的影响最大，所以，有效的降低寻道时间能够提高磁盘的读取速度。</span></p><p id="91c6c8ce16ce7b9388de0e43ef253a37" class="ne-p"><br></p><p id="8d11395ec1947cc3a0b7ab12754b4328" class="ne-p"><span class="ne-text">如果磁盘驱动程序每次接收一个请求并按照接收顺序完成请求，这种处理方式也就是 </span><code class="ne-code"><span class="ne-text">先来先服务(First-Come, First-served, FCFS)</span></code><span class="ne-text"> ，这种方式很难优化寻道时间。因为每次都会按照顺序处理，不管顺序如何，有可能这次读完后需要等待一个磁盘旋转一周才能继续读取，而其他柱面能够马上进行读取，这种情况下每次请求也会排队。</span></p><p id="7d18009d76c74dd7b8db33951c729bd5" class="ne-p"><br></p><p id="c10ff5cc598f273b4133beab2f7333d7" class="ne-p"><span class="ne-text">通常情况下，磁盘在进行寻道时，其他进程会产生其他的磁盘请求。磁盘驱动程序会维护一张表，表中会记录着柱面号当作索引，每个柱面未完成的请求会形成链表，链表头存放在表的相应表项中。</span></p><p id="e046aef3abb66ef5daf5fc38d4c7ca3e" class="ne-p"><br></p><p id="6a69ca5623a5c553a4153757cc235dc8" class="ne-p"><span class="ne-text">一种对先来先服务的算法改良的方案是使用 </span><code class="ne-code"><span class="ne-text">最短路径优先(SSF)</span></code><span class="ne-text"> 算法，下面描述了这个算法。</span></p><p id="32b5296ec1d24eb2a7d5a6939088ad43" class="ne-p"><br></p><p id="9b84f8da5378b036c6c206344a7a7154" class="ne-p"><span class="ne-text">假如我们在对磁道 6 号进行寻址时，同时发生了对 11 , 2 , 4, 14, 8, 15, 3 的请求，如果采用先来先服务的原则，如下图所示</span></p><p id="807006c94eac31f179e807c72677c14d" class="ne-p"><br></p><p id="139b589cb34fee0e242e2a53b569c729" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830646-2dfee703-9a35-47c9-880c-2c620d64464a.png" width="762" id="GIQle" class="ne-image"></p><p id="852c3cef391fcf30dcbc45d68ead84cb" class="ne-p"><br></p><p id="07318c6d578eb7970403c2e9c0200380" class="ne-p"><span class="ne-text">我们可以计算一下磁盘臂所跨越的磁盘数量为 5 + 9 + 2 + 10 + 6 + 7 + 12 = 51，相当于是跨越了 51 次盘面，如果使用最短路径优先，我们来计算一下跨越的盘面</span></p><p id="9251d4187ee9e3955d98e126f5a61b7b" class="ne-p"><br></p><p id="f7750d7e03767b8fb7464af21e31e096" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830629-e3cda6d4-2317-438b-a377-9e5dc5a3a802.png" width="709" id="k9irp" class="ne-image"></p><p id="33fc7e528d1fb915ae0e5eb381f979a1" class="ne-p"><br></p><p id="a31730f3fb60b31dd1c442e0b3c89ff8" class="ne-p"><span class="ne-text">跨越的磁盘数量为 4 + 1 + 1 + 4 + 3 + 3 + 1 = 17 ，相比 51 足足省了两倍的时间。</span></p><p id="aeb569eb1e81c5ef30132a4f118513d6" class="ne-p"><br></p><p id="bbe4e798ae04ba9181c1b53f7030014c" class="ne-p"><span class="ne-text">但是，最短路径优先的算法也不是完美无缺的，这种算法照样存在问题，那就是</span><code class="ne-code"><span class="ne-text">优先级</span></code><span class="ne-text"> 问题，</span></p><p id="33bbdf6c3903be454a5434c1b4b45129" class="ne-p"><br></p><p id="753770733d67a5f8ee48a11ff1bbe27a" class="ne-p"><span class="ne-text">这里有一个原型可以参考就是我们日常生活中的电梯，电梯使用一种</span><code class="ne-code"><span class="ne-text">电梯算法(elevator algorithm)</span></code><span class="ne-text"> 来进行调度，从而满足协调效率和公平性这两个相互冲突的目标。电梯一般会保持向一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</span></p><p id="58e3089c129557a6025b4b2e291be8e5" class="ne-p"><br></p><p id="6148ba2cda1c3131d27d57b6737daef0" class="ne-p"><span class="ne-text">电梯算法需要维护一个</span><code class="ne-code"><span class="ne-text">二进制位</span></code><span class="ne-text">，也就是当前的方向位：</span><code class="ne-code"><span class="ne-text">UP(向上)</span></code><span class="ne-text">或者是 </span><code class="ne-code"><span class="ne-text">DOWN(向下)</span></code><span class="ne-text">。当一个请求处理完成后，磁盘或电梯的驱动程序会检查该位，如果此位是 UP 位，磁盘臂或者电梯仓移到下一个更高跌未完成的请求。如果高位没有未完成的请求，则取相反方向。当方向位是 </span><code class="ne-code"><span class="ne-text">DOWN</span></code><span class="ne-text"> 时，同时存在一个低位的请求，磁盘臂会转向该点。如果不存在的话，那么它只是停止并等待。</span></p><p id="e90c80069ca940c4dccc45414d988aa6" class="ne-p"><br></p><p id="2e5464096db15e05287322aedc930903" class="ne-p"><span class="ne-text">我们举个例子来描述一下电梯算法，比如各个柱面得到服务的顺序是 4，7，10，14，9，6，3，1 ，那么它的流程图如下</span></p><p id="f8c4a980d7ccbf906215cfae641fb9de" class="ne-p"><br></p><p id="9db3b630e1e92fea3c4e594885ac701c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830648-6e8afe9c-f2fd-4c64-8db9-7f68930d0a27.png" width="710" id="qkkaP" class="ne-image"></p><p id="c0843a5f92d2fd7b0137831f7a66b398" class="ne-p"><br></p><p id="56a54c492ce1f8a483ad07c078eedaa6" class="ne-p"><span class="ne-text">所以电梯算法需要跨越的盘面数量是 3 + 3 + 4 + 5 + 3 + 3 + 1 = 22</span></p><p id="6537fc8bf8f453295d6a455f604979f3" class="ne-p"><br></p><p id="67c0f7b60aa67bfebb7ad608b2d9b80e" class="ne-p"><span class="ne-text">电梯算法通常情况下不如 SSF 算法。</span></p><p id="6cdbd3e42df5f443f82a300371150d79" class="ne-p"><br></p><h3 id="6a8bef7b-2"><span class="ne-text">错误处理</span></h3><p id="cd448c76eee05090052f87c787370093" class="ne-p"><br></p><p id="e35a9d1da80fb23de9e8c755ab4375f7" class="ne-p"><span class="ne-text">一般坏块有两种处理办法，一种是在控制器中进行处理；一种是在操作系统层面进行处理。</span></p><p id="f72cda08c63f4925bb58c1e69dc98731" class="ne-p"><br></p><p id="efe36e8265e3ea31c5ca3acbbd4d2419" class="ne-p"><span class="ne-text">这两种方法经常替换使用，比如一个具有 30 个数据扇区和两个备用扇区的磁盘，其中扇区 4 是有瑕疵的。</span></p><p id="46e08dedb1f01e545beee9d410b8ca30" class="ne-p"><br></p><p id="973a0923ca8878b60159e1381d2db988" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830690-4489f1b3-d4a8-49d6-bd29-1becb143d418.png" width="423" id="j9QM3" class="ne-image"></p><p id="efc58b0eaccde5c29602b247280b7659" class="ne-p"><br></p><p id="c04a32c0f9c7869487d8bf460b2af6f0" class="ne-p"><span class="ne-text">控制器能做的事情就是将备用扇区之一重新映射。</span></p><p id="b409a58389fcff3598c331a89f6dbeb2" class="ne-p"><br></p><p id="4da899689af489cd2c870ae6658c4290" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830735-2f51c8ae-a37f-4673-9781-a2519263c63f.png" width="500" id="BSem5" class="ne-image"></p><p id="8e494cf7453125ff435eff2d552fb41d" class="ne-p"><br></p><p id="e6f45bb62550a08872dea21674e5c005" class="ne-p"><span class="ne-text">还有一种处理方式是将所有的扇区都向上移动一个扇区</span></p><p id="c46a73b199e28b719c907ef92d49b313" class="ne-p"><br></p><p id="48f0cc7b31fc216b96308193861a1900" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830717-1dc1be76-6eff-4891-8d89-843a7110e6a8.png" width="497" id="OZ9U3" class="ne-image"></p><p id="c3abc09db901f9b310fad8ef6cdb5415" class="ne-p"><br></p><p id="1559044f1c5e9c73aff061102d26bd29" class="ne-p"><span class="ne-text">上面这这两种情况下控制器都必须知道哪个扇区，可以通过内部的表来跟踪这一信息，或者通过重写前导码来给出重新映射的扇区号。如果是重写前导码，那么涉及移动的方式必须重写后面所有的前导码，但是最终会提供良好的性能。</span></p><p id="f15e6f8229cb758b7b0c9e8ebb12edd8" class="ne-p"><br></p><h3 id="dd4fb2cb"><span class="ne-text">稳定存储器</span></h3><p id="4ad899cab1ab97a5aabbaf01a5be34cf" class="ne-p"><br></p><p id="58e282adac0cb4419208d340a02153a8" class="ne-p"><span class="ne-text">磁盘经常会出现错误，导致好的扇区会变成坏扇区，驱动程序也有可能挂掉。RAID 可以对扇区出错或者是驱动器崩溃提出保护，然而 RAID 却不能对坏数据中的写错误提供保护，也不能对写操作期间的崩溃提供保护，这样就会破坏原始数据。</span></p><p id="473a78fd5112572f75a9b22ad7bf64eb" class="ne-p"><br></p><p id="27763f1b1c4778a17eba274ab07dbeec" class="ne-p"><span class="ne-text">我们期望磁盘能够准确无误的工作，但是事实情况是不可能的，但是我们能够知道的是，一个磁盘子系统具有如下特性：当一个写命令发给它时，磁盘要么正确地写数据，要么什么也不做，让现有的数据完整无误的保留。这样的系统称为 </span><code class="ne-code"><span class="ne-text">稳定存储器(stable storage)</span></code><span class="ne-text">。 稳定存储器的目标就是不惜一切代价保证磁盘的一致性。</span></p><p id="e0bbd24c6e2eac90bc9bef03d023565c" class="ne-p"><br></p><p id="23c65e8ec21c9f98369932ed2ca149d8" class="ne-p"><span class="ne-text">稳定存储器使用两个一对相同的磁盘，对应的块一同工作形成一个无差别的块。稳定存储器为了实现这个目的，定义了下面三种操作：</span></p><p id="5fb6db8f32f3839372d1c236a3e8bf98" class="ne-p"><br></p><ul class="ne-ul"><li id="11e13f4166e70f36fb7c87fb739dea9c"><code class="ne-code"><span class="ne-text">稳定写(stable write)</span></code></li><li id="895c72d40eb8c8f6b8d1b19066db9933"><code class="ne-code"><span class="ne-text">稳定读(stable read)</span></code></li></ul><ul class="ne-ul"><li id="da686324dfe297329016a5be43c1141d"><code class="ne-code"><span class="ne-text">崩溃恢复(crash recovery)</span></code></li></ul><p id="3bf3c6998eede59026606fee3cbb805a" class="ne-p"><br></p><h2 id="751437d1"><span class="ne-text">时钟</span></h2><p id="42bfc7cc58126df175de0804edb625f1" class="ne-p"><br></p><p id="275f2f33e6f9a41aaf0f1af466175266" class="ne-p"><code class="ne-code"><span class="ne-text">时钟(Clocks)</span></code><span class="ne-text"> 也被称为</span><code class="ne-code"><span class="ne-text">定时器(timers)</span></code><span class="ne-text">，时钟/定时器对任何程序系统来说都是必不可少的。时钟负责维护时间、防止一个进程长期占用 CPU 时间等其他功能。</span><code class="ne-code"><span class="ne-text">时钟软件(clock software)</span></code><span class="ne-text"> 也是一种设备驱动的方式。下面我们就来对时钟进行介绍，一般都是先讨论硬件再介绍软件，采用由下到上的方式，也是告诉你，底层是最重要的。</span></p><p id="53b9aa404a3a4a083622863777556273" class="ne-p"><br></p><h3 id="e8a4fb9a"><span class="ne-text">时钟硬件</span></h3><p id="2a655f87074ad58d9ef984e79932a319" class="ne-p"><br></p><p id="8ef96daa1f5875a499646dd402188b1f" class="ne-p"><span class="ne-text">在计算机中有两种类型的时钟，这些时钟与现实生活中使用的时钟完全不一样。</span></p><p id="2e4a913ade7c6d01a0f32f2a434d095c" class="ne-p"><br></p><ul class="ne-ul"><li id="55f7695ceccc219d7810683c20403f2f"><span class="ne-text">比较简单的一种时钟被连接到 110 V 或 220 V 的电源线上，这样每个</span><code class="ne-code"><span class="ne-text">电压周期</span></code><span class="ne-text">会产生一个中断，大概是 50 - 60 HZ。这些时钟过去一直占据支配地位。</span></li><li id="cf9376a6328b7c2eb22a1a93c6f08aa6"><span class="ne-text">另外的一种时钟由晶体振荡器、计数器和寄存器组成，示意图如下所示</span></li></ul><p id="439d4fe21f5ac9db8fcc1898d175e44d" class="ne-p"><br></p><p id="58e69eb2dd1d8030de36ab796376c1f3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830741-6daaaf06-0552-44b1-bf19-85729fd25288.png" width="627" id="VUI1p" class="ne-image"></p><p id="138cdebd4b5315b038710c7d2442d19c" class="ne-p"><br></p><p id="fed5845bb86ffee727f4ec21c1f3305b" class="ne-p"><span class="ne-text">这种时钟称为</span><code class="ne-code"><span class="ne-text">可编程时钟</span></code><span class="ne-text"> ，可编程时钟有两种模式，一种是 </span><code class="ne-code"><span class="ne-text">一键式(one-shot mode)</span></code><span class="ne-text">，当时钟启动时，会把存储器中的值复制到计数器中，然后，每次晶体的振荡器的脉冲都会使计数器 -1。当计数器变为 0 时，会产生一个中断，并停止工作，直到软件再一次显示启动。还有一种模式时 </span><code class="ne-code"><span class="ne-text">方波(square-wave mode)</span></code><span class="ne-text"> 模式，在这种模式下，当计数器变为 0 并产生中断后，存储寄存器的值会自动复制到计数器中，这种周期性的中断称为一个时钟周期。</span></p><p id="bda3a730c41682e58599382a899dcd60" class="ne-p"><br></p><h3 id="b173f2cb"><span class="ne-text">时钟软件</span></h3><p id="d8bdf65c9a5135888a2497a3439f7145" class="ne-p"><br></p><p id="b00c628ad58f5b5dce23e9850a61c034" class="ne-p"><span class="ne-text">时钟硬件所做的工作只是根据已知的时间间隔产生中断，而其他的工作都是由</span><code class="ne-code"><span class="ne-text">时钟软件</span></code><span class="ne-text">来完成，一般操作系统的不同，时钟软件的具体实现也不同，但是一般都会包括以下这几点</span></p><p id="c9f6a7282375ba50967103b96e0fa187" class="ne-p"><br></p><ul class="ne-ul"><li id="87f3966c7f38a21ec3de2e00caa8c495"><span class="ne-text">维护一天的时间</span></li><li id="83f9eb2354f6857b43e402f24d895af3"><span class="ne-text">阻止进程运行的时间超过其指定时间</span></li></ul><ul class="ne-ul"><li id="b15f932d0660dfeed727e20b42edf52d"><span class="ne-text">统计 CPU 的使用情况</span></li><li id="5b41149ddbaee4b2dc5216e16149e38a"><span class="ne-text">处理用户进程的警告系统调用</span></li></ul><ul class="ne-ul"><li id="3e1b60c00fc9f9f5bc20bfc979ef00a2"><span class="ne-text">为系统各个部分提供看门狗定时器</span></li><li id="d2276a0cd1af25e63d9f08f9fe7ee549"><span class="ne-text">完成概要剖析，监视和信息收集</span></li></ul><p id="9e1dabd93c76dcfad0d1beab34188d56" class="ne-p"><br></p><h3 id="b91fda0e"><span class="ne-text">软定时器</span></h3><p id="95ae8d930b294e9c0fbf9c4a05ebbc55" class="ne-p"><br></p><p id="a5c4252cb21d8d6068043a7afe3d314c" class="ne-p"><span class="ne-text">时钟软件也被称为可编程时钟，可以设置它以程序需要的任何速率引发中断。时钟软件触发的中断是一种硬中断，但是某些应用程序对于硬中断来说是不可接受的。</span></p><p id="f79ba5cf1321c60b2dc29763e734e1ac" class="ne-p"><br></p><p id="e6dfdfd7167d693006ca2a8a105d7c9b" class="ne-p"><span class="ne-text">这时候就需要一种</span><code class="ne-code"><span class="ne-text">软定时器(soft timer)</span></code><span class="ne-text"> 避免了中断，无论何时当内核因为某种原因呢在运行时，它返回用户态之前都会检查时钟来了解软定时器是否到期。如果软定时器到期，则执行被调度的事件也无需切换到内核态，因为本身已经处于内核态中。这种方式避免了频繁的内核态和用户态之前的切换，提高了程序运行效率。</span></p><p id="4d84d77fd04a9489fe535b3daa4f7b69" class="ne-p"><br></p><p id="d50c55b092a1800b5a7f27a4dc606790" class="ne-p"><span class="ne-text">软定时器因为不同的原因切换进入内核态的速率不同，原因主要有</span></p><p id="b15053b7084f5d35f327aba23c558ddd" class="ne-p"><br></p><ul class="ne-ul"><li id="e896c450129d2ead85b0eb99d11bb5eb"><span class="ne-text">系统调用</span></li><li id="0c1a4062ca9907469cc5b5a914f250ef"><span class="ne-text">TLB 未命中</span></li></ul><ul class="ne-ul"><li id="f984a4635683adf2eff00aa2764aae22"><span class="ne-text">缺页异常</span></li><li id="1e8fa7b36d7c84263c14a105f9d8a40a"><span class="ne-text">I/O 中断</span></li></ul><ul class="ne-ul"><li id="8584034cbecc7bed86a6ce92b0021351"><span class="ne-text">CPU 变得空闲</span></li></ul><p id="8c1b12bc4cb14f1332748c06db0e8a82" class="ne-p"><br></p><p id="20bd0c60869e5232c1a9da4f41bc3362" class="ne-p"><span class="ne-text">死锁问题也是操作系统非常重要的一类问题</span></p><p id="d8b84eaac214a26402cf69e0457896cb" class="ne-p"><br></p><p id="2e47e39e0877ecee085aa3aa086c4bd7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830748-305133ff-5324-4e46-b119-74609aedd401.png" width="721" id="WK6xj" class="ne-image"></p><p id="a9d7734a1e890759c5b156cdd8f82011" class="ne-p"><br></p><h2 id="eee83a92"><span class="ne-text">资源</span></h2><p id="d7231e68daee7dc7da7271048e9e2f43" class="ne-p"><br></p><p id="9478bc370ebcfa642d99c1b1d4e681fa" class="ne-p"><span class="ne-text">大部分的死锁都和资源有关，在进程对设备、文件具有独占性（排他性）时会产生死锁。我们把这类需要排他性使用的对象称为</span><code class="ne-code"><span class="ne-text">资源(resource)</span></code><span class="ne-text">。资源主要分为 </span><strong><span class="ne-text">可抢占资源和不可抢占资源</span></strong></p><p id="3eac1e4d117abd05087b36175c975155" class="ne-p"><br></p><h3 id="27201743"><span class="ne-text">可抢占资源和不可抢占资源</span></h3><p id="72ec56e9b234da0b742fc02a6cabc6f5" class="ne-p"><br></p><p id="aca2fb281a7bd5541bea22c94bd6b33a" class="ne-p"><span class="ne-text">资源主要有可抢占资源和不可抢占资源。</span><code class="ne-code"><span class="ne-text">可抢占资源(preemptable resource)</span></code><span class="ne-text"> 可以从拥有它的进程中抢占而不会造成其他影响，内存就是一种可抢占性资源，任何进程都能够抢先获得内存的使用权。</span></p><p id="5b8beb8ea2c4de6036320fcc924dcf57" class="ne-p"><br></p><p id="e1b275fbf0b76f9c98f8612371b35e35" class="ne-p"><code class="ne-code"><span class="ne-text">不可抢占资源(nonpreemtable resource)</span></code><span class="ne-text"> 指的是除非引起错误或者异常，否则进程无法抢占指定资源，这种不可抢占的资源比如有光盘，在进程执行调度的过程中，其他进程是不能得到该资源的。</span></p><p id="1bb4f502e68b522ee9f808e108067db3" class="ne-p"><br></p><h2 id="60461afa"><span class="ne-text">死锁</span></h2><p id="fb62f7163749f731b9eea44242c66117" class="ne-p"><br></p><p id="fd64352b74e15c5119d31f2d078fa99f" class="ne-p"><span class="ne-text">如果要对死锁进行一个定义的话，下面的定义比较贴切</span></p><p id="481b22ddedf0cdb8abca22a089108ce4" class="ne-p"><br></p><p id="baae47f87c55b321b1a847755d5bd5a2" class="ne-p"><strong><span class="ne-text">如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁</span></strong><span class="ne-text">。</span></p><p id="cd3b049f801c785902aa2ee9f5537659" class="ne-p"><br></p><h3 id="a4ffc042"><span class="ne-text">资源死锁的条件</span></h3><p id="8cf2cde31de59698515b56ec5a49c581" class="ne-p"><br></p><p id="7bf9ec1a4e71c2362bc024c611a36dab" class="ne-p"><span class="ne-text">针对我们上面的描述，资源死锁可能出现的情况主要有</span></p><p id="d2965e8c80a02d9f6ae8ad4dd9741a6c" class="ne-p"><br></p><ul class="ne-ul"><li id="2461cac20ec655f2ce5216f716ed970d"><span class="ne-text">互斥条件：每个资源都被分配给了一个进程或者资源是可用的</span></li><li id="b59b3d4339b30dbbd1d4c840019f29fa"><span class="ne-text">保持和等待条件：已经获取资源的进程被认为能够获取新的资源</span></li></ul><ul class="ne-ul"><li id="c83defcb158380ae745008f1ce2e7b4b"><span class="ne-text">不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</span></li><li id="24871dfae1e4208085188d6d4dffdce3"><span class="ne-text">循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</span></li></ul><p id="57e7bca96f378b5215fc1af485de28e6" class="ne-p"><br></p><p id="ec8baeee4c99e209781933e1f1514ea9" class="ne-p"><span class="ne-text">发生死锁时，上面的情况必须同时会发生。如果其中任意一个条件不会成立，死锁就不会发生。可以通过破坏其中任意一个条件来破坏死锁，下面这些破坏条件就是我们探讨的重点</span></p><p id="1df908aa8bf7935a457c9c552b0fea44" class="ne-p"><br></p><h3 id="2ba04a66"><span class="ne-text">死锁模型</span></h3><p id="a04f8c5e84de9684afc27ae414a6d779" class="ne-p"><br></p><p id="85b83d0ed4eb6aa01bc52b5c0e6916ca" class="ne-p"><span class="ne-text">Holt 在 1972 年提出对死锁进行建模，建模的标准如下：</span></p><p id="35efa46631e12a3613067329ef47eaa6" class="ne-p"><br></p><ul class="ne-ul"><li id="5c6ff301023c6b32a75add616a9f195a"><span class="ne-text">圆形表示进程</span></li><li id="8fd6eb48acae20dc5052e40e62d39242"><span class="ne-text">方形表示资源</span></li></ul><p id="76e680e1ac67826c1904b922f2508207" class="ne-p"><br></p><p id="0eb57a1be3e1c45d5a9d5d78b3855fb1" class="ne-p"><span class="ne-text">从资源节点到进程节点表示资源已经被进程占用，如下图所示</span></p><p id="59962074ed9fa78004d8f206555aeb1c" class="ne-p"><br></p><p id="e23a383dff53004dac74daaebfa5cf62" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830760-e22f0a74-94ab-4be7-9b39-3f611c32823a.png" width="331" id="BjL47" class="ne-image"></p><p id="0a2f8ae870c3bb8c95857ace4b4c3e73" class="ne-p"><br></p><p id="cdfcbee5b6e9b6948f037308db4d7622" class="ne-p"><span class="ne-text">在上图中表示当前资源 R 正在被 A 进程所占用</span></p><p id="67676b8c22e281f016c0d0b1e01204e0" class="ne-p"><br></p><p id="1fb8a54214e882e963e6db8825977fc4" class="ne-p"><span class="ne-text">由进程节点到资源节点的有向图表示当前进程正在请求资源，并且该进程已经被阻塞，处于等待这个资源的状态</span></p><p id="bb1747bacfa748ab9f5f396430510658" class="ne-p"><br></p><p id="53fdec97a470c1c990d4c19da34a87c2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830813-2b57251b-055b-4664-b040-89f60d1d43c4.png" width="345" id="u51ZN" class="ne-image"></p><p id="fc7fcab5e87f8354278b202646ce6bb8" class="ne-p"><br></p><p id="2ca0e28dee5d52b527286b9f49dc14da" class="ne-p"><span class="ne-text">在上图中，表示的含义是进程 B 正在请求资源 S 。Holt 认为，死锁的描述应该如下</span></p><p id="3f72668bb9a949d52e87791eae34010b" class="ne-p"><br></p><p id="51082e3beb38f015ef3ac95212b138d2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830811-a3afe75e-0c48-40b9-8fa4-e74d132d9b58.png" width="485" id="bhef4" class="ne-image"></p><p id="01f74cd30421be5cf72c44619b12477f" class="ne-p"><br></p><p id="01f565a83434d718c7ae59fd03de6811" class="ne-p"><span class="ne-text">这是一个死锁的过程，进程 C 等待资源 T 的释放，资源 T 却已经被进程 D 占用，进程 D 等待请求占用资源 U ，资源 U 却已经被线程 C 占用，从而形成环。</span></p><p id="b237901b2be04c14ea3abad0df23223c" class="ne-p"><br></p><p id="d3950d5ac640dba2723c9ce141487292" class="ne-p"><span class="ne-text">有四种处理死锁的策略：</span></p><p id="9c28eb93725ce1026b8e57cbdc9d884a" class="ne-p"><br></p><ul class="ne-ul"><li id="f02059d209937e043cc91b3202332b45"><span class="ne-text">忽略死锁带来的影响（惊呆了）</span></li><li id="7ed0ecd020c81e768cc3daddc64d269c"><span class="ne-text">检测死锁并回复死锁，死锁发生时对其进行检测，一旦发生死锁后，采取行动解决问题</span></li></ul><ul class="ne-ul"><li id="15d6f899a7a219f73c9f9c5d3d84284a"><span class="ne-text">通过仔细分配资源来避免死锁</span></li><li id="3480f5545cb59921ddc8cce5bb380e7e"><span class="ne-text">通过破坏死锁产生的四个条件之一来避免死锁</span></li></ul><p id="01bc1144b78631aef94e579fa8d1d912" class="ne-p"><br></p><p id="495a1907b5f77a040cb025c261a0dde9" class="ne-p"><span class="ne-text">下面我们分别介绍一下这四种方法</span></p><p id="364bc81ab84b40122e907de1d02cf761" class="ne-p"><br></p><h2 id="445e7ac3"><span class="ne-text">鸵鸟算法</span></h2><p id="036b75a65beb0a6e2c2ca45ebd1bf297" class="ne-p"><br></p><p id="e6043383dfd449422770da6892dcea16" class="ne-p"><span class="ne-text">最简单的解决办法就是使用</span><code class="ne-code"><span class="ne-text">鸵鸟算法(ostrich algorithm)</span></code><span class="ne-text">，把头埋在沙子里，假装问题根本没有发生。每个人看待这个问题的反应都不同。数学家认为死锁是不可接受的，必须通过有效的策略来防止死锁的产生。工程师想要知道问题发生的频次，系统因为其他原因崩溃的次数和死锁带来的严重后果。如果死锁发生的频次很低，而经常会由于硬件故障、编译器错误等其他操作系统问题导致系统崩溃，那么大多数工程师不会修复死锁。</span></p><p id="52f6db636d5ff751b26f95bdd338d289" class="ne-p"><br></p><h2 id="c34052de"><span class="ne-text">死锁检测和恢复</span></h2><p id="225135e8a2070f389de38812717eb75d" class="ne-p"><br></p><p id="f06571b2cb07e67da53eb1f9ae46f666" class="ne-p"><span class="ne-text">第二种技术是死锁的检测和恢复。这种解决方式不会尝试去阻止死锁的出现。相反，这种解决方案会希望死锁尽可能的出现，在监测到死锁出现后，对其进行恢复。下面我们就来探讨一下死锁的检测和恢复的几种方式</span></p><p id="14ee619ccacc077fbb0ab230f795ff08" class="ne-p"><br></p><h3 id="845b19bd"><span class="ne-text">每种类型一个资源的死锁检测方式</span></h3><p id="8856acadce3e4be26400996c75037a18" class="ne-p"><br></p><p id="1dce1bbff3adfcf55a761b49b459a9a9" class="ne-p"><span class="ne-text">每种资源类型都有一个资源是什么意思？我们经常提到的打印机就是这样的，资源只有打印机，但是设备都不会超过一个。</span></p><p id="7aa26a189549bf96df754b2f1ace77ae" class="ne-p"><br></p><p id="ae3dd6af307505c10b0eb562a80986f1" class="ne-p"><span class="ne-text">可以通过构造一张资源分配表来检测这种错误，比如我们上面提到的</span></p><p id="57bb0ac633cecdfa908fa75afa54cbdc" class="ne-p"><br></p><p id="ad5e4cd721b90f28101f2acd23afe3bb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830848-f4bc59e7-89e2-4e78-909c-e8dcd1718ebe.png" width="475" id="TYPR7" class="ne-image"></p><p id="2745a826110fc96a2b6216f300175397" class="ne-p"><br></p><p id="32c152b4a1b42accb3ee8f73ca42fd9a" class="ne-p"><span class="ne-text">如果这张图包含了一个或一个以上的环，那么死锁就存在，处于这个环中任意一个进程都是死锁的进程。</span></p><p id="00db8fb2a967b493da00c952b7385bb2" class="ne-p"><br></p><h3 id="0e6d1847"><span class="ne-text">每种类型多个资源的死锁检测方式</span></h3><p id="feab24bd3b82d2799e2dac6d56957450" class="ne-p"><br></p><p id="8675e27ef21c4d6f4e3c390a9039463d" class="ne-p"><span class="ne-text">如果有多种相同的资源存在，就需要采用另一种方法来检测死锁。可以通过构造一个矩阵来检测从 P1 -&gt; Pn 这 n 个进程中的死锁。</span></p><p id="04fc31dd56db424542188c800706797c" class="ne-p"><br></p><p id="a24b641ae3e9651167024af87187bf28" class="ne-p"><span class="ne-text">现在我们提供一种基于矩阵的算法来检测从 P1 到 Pn 这 n 个进程中的死锁。假设资源类型为 m，E1 代表资源类型 1，E2 表示资源类型 2 ，Ei 代表资源类型 i (1 &lt;= i &lt;= m)。E 表示的是 </span><code class="ne-code"><span class="ne-text">现有资源向量(existing resource vector)</span></code><span class="ne-text">，代表每种已存在的资源总数。</span></p><p id="9d26e86025397b8d6319268fa76a93a3" class="ne-p"><br></p><p id="41f401b08793431302caeb310f9f5076" class="ne-p"><span class="ne-text">现在我们就需要构造两个数组：C 表示的是</span><code class="ne-code"><span class="ne-text">当前分配矩阵(current allocation matrix)</span></code><span class="ne-text"> ，R 表示的是 </span><code class="ne-code"><span class="ne-text">请求矩阵(request matrix)</span></code><span class="ne-text">。Ci 表示的是 Pi 持有每一种类型资源的资源数。所以，Cij 表示 Pi 持有资源 j 的数量。Rij 表示 Pi 所需要获得的资源 j 的数量</span></p><p id="66cca3aac1c7c3a268bcf0cbe528756c" class="ne-p"><br></p><p id="92630dcca8243665dde0564f6c12e1cd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830847-d4f0a077-7abd-4507-a720-337bc99b121e.png" width="686" id="JZ0fA" class="ne-image"></p><p id="56bc171dc0bf324243530e635d5bab68" class="ne-p"><br></p><p id="423bab2c70172066263bee3d30dad1f7" class="ne-p"><span class="ne-text">一般来说，已分配资源 j 的数量加起来再和所有可供使用的资源数相加 = 该类资源的总数。</span></p><p id="77aae0d262cefbaa04162ad431e28520" class="ne-p"><br></p><p id="6c93735bd020f34c0a7d4addc689ef08" class="ne-p"><span class="ne-text">死锁的检测就是基于向量的比较。每个进程起初都是没有被标记过的，算法会开始对进程做标记，进程被标记后说明进程被执行了，不会进入死锁，当算法结束时，任何没有被标记过的进程都会被判定为死锁进程。</span></p><p id="14e91ed8d03af86ca1b09968d2699d12" class="ne-p"><br></p><p id="124b222886574ccd5653fc831d93cb96" class="ne-p"><span class="ne-text">上面我们探讨了两种检测死锁的方式，那么现在你知道怎么检测后，你何时去做死锁检测呢？一般来说，有两个考量标准：</span></p><p id="1a40a355ed7a5a9fea8130b2e3e33388" class="ne-p"><br></p><ul class="ne-ul"><li id="ee8c565c1201d24a8441c6fbb77ece7b"><span class="ne-text">每当有资源请求时就去检测，这种方式会占用昂贵的 CPU 时间。</span></li><li id="afc8b082824e82774c1c3be31d74ac3e"><span class="ne-text">每隔 k 分钟检测一次，或者当 CPU 使用率降低到某个标准下去检测。考虑到 CPU 效率的原因，如果死锁进程达到一定数量，就没有多少进程可以运行，所以 CPU 会经常空闲。</span></li></ul><p id="6488c6772dd853d8292d2e105a388286" class="ne-p"><br></p><h3 id="95bdbdb5"><span class="ne-text">从死锁中恢复</span></h3><p id="a374c9f6b0536b99e76dc7d380d5ad4d" class="ne-p"><br></p><p id="6c6fa66bb994f4b13767e0758e7bc15b" class="ne-p"><span class="ne-text">上面我们探讨了如何检测进程死锁，我们最终的目的肯定是想让程序能够正常的运行下去，所以针对检测出来的死锁，我们要对其进行恢复，下面我们会探讨几种死锁的恢复方式</span></p><p id="17c663707ef8dd6df4ca3362d812f340" class="ne-p"><br></p><h4 id="82459936"><span class="ne-text">通过抢占进行恢复</span></h4><p id="8611e726a4b51bbc2a2a73b2584f2cf4" class="ne-p"><br></p><p id="b09a07bd4466a6494cae3cb7b5f3487c" class="ne-p"><span class="ne-text">在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。</span></p><p id="9db11e547d3327df9fd8150582728d11" class="ne-p"><br></p><h4 id="48c12fe7"><span class="ne-text">通过回滚进行恢复</span></h4><p id="7c6c5b54d8c697c690324a6fa94cdf41" class="ne-p"><br></p><p id="718e20e97011e6148925c731421cd028" class="ne-p"><span class="ne-text">如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含</span><code class="ne-code"><span class="ne-text">存储映像(memory image)</span></code><span class="ne-text">，还包含</span><code class="ne-code"><span class="ne-text">资源状态(resource state)</span></code><span class="ne-text">。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。</span></p><p id="339f29e4c95b23688e573aa6483a9909" class="ne-p"><br></p><p id="600363987ac3776bc472e109917d4090" class="ne-p"><span class="ne-text">为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。</span></p><p id="2d8e54e18dce59911f57770e4ea8f824" class="ne-p"><br></p><h4 id="ec735624"><span class="ne-text">杀死进程恢复</span></h4><p id="b10cebb135de327c0a84909c0003ab1f" class="ne-p"><br></p><p id="1c29d7da30e23b9c755589852bb6efe3" class="ne-p"><span class="ne-text">最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。</span></p><p id="4665eae3b27d917878b8ac71b95d7352" class="ne-p"><br></p><p id="b4068288f1099860bf4bef3010a9cc89" class="ne-p"><span class="ne-text">另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。</span></p><p id="1bb34cd91b0412e04dc1a611adbc6be6" class="ne-p"><br></p><h2 id="9f401114"><span class="ne-text">死锁避免</span></h2><p id="d96231a65e2b63d55b620a5f9679a5f5" class="ne-p"><br></p><p id="460e408b4f85f86b4fc5ffc9c3cabaaa" class="ne-p"><span class="ne-text">我们上面讨论的是如何检测出现死锁和如何恢复死锁，下面我们探讨几种规避死锁的方式</span></p><p id="e2769cc5a198cfa247c1b1e14580c945" class="ne-p"><br></p><h3 id="221804d8"><span class="ne-text">单个资源的银行家算法</span></h3><p id="e89b2e891d5b7f70257c4553152b1789" class="ne-p"><br></p><p id="59b8da1dc357e739ca2d3879ad6138c5" class="ne-p"><span class="ne-text">银行家算法是 Dijkstra 在 1965 年提出的一种调度算法，它本身是一种死锁的调度算法。它的模型是基于一个城镇中的银行家，银行家向城镇中的客户承诺了一定数量的贷款额度。算法要做的就是判断请求是否会进入一种不安全的状态。如果是，就拒绝请求，如果请求后系统是安全的，就接受该请求。</span></p><p id="41faefa6584da64f07618f4036a158d8" class="ne-p"><br></p><p id="7507faed5c63e725af97d762eaec96b0" class="ne-p"><span class="ne-text">类似的，还有多个资源的银行家算法，读者可以自行了解。</span></p><p id="c6c2f8962b34bd84d67b6adae75e4c47" class="ne-p"><br></p><h2 id="1c662b9c"><span class="ne-text">破坏死锁</span></h2><p id="1042b3632351757a6665bfb3b2cab55c" class="ne-p"><br></p><p id="614019792c2d83e0b74de617146216f2" class="ne-p"><span class="ne-text">死锁本质上是无法避免的，因为它需要获得未知的资源和请求，但是死锁是满足四个条件后才出现的，它们分别是</span></p><p id="342083631481cc21a58439f88448ba23" class="ne-p"><br></p><ul class="ne-ul"><li id="7f073eb63fdf3296f66785047892f3da"><span class="ne-text">互斥</span></li><li id="8ec9e0fc4c8a1ce01e825d8cb74487f5"><span class="ne-text">保持和等待</span></li></ul><ul class="ne-ul"><li id="3243ef42ffbe01b313da032f2182b94e"><span class="ne-text">不可抢占</span></li><li id="d45e0cad6dc74d87e3c08fec2ee0f8d8"><span class="ne-text">循环等待</span></li></ul><p id="fe59f031b5ed305654906780fa2edef6" class="ne-p"><br></p><p id="7177a34bdca01a41d03870d15ba1e6a8" class="ne-p"><span class="ne-text">我们分别对这四个条件进行讨论，按理说破坏其中的任意一个条件就能够破坏死锁</span></p><p id="c27bcda5e1b8bdec4067b11fcc6c05d8" class="ne-p"><br></p><h3 id="48c312fb"><span class="ne-text">破坏互斥条件</span></h3><p id="26613ade80fc258b9f36f537ecc823f0" class="ne-p"><br></p><p id="d10c8076c6a1afdc5be18d3da29045a0" class="ne-p"><span class="ne-text">我们首先考虑的就是</span><strong><span class="ne-text">破坏互斥使用条件</span></strong><span class="ne-text">。如果资源不被一个进程独占，那么死锁肯定不会产生。如果两个打印机同时使用一个资源会造成混乱，打印机的解决方式是使用 </span><code class="ne-code"><span class="ne-text">假脱机打印机(spooling printer)</span></code><span class="ne-text"> ，这项技术可以允许多个进程同时产生输出，在这种模型中，实际请求打印机的唯一进程是打印机守护进程，也称为后台进程。后台进程不会请求其他资源。我们可以消除打印机的死锁。</span></p><p id="0075a1624d67b11ba8d15ed77b0e1b7b" class="ne-p"><br></p><p id="4bf1551f195c5c46cf38ed105690a369" class="ne-p"><span class="ne-text">后台进程通常被编写为能够输出完整的文件后才能打印，假如两个进程都占用了假脱机空间的一半，而这两个进程都没有完成全部的输出，就会导致死锁。</span></p><p id="fa76008afa94ebc89b5a16b2f22cd27c" class="ne-p"><br></p><p id="4709a3f6c7bb8468e3d0556402b77cd3" class="ne-p"><span class="ne-text">因此，尽量做到尽可能少的进程可以请求资源。</span></p><p id="95cb9bb0e7f02afb35945ffbb03cb13b" class="ne-p"><br></p><h3 id="1ce8619b"><span class="ne-text">破坏保持等待的条件</span></h3><p id="a0402a5e468f049bcea75885f6bdb094" class="ne-p"><br></p><p id="59a68622dc4bdac082e2cf8505d3a8a3" class="ne-p"><span class="ne-text">第二种方式是如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁。一种实现方式是让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束。如果有任何一个资源处于频繁分配的情况，那么没有分配到资源的进程就会等待。</span></p><p id="cc80a0d7d7adc5e15d896ab15932e1d9" class="ne-p"><br></p><p id="44f4b6bc44f660cc6ec2cb66a0dcab09" class="ne-p"><span class="ne-text">很多进程</span><strong><span class="ne-text">无法在执行完成前就知道到底需要多少资源</span></strong><span class="ne-text">，如果知道的话，就可以使用银行家算法；还有一个问题是这样</span><strong><span class="ne-text">无法合理有效利用资源</span></strong><span class="ne-text">。</span></p><p id="cb584b7d098165ccd9f854d4403c81a7" class="ne-p"><br></p><p id="e4c08e27eb55f0691ba9869f7d983987" class="ne-p"><span class="ne-text">还有一种方式是进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。</span></p><p id="b1b1836523c7189c11cdf7b4a834cab5" class="ne-p"><br></p><h3 id="d83055ce"><span class="ne-text">破坏不可抢占条件</span></h3><p id="83056be73110a576565be358f73dc447" class="ne-p"><br></p><p id="d095796526d11fc7b3a879f40f8b76af" class="ne-p"><span class="ne-text">破坏不可抢占条件也是可以的。可以通过虚拟化的方式来避免这种情况。</span></p><p id="595c68731aa3abbd5a09a8c780c2c6fb" class="ne-p"><br></p><h3 id="75513240"><span class="ne-text">破坏循环等待条件</span></h3><p id="2cce5860fcb20508493132ff4d52c8e7" class="ne-p"><br></p><p id="6bd78a1878c0b44133e8615952a7b6cd" class="ne-p"><span class="ne-text">现在就剩最后一个条件了，循环等待条件可以通过多种方法来破坏。一种方式是制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源。对于需要将大文件从磁带复制到打印机的过程，此限制是不可接受的。</span></p><p id="3e6e2f47972b8cfddb751b8b98fd4e57" class="ne-p"><br></p><p id="ff2b35f6c8e9a28f1b38326659b83623" class="ne-p"><span class="ne-text">另一种方式是将所有的资源统一编号，如下图所示</span></p><p id="c009095ac315c19ae85c392536222bb8" class="ne-p"><br></p><p id="719cfd06171e090674e6588ea72e2514" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830860-d72b0344-264f-4bfe-91f7-43d5b4121f58.png" width="419" id="Nm5h1" class="ne-image"></p><p id="378b45679e11bbc4ae4cbb1bb07f051b" class="ne-p"><br></p><p id="4d406e8ec640206937c30f4f87d1e0df" class="ne-p"><span class="ne-text">进程可以在任何时间提出请求，但是所有的请求都必须按照资源的顺序提出。如果按照此分配规则的话，那么资源分配之间不会出现环。</span></p><p id="33a3a40e0e4503fb2a58f13489a613ad" class="ne-p"><br></p><p id="d0388e319759e7f357c45d4e95179c2e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830858-19d66189-e808-4999-879e-3e2e8d4273f0.png" width="423" id="xulHt" class="ne-image"></p><p id="8c42c0e89584a6d912c13ee84ca0d1da" class="ne-p"><br></p><p id="998a94d4e63eda812da79b5f56e93eea" class="ne-p"><span class="ne-text">尽管通过这种方式来消除死锁，但是编号的顺序不可能让每个进程都会接受。</span></p><p id="65f5a9bf2b2f3359e44646086bf6db51" class="ne-p"><br></p><h2 id="bf52b411"><span class="ne-text">其他问题</span></h2><p id="3b41d963203b64c7498fc565603991b5" class="ne-p"><br></p><p id="d91adc7b4ff6e74ed3b09939b40132d8" class="ne-p"><span class="ne-text">下面我们来探讨一下其他问题，包括 </span><strong><span class="ne-text">通信死锁、活锁是什么、饥饿问题和两阶段加锁</span></strong></p><p id="48288ba7fbb610cf326cedc0d9f0f6d7" class="ne-p"><br></p><h3 id="e8230499"><span class="ne-text">两阶段加锁</span></h3><p id="1e34b78f13fa6ccb27f3e79ce5525ea9" class="ne-p"><br></p><p id="9a404aeba16fe407449e9620f8e60b5a" class="ne-p"><span class="ne-text">虽然很多情况下死锁的避免和预防都能处理，但是效果并不好。随着时间的推移，提出了很多优秀的算法用来处理死锁。例如在数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁定的记录。当同时有多个进程运行时，就会有死锁的风险。</span></p><p id="31bbdd311778f49d2f23e1b5f99582fb" class="ne-p"><br></p><p id="6a87b8d5f0df4dfddf9222397284816e" class="ne-p"><span class="ne-text">一种解决方式是使用 </span><code class="ne-code"><span class="ne-text">两阶段提交(two-phase locking)</span></code><span class="ne-text">。顾名思义分为两个阶段，一阶段是进程尝试一次锁定它需要的所有记录。如果成功后，才会开始第二阶段，第二阶段是执行更新并释放锁。第一阶段并不做真正有意义的工作。</span></p><p id="5b1b66cb117a5aa66675875203023dc1" class="ne-p"><br></p><p id="d0a72b442ed8f3bf7c655ddef2038559" class="ne-p"><span class="ne-text">如果在第一阶段某个进程所需要的记录已经被加锁，那么该进程会释放所有锁定的记录并重新开始第一阶段。从某种意义上来说，这种方法类似于预先请求所有必需的资源或者是在进行一些不可逆的操作之前请求所有的资源。</span></p><p id="6d0daef74b5849a82b735e9072ff2277" class="ne-p"><br></p><p id="40ca79e448a5b8410caca0b328fa6ae5" class="ne-p"><span class="ne-text">不过在一般的应用场景中，两阶段加锁的策略并不通用。如果一个进程缺少资源就会半途中断并重新开始的方式是不可接受的。</span></p><p id="a93254cb959a97f440ed888fe197b863" class="ne-p"><br></p><h3 id="44d2b9b0"><span class="ne-text">通信死锁</span></h3><p id="2130ade79d2e280cb7ddd6f93f606bae" class="ne-p"><br></p><p id="64776094a4eeb9c963f8960bfdd20280" class="ne-p"><span class="ne-text">我们上面一直讨论的是资源死锁，资源死锁是一种死锁类型，但并不是唯一类型，还有通信死锁，也就是两个或多个进程在发送消息时出现的死锁。进程 A 给进程 B 发了一条消息，然后进程 A 阻塞直到进程 B 返回响应。假设请求消息丢失了，那么进程 A 在一直等着回复，进程 B 也会阻塞等待请求消息到来，这时候就产生</span><code class="ne-code"><span class="ne-text">死锁</span></code><span class="ne-text">。</span></p><p id="7b2dca72612d5432be0e4378ee44b636" class="ne-p"><br></p><p id="40989330fbee6643a7ebeab9d1b7f7e8" class="ne-p"><span class="ne-text">尽管会产生死锁，但是这并不是一个资源死锁，因为 A 并没有占据 B 的资源。事实上，通信死锁并没有完全可见的资源。根据死锁的定义来说：每个进程因为等待其他进程引起的事件而产生阻塞，这就是一种死锁。相较于最常见的通信死锁，我们把上面这种情况称为</span><code class="ne-code"><span class="ne-text">通信死锁(communication deadlock)</span></code><span class="ne-text">。</span></p><p id="0cde873bd73f03c66e1e81dfabb9ecff" class="ne-p"><br></p><p id="14dbb722a2f2fd6709732ca83eedd397" class="ne-p"><span class="ne-text">通信死锁不能通过调度的方式来避免，但是可以使用通信中一个非常重要的概念来避免：</span><code class="ne-code"><span class="ne-text">超时(timeout)</span></code><span class="ne-text">。在通信过程中，只要一个信息被发出后，发送者就会启动一个定时器，定时器会记录消息的超时时间，如果超时时间到了但是消息还没有返回，就会认为消息已经丢失并重新发送，通过这种方式，可以避免通信死锁。</span></p><p id="05e534c4b272054adbc3e743bbb87ed5" class="ne-p"><br></p><p id="ebad5559c5e8228b7c32bd7e22a53fcc" class="ne-p"><span class="ne-text">但是并非所有网络通信发生的死锁都是通信死锁，也存在资源死锁，下面就是一个典型的资源死锁。</span></p><p id="43db3302928da79ca9d4847a52057335" class="ne-p"><br></p><p id="d2066eecb8a130f79bde31d4bc952698" class="ne-p"><span class="ne-text">当一个数据包从主机进入路由器时，会被放入一个缓冲区，然后再传输到另外一个路由器，再到另一个，以此类推直到目的地。缓冲区都是资源并且数量有限。如下图所示，每个路由器都有 10 个缓冲区（实际上有很多）。</span></p><p id="fd8d6b4496f962959fbda6d31e8fe14a" class="ne-p"><br></p><p id="4605b8d7affea0247962f50ca34605a0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830887-98d92f9c-72d1-4710-a487-1bd4dc953b7c.png" width="702" id="JN6QA" class="ne-image"></p><p id="3cc175c53ce850923dd266c70fa2d2da" class="ne-p"><br></p><p id="404a0deda9c033b83ccdd5f1e1085499" class="ne-p"><span class="ne-text">假如路由器 A 的所有数据需要发送到 B ，B 的所有数据包需要发送到 D，然后 D 的所有数据包需要发送到 A 。没有数据包可以移动，因为在另一端没有缓冲区可用，这就是一个典型的资源死锁。</span></p><p id="c619f7fb9d739d143fbd13aed16af5e1" class="ne-p"><br></p><h3 id="94c14e72"><span class="ne-text">活锁</span></h3><p id="d58bf9c2b4a5f6bbecbf4b7136473e80" class="ne-p"><br></p><p id="4cf25a1c790a47e1298e729b06421709" class="ne-p"><span class="ne-text">某些情况下，当进程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待非常短的时间再次尝试获取。可以想像一下这个场景：当两个人在狭路相逢的时候，都想给对方让路，相同的步调会导致双方都无法前进。</span></p><p id="65625d90055aa1173e9f493729a8a70a" class="ne-p"><br></p><p id="38424978488c1ad9578cd5c604bd379c" class="ne-p"><span class="ne-text">现在假想有一对并行的进程用到了两个资源。它们分别尝试获取另一个锁失败后，两个进程都会释放自己持有的锁，再次进行尝试，这个过程会一直进行重复。很明显，这个过程中没有进程阻塞，但是进程仍然不会向下执行，这种状况我们称之为 </span><code class="ne-code"><span class="ne-text">活锁(livelock)</span></code><span class="ne-text">。</span></p><p id="2772a3ba2c19ab0d95902ec3f6f3fc3d" class="ne-p"><br></p><h3 id="48073fce"><span class="ne-text">饥饿</span></h3><p id="d44dc6d0b955b9b3194082ba392239a7" class="ne-p"><br></p><p id="d089c608be88bd00f0435afcf9fedf5b" class="ne-p"><span class="ne-text">与死锁和活锁的一个非常相似的问题是 </span><code class="ne-code"><span class="ne-text">饥饿(starvvation)</span></code><span class="ne-text">。想象一下你什么时候会饿？一段时间不吃东西是不是会饿？对于进程来讲，最重要的就是资源，如果一段时间没有获得资源，那么进程会产生饥饿，这些进程会永远得不到服务。</span></p><p id="2cbb310b9cbe820deb2a9140fd73b7b2" class="ne-p"><br></p><p id="2ae27778a42bd6691929243288b93f65" class="ne-p"><span class="ne-text">我们假设打印机的分配方案是每次都会分配给最小文件的进程，那么要打印大文件的进程会永远得不到服务，导致进程饥饿，进程会无限制的推后，虽然它没有阻塞。</span></p><p id="31731cb931d8de3f4bb18fd8da9bc111" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用软件快捷键/CMD/Linux命令及其他使用</title>
      <link href="/blog/nvlr2g/"/>
      <url>/blog/nvlr2g/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue27923e8" class="ne-p"><span class="ne-text">做个记录</span></p><h2 id="3bd7297d"><span class="ne-text">一、软件常用快捷键</span></h2><h3 id="399b57eb"><span class="ne-text">Win10 快捷键</span></h3><div class="ne-quote"><p id="ue7e3c9ce" class="ne-p"><strong><span class="ne-text">HP惠普笔记本</span></strong></p></div><pre data-language="plain" id="69f88db2" class="ne-codeblock language-plain">Win+E                  打开文件管器<p>Win+D 显示桌面<br>Win+L 锁计算机<br>Win+V： 打开剪贴板<br>Win+PgUp： 在桌面选定左上角软件/文件<br>Win+PgDown： 在桌面选定右下角软件/文件<br>Win+G 录频选项<br>Win+alt+G 直接录频</p><p>alt+F4 关闭当前程序</p><p>ctrl+shift+Esc/ctrl+alt+delete：任务管理器<br>ctrl+F 文本或网页中查找（退出一般按 ESC）<br>ctrl+A 选中所有文本</pre><p id="120c3ff4f439846cb54943848d15bdf3" class="ne-p"><br></p><h3 id="b2eab411"><span class="ne-text">Eclipse 快捷键</span></h3><div class="ne-quote"><p id="bdea73380976670588d1c1baf02f4001" class="ne-p"><span class="ne-text">ctrl+shift+L：eclipse 所有快捷键</span></p><p id="e77ac893d4ee87f990183fa01fe086f0" class="ne-p"><code class="ne-code"><span class="ne-text">//</span></code><span class="ne-text">注释：</span><code class="ne-code"><span class="ne-text">ctrl+shift+c</span></code><span class="ne-text">（添加和注释都是这样）或者</span><code class="ne-code"><span class="ne-text">ctrl+/</span></code></p><p id="8a9accc05689f8bfb9fad31f64c81aa3" class="ne-p"><code class="ne-code"><span class="ne-text">/**/</span></code><span class="ne-text">注释：添加</span><code class="ne-code"><span class="ne-text">ctrl+shift+/</span></code><span class="ne-text">   取消</span><code class="ne-code"><span class="ne-text">ctrl+shift+&lt;/span></code></p></div><p id="ed791e406af38c342f82e48be168316b" class="ne-p"><br></p><pre data-language="plain" id="3e8c699f" class="ne-codeblock language-plain">Alt+方向键： 将当前行向上或者向下移动<br>ctrl+m： 编辑窗口最大化（反复两次按即取消）<br>ctrl+.及 ctrl+1： 下一个错误及快速修改<br>Control+O: 快速概要,迅速的跳到一个方法或者属性，只需要输入名字的头几个字母。</p><p>shift+home/end： 选中一行<br>ctrl+pgup/pgdn： 切换页面（浏览器打开的页面/编辑器的多窗口）</pre><p id="c2d932deb2857caa94191943c73f3f3e" class="ne-p"><br></p><h3 id="c02f107e"><span class="ne-text">VScode 快捷键</span></h3><pre data-language="plain" id="46dGR" class="ne-codeblock language-plain">ctrl+shift+c 直接进入博客根目录下的 CMD 模式</pre><p id="de4dafba06a83a8066054b7a922af12f" class="ne-p"><br></p><h3 id="c7b2cf8d"><span class="ne-text">Pycharm/JetBrains 快捷键</span></h3><p id="52fabd9b70e7e013ac8cbe059e06a00a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666000-0fb595f1-51e4-4e71-8547-96aa0b938148.png" width="769" id="E0vxq" class="ne-image"></p><pre data-language="plain" id="2c9506c9" class="ne-codeblock language-plain">Ctrl+F5（左上角）：（return "project"）重新 debug 该文件<br>F9：（resume program）一个断点接着一个断点走，不按行走（eg：有循环会随着 i 一步一步走完）<br>F8：（step over） 一行一行走代码<br>F7：（step into） 进入函数内部<br>Alt+shift+F7：（step into mycode）遇到自己函数 进去<br>shift+F8：（step out）跳出，进入函数后，跳出来<br>Alt+F10：（show execution point）指针显示当前断点旁边<br><strong>Show Python Prompt</strong>按键,交互式调试命令</pre><p id="7005217ed8497e5c69204dce391e17fa" class="ne-p"><br></p><h2 id="eefb7855"><span class="ne-text">二、CMD</span></h2><h3 id="LFTlM"><span class="ne-text">CMD 常用命令</span></h3><div class="ne-quote"><ul class="ne-ul"><li id="3927602bd1d02818e3e89a51366cbb5b"><span class="ne-text">使用 help 命令，查看所有的 dos 命令</span></li><li id="405c3b81ee6e46975e66f0e5eed1aa11"><span class="ne-text">找到命令之后，使用 </span><code class="ne-code"><span class="ne-text">命令+ /?</span></code><span class="ne-text">来查看该命令下的其他属性</span></li></ul><ul class="ne-ul"><li id="e839e8cc93799c32b2f20c32f402ea29"><span class="ne-text">DOS 不区分大小写</span></li></ul></div><p id="ua20d9285" class="ne-p"><strong><span class="ne-text">磁盘/文件夹相关：</span></strong></p><ul class="ne-ul"><li id="607f926ccbd45ff934a3e5f8a07cb96a"><code class="ne-code"><span class="ne-text">d:</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">e:</span></code><span class="ne-text"> 进入不同的盘</span></li><li id="f24e27509e75be8e22d5e375f5afbcd1"><code class="ne-code"><span class="ne-text">cd:</span></code><span class="ne-text"> 进入指定文件夹。注意：只在</span><strong><span class="ne-text">该磁盘</span></strong><span class="ne-text">才有效</span></li></ul><ul class="ne-ul"><li id="98cb68c4fd4a942a202c393f7edbe350"><code class="ne-code"><span class="ne-text">dir</span></code><span class="ne-text"> 查看当前目录下的所有文件，使用 dir /?来查看其它用法</span></li><li id="6a436e74487058fc6747427d0de3ffd6"><span class="ne-text">创建和删除目录</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ff4f4590f077283b4870ee44e92b03fc"><span class="ne-text">md 目录名（文件夹） </span><span class="ne-text">//创建目录</span></li><li id="b1f1dac5d108c5728debfd53a6ce7705"><span class="ne-text">rd   目录名（文件夹） </span><span class="ne-text">//删除目录</span></li></ul></ul><ul class="ne-ul"><li id="41821c16d653fc8b39a699233d31ca04"><span class="ne-text">cd .. 返回上一级文件夹</span></li><li id="3379e065628f52d97723f5835629e225"><span class="ne-text">复制文件:把一个文件移动（就是剪切+复制）到另一个地方。甚至可以改后缀</span></li></ul><div class="ne-quote"><p id="a9ca862d00fc1faa5816fa47652feaa2" class="ne-p"><span class="ne-text">move 路径\文件名 路径\文件名</span></p></div><ul class="ne-ul"><li id="38f3c541c1d41b303e573455b25d7487"><span class="ne-text">删除文件</span></li></ul><div class="ne-quote"><p id="3e36f2cb437c5c773ba909810d2c8a6c" class="ne-p"><span class="ne-text">这个是专门删除文件的，不能删除文件夹</span></p><p id="94da1b9b9e587cb299ed39472ca9f9f2" class="ne-p"><span class="ne-text">del 文件名</span></p></div><ul class="ne-ul"><li id="a84adc927449bb651dfb28fbaf74ee8f"><span class="ne-text">生成文件树</span></li></ul><div class="ne-quote"><p id="93a677d01b8d7e0448e73d7ad489c53c" class="ne-p"><code class="ne-code"><span class="ne-text">tree /f >tree.txt</span></code></p></div><p id="ue179af09" class="ne-p"><strong><span class="ne-text">网络相关：</span></strong></p><ul class="ne-ul"><li id="c9b75a1d8666a2eb9c60654387d6cdd0"><code class="ne-code"><span class="ne-text">ipconfig</span></code><span class="ne-text"> 查看本机 ip</span></li><li id="c1b345eb7de3b34cea40a5b668da465f"><code class="ne-code"><span class="ne-text">cls</span></code><span class="ne-text"> 清除屏幕</span></li></ul><ul class="ne-ul"><li id="c57415e85f061abd7fba07deb50d9f46"><code class="ne-code"><span class="ne-text">ping</span></code></li></ul><div class="ne-quote"><p id="02b3d39ce6cb7f3bec6d34070a32eab6" class="ne-p"><span class="ne-text">用来测试网络是否畅通</span></p><p id="88183e1ede157761a06b4fab6a155521" class="ne-p"><span class="ne-text">ping ip(主机名)</span></p></div><p id="u253bfc2c" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="u5c76b7b9" class="ne-p"><strong><span class="ne-text">其他：</span></strong></p><ul class="ne-ul"><li id="5de76c56311d77dae27e4209e256112d"><span class="ne-text">在文件夹空白处按住 Shift，然后右键弹出快捷菜单，可以看到“在此处打开命令行窗口”</span></li><li id="d0b302a20a4ff3b4a5dfca0e1c2ed896"><span class="ne-text">tab 补齐功能！！！</span></li></ul><ul class="ne-ul"><li id="af6260a701b9561e8fb82946b116dec5"><span class="ne-text">文件及目录名中不能包含下列任何字符：\ / : * ? “ &lt; &gt; |</span></li></ul><h3 id="rXY8a"><span class="ne-text">CMD 默认非 utf-8 编码解决方案</span></h3><p id="cafac0cfae4cb6139cd7ec8cc0616f39" class="ne-p"><span class="ne-text">报错：运行 java 程序时候，如果代码中有中文，会出现中文报错乱码情况/</span></p><ul class="ne-ul"><li id="ua4a38aac"><span class="ne-text">方法一：治标方法</span></li></ul><p id="1452111825f1976fd75cfb28b796321b" class="ne-p"><code class="ne-code"><span class="ne-text">CMD</span></code><span class="ne-text"> 中输入 </span><code class="ne-code"><span class="ne-text">chcp 65001</span></code><span class="ne-text"> 进入 utf-8 模式下的的控制台，再运行程序</span></p><p id="2e94b2cc5f26755152af55f3cf305ddb" class="ne-p"><br></p><ul class="ne-ul"><li id="ub582005a"><span class="ne-text">方法二：治本方法</span></li></ul><p id="f8b4ae39f36b35f5f1f4d1e8c2e0d92a" class="ne-p"><span class="ne-text">注意：自己已经再注册表中增加了一行 tuf-8 编码数据，以后要留意、</span></p><p id="a27e189914f7580368424b96593c879c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666566-625a520c-ff9d-4eea-8fba-3a8c4f8f696e.png" width="660" id="SsvdB" class="ne-image"></p><p id="ufb328a5e" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="uce8d5854"><span class="ne-text"></span><a href="https://blog.csdn.net/gulang03/article/details/81771343" data-href="https://blog.csdn.net/gulang03/article/details/81771343" target="_blank" class="ne-link"><span class="ne-text">修改 cmd 控制台默认代码页编码的几种方法【GBK、UTF-8】</span></a><span class="ne-text">  </span></li><li id="u65364600"><span class="ne-text"></span><a href="https://blog.csdn.net/runAndRun/article/details/103072938" data-href="https://blog.csdn.net/runAndRun/article/details/103072938" target="_blank" class="ne-link"><span class="ne-text">windows 控制台 cmd/PowerShell 中文显示乱码，解决方法</span></a></li></ul><p id="605fe6b12178050bbb69ae94a2652acc" class="ne-p"><br></p><h3 id="K0ElO"><span class="ne-text">CMD 运行 JAVA 文件</span></h3><h4 id="jukMj"><span class="ne-text">CMD 运行 java 程序</span></h4><p id="07bc59222091968043ea5c856bdd5014" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666652-cb97d69b-664c-4506-a24f-1dc5b8220a02.png" width="902" id="B6IyR" class="ne-image"></p><h4 id="JDJ2n"><span class="ne-text">命令行参数</span></h4><p id="5a84f710a699b7b629244cf6c93a312f" class="ne-p"><br></p><ul class="ne-ul"><li id="ue1c1cdb7"><span class="ne-text">main 主函数可以看成一个普通的方法，也可以传递实参来调用普通方法</span></li></ul><p id="a08a7fb3ab5ef55915a0df01870af9aa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666759-75d2a062-c52d-4c49-acce-7310a0280f24.png" width="455" id="T7PKm" class="ne-image"></p><p id="u2debd83c" class="ne-p"><br></p><ul class="ne-ul"><li id="u624b28c4"><span class="ne-text">向 main 方法传递字符串</span></li></ul><p id="u9235dd32" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666878-98ce351e-4485-4381-bcfe-4b9121226fc9.png" width="292" id="PYoCa" class="ne-image"></p><p id="ed07c459310efec65b0d30d169a54ecf" class="ne-p"><br></p><h4 id="YcFdg"><span class="ne-text">CMD 下运行 Java 中文乱码</span></h4><p id="69cd2d33791350065c0ba63567786f57" class="ne-p"><code class="ne-code"><span class="ne-text">javac -encoding utf-8 test.java</span></code></p><p id="a333b05d84ff6f30ef36975eaba24097" class="ne-p"><span class="ne-text">还是上面的问题，DOS 默认使用的编码是 GBK,这里需要再编译的时候制定使用的编码</span></p><h2 id="u5wpj"><span class="ne-text">三、Linux</span></h2><h3 id="glaz1"><span class="ne-text">Linux 命令</span></h3><p id="uf5ee9737" class="ne-p"><span class="ne-text">查看 CentOS 版本：</span></p><pre data-language="bash" id="H8mzx" class="ne-codeblock language-bash">cat /etc/redhat-release</pre><p id="u5ca36bee" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1643018844135-441f0c04-500b-4dd4-97a3-d11edc72cae3.png" width="366" id="Q1RIE" class="ne-image"></p><p id="uc2252afe" class="ne-p"><span class="ne-text">在此可以去学习 Linux 相关命令，如果只是用 xshell 不适用其他软件，那么 linux 的使用很重要</span></p><h3 id="YEMJR"><span class="ne-text">Linux yum 命令</span></h3><p id="uad7448a3" class="ne-p"><span class="ne-text">Linux yum 命令参考：</span><a href="https://www.runoob.com/linux/linux-yum.html" data-href="https://www.runoob.com/linux/linux-yum.html" target="_blank" class="ne-link"><span class="ne-text">https://www.runoob.com/linux/linux-yum.html</span></a></p><div class="ne-quote"><p id="u893049a5" class="ne-p"><span class="ne-text">是一个终端的前端软件包管理器</span></p></div><p id="uf4a649de" class="ne-p"><span class="ne-text">更新 CentOS 版本：</span></p><pre data-language="bash" id="nLfa7" class="ne-codeblock language-bash">yum -y update</pre><p id="u0249c4b9" class="ne-p"><br></p><p id="u47193685" class="ne-p"><br></p><p id="u68c50299" class="ne-p"><br></p><p id="u8f6b646b" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter使用总结</title>
      <link href="/blog/ouipza/"/>
      <url>/blog/ouipza/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h2 data-lake-id="56ba6a2aadcb3630c55544debb007a72" id="buLMf" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">一、Jupyter环境的搭建</h2><ol start="1" data-lake-id="40fa4ba87608aa8e704716aabb4154c9" lake-indent="0" style="list-style-type: decimal; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="a01b2ca87d4d3df7fc74dd1df2d58a62">pip下载</li><li data-lake-id="f082b39258209d6b76215f87aff2b5b1">跟随anaconda下载</li></ol><h2 id="416a4b37" data-lake-id="bf37cba4da19cfb76cdb6df28a5cd8b8" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">二、高效使用，安装扩展插件</h2><p data-lake-id="c9e3c37f9d7768bffc93951055eafb5e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="32347bdf3fa90460c3fa3cfdf936809f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">一般只需要下面两条命令，就可以重新打开就可看见新安装的插件环境。</p><p data-lake-id="732f0645a831af474306b8fb57c33f1f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="f8e24e384b337503d7d273a85a5a79f9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">pip install jupyter_contrib_nbextensions</code></p><p data-lake-id="9919269fc924edd9519b6e188c76b5c7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="1751a12d41007ec962b0877ae0bbc405" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">或者</p><p data-lake-id="6e5cb1089e09787c400381bb39a136af" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ecfe4f64833f809ac16bf66ad8f36539" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">jupyter contrib nbextension install</code></p><p data-lake-id="24f41e0a6ec74af298a89bff9c8b7272" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="392b8fb1344b016d9cef2fa505e39386" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">但是pip下载完，会出现jupyter_contrib_nbextension扩展功能后不显示Nbextensions标签的bug，在此记录下解决的方式。</p><p data-lake-id="c154a1dbdc5e89aeca3978a73887a22f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 id="a0cd3a84" data-lake-id="be67711a150e8eaa72d1e320417eac73" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">三、扩展插件不显示的解决方法</h2><ol start="1" data-lake-id="fb6a9f3c8ab172db73e2aef993d8ced4" lake-indent="0" style="list-style-type: decimal; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="4a187725778ef6d8905618c889e5ee33">如果之前已经用上述两条命令之一安装了上述包，且用pip list查看的确成功安装，则依次进行下面删除命令（选y）:<br><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">pip uninstall jupyter_contrib_nbextensions</code><br><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">pip uninstall jupyter_nbextensions_configurator</code></li><li data-lake-id="a83d952c0523d604251e3f5c66d2d920">打开Anaconda Prompt窗口，执行第一个命令，用于安装nbextensions:<br><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">pip install jupyter_contrib_nbextensions</code></li><li data-lake-id="4f8650666c7d618e826b11abab8e47b2">再执行第下面命令，用于安装 javascript and css files:<br><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">jupyter contrib nbextension install --user</code></li><li data-lake-id="dc49571735d62404e28b3529dccff553">最后执行，用于安装configurator:<br><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">pip install jupyter_nbextensions_configurator</code></li></ol><p data-lake-id="1cb9391eb292bce0ca353a387e40781c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 id="d17a0f0b" data-lake-id="4a9c3bd7a0e4d6a5d575ee115fc72bd1" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">参考</h2><ul data-lake-id="6979e188c8b503b2b577ebb51cf921b5" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="29eaa12b9c8445118a8e100e8ea3dceb"><a href="https://www.jiqizhixin.com/articles/2018-12-20-12" target="_blank">五个常用插件 - 简书</a></li><li data-lake-id="91b347d7e1b074a113a0af62adbbbad7"><a href="https://www.zhihu.com/question/59392251/answer/560977151" target="_blank">如何优雅地使用 Jupyter？ - 量子位的回答 - 知乎</a></li><li data-lake-id="37018b913cede6b141d38ddb221a577c"><a href="https://blog.csdn.net/xiaodongxiexie/article/details/54633183" target="_blank">jupyter使用技巧</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置java开发环境</title>
      <link href="/blog/cwqx6l/"/>
      <url>/blog/cwqx6l/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="WJsSs"><span class="ne-text">一、下载</span></h2><p id="94772b8776b4506a079808b9228b9c9c" class="ne-p"><a href="https://www.oracle.com/cn/java/technologies/javase-downloads.html" data-href="https://www.oracle.com/cn/java/technologies/javase-downloads.html" target="_blank" class="ne-link"><span class="ne-text">https://www.oracle.com/cn/java/technologies/javase-downloads.html</span></a></p><h2 id="bee77271"><span class="ne-text">二、环境变量配置</span></h2><p id="f886bb5195ea880247108a59eb8e2b6e" class="ne-p"><br></p><p id="f1d5d1261b875f365fc36f6be911a261" class="ne-p"><strong><span class="ne-text">在系统变量下</span></strong></p><h3 id="CLASSPATH"><span class="ne-text">CLASSPATH</span></h3><p id="71a2668cb130c53f0fe8d76a38047dac" class="ne-p"><br></p><div class="ne-quote"><p id="035722a81469fb0db03ac69dc6c54600" class="ne-p"><span class="ne-text">.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;%CATALINA_HOME%\common\lib\servlet-api.jar;</span></p></div><p id="677a6fedc7a89dfa14cec6fe3e1ef35d" class="ne-p"><br></p><p id="f80a605c210254a888b22a01def5ccbf" class="ne-p"><span class="ne-text">其中</span><code class="ne-code"><span class="ne-text">%CATALINA_HOME%\common\lib\servlet-api.jar;</span></code><span class="ne-text">为tomcat的加包配置</span></p><p id="6a9ee80a570cb539d084e9a6898da2d2" class="ne-p"><br></p><h3 id="JAVA_HOME"><span class="ne-text">JAVA_HOME</span></h3><p id="e32350bfb5757a8d058339b41dd956fa" class="ne-p"><br></p><div class="ne-quote"><p id="7b87dce1888ff435832173cdf57f39ec" class="ne-p"><span class="ne-text">C:\Program Files\Java\jdk1.8.0_181</span></p></div><p id="e1c7994756c1a755c19bd9d0edccdb36" class="ne-p"><br></p><h3 id="path"><span class="ne-text">path</span></h3><p id="1e2011831fa3a492ec008f7223d4883f" class="ne-p"><br></p><div class="ne-quote"><p id="6bf05e9fbf30409695a41940b299fd35" class="ne-p"><span class="ne-text">%JAVA_HOME%\bin</span></p><p id="e537226076a33a8f21c8f7ea442b963f" class="ne-p"><span class="ne-text">%JAVA_HOME%\jre\bin</span></p></div><p id="61299833e917408aa80c4bc2cafc883c" class="ne-p"><br></p><h2 id="f01972f5"><span class="ne-text">三、测试</span></h2><p id="3be498e236daeb86f2b232624a6b7cbf" class="ne-p"><br></p><p id="d0d6e7019cd6ca595dd20974fcbb508c" class="ne-p"><span class="ne-text">CMD下输入</span><code class="ne-code"><span class="ne-text">java -version</span></code></p></div>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm,Anaconda,JetBrains系列app相关总结</title>
      <link href="/blog/mv7tir/"/>
      <url>/blog/mv7tir/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="ndOrX"><span class="ne-text">一、Anaconda和Pycharm下载与配置</span></h2><h3 id="09d85f5c"><span class="ne-text">下载Anaconda且配置</span></h3><ul class="ne-ul"><li id="5b583420df7679ff7fe5d8d3a223aa47"><span class="ne-text">（更新）下载了anaconda就不要单独下载python，之前下的也删掉，以此避免路径冲突</span></li><li id="521f6e7f65f820fd63c96665ccee3a21"><span class="ne-text">方式一：</span><strong><span class="ne-text">迅雷下载</span></strong><span class="ne-text">（推荐）；方式二：提取链接</span><strong><span class="ne-text">网盘下载</span></strong><span class="ne-text">；方式三：清华镜像下载，下载完安装【直接next即可】</span></li></ul><ul start="3" class="ne-ul"><li id="d0f5d7fd01611a5ca208d65e3265dce6"><strong><span class="ne-text">测试</span></strong><span class="ne-text">：</span><code class="ne-code"><span class="ne-text">win + R</span></code><span class="ne-text"> 进入终端输入</span><code class="ne-code"><span class="ne-text">conda</span></code><span class="ne-text">出现conda命令使用指南，即证明成功安装</span></li><li id="421b7a496e3fb30a523eb33868861881"><strong><span class="ne-text">配置环境变量</span></strong><span class="ne-text">：在</span><strong><span class="ne-text">系统变量</span></strong><span class="ne-text">path路径中加入下面配置（具体路径具体填写）</span></li></ul><p id="f5302e4b4d6949a4f63740c1de14cbb1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606634508207-8eb4dda2-6dbe-4162-b7eb-93cc5b35dc0e.png" width="296" id="oIosg" class="ne-image"></p><p id="cd71b789b6e9ce7a7294133a080076e1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606634439956-bfa830a0-ece9-4caa-9bf7-641b14dafd70.png" width="322.5" id="v6rw7" class="ne-image"></p><h3 id="18a731be"><span class="ne-text">下载Pycharm且配置</span></h3><p id="4538e0858e3013d02f248b1e37143de6" class="ne-p"><br></p><ul class="ne-ul"><li id="f64d6672b36400cdab083604f5bf1567"><strong><span class="ne-text">下载版本</span></strong><a href="https://www.jetbrains.com/pycharm/download/" data-href="https://www.jetbrains.com/pycharm/download/" target="_blank" class="ne-link"><span class="ne-text">社区/专业</span></a><span class="ne-text">：专业版本需要激活码，社区版本功能基本能应付日常使用  </span></li></ul><div class="ne-quote"><p id="ba7660b3fee571ec954f8c3df51b13c1" class="ne-p"><span class="ne-text">（大学学生时期可以用学生邮箱申请使用JetBrains系列软件，我的方法是先认证GitHub学生认证，然后直接从GitHub那边认证JetBrains软件的使用权，当然也可以直接用学生邮箱去</span><span class="ne-text">JetBrains官网认证</span><span class="ne-text">）</span></p></div><ul class="ne-ul"><li id="d73d3a26f1ffb98af76765e9ff8b7dad"><strong><span class="ne-text">❗补充：取消上面用学生邮箱去申请JetBrains系列软件使用方法。先去GitHub申请学生包，然后通过GitHub已认证的GitHub账号再去申请JetBrains系列软件较为方便 </span></strong><a href="https://www.jetbrains.com/zh-cn/community/education/?_ga=2.186354217.1063699871.1594345232-1379189663.1590592761#students" data-href="https://www.jetbrains.com/zh-cn/community/education/?_ga=2.186354217.1063699871.1594345232-1379189663.1590592761#students" target="_blank" class="ne-link"><strong><span class="ne-text">JetBrains申请链接🔗</span></strong></a></li><li id="6627c491cfc17582e85b9017c1422c6c"><span class="ne-text">Pycharm使用Anaconda的配置 （ </span><strong><span class="ne-text">❗补充：下面貌似是社区版本的添加方式，但是专业版本会自动识别</span></strong><span class="ne-text"> ）：</span></li></ul><p id="3245f1276e7df950545157d7329f1df8" class="ne-p"><br></p><p id="e653c63091219f644a6ad2818a73dbde" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306285-e6ca8228-9234-4c7f-97f3-9d7fc26e0728.png" width="456" id="yAxpP" class="ne-image"></p><p id="cef888c4d3dd9a1407d485f7c2acf49a" class="ne-p" style="text-align: center"><br></p><p id="3228284acfbdbbb38b8884c152ffeb1e" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306347-9a79eaf2-93cf-4ed4-b008-9e49aa66ad7e.png" width="449" id="bePXH" class="ne-image"></p><p id="a5ab58c06206e67eb6d8da0b1a2f7acc" class="ne-p"><br></p><h2 id="b619559f"><span class="ne-text">二、Anaconda环境管理</span></h2><h3 id="c97910bc"><span class="ne-text">pip,conda,Miniconda,Anaconda</span></h3><ul class="ne-ul"><li id="c8c8d8abf2f967f951edb34d961fa96a"><span class="ne-text">pip包管理工具，python官方认证</span></li><li id="150127e1633fcdee1bd7d69a18131474"><span class="ne-text">conda是一种通用包管理系统，旨在构建和管理任何语言和任何类型的软件。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并可以快速切换。</span></li></ul><ul start="3" class="ne-ul"><li id="f0a6d15b030758f36511b53a06ad49c2"><span class="ne-text">Anaconda则是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等等，就是把很多常用的不常用的库都给你装好了。同时利用配置/工具/命令conda来进行package和</span><strong><span class="ne-text">environment</span></strong><span class="ne-text">的管理。</span></li><li id="946c7739d525be202b7f8dc7da9488d8"><span class="ne-text">Miniconda，它只包含最基本的内容——python与conda，以及相关的必须依赖项，对于空间要求严格的用户，Miniconda是一种选择。就只包含最基本的东西，其他的库得自己装。</span></li></ul><p id="02db07711cdc4d4718350ebac88634d8" class="ne-p"><br></p><div class="ne-quote"><p id="7c199d10645ebf43f4514690048a6e19" class="ne-p"><span class="ne-text">pip下载/管理经常bug，用conda结合anaconda/miniconda方便使用</span></p></div><h3 id="3f08ea70"><span class="ne-text">Python相关包路径的查看</span></h3><ul class="ne-ul"><li id="911faa86ef04d4ad01862589ec865a2f"><code class="ne-code"><span class="ne-text">win+R</span></code><span class="ne-text">  输入</span><code class="ne-code"><span class="ne-text">cmd</span></code><span class="ne-text">  输入</span><code class="ne-code"><span class="ne-text">python</span></code><span class="ne-text"> 输入</span><code class="ne-code"><span class="ne-text">import sys</span></code><span class="ne-text"> 输入</span><code class="ne-code"><span class="ne-text">sys.path</span></code></li><li id="30fc1d7e96b3ece62750b62dfca75e60"><span class="ne-text">标准库：anaconda文件夹下的lib文件夹</span></li></ul><ul start="3" class="ne-ul"><li id="8adb84260bada17144ec2204ca0c52ab"><span class="ne-text">第三方库：下述代码中的文件夹 </span><code class="ne-code"><span class="ne-text">C:\Users\wztli\Anaconda3\Lib\site-packages</span></code><span class="ne-text"> </span></li></ul><h3 id="70776e8d"><span class="ne-text">Sklearn包安装失败总结</span></h3><p id="506bb4edaa8f67b3cd799b010f47a1c8" class="ne-p"><span class="ne-text">安装scikit-learn包，导入sklearn的Bug</span></p><p id="380e07e949f424f1e9f7bc8833a2d8a1" class="ne-p"><br></p><pre data-language="powershell" id="31ae91c9" class="ne-codeblock">ImportError: DLL load failed: 找不到指定的模块</pre><p id="08d5f71abfa3c7dfad37fd04841f4290" class="ne-p"><br></p><p id="838f836e6895b0a7df63c832666f08b8" class="ne-p"><code class="ne-code"><span class="ne-text">scikit-learn</span></code><span class="ne-text">的下载会对numpy、scipy、joblib三个库相应版本有所要求，总之如果用anaconda的话，全部更新为最新即可（</span><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" data-href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" class="ne-link"><span class="ne-text">参考whl版本</span></a><span class="ne-text">）</span></p><div class="ne-quote"><ul class="ne-ul"><li id="01cc0500ee9b19e4153fffcc7b8fd025"><code class="ne-code"><span class="ne-text">C:\Users\wztli\Anaconda3\pkgs\scikit-learn-0.21.3-py37h6288b17_0\Lib\site-packages\sklearn\datasets\data</span></code></li><li id="723db2c7b107cb97ebce7465d489163f"><span class="ne-text">数据集在电脑中的位置</span></li></ul></div><h3 id="f184b6a9"><span class="ne-text">Scrapy包安装失败总结</span></h3><ul class="ne-ul"><li id="899cc91773bf069836a9eb066c193c26"><span class="ne-text">pip 下载可能会失败</span></li><li id="fb616eae9a1af9b577805a7266fe51b0"><span class="ne-text">使用conda（镜像）下载</span><code class="ne-code"><span class="ne-text">conda install -c scrapinghub scrapy</span></code></li></ul><h2 id="0d03af7f"><span class="ne-text">三、JetBrains系列软件的高效使用</span></h2><p id="d26622e9592b03713e605fe1b43f0249" class="ne-p"><br></p><h3 id="1622395b"><span class="ne-text">JetBrains之初始配置</span></h3><div class="ne-quote"><p id="11afb75f70cb0240cc46ea033f859cda" class="ne-p"><span class="ne-text">界面字体大小、代码字体大小、主题默认（dark）、背景图片（看心情）</span></p></div><ul class="ne-ul"><li id="17d7cf8184578db6ea6345bf167dc21a"><span class="ne-text">字体相关<p></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306645-d747b801-f817-475d-93e7-a9357a6f810b.png" width="393" id="vCu8H" class="ne-image"></li><li id="136335ae542e2d015ebc18bd03cba84d"><span class="ne-text">主题相关<br></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306383-6425ce01-32e1-4216-b62e-def25d1e9dc7.png" width="398" id="GQ6ez" class="ne-image"></li></ul><p id="ed5f3f81e5f9b1d801dc74510cd6437f" class="ne-p"><br></p><h3 id="f0290bfc"><span class="ne-text">JetBrains 之 Debug 断点调试</span></h3><div class="ne-quote"><p id="d4a6ec2c32e163f1eb981d46ad9d841e" class="ne-p"><span class="ne-text">断点调试是优于打印输出的一种调试程序的一种手段（Pycharm 编辑器，其他系列软件也一样）</span></p></div><p id="528191a61afa960709f80aacb3d7ef17" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306462-78e560c3-6150-4b08-b806-34919a36f0a2.png" width="548" id="D1jlp" class="ne-image"></p><div class="ne-quote"><ul class="ne-ul"><li id="801a4a62cdadbc50b2beddfc1f40b57b"><span class="ne-text">Ctrl+F5（左上角）：（return “project”）重新 debug 该文件</span></li><li id="4cb64363e695431381fbe14de9502593"><span class="ne-text">F9：（resume program）一个断点接着一个断点走，不按行走（eg：有循环会随着 i 一步一步走完）</span></li></ul><ul start="3" class="ne-ul"><li id="da350373c9f4444865f1073e93c589b9"><span class="ne-text">F8：（step over） 一行一行走代码</span></li><li id="455b1850e833c1d52b7c1ab50dffb664"><span class="ne-text">F7：（step into） 进入函数内部</span></li></ul><ul start="5" class="ne-ul"><li id="1606e718138e730c14ffb93f9af6b33c"><span class="ne-text">Alt+shift+F7：（step into mycode）遇到自己函数   进去</span></li><li id="c465b4b3662801cafbd6e4373b7f3e3b"><span class="ne-text">shift+F8：（step out）跳出，进入函数后，跳出来</span></li></ul><ul start="7" class="ne-ul"><li id="9344e302477f2e0f18e3ad96db604ac1"><span class="ne-text">Alt+F10：（show execution point）指针显示当前断点旁边</span></li><li id="d99caaf48a61b89b0582c0e1974bb0a9"><strong><span class="ne-text">Show Python Prompt</span></strong><span class="ne-text">按键<br></span><span class="ne-text">交互式调试命令</span></li></ul></div><p id="8e396fe0c8c29f88b815a511a7c10205" class="ne-p"><br></p><h3 id="74d4f47a"><span class="ne-text">JetBrains 之 GitHub 使用</span></h3><ol class="ne-ol"><li id="e11bd32c211d809c2269532ae256e962"><span class="ne-text">配置 Git 和 GitHub（先连接本地 git，然后登录 GitHub）<br></span><span class="ne-text">页面   依次点击</span><code class="ne-code"><span class="ne-text">File</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">Setting</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">Version Control</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">GitHub</span></code><span class="ne-text">然后登录账户进行配置</span></li><li id="96d226a7fb1175b7d6addcfaa92de00e"><span class="ne-text">将项目新建在 GitHub<br></span><span class="ne-text">菜单栏 依次点击 </span><code class="ne-code"><span class="ne-text">VCS</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">Import into Version Control</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">Share Project on GitHub</span></code></li></ol><ol start="3" class="ne-ol"><li id="3d4d3d4276b82ebd9f6845881142fba7"><strong><span class="ne-text">将项目克隆在本地</span></strong><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">VCS</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">Get from Version Control</span></code></li></ol><p id="ad02bc6276d4c5b30f5b30730ffe5224" class="ne-p"><br></p><h3 id="3dbad505"><span class="ne-text">JetBrains 之 TODO 使用</span></h3><p id="8adbfdd10501735ae6023cd64a261d41" class="ne-p"><br></p><p id="d52d13f5de31f6d887f8c469247e34ee" class="ne-p"><span class="ne-text">便于编写大型代码，将注释加上前缀以便分类处理，以下图片展示</span></p><p id="4ae3bedb4c1fd505b952f1986d26db8a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306509-efc968a4-bf76-44f3-8347-52cbb5a7cc73.png" width="1890" id="ztWN4" class="ne-image"></p><p id="0337881be11eb88f7a8cad53a1137f80" class="ne-p"><br></p><p id="855614a664f4e7c65265683f425f7a73" class="ne-p"><span class="ne-text">参考：</span></p><p id="8a5aa92c0a6d736fba4b85474fc4eb2b" class="ne-p"><br></p><ul class="ne-ul"><li id="b64832b39b804a9aeb68372adf518c4e"><a href="https://www.jetbrains.com/help/pycharm/using-todo.html" data-href="https://www.jetbrains.com/help/pycharm/using-todo.html" target="_blank" class="ne-link"><span class="ne-text">TODO 的使用官方文档</span></a></li><li id="e8247593617bd5e1e692363a7095ef7e"><a href="https://blog.csdn.net/weixin_34277853/article/details/94205060?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5" data-href="https://blog.csdn.net/weixin_34277853/article/details/94205060?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5" target="_blank" class="ne-link"><span class="ne-text">TODO 的用法</span></a></li></ul><p id="a33bf6e407a76e006fb093752a4261c0" class="ne-p"><br></p><h3 id="5bbec828"><span class="ne-text">JetBrains 之插件枚举</span></h3><p id="b1ea30bc232d6c5c99379ba41682de0b" class="ne-p"><br></p><ul class="ne-ul"><li id="3e7d0bc5fe585cbb239f5549a82e8ca5"><span class="ne-text">Waka Time：持续记录自己的 IDE 以及编程语言的使用时长</span></li><li id="eac501f074858261f0f434aa1426e48e"><span class="ne-text">leetcode editor：leetcode 刷题插件</span></li></ul><p id="823ba2e2781c8defccc6d81b8eba1145" class="ne-p"><br></p><h3 id="f617d329"><span class="ne-text">JetBrains 之初用警告</span></h3><p id="4217510e20bb7a9fa04e27b16f138791" class="ne-p"><br></p><p id="78da0b88600a975ff3bd32d9705a9416" class="ne-p"><span class="ne-text">一般下载完开始使用，IDE 会报一个 </span><code class="ne-code"><span class="ne-text">Windows 安全中心</span></code><span class="ne-text"> 的警告</span></p><p id="21b3546d1f182a772f009d0083823bf9" class="ne-p"><br></p><pre data-language="plain" id="44f95de6" class="ne-codeblock">Windows Defender might be impacting your build performance. PyCharm checked the following directorie</pre><p id="2b33e7d685046fa2ba58efc4b432efdc" class="ne-p"><br></p><p id="a6b10e823b0543fd4e11ab620088fa41" class="ne-p"><span class="ne-text">解决：</span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306961-bcb04392-e8c2-4f3a-a7f0-d2d1516afe70.png" width="1184" id="ReCbv" class="ne-image"></p><p id="5d765564e7f3603c9bd1bf045264b7fb" class="ne-p"><span class="ne-text">然后再进入排除项添加报错的文件夹即可</span></p><h3 id="G1n7V"><span class="ne-text">JetBrains 之 IDEA 的 leetcode 插件</span></h3><div class="ne-quote"><p id="b62bcededdb88acbb63947d2562e4d99" class="ne-p"><span class="ne-text">记录一些配置</span></p></div><ul class="ne-ul"><li id="eb50ac1320c6384ace03a89de6d6ca7d"><span class="ne-text">勾选 Custom Template 和 Plugin Update</span></li><li id="e2506bb664864e15138b5b55354f5b1d"><span class="ne-text">TempFilePath</span></li></ul><pre data-language="plain" id="26emH" class="ne-codeblock">D:\project-java\datastructure\src\com\wztlink1013\problems</pre><ul class="ne-ul"><li id="b143f9a217847a9a936fbde44b7a9387"><span class="ne-text">CodeFileName</span></li></ul><pre data-language="plain" id="gEVkR" class="ne-codeblock">P${question.frontendQuestionId}$!velocityTool.camelCaseName(${question.titleSlug})</pre><ul class="ne-ul"><li id="39be212120668d85699c12f435fe64e2"><span class="ne-text">CodeTemplate</span></li></ul><pre data-language="plain" id="lEiNw" class="ne-codeblock">package com.wztlink1013.problems.leetcode.editor.cn;</p><p>${question.content}<br>public class P${question.frontendQuestionId}$!velocityTool.camelCaseName(${question.titleSlug}){<br>public static void main(String[] args) {<br>Solution solution = new P${question.frontendQuestionId}$!velocityTool.camelCaseName(${question.titleSlug})().new Solution();</p><pre><code>&#125;</code></pre><p>${question.code}<br>}</pre><p id="ed3b870db39cb22965aa08fdd660138d" class="ne-p"><br></p><p id="18ec4628e8a6d2592815ad0222051f1a" class="ne-p"><span class="ne-text">参考：</span></p><p id="d6a4c36f44385c5c18a7e4fabb3317e1" class="ne-p"><a href="https://blog.csdn.net/yxf19034516/article/details/106087994/" data-href="https://blog.csdn.net/yxf19034516/article/details/106087994/" target="_blank" class="ne-link"><span class="ne-text">IDEA 的 LeetCode 力扣插件设置与使用</span></a></p><p id="e4ec6bfdeda4c0f63e7777918ef26a0a" class="ne-p"><a href="https://hacpai.com/article/1575547715310" data-href="https://hacpai.com/article/1575547715310" target="_blank" class="ne-link"><span class="ne-text">IDEA 的 LeetCode 刷题插件 leetcode editor</span></a></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git使用Token连接</title>
      <link href="/blog/lg6q7n/"/>
      <url>/blog/lg6q7n/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u86415782" class="ne-p"><br></p><h2 id="5d4c567c"><span class="ne-text">一、应用</span></h2><p id="a1d791bd6206c9e714ac671ac749ab7d" class="ne-p"><span class="ne-text">多个终端使用，而且没必要配置SSH连接的情况，可以使用GitHub Token来连接使用。还有就是使用GitHub Actions时候用Token情况较SSH方便。</span></p><p id="dbcb0542983e256653a696e0108ad94f" class="ne-p"><br></p><p id="3e7c0edd1b7bd266032da9d8ae4daa89" class="ne-p"><span class="ne-text">不同的托管平台使用语法会有差异，在此记录下GitHub、Coding、Gitee的使用</span></p><p id="27795895dadbf965d1a132764a884e1f" class="ne-p"><br></p><h2 id="ae698d41"><span class="ne-text">二、GitHub</span></h2><p id="a7f51f5b1e7cfef03ceef858cf2eac15" class="ne-p"><br></p><p id="572d39f3c50b153e73bef188725562f6" class="ne-p"><span class="ne-text">GitHub生成一个Token：***</span></p><p id="ad80b074987bd3e6eebd8f02faa1b0fc" class="ne-p"><br></p><p id="e3a11c6096ddc9a44a904eed7ed7713f" class="ne-p"><span class="ne-text">使用SSH情况：</span><code class="ne-code"><span class="ne-text">git clone </span><a href="https://github.com/wztlink1013/blog3.0.git" data-href="https://github.com/wztlink1013/blog3.0.git" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wztlink1013/blog3.0.git</span></a></code></p><p id="a20bad5a1195060fb1a983435c958666" class="ne-p"><br></p><p id="ba900a44b11cf91921b8579b57117fc6" class="ne-p"><span class="ne-text">使用Token情况：</span><code class="ne-code"><a href="https://x-access-token:**************@github.com/wztlink1013/blog3.0.git" data-href="https://x-access-token:**************@github.com/wztlink1013/blog3.0.git" target="_blank" class="ne-link"><span class="ne-text">https://x-access-token:**************@github.com/wztlink1013/blog3.0.git</span></a></code></p><p id="8bb442f9c95f69fd6ebb4c62d498fb33" class="ne-p"><br></p><h2 id="7a90c0c0"><span class="ne-text">三、Coding</span></h2><p id="e58023abd48b8bd2d25a5d3d8afa6e75" class="ne-p"><br></p><p id="3b96fa754226156cd18a4255afcd133b" class="ne-p"><span class="ne-text">在个人设置中设置一个访问令牌</span></p><p id="7bb9b07f75c581244e2f9a1d32bf79c8" class="ne-p"><br></p><ul class="ne-ul"><li id="7b67b64ea6240ba3e3161611c827469d"><span class="ne-text">令牌用户名：####</span></li><li id="4e81b1dcd3551160ea65e76f4dea0eb0"><span class="ne-text">令牌Token：*</span></li></ul><p id="dde0302fb7e02d28f7d482bc09ff76d6" class="ne-p"><br></p><p id="043b79557c7a8d60f336dc6ce4f8ea85" class="ne-p"><span class="ne-text">使用SSH情况：</span><code class="ne-code"><a href="https://e.coding.net/wztlink1013/project/repo.git" data-href="https://e.coding.net/wztlink1013/project/repo.git" target="_blank" class="ne-link"><span class="ne-text">https://e.coding.net/wztlink1013/project/repo.git</span></a></code></p><p id="dc52361d87396b8c9a34133508c18c65" class="ne-p"><span class="ne-text">使用令牌情况：</span><code class="ne-code"><a href="https://####:***********@e.coding.net/wztlink1013/project/repo.git" data-href="https://####:***********@e.coding.net/wztlink1013/project/repo.git" target="_blank" class="ne-link"><span class="ne-text">https://####:***********@e.coding.net/wztlink1013/project/repo.git</span></a></code></p><p id="d3869df8023a8cd7ebc75bee50305598" class="ne-p"><br></p><h2 id="88be64df"><span class="ne-text">四、Gitee</span></h2><p id="4dc85e09f4c1105689b96ade345939df" class="ne-p"><br></p><p id="b4823addcf0e04d1a84475b5c78c653a" class="ne-p"><span class="ne-text">头像设置中申请私人令牌：**</span></p><p id="36afefacb9aa992c5b51b90b44ed587b" class="ne-p"><br></p><p id="562d103e9c850fb5675fb40c12e70024" class="ne-p"><span class="ne-text">使用SSH情况：</span><code class="ne-code"><a href="https://gitee.com/user/repo.git" data-href="https://gitee.com/user/repo.git" target="_blank" class="ne-link"><span class="ne-text">https://gitee.com/user/repo.git</span></a></code></p><p id="27fa0efc6c3143ed2aae7cc8ae31ea9a" class="ne-p"><br></p><p id="99c54fe1990b811c9cff121938ea6a20" class="ne-p"><span class="ne-text">使用Token情况：</span><code class="ne-code"><a href="https://oauth2:**********@gitee.com/user/repo.git" data-href="https://oauth2:**********@gitee.com/user/repo.git" target="_blank" class="ne-link"><span class="ne-text">https://oauth2:**********@gitee.com/user/repo.git</span></a></code></p><p id="9ac2004bd0077be8689a400d45b210d6" class="ne-p"><br></p><h2 id="5bc5db4d"><span class="ne-text">五、GitHub Actions中的使用</span></h2><p id="4f23e929f040f7f71f95a7dc6f50895e" class="ne-p"><br></p><pre data-language="bash" id="5c109445" class="ne-codeblock">Github_Pages:  github.com/wztlink1013/wztlink1013.github.io<p>Github_Token: $</p><p>git push –force –quiet “https://${Github_Token}@${Github_Pages}”</pre><p id="e1d782ea52f90fd34d6296cf616b9b89" class="ne-p"><br></p><pre data-language="bash" id="2d859456" class="ne-codeblock">Coding_Pages: e.coding.net/wztlink1013/wztlink1013.git<br>Coding_Token: $<br>Coding_Username: $</p><p>git push –force –quiet “https://${Coding_Username}:${Coding_Token}@${Coding_Pages}”</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse的使用总结</title>
      <link href="/blog/at014v/"/>
      <url>/blog/at014v/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="08648db2"><span class="ne-text">一、Eclipse的下载与安装</span></h2><p id="7536057be2edc73ef247e00b37a8aa94" class="ne-p"><br></p><ul class="ne-ul"><li id="u80ad3b79"><span class="ne-text"></span><a href="https://www.eclipse.org/downloads/" data-href="https://www.eclipse.org/downloads/" target="_blank" class="ne-link"><span class="ne-text">下载地址</span></a></li></ul><p id="25c82c931426a2f6f1e96e18450c4aa9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180944-7ec7ebc3-8c39-44a7-9bec-85fded021a40.png" width="1817" id="dYx1H" class="ne-image"></p><p id="79ba222c54c57dc646ad453f2fffdb24" class="ne-p"><br></p><p id="7716f79f3035b1d2595feeb46775a7ad" class="ne-p"><strong><span class="ne-text">注意不要下错版本，不然开发不了web环境</span></strong></p><p id="7a4f121dc96a82ab6a70e45fa4fb5c49" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180923-a106c8c7-aebe-4f0a-bc06-d166bfc8894d.png" width="731" id="AjuXj" class="ne-image"></p><p id="057c35073a50654129cf3c394d156f77" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180948-16e05303-0d11-454e-8bbd-71a11d7a3ef7.png" width="741" id="yVKJo" class="ne-image"></p><p id="d1e472e053f8441f7a9a514b711ead15" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180925-0262b0ea-f7af-493b-85a5-d8e7cbd12751.png" width="762" id="NLbFI" class="ne-image"></p><p id="985cd8f1f789946d0e6998acf0f94df4" class="ne-p"><br></p><h2 id="f659fd57"><span class="ne-text">二、插件</span></h2><p id="c234f354bc18943cd0b5cc401b14c014" class="ne-p"><br></p><div class="ne-quote"><p id="2ec0b9a353bd8f0ae49a025230ada072" class="ne-p"><span class="ne-text">进入：</span><code class="ne-code"><span class="ne-text">Help Eclipse</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">MarketPlace</span></code></p></div><p id="198f890d9d6c04a72884a9011ea85317" class="ne-p"><br></p><ul class="ne-ul"><li id="9d753e5748509c6987d1c7fa130e6a77"><span class="ne-text">Plugin1：Waka Time</span></li></ul><p id="22821cfce7ca1b7ee911a54bfe92aa52" class="ne-p"><br></p><h2 id="74b5d460"><span class="ne-text">三、使用</span></h2><p id="80a0ffbc93078f77b0c05463f2027cc6" class="ne-p"><br></p><h3 id="39003734"><span class="ne-text">样式</span></h3><p id="5ab923aac74917458ad0efd7f6651b65" class="ne-p"><br></p><ul class="ne-ul"><li id="1b0994b66fb32ee4538d80bff45f2553"><span class="ne-text">字体设置</span></li><li id="71b02e98756f4081bb6d41e2a42a765e"><span class="ne-text">行数显示</span></li><li id="4a1ef318f1c180d8f48e4b195e247a2c"><span class="ne-text">更改工作空间的默认编码</span></li><li id="0c07e2002c5f99108c95aed7463bb434"><span class="ne-text">代码增强显示，在设置中的</span><code class="ne-code"><span class="ne-text">java</span></code><span class="ne-text">中的</span><code class="ne-code"><span class="ne-text">content Assistant</span></code><span class="ne-text">中，将</span><code class="ne-code"><span class="ne-text">.</span></code><span class="ne-text">改为</span><code class="ne-code"><span class="ne-text">.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789</span></code></li></ul><p id="d47953b5126b60592d42f3659de53c44" class="ne-p"><br></p><h3 id="616c8f3c"><span class="ne-text">导入已存在的项目</span></h3></div>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse下载使用以及配置Tomcat创建Servlet</title>
      <link href="/blog/ro0lgm/"/>
      <url>/blog/ro0lgm/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="XKsm7"><span class="ne-text">一、Eclipse的下载与安装与使用</span></h2><p id="d22f933e54231c45c739b35455fd6011" class="ne-p"><br></p><ul class="ne-ul"><li id="ufba0ac5e"><span class="ne-text"></span><a href="https://www.eclipse.org/downloads/" data-href="https://www.eclipse.org/downloads/" target="_blank" class="ne-link"><span class="ne-text">下载地址</span></a></li></ul><p id="174e419e65f783ac80f61dfd35ef9c40" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043597-84e5ed4c-8ad9-496b-997d-fd84136d0a86.png" width="1817" id="G6LM6" class="ne-image"></p><p id="1b6bae00950afb9547af4e978bf4446f" class="ne-p"><br></p><p id="a3d30bd43c066f1d672e6112f759eaf5" class="ne-p"><strong><span class="ne-text">注意不要下错版本，不然开发不了web环境</span></strong></p><p id="12c8a7dc4aefffea788e01b6c7a9788f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043623-2432fa56-57df-4b19-bbcf-d7f803db63d3.png" width="731" id="yRync" class="ne-image"></p><p id="411b244c71fbe46ee61f59b8b7ede2ad" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043608-ed00c908-2eb3-4a07-bcd4-c93a58aed494.png" width="741" id="rkrad" class="ne-image"></p><p id="c05a34b4624c677dbbec8cc59d68a795" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043479-aac1b3ff-f51d-4dce-8313-4e10d2e78bbb.png" width="762" id="ThLfH" class="ne-image"></p><p id="aa5b4f1c12e6b9e9bdcbd203a06c3565" class="ne-p"><br></p><h2 id="f1467b90"><span class="ne-text">二、Tomcat的下载与配置</span></h2><p id="f784f5b3157ad91ce492e8b0e60cd990" class="ne-p"><br></p><p id="28803d989b6f99f11f161d7a556ef94e" class="ne-p"><a href="https://tomcat.apache.org/download-90.cgi" data-href="https://tomcat.apache.org/download-90.cgi" target="_blank" class="ne-link"><span class="ne-text">下载地址</span></a></p><p id="d19f70ff91634e3f9466a396b3b5120e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043712-245a08a5-48cd-4446-ae4b-2ac442f09a44.png" width="1829" id="t3Fxz" class="ne-image"></p><p id="09104af19350c1c49fd07d7dd891eea8" class="ne-p"><strong><span class="ne-text">一直下一步即可</span></strong></p><p id="c8c49b905b1658f1a9a85965661ad639" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043478-1e8b6460-5b48-424e-8f2d-db26d6bbce42.png" width="623" id="obx49" class="ne-image"></p><p id="01265c86fc349f49d4e19bef94d44951" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043417-e391db44-2cd9-4c7c-8e6b-1f131ab95769.png" width="624" id="gKPxP" class="ne-image"></p><p id="84f1d5682264b8688d547eb7d08e9510" class="ne-p"><br></p><p id="f531331bcabb676811807be8d89a3a38" class="ne-p"><span class="ne-text">打开浏览器 键入 </span><a href="http://localhost:8080" data-href="http://localhost:8080" target="_blank" class="ne-link"><span class="ne-text">http://localhost:8080</span></a><span class="ne-text"> 进入页面则表示安装成功</span></p><p id="9aebfad63b25a67c10ce99f874b60e63" class="ne-p"><br></p><p id="56f78c429cbde9e55a8369a30f44a75d" class="ne-p"><span class="ne-text">添加环境变量，以下全在系统环境变量下配置</span></p><p id="7dea95d94accdd15d57a2bf300f7168d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043418-feddef63-fcb3-45ce-ac5a-33dd94d77655.png" width="1089" id="Flmgj" class="ne-image"></p><p id="7dc9340094727e16c37023f6d5a4987f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043499-20fddab9-abfb-4d0d-9c6d-956933ee59be.png" width="704" id="FC9yv" class="ne-image"></p><p id="a62e46ce6cd6c7f657f197724c007666" class="ne-p"><br></p><pre data-language="plain" id="4baeacb9" class="ne-codeblock language-plain">TOMCAT_HOME：C:\Program Files\Apache Software Foundation\Tomcat 9.0<p>CATALINA_BASE：C:\Program Files\Apache Software Foundation\Tomcat 9.0;<br>CATALINA_HOME：C:\Program Files\Apache Software Foundation\Tomcat 9.0;<br>在 classpath 当中加入%CATALINA_HOME%\common\lib\servlet-api.jar;<br>在 path 中加入%CATALINA_HOME%\bin;</pre><p id="91a01e38a8df64d1842240be9f390bba" class="ne-p"><br></p><p id="5381ad444b45a3b3160597a49dbe8a00" class="ne-p"><span class="ne-text">打开浏览器 键入 </span><a href="http://localhost:8080" data-href="http://localhost:8080" target="_blank" class="ne-link"><span class="ne-text">http://localhost:8080</span></a><span class="ne-text"> 进入页面则表示配置成功</span></p><p id="ceabc5386bc0513f2968026145f7d51c" class="ne-p"><br></p><h2 id="8891e692"><span class="ne-text">三、Eclipse 配置 Tomcat</span></h2><p id="a40255cea2effc2794e27f76113db839" class="ne-p"><br></p><p id="23a0a32c1a59b68d9506255c9a290439" class="ne-p"><strong><span class="ne-text">让 Tomcat 服务器显示在控制台上，将 Web 应用部署到 Tomcat 中</span></strong></p><p id="c180076da3f14ac0c2af90dc6e689aed" class="ne-p"><br></p><p id="7246ebc8e238d7bc1f0ff3d40281e29a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043589-c8022021-1185-4c41-b114-630856e16984.png" width="1837" id="CVcDY" class="ne-image"></p><p id="ff004e2f6f6e7b32152f85d996c83863" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043661-236843dd-f3ea-433e-b23a-254cc0a41c9b.png" width="1217" id="KUNBB" class="ne-image"></p><p id="8a70eeb1bceda5b7a170b4cf1a6fce6c" class="ne-p"><span class="ne-text">点击</span><code class="ne-code"><span class="ne-text">Window</span></code><span class="ne-text"> → </span><code class="ne-code"><span class="ne-text">Show View</span></code><span class="ne-text"> → </span><code class="ne-code"><span class="ne-text">Servers</span></code><span class="ne-text"> 也可以在控制台点击</span><code class="ne-code"><span class="ne-text">Servers</span></code></p><p id="fdde81f7a4c0621106c6c75e827632ee" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043514-556e9b3f-1003-40ff-9066-70349be51101.png" width="1600" id="hNwzT" class="ne-image"></p><p id="40aa8fa3df20d469177bc07e700f621c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043568-aa8984a7-e9e9-4206-a922-f3386127191d.png" width="597" id="B8gZ2" class="ne-image"></p><p id="4fbec848f244fa2fb9d50647f3a1faf5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043484-23195297-3636-47d7-bf44-ee0151382f87.png" width="1478" id="dJMaU" class="ne-image"></p><p id="e6cb854de4ab32e6679322755d329407" class="ne-p"><strong><span class="ne-text">双击点击</span></strong></p><p id="c84ca78dfcdd8b9a56f770ed9c720993" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043403-e34d7544-8144-4516-bb7c-53adbabac167.png" width="1375" id="Gcbaq" class="ne-image"></p><p id="7bd810a5aed4db03860eae1fa9b5ceca" class="ne-p"><br></p><h2 id="48a8162f"><span class="ne-text">四、Eclipse 使用 Servlet</span></h2><p id="7bff59aaedfd80a8844fbb7d0b8109fa" class="ne-p"><br></p><h3 id="bfb57051"><span class="ne-text">创建 web 工程</span></h3><p id="1926075b59cca19f23e85b5efe2d48b3" class="ne-p"><br></p><p id="81791be211f329d81374866c4d9406e7" class="ne-p"><strong><span class="ne-text">创建过程中，要记得勾选生成 web.xml 文件选项</span></strong></p><p id="317dec62e3c84ad2008ffc45e987bae4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043545-0429f9cf-3910-4401-85da-08dd0118e9b1.png" width="1838" id="wOVWA" class="ne-image"></p><p id="829a66a096b0301ff20e6174cddc3608" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043538-d98f2569-40d6-4c3a-8111-9c3d6702052a.png" width="820" id="svPwh" class="ne-image"></p><p id="3525d6a2192de5bd1693c0d214faa031" class="ne-p"><br></p><h3 id="54c2047f"><span class="ne-text">添加相关文件</span></h3><p id="77bd63fe78189308f68d609b135445fd" class="ne-p"><br></p><p id="900d2902035d1086b673d3b9ff9fb04f" class="ne-p"><strong><span class="ne-text">添加下面的四个文件</span></strong></p><p id="07ea45f4ba61c35c4831d762c6bba533" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043712-c178c180-3c3a-44a2-9518-671033558337.png" width="1831" id="oHS9Z" class="ne-image"></p><p id="6463a75cb07cc2e4ed80409452af0ee9" class="ne-p"><br></p><div class="ne-quote"><p id="f187acf4216f85e2095ef3fef1d30f06" class="ne-p"><span class="ne-text">HelloWordServlet.java</span></p></div><p id="1e759b3516d28291761a08d1690d04b6" class="ne-p"><br></p><pre data-language="java" id="6abf4106" class="ne-codeblock language-java">package cn.itcast.firstmyapp.servlet;</p><p>import java.io.IOException;<br>import java.io.PrintWriter;</p><p>import javax.servlet.ServletException;<br>import javax.servlet.http.HttpServlet;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;</p><p>public class HelloWordServlet extends HttpServlet {</p><pre><code> protected void doGet(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException &#123;     System.out.println(&quot;接受了客户端的请求----------------------------------------------------&quot;);     // 设置响应类型:        resp.setContentType(&quot;text/html&quot;);        // 获取输出流:        PrintWriter pw = resp.getWriter();        // 写入响应:        pw.write(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;);        // 最后不要忘记flush强制输出:        pw.flush();    &#125;</code></pre><p>}</pre><p id="9c1bd153aac1d7c834f855995b2deff2" class="ne-p"><br></p><div class="ne-quote"><p id="97fcc0bb0bde9264593f8d2e19b709f8" class="ne-p"><span class="ne-text">web.xml</span></p><p id="c577747e78b27f5db86c33829ed1bed6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043517-5459e979-8525-4be9-8dab-d38f0857ef56.png" width="1178" id="EcMnq" class="ne-image"></p></div><p id="7195f94127c578cee2b547cd58c6412a" class="ne-p"><br></p><h3 id="e37b1858"><span class="ne-text">运行并查看结果</span></h3><p id="aaa2fa67ed7a520e8b24a62f91789f78" class="ne-p"><br></p><p id="0a65d1edc6d861758493de9c852d1f03" class="ne-p"><strong><span class="ne-text">运行</span></strong></p><p id="af91bcbc0c0732579c38ac9ac2b0bfa8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043718-5d90186b-8040-4098-b1d4-bb1f67740382.png" width="1434" id="eFEub" class="ne-image"></p><p id="7d45073dbe36aac9bd6d1d5cf43fd878" class="ne-p"><span class="ne-text">然后查看 console 部分</span></p><p id="fa101114255ccbcf9f8a634b0430ac07" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043524-efeaf228-713b-43e1-ba15-375060ef20d2.png" width="1449" id="iYu91" class="ne-image"></p><p id="2ffb68210e9c9a42b8bde66b48dda724" class="ne-p"><strong><span class="ne-text">服务器响应情况</span></strong></p><p id="6e5e760df7a4d8751f5a30fba73bf6e6" class="ne-p"><br></p><div class="ne-quote"><p id="7df4eda92c46e111ca0c39e4f1ede5d9" class="ne-p"><span class="ne-text">出现下图则说明成功</span></p><p id="25b99464fa0e3d323ddd6d3bbde88cdb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043360-fd5bb570-f56a-429a-ad0e-627646447132.png" width="1318" id="sq6h2" class="ne-image"></p></div><p id="94163f88494e7cdfedbb93010b019ee5" class="ne-p"><br></p><div class="ne-quote"><p id="c9e565bc54d4c4d40224bf4c55a9e6ac" class="ne-p"><span class="ne-text">还可以回到控制台查看请求成功情况</span></p><p id="9ced40694bd97894433c18b773da8042" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043568-b62922c0-c458-4c71-bd9c-800f57b356de.png" width="1445" id="PPuUA" class="ne-image"></p></div><p id="6b5d745582849784116d0b6823f6af28" class="ne-p"><br></p><h2 id="cc8f5ec4"><span class="ne-text">五、过程中出现的问题</span></h2><p id="21c7d1a4ae3e2f923bcb0f90d311cc11" class="ne-p"><br></p><h3 id="89cb7a49"><span class="ne-text">IDEA 上的部署</span></h3><p id="254bcd966f8975b9194dc51b927dcddf" class="ne-p"><br></p><p id="8b18c36e455d27f54993f19c7c1e4957" class="ne-p"><span class="ne-text">一开始从 tomcat 部署是完成的，具体参考我的 csdn 一篇小文章</span><a href="https://blog.csdn.net/ZTlink1013/article/details/104815639" data-href="https://blog.csdn.net/ZTlink1013/article/details/104815639" target="_blank" class="ne-link"><span class="ne-text">地址</span></a><span class="ne-text">。但是在后面使用 Servlet 的时候，不能成功部署，具体原因【图片内容来自</span><a href="https://blog.csdn.net/HughGilbert/article/details/56424137" data-href="https://blog.csdn.net/HughGilbert/article/details/56424137" target="_blank" class="ne-link"><span class="ne-text">链接</span></a><span class="ne-text">！！】</span></p><p id="28b6c4548b90adde05e67cc187a3f162" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043902-5708dbdc-79d7-4e16-9e6d-d5571c5de758.png" width="941" id="WybYZ" class="ne-image"></p><p id="6cb78eda93f95140cd0dec88755e0aa5" class="ne-p"><br></p><div class="ne-quote"><p id="2cb452c4e05997ac7458758cfbd716f9" class="ne-p"><span class="ne-text">暂时分析：是和 idea 下的根目录下的某个配置文件的默认配置有关，需要更改相关内容，暂时不折腾了。先记录下，有空再折腾，先学习。还是 eclipse 好配置···</span></p></div><p id="eb3170ef48ea425b1b65db43a108f7e7" class="ne-p"><br></p><h3 id="35808e79"><span class="ne-text">参考资料</span></h3><p id="08bc55847419f2294c336f7f4436e0ba" class="ne-p"><br></p><ul class="ne-ul"><li id="89b7cf1df4cc307fa13d89fb43873760"><a href="https://blog.csdn.net/weixin_34026276/article/details/93834823?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" data-href="https://blog.csdn.net/weixin_34026276/article/details/93834823?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/weixin_34026276/article/details/93834823?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</span></a></li><li id="b1c363efa5d5b09917907fc4572ceea0"><a href="https://blog.csdn.net/qq_38190185/article/details/88198794?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" data-href="https://blog.csdn.net/qq_38190185/article/details/88198794?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/qq_38190185/article/details/88198794?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</span></a></li><li id="39e754e822292dba62842add453503e8"><a href="https://www.yiibai.com/servlet/creating-servlet-in-eclipse-ide.html" data-href="https://www.yiibai.com/servlet/creating-servlet-in-eclipse-ide.html" target="_blank" class="ne-link"><span class="ne-text">直接创建 Servlet</span></a></li><li id="741f5e0aedac7b1c8fb430facaf1e1a9"><span class="ne-text">快捷键：</span><a href="https://www.open-open.com/bbs/view/1320934157953" data-href="https://www.open-open.com/bbs/view/1320934157953" target="_blank" class="ne-link"><span class="ne-text">https://www.open-open.com/bbs/view/1320934157953</span></a></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions使用之不同仓库文件夹迁移</title>
      <link href="/blog/qp5kuu/"/>
      <url>/blog/qp5kuu/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="danger" class="ne-alert"><p id="uc844dfb0" class="ne-p"><span class="ne-text">弃用：繁琐</span></p><p id="u0acfb382" class="ne-p"><span class="ne-text">新思路：走CDN回源</span></p></div><h2 id="LsiHO"><span class="ne-text">一、思路</span></h2><ul class="ne-ul"><li id="eb43b88a15ca550c0f5841c8d3b79760"><span class="ne-text">仓库一：wztlink1013.github.io【master】</span></li><li id="e242d9a1232806cd132268f305ca6449"><span class="ne-text">仓库二：test【gh-pages】</span></li></ul><p id="a927d1d1cce92304cec52f12e574d054" class="ne-p" style="text-indent: 2em"><span class="ne-text" style="text-decoration: line-through">将test仓库下gh-pages分支下的所有文件复制到文件夹test，在wztlink1013.github.io仓库下clone到文件夹wztlink1013.github.io中，进入wztlink1013.github.io文件夹，然后通过命令将test文件夹复制到wztlink1013文件夹中，最后push到wztlink1013.github.io仓库中。</span></p><p id="ufdc6cec3" class="ne-p"><br></p><h2 id="fc2260b5"><span class="ne-text">二、编写脚本</span></h2><p id="6841877c72e520141268f8eeb584a88e" class="ne-p"><br></p><pre data-language="bash" id="1a9a3369" class="ne-codeblock language-bash">git config --global user.name 'wztlink1013'<p>git config –global user.email ‘<a href="mailto:&#x77;&#122;&#x74;&#x6c;&#105;&#110;&#x6b;&#x31;&#48;&#49;&#x33;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#x6f;&#109;">&#x77;&#122;&#x74;&#x6c;&#105;&#110;&#x6b;&#x31;&#48;&#49;&#x33;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#x6f;&#109;</a>‘<br>git clone <a href="https://github.com/wztlink1013/test.git">https://github.com/wztlink1013/test.git</a><br>git clone <a href="https://github.com/wztlink1013/wztlink1013.github.io.git">https://github.com/wztlink1013/wztlink1013.github.io.git</a></pre><p id="806e0bc1449dfd08b014c3b33cfb727f" class="ne-p"><br></p><pre data-language="shell" id="88a74b13" class="ne-codeblock language-shell">cd wztlink1013.github.io<br>mkdir test<br>cd ..<br>xcopy .\test .\wztlink1013.github.io /e</pre><p id="0667e64e67844b7c2e6b71a58175d47e" class="ne-p"><br></p><pre data-language="bash" id="6362820c" class="ne-codeblock language-bash">cd wztlink1013.github.io<br>git status<br>git add .<br>git commit -m "add gh-pages files"<br>git push "https://${Github_Token}@github.com/wztlink1013/wztlink1013.github.io" master:master</pre><p id="f1303e9a8bd8a36e2f3e660041c3c2c8" class="ne-p"><br></p><h2 id="c28e0ff6"><span class="ne-text">三、编写 GitHub Actions</span></h2><p id="f79a68536e8e8ad5aee3833f9ad2a40b" class="ne-p"><br></p><pre data-language="yaml" id="dd3af39a" class="ne-codeblock language-yaml">name: CI for wztlink1013.github.io</p><p>on: [push, watch]</p><p>jobs:<br>build:<br>runs-on: ubuntu-latest</p><pre><code>steps:- uses: actions/checkout@v2- name: 配置Git  run: |    git config --global user.name &#39;wztlink1013&#39;    git config --global user.email &#39;wztlink1013@163.com&#39;- name: 在云端进行复制文件夹操作  env:    Github_Token: $&#123;&#123; secrets.TOKEN_GITHUBAPI &#125;&#125;  run: |    git clone https://github.com/wztlink1013/visualization visualization    git clone https://github.com/wztlink1013/wztlink1013.github.io .github_pages    cd visualization    rm -r .git    rm -r .github    cd ..    cd .github_pages    rm -r visualization    cd ..    mv visualization/ -f .github_pages/    cd .github_pages    git status    git add .    git commit -m &quot;add gh-pages files&quot;    git push --force --quiet &quot;https://$&#123;Github_Token&#125;@github.com/wztlink1013/wztlink1013.github.io&quot;  master:master&lt;/pre&gt;&lt;/div&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VScode 插件及环境配置总结等</title>
      <link href="/blog/pm7mpk/"/>
      <url>/blog/pm7mpk/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="udeb49267" class="ne-p"><span class="ne-text">前言：本来我也不是插件重度用户，写项目觉得太累赘，然后在公司前端工作之后，嗯，真香……本文总结vscode的使用，并记录配置相关信息以便更换设备迁移配置，具体内容有：</span></p><ul class="ne-ul"><li id="uc978866e"><span class="ne-text">常用插件</span></li><li id="ub74345ff"><span class="ne-text">代码校验（ESLint）和代码格式化（Prettier）的插件配置</span></li></ul><ul class="ne-ul"><li id="udb4052d9"><span class="ne-text">vscode配置C++运行环境</span></li></ul><h2 id="kSVW4" style="text-align: center"><span class="ne-text">DELETE: 彻底删除vscode软件</span></h2><p id="u152e3230" class="ne-p" style="text-align: left"><strong><span class="ne-text">本着要学会如何配置环境，首先要学会如何彻底删除软件的原则（曾经的javaweb懂得都懂……），先介绍一下如何在本地设备彻底删除vscode软件。</span></strong></p><p id="u24815e89" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1640403466550-8a3fb5fa-9fe5-4ba0-8ea9-80e773fd43f5.jpeg" width="105.99074172973633" id="nq92q" class="ne-image"></p><p id="u88f56a55" class="ne-p"><span class="ne-text">因为：vscode如果更换电脑配置混乱（比如vue相关，既有vetur也有ESLint和Prettier会进行选择等），就删除软件，重新下载然后配置插件：</span></p><ul class="ne-ul"><li id="u314cd579"><code class="ne-code"><span class="ne-text">win + r</span></code><span class="ne-text"> 打开运行</span></li><li id="u5687f4ff"><code class="ne-code"><span class="ne-text">%appdata%</span></code><span class="ne-text"> 回车</span></li></ul><ul class="ne-ul"><li id="u13cff4bb"><span class="ne-text">删除 Code 和 Visual Studio Code 文件夹</span></li><li id="uc3e62902"><span class="ne-text">地址栏输入 </span><code class="ne-code"><span class="ne-text">%userprofile%</span></code><span class="ne-text"> 回车</span></li></ul><ul class="ne-ul"><li id="ubac316ef"><span class="ne-text">删除 </span><code class="ne-code"><span class="ne-text">.vscode</span></code><span class="ne-text"> 文件夹</span></li></ul><h2 id="ce9bb4e0"><span class="ne-text">一、VScode插件使用</span></h2><h3 id="qaLIR"><span class="ne-text">常用插件</span></h3><ul class="ne-tl"><li id="3332911a31b4f035638135342944c6e4"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">Chinese (simplified)Language pack for Visual Code</span></li></ul><p id="u8ddbcca2" class="ne-p"><span class="ne-text">vscode中文化</span></p><ul class="ne-tl"><li id="3ff29d09e53c44678d9c507d6fd5da68"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">vscode-icons</span></li></ul><p id="u4b5759c1" class="ne-p"><span class="ne-text">美化图标</span></p><ul class="ne-tl"><li id="ba2fe10a36fb69a74150521df091adb6"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">Waka Time</span></li></ul><p id="ub7a43239" class="ne-p"><span class="ne-text">记录软件编写各类语言时间分配</span></p><ul class="ne-tl"><li id="32fcc5aa5b469aa290dfb90ca3903b1c"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">Todo Highlight</span></li></ul><p id="u93f820fb" class="ne-p"><span class="ne-text">优化TODO：高亮</span></p><ul class="ne-tl"><li id="f9f53deacc04e8f59bcbb6d3451121fb"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">Live Server</span></li></ul><p id="u3bf49f5d" class="ne-p"><span class="ne-text">运行HTML</span></p><ul class="ne-tl"><li id="ud4c1296f"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">Auto Import</span></li></ul><p id="u016f23bc" class="ne-p"><span class="ne-text">自动导入包（组件）</span></p><p id="u1af612be" class="ne-p"><span class="ne-text">第一次用到该组件（包）时是不会有自动导入提示的，在另一个文件第二次用时就会有自动导入提示了</span></p><ul class="ne-tl"><li id="u9744937d"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">Color Highlight</span></li></ul><p id="u713b4c68" class="ne-p"><span class="ne-text">代码中有颜色的地方会高亮</span></p><p id="uf650c0f8" class="ne-p"><span class="ne-text">文件中找到的 css/web 颜色，所以你无需打开页面就能看到它们是什么颜色。</span></p><ul class="ne-tl"><li id="u22b96203"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">HTML CSS Support</span></li></ul><p id="u03ddec3a" class="ne-p"><span class="ne-text">让 html 标签上写class 智能提示当前项目所支持的样式</span></p><ul class="ne-tl"><li id="u856a11f0"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">IntelliSense for CSS class names in HTML</span></li><li id="u1ebe3fcd"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">JavaScript (ES6) code snippets</span></li></ul><p id="u1a9339b9" class="ne-p"><span class="ne-text">ES6语法智能提示以及快速输入，除js外还支持.ts，.jsx，.tsx，.html，.vue，省去了配置其支持各种包含js代码文件的时间</span></p><ul class="ne-tl"><li id="ud7466f93"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">koroFileHeader</span></li></ul><p id="uff2b34e4" class="ne-p"><span class="ne-text">生成文件头注释</span></p><p id="u74dd0718" class="ne-p"><span class="ne-text">配置参考：</span><a href="https://github.com/OBKoro1/koro1FileHeader" data-href="https://github.com/OBKoro1/koro1FileHeader" target="_blank" class="ne-link"><span class="ne-text">https://github.com/OBKoro1/koro1FileHeader</span></a></p><pre data-language="json" id="aeWLo" class="ne-codeblock language-json">// 头部注释<p>“fileheader.customMade”: {<br>// 头部注释默认字段<br>“Author”: “wztlink1013”,<br>“Date”: “Do not edit”, // 设置后默认设置文件生成时间<br>“LastEditTime”: “Do not edit”, // 设置后，保存文件更改默认更新最后编辑时间<br>“Description”: “”<br>},<br>// 函数注释<br>“fileheader.cursorMode”: {<br>// 默认字段<br>“description”:””,<br>“param”:””,<br>“return”:””<br>},</pre><ul class="ne-tl"><li id="u4b429e9e"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">Nuxt Typescript Snippets</span></li><li id="uad01a17c"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">Path Autocomplete</span></li></ul><p id="ua3a38cfa" class="ne-p"><span class="ne-text">会有路径提示</span></p><ul class="ne-tl"><li id="ufa58c1a7"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">Path Intellisense</span></li></ul><p id="ua5a457f7" class="ne-p"><span class="ne-text">自动路径补全</span></p><ul class="ne-tl"><li id="u94228d42"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">Reactjs code snippets</span></li><li id="uf51e4074"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">Vetur</span></li></ul><p id="u32858c71" class="ne-p"><span class="ne-text">VSCode 里安装 Vetur 可以将“.vue”文件中的语法进行高亮显示，Vetur 不仅支持 Vue 中的 template 模板以外，还支持大多数主流的前端开发脚本和插件，比如 Sass、TypeScript、Jade 和 Less 等等。</span></p><ul class="ne-tl"><li id="ubcefbc0d"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">vue</span></li><li id="u7c413155"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">Vue 3 Snippets</span></li></ul><ul class="ne-tl"><li id="ua93de0a3"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">Vue VSCode Snippets</span></li><li id="udf12dc96"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">Auto Close Tag</span></li></ul><p id="u66376ac6" class="ne-p"><span class="ne-text">自动闭合 HTML/XML 标签</span></p><ul class="ne-tl"><li id="udd680fc7"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text"> Auto Rename Tag</span></li></ul><p id="u43f11d13" class="ne-p"><span class="ne-text">自动关闭 Html 标签，输入起始标签后会自动变换尾部标签。</span></p><ul class="ne-tl"><li id="ufabf30bc"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">background</span></li></ul><p id="u96ee74a3" class="ne-p"><span class="ne-text">背景图片的设置</span></p><ul class="ne-tl"><li id="u17d5d537"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">🔲</span><span class="ne-text">DotENV【添加 env 环境变量参数】</span></li></ul><p id="u66417218" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/hbiao68/article/details/105205112" data-href="https://blog.csdn.net/hbiao68/article/details/105205112" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/hbiao68/article/details/105205112</span></a></p><ul class="ne-tl"><li id="uf25f7098"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">🔲</span><span class="ne-text">CodeRunner【编写 C/C++】</span></li><li id="uf0689ec6"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">🔲</span><span class="ne-text">C/C++【编写 C/C++】</span></li></ul><ul class="ne-tl"><li id="u90569d29"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">🔲</span><span class="ne-text">Todo Tree【优化 TODO：侧边栏】</span></li><li id="u9e377c6e"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">🔲</span><span class="ne-text">language-stylus【hexo 博客】</span></li></ul><ul class="ne-tl"><li id="ub4a65b1a"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">🔲</span><span class="ne-text">Markdown Preview Github Styling【Markdown】</span></li><li id="u190a4902"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">🔲</span><span class="ne-text">Markdown All in One【Markdown】</span></li></ul><ul class="ne-tl"><li id="u68f97402"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">🔲</span><span class="ne-text">GitLens 【显示当前行 commit 信息，管理 git】</span></li><li id="u4d4e55c0"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">🔲</span><span class="ne-text">Git History 【查看 commit 信息】</span></li></ul><ul class="ne-tl"><li id="u3747756b"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">🔲</span><span class="ne-text">Bracket Pair Colorrizer 2 【优化大括号】</span></li></ul><p id="u6a9f1ec7" class="ne-p"><span class="ne-text">vscode 可以自定义 markdown 预览样式，css 文件以外链的方式放上</span></p><h2 id="IxZ6z"><span class="ne-text">二、集成 ESLint 和 Prettier 代码校验格式化环境</span></h2><ul class="ne-tl"><li id="u571c74af"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">Prettier - Code formatter</span></li></ul><p id="u0674ac87" class="ne-p"><span class="ne-text">代码格式化插件：按照所需配置直接格式化代码</span></p><ul class="ne-tl"><li id="u0e81bd31"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">ESLint</span></li></ul><p id="u4c54dfd4" class="ne-p"><span class="ne-text">格式化检测工具：会给出警告抑或是报错，但不会修改</span></p><h3 id="EHhwf"><span class="ne-text">eslint-plugin-html</span></h3><p id="u84ebd259" class="ne-p"><span class="ne-text">目的是为了检测 html 文件中的 js 代码，全局下载，让设备非 node 项目也能使用</span></p><pre data-language="bash" id="ssMLw" class="ne-codeblock language-bash">npm install -g eslint-plugin-html</pre><p id="u43b1986c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640400558364-b89c0585-1302-4515-b27a-bdb053cf8701.png" width="828" id="uc4ceedb9" class="ne-image"></p><p id="u8bca4c3c" class="ne-p"><span class="ne-text">每次打开 html，eslint 就会报错：</span></p><pre data-language="plain" id="BogCY" class="ne-codeblock language-plain">'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.</pre><p id="u075e0d78" class="ne-p"><span class="ne-text">官网 issues </span><a href="https://github.com/microsoft/vscode-eslint/issues/1376" data-href="https://github.com/microsoft/vscode-eslint/issues/1376" target="_blank" class="ne-link"><span class="ne-text">https://github.com/microsoft/vscode-eslint/issues/1376</span></a><span class="ne-text"> 中貌似也并未给出根治方法，暂时禁用：</span></p><p id="uad85479a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640401735422-2e618454-6752-4b2e-9020-8788d0ad114d.png" width="365" id="u7b0c7db1" class="ne-image"></p><h2 id="87c5883a"><span class="ne-text">三、VScode 配置 C/C++环境</span></h2><h3 id="V8Iq2"><span class="ne-text">下载编译器</span></h3><div class="ne-quote"><p id="u4e2fd0ab" class="ne-p"><span class="ne-text">下载地址：</span><a href="https://sourceforge.net/projects/mingw-w64/files/" data-href="https://sourceforge.net/projects/mingw-w64/files/" target="_blank" class="ne-link"><span class="ne-text">https://sourceforge.net/projects/mingw-w64/files/</span></a></p></div><p id="u2efd8d80" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624949859317-61aab22e-74c9-4210-9c4b-f192c9af76ea.png" width="955.5" id="u0f6c1ee7" class="ne-image"></p><div class="ne-quote"><p id="u8b5f377f" class="ne-p"><span class="ne-text">配置环境</span></p></div><p id="u31964630" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624949943592-2695ea6b-4237-4a26-8d5b-c39a2c2ff920.png" width="485" id="u901eeafb" class="ne-image"></p><p id="u2dcc7cc0" class="ne-p"><span class="ne-text">检查是否配置成功</span></p><p id="ufd6722a7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624949993088-16f38896-e62c-4347-8e3e-d4ac0e5c4273.png" width="720" id="u842c5c50" class="ne-image"></p><h3 id="r1XIX"><span class="ne-text">下载插件</span></h3><p id="u3130b0be" class="ne-p"><span class="ne-text">在 vscode 中下载如下两个插件</span></p><ul class="ne-tl"><li id="u9fc786ec"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">CodeRunner</span></li><li id="uf640c9d4"><span class="ne-tli-symbol" style="margin: 3px 0.5ex; vertical-align: middle">✅</span><span class="ne-text">C/C++</span></li></ul><p id="ucbe47b0f" class="ne-p"><span class="ne-text"></span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624948996187-240d18a3-446f-4381-a685-e9a2a7af5d91.png" width="139.5" id="ubffcb48a" class="ne-image"></p><h3 id="iqbXP"><span class="ne-text">项目.vscode 配置</span></h3><p id="u41e685cc" class="ne-p"><span class="ne-text">建立一个 </span><code class="ne-code"><span class="ne-text">.vscode</span></code><span class="ne-text">  文件夹，然后在里面新建下面三个文件即可。</span></p><p id="u03e482c9" class="ne-p"><span class="ne-text"></span></p><p id="uad961a08" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624949162500-fc5ebdeb-2c45-49d6-afb0-badec740d502.png" width="167" id="ue1af6290" class="ne-image"></p><div data-type="danger" class="ne-alert"><p id="ub7fb3b0b" class="ne-p"><span class="ne-text">注意：以后只有该配置文件夹的文件夹才能编写 C/C++代码</span></p></div><p id="u4c45515c" class="ne-p"><br></p><h4 id="L5w9u"><span class="ne-text">launch.json</span></h4><pre data-language="json" id="8PXun" class="ne-codeblock language-json">{<br>"version": "0.2.0",<br>"configurations": [{<br>"name": "(gdb) Launch",<br>"type": "cppdbg",<br>"request": "launch",<br>"program": "${fileDirname}/${fileBasenameNoExtension}.exe",<br>"args": [],<br>"stopAtEntry": false,<br>"cwd": "${workspaceFolder}",<br>"environment": [],<br>"externalConsole": true,<br>"internalConsoleOptions": "neverOpen",<br>"MIMode": "gdb",<br>"miDebuggerPath": "gdb.exe",<br>"setupCommands": [<br>{<br>"description": "Enable pretty-printing for gdb",<br>"text": "-enable-pretty-printing",<br>"ignoreFailures": false<br>}<br>],<br>"preLaunchTask": "Compile"<br>}]<br>}</p><p></pre><h4 id="ImhQO"><span class="ne-text">settings.json</span></h4><pre data-language="json" id="0ohE2" class="ne-codeblock language-json">{<br>    "files.defaultLanguage": "c",<br>    "editor.formatOnType": true,<br>    "editor.suggest.snippetsPreventQuickSuggestions": false,<br>    "editor.acceptSuggestionOnEnter": "off",<br>    "code-runner.runInTerminal": true,<br>    "code-runner.executorMap": {<br>        "c": "gcc '$fileName' -o '$fileNameWithoutExt.exe' -Wall -O2 -m64 -lm -static-libgcc -std=c11 -fexec-charset=GBK && &'./$fileNameWithoutExt.exe'",<br>        "cpp": "g++ '$fileName' -o '$fileNameWithoutExt.exe' -Wall -O2 -m64 -static-libgcc -std=c++14 -fexec-charset=GBK && &'./$fileNameWithoutExt.exe'"<br>    },<br>    "code-runner.saveFileBeforeRun": true,<br>    "code-runner.preserveFocus": true,<br>    "code-runner.clearPreviousOutput": false,<br>    "code-runner.ignoreSelection": true,<br>    "code-runner.fileDirectoryAsCwd": true,</p><pre><code>&quot;C_Cpp.clang_format_sortIncludes&quot;: true</code></pre><p>}</p><p></pre><h4 id="Hmg1P"><span class="ne-text">tasks.json</span></h4><pre data-language="json" id="Na3gE" class="ne-codeblock language-json">{<br>    "version": "2.0.0",<br>    "tasks": [{<br>        "label": "Compile",<br>        "command": "gcc",<br>        "args": [<br>            "${file}",<br>            "-o",<br>            "${fileDirname}/${fileBasenameNoExtension}.exe",<br>            "-g",<br>            "-m64",<br>            "-Wall",<br>            "-static-libgcc",<br>            "-fexec-charset=GBK", </p><pre><code>    ],     &quot;type&quot;: &quot;process&quot;,     &quot;group&quot;: &#123;        &quot;kind&quot;: &quot;build&quot;,        &quot;isDefault&quot;: true     &#125;,    &quot;presentation&quot;: &#123;        &quot;echo&quot;: true,        &quot;reveal&quot;: &quot;always&quot;,         &quot;focus&quot;: false,             &quot;panel&quot;: &quot;shared&quot;       &#125;,    &quot;problemMatcher&quot;:&quot;$gcc&quot;     &#125;]</code></pre><p>}<br></pre><p id="u659e40f3" class="ne-p"><br></p><h2 id="d17a0f0b"><span class="ne-text">References</span></h2><ul class="ne-ul"><li id="8025a45d2115e1bc69e2134533ca2b6d"><a href="https://www.zhihu.com/question/30315894" data-href="https://www.zhihu.com/question/30315894" target="_blank" class="ne-link"><span class="ne-text">Visual Studio Code 如何编写运行 C、C++ 程序？</span></a></li><li id="db448bf7466e95f79a2566ecc0d4004a"><a href="https://segmentfault.com/a/1190000006697219" data-href="https://segmentfault.com/a/1190000006697219" target="_blank" class="ne-link"><span class="ne-text">vscode 插件推荐 - 献给所有前端工程师（2019.10.12更新）</span></a></li></ul><ul class="ne-ul"><li id="f11e27ba0df4f5ba4d743cdca0245ed5"><a href="https://blog.csdn.net/TriDiamond6/article/details/105604427?utm_source=app" data-href="https://blog.csdn.net/TriDiamond6/article/details/105604427?utm_source=app" target="_blank" class="ne-link"><span class="ne-text">VSCode插件大全｜VSCode高级玩家之第二篇</span></a></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电脑重装win10系统以及重装后的软件下载</title>
      <link href="/blog/qq1dno/"/>
      <url>/blog/qq1dno/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uc80604f5" class="ne-p"><span class="ne-text">前言：个人重装系统的缘由有如下几个原因：</span></p><ul class="ne-ul"><li id="u73d09211"><span class="ne-text">环境配置混乱</span></li><li id="ucd45fc15"><span class="ne-text">网卡驱动出错（一次电脑莫名的出错）</span></li><li id="uc40d6110"><span class="ne-text">电脑的空间太杂乱</span></li></ul><p id="ucf5120c1" class="ne-p"><span class="ne-text">同时，重装系统能解决电脑带来的大部分问题，所以在此记录一下重装的各类方法、操作流程、以及重装之后的电脑所需要下载的软件总结。</span></p><h2 id="87d96d8d"><span class="ne-text">一、重装系统流程</span></h2><p id="uaca7f33c" class="ne-p"><span class="ne-text">重装系统有很多种方法：传统的U盘下载镜像重装，win10的重置电脑功能，三方软件的一键重装，但是个人而言，所有的方法都没有U盘方法“干净”，比如win10的重置功能会保留一些文件在重装后的电脑中，导致占内存，三方软件一般都会捆绑三方软件在你的重装之后电脑中，</span><strong><span class="ne-text">所以推荐使用U盘下载镜像的方法</span></strong><span class="ne-text">。</span></p><h3 id="c625568f"><span class="ne-text">镜像的下载与启动盘的制作</span></h3><ul class="ne-ul"><li id="dc457abcd8fd97e313f29b08dc957b13"><a href="https://msdn.itellyou.cn/" data-href="https://msdn.itellyou.cn/" target="_blank" class="ne-link"><span class="ne-text">方法一：MSDN下载镜像</span></a></li></ul><p id="u8c45a07e" class="ne-p"><span class="ne-text">①迅雷下载  ②网盘下载。下载完镜像之后，再用 ULtralSO/ </span><a href="https://rufus.ie/zh_CN.html" data-href="https://rufus.ie/zh_CN.html" target="_blank" class="ne-link"><span class="ne-text">rufus</span></a><span class="ne-text"> 软件刻录在U盘（大于4G的U盘）</span></p><ul class="ne-ul"><li id="d56a58049041033b706d63176af74125"><a href="https://www.microsoft.com/zh-cn/software-download/windows10" data-href="https://www.microsoft.com/zh-cn/software-download/windows10" target="_blank" class="ne-link"><span class="ne-text">方法二：微软官方下载镜像</span></a></li></ul><p id="u3d2f8bcf" class="ne-p"><span class="ne-text">网速不能太慢，WiFi较快的可以用这个，不过下载的电脑原装Windows版本，不追求专业版本的Windows，最好还是下这个。</span></p><p id="u37bb308c" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="4849a7a4fc0701d58912da5cc7b482f4" class="ne-p"><span class="ne-text">坑1：如果下载的镜像大于4G左右，ULtralSO不能刻录。</span></p><p id="9c78f9ed5a023c57ea7696b83744fc35" class="ne-p"><span class="ne-text">亮2：官方下载，可以匹配自己电脑本来的版本；可以直接刻录在U盘，唯一不足应该就是网速问题。</span></p><p id="41dd48629d8a97242e83c7734fb924d6" class="ne-p"><span class="ne-text">坑3：U盘如果“身患重伤”，下个相关优化U盘软件处理一下</span></p></div><h3 id="856f2641"><span class="ne-text">正式重装步骤</span></h3><p id="u2db0f8df" class="ne-p" style="text-align: center"><strong><span class="ne-text">未配图，下次重装一定</span></strong><img src="https://cdn.nlark.com/yuque/0/2022/gif/1484158/1644205174244-93671f35-36d0-4aae-8318-780a20970f83.gif" width="45" id="GViLZ" class="ne-image"></p><p id="u2c3ac9c1" class="ne-p"><br></p><ul class="ne-ul"><li id="04bc048a4f00d1b766d1463eacad1efe"><span class="ne-text">进入bios界面</span></li></ul><p id="u60bea334" class="ne-p"><span class="ne-text">如何进入bios界面：开机刚要出现</span><code class="ne-code"><span class="ne-text">HP</span></code><span class="ne-text">字样，一直点</span><code class="ne-code"><em><span class="ne-text">esc</span></em></code><span class="ne-text">键，然后再设置开机进入启动盘</span></p><p id="u5dd78897" class="ne-p"><span class="ne-text">（不同电脑，不同进入方式，网上搜一下就可以了）</span></p><ul class="ne-ul"><li id="57ddfe047320f44ccc81710581a674fa"><span class="ne-text">Next Wait即可<p></span><span class="ne-text">格式化 C 盘 → 安装 → 等候 → 登录微软账号…</span></li></ul><p id="u145a13d5" class="ne-p"><span class="ne-text"></span></p><h3 id="af05a627"><span class="ne-text">关于磁盘管理</span></h3><ul class="ne-ul"><li id="u690ed442"><span class="ne-text">重装系统的安装，一般是安装到 C 盘，也就是系统盘</span></li><li id="u72421bda"><span class="ne-text">重装完成之后，根据需求也可以人为将磁盘分区</span></li></ul><p id="1ffbf8f78951c0685565b1ade7df069b" class="ne-p"><br></p><div class="ne-quote"><p id="u7d4c0a11" class="ne-p"><span class="ne-text">相关问题 1：给 C 盘扩展时不能扩展？</span></p><p id="u687b73d1" class="ne-p"><span class="ne-text">磁盘只有相邻卷才能扩展卷：解决办法就是把右边的磁盘删除（状态为未分配空间），然后用左边的磁盘合并之（使用扩展卷）</span></p></div><h3 id="51af8e23"><span class="ne-text"> 关于破解</span></h3><ul class="ne-ul"><li id="ua92bf028"><span class="ne-text">有条件购买支持正版，支持同行</span></li><li id="u5d843ffb"><span class="ne-text">下载自己笔记本出厂 Windows 版本，则不需要激活码，自带</span></li><li id="u49adf3f9"><span class="ne-text">最后使用：HWIDGen 激活工具 pojie 之</span></li></ul><h2 id="8d4a5a1f"><span class="ne-text">二、电脑备份相关工作</span></h2><h3 id="1EabK"><span class="ne-text">上网与浏览器</span></h3><ul class="ne-tl"><li checked="true" id="ubc52a0dc"><span class="ne-text">kxsw： </span><a href="https://console.bywa.art/aff.php?aff=3215" data-href="https://console.bywa.art/aff.php?aff=3215" target="_blank" class="ne-link"><span class="ne-text">ByWave</span></a></li></ul><div class="ne-quote"><p id="u6da7b276" class="ne-p"><span class="ne-text">Clash for Windows</span></p></div><ul class="ne-tl"><li checked="true" id="u82f1a9e8"><span class="ne-text">谷歌浏览器：</span><a href="https://www.google.com/intl/zh-CN/chrome/" data-href="https://www.google.com/intl/zh-CN/chrome/" class="ne-link"><span class="ne-text">由 Google 打造的浏览器 适用于 Windows 11/10/8.1/8/7 64 位</span></a></li></ul><div class="ne-quote"><p id="u7d8ddff5" class="ne-p"><span class="ne-text">登录谷歌账号同步书签插件等设置</span></p></div><ul class="ne-tl"><li checked="true" id="u5c268a17"><a href="https://authy.com/download/" data-href="https://authy.com/download/" target="_blank" class="ne-link"><span class="ne-text">Authy Desktop（二重验证）</span></a></li></ul><ul class="ne-tl"><li id="u3f0fd0db"><span class="ne-text">IDM 下载器</span></li></ul><h3 id="mwZUB"><span class="ne-text">文件备份及恢复</span></h3><ul class="ne-tl"><li checked="true" id="u7ef9c7d2"><span class="ne-text">百度网盘</span></li></ul><div class="ne-quote"><p id="u89ce765f" class="ne-p"><span class="ne-text">workspaces 同步文件夹</span></p></div><ul class="ne-tl"><li checked="true" id="ue15b95fc"><span class="ne-text">阿里云盘</span></li><li checked="true" id="u70fe7b61"><a href="https://github.com/wztlink1013" data-href="https://github.com/wztlink1013" target="_blank" class="ne-link"><strong><span class="ne-text">GitHub </span></strong></a><span class="ne-text">同步开发项目代码</span></li></ul><h3 id="EWhRX"><span class="ne-text">开发</span></h3><h4 id="PvgYl"><span class="ne-text">环境搭建</span></h4><ul class="ne-tl"><li checked="true" id="ud7836c26"><span class="ne-text">Git（全局用户）：</span><a href="https://www.wztlink1013.com/blog/fnsge3/" data-href="https://www.wztlink1013.com/blog/fnsge3/" target="_blank" class="ne-link"><span class="ne-text">Git 常见使用+多账号同设备部署总结 | 尼采般地抒情</span></a></li><li checked="true" id="ud68d2d1a"><span class="ne-text">Nodejs：</span><a href="https://www.wztlink1013.com/blog/yo1xhz/" data-href="https://www.wztlink1013.com/blog/yo1xhz/" target="_blank" class="ne-link"><span class="ne-text">Hexo+GitHub Pages 搭建个人静态网站 | 尼采般地抒情</span></a></li></ul><div class="ne-quote"><p id="u0b565f66" class="ne-p"><span class="ne-text">使用 nvm 管理 Node.js 版本（</span><a href="https://www.yuque.com/wztlink1013/lyrics/orml31" data-href="https://www.yuque.com/wztlink1013/lyrics/orml31" target="_blank" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/lyrics/orml31</span></a><span class="ne-text">）</span></p></div><ul class="ne-tl"><li checked="true" id="u192b8196"><span class="ne-text">Java（jdkjdk1.8.0_181，jrejdk1.8.0_181）：</span><a href="https://www.wztlink1013.com/blog/cwqx6l/" data-href="https://www.wztlink1013.com/blog/cwqx6l/" target="_blank" class="ne-link"><span class="ne-text">配置 java 开发环境 | 尼采般地抒情</span></a></li><li checked="true" id="u948c58cd"><span class="ne-text">ffmpeg</span></li><li id="uab4708ea"><span class="ne-text">MySQL</span></li><li id="uba543543"><span class="ne-text">MongoDB</span></li><li id="u69bce959"><span class="ne-text">Unix：VMware15，Windows 子系统（开发三剑客）</span></li></ul><h4 id="wGFLy"><span class="ne-text">开发工具</span></h4><ul class="ne-tl"><li checked="true" id="ua332ff38"><span class="ne-text">Web：</span><a href="https://code.visualstudio.com/download" data-href="https://code.visualstudio.com/download" target="_blank" class="ne-link"><span class="ne-text">vscode</span></a></li><li checked="true" id="u1dbce3d5"><span class="ne-text">C&amp;C++：</span><a href="https://www.wztlink1013.com/blog/pm7mpk/" data-href="https://www.wztlink1013.com/blog/pm7mpk/" target="_blank" class="ne-link"><span class="ne-text">VScode（搭配 C/C++开发插件使用）</span></a><span class="ne-text" style="text-decoration: line-through">、Clion、Codeblocks(次选)、VS2019(PC 空间大则优选)、VS2013</span></li><li id="u39ee0465"><span class="ne-text">Python：Anaconda、Pycharm(</span><span class="ne-text" style="text-decoration: line-through">配置 nltk、tensorflow 等</span><span class="ne-text">)(</span><span class="ne-text" style="text-decoration: line-through">关于破解或</span><span class="ne-text"> </span><strong><span class="ne-text">学生用户登录</span></strong><span class="ne-text">)</span></li><li id="u06f6e418"><span class="ne-text">Java/JavaWeb：IDEA、IDEA/Eclipse(配置 Tomcat)</span></li><li id="u4875808b"><span class="ne-text">DataBase：</span><a href="https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=30438" data-href="https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=30438" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">SQL Server 2008</span></a><span class="ne-text" style="text-decoration: line-through"> 和 </span><a href="https://zhuanlan.zhihu.com/p/65630194" data-href="https://zhuanlan.zhihu.com/p/65630194" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">安装教程</span></a><span class="ne-text" style="text-decoration: line-through"> </span><span class="ne-text">、 Navicat Premium 15</span></li><li id="u0891f20c"><span class="ne-text">Android：Android Studio、HBuilder X、微信开发者工具</span></li><li id="u9cdcbf46"><span class="ne-text">OS：CPU Simulator</span></li><li id="ucf72f291"><span class="ne-text">Matlab</span></li><li id="ud4422788"><span class="ne-text">研究-CAJViewer 7.3</span></li><li id="ucfb9e93f"><span class="ne-text">研究-AxMath</span></li><li id="udbaeb2d2"><span class="ne-text">研究-AxGlyph</span></li><li id="u0d4eb495"><span class="ne-text">服务器</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li id="u60b691af"><span class="ne-text">FinalShell</span></li><li id="u6827760f"><span class="ne-text">FileZilla Client（云服务器、云虚拟主机）</span></li></ul></ul><ul class="ne-tl"><li checked="true" id="u43f9a6e8"><span class="ne-text">前端</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li checked="true" id="ud377c09d"><span class="ne-text">Postman</span></li><li checked="true" id="uc4cb0514"><span class="ne-text">vscode</span></li><li checked="true" id="u531abe41"><span class="ne-text">Charles（抓包工具）</span></li><li checked="true" id="u03c60703"><span class="ne-text">谷歌、火狐、PS</span></li></ul></ul><h3 id="36e56c01"><span class="ne-text">通用软件</span></h3><ul class="ne-tl"><li checked="true" id="u97697cb4"><span class="ne-text">Bandizip</span></li><li checked="true" id="u42c23f54"><span class="ne-text">Adobe Acrobat DC</span></li><li checked="true" id="u3f310ec7"><span class="ne-text">Potplayer</span></li></ul><ul class="ne-tl"><li checked="true" id="ube311ec6"><span class="ne-text">QQ、微信、网易邮箱大师、网易云、酷狗</span></li><li checked="true" id="u9c8ae081"><a href="https://www.snipaste.com/download.html" data-href="https://www.snipaste.com/download.html" target="_blank" class="ne-link"><span class="ne-text">Snipaste</span></a></li></ul><h4 id="J1Oj8"><span class="ne-text">后期制作</span></h4><ul class="ne-tl"><li id="u9f05a758"><span class="ne-text">Ps</span></li><li id="uc35dd1ed"><span class="ne-text">Pr、Ae </span></li></ul><ul class="ne-tl"><li id="u7f295ecb"><span class="ne-text">An、Au、EV 录频、Format factory 格式转换工厂</span></li></ul><h4 id="m4k5N"><span class="ne-text">其他</span></h4><ul class="ne-tl"><li id="ufbc0fdbb"><a href="https://www.yuque.com/install/desktop" data-href="https://www.yuque.com/install/desktop" target="_blank" class="ne-link"><span class="ne-text">语雀桌面客户端</span></a></li></ul><ul class="ne-tl"><li id="u9906dfa4"><span class="ne-text">火萤桌面视频</span></li><li id="u6484e5af"><span class="ne-text">Rainmeter</span></li><li id="ue845c34e"><a href="https://github.com/Molunerfinn/PicGo" data-href="https://github.com/Molunerfinn/PicGo" target="_blank" class="ne-link"><span class="ne-text">PicGo</span></a><span class="ne-text"> </span></li><li id="u738a3e83"><span class="ne-text">steam</span></li><li id="u6940cf9d"><span class="ne-text">qq 飞车</span></li><li id="uad671f08"><span class="ne-text">Visio</span></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>时间格式UTC、GMT、GST</title>
      <link href="/blog/delag2/"/>
      <url>/blog/delag2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="ZR0ag"><span class="ne-text">一、三者区别与关系</span></h2><h3 id="e4d17160"><strong><span class="ne-text">UTC：世界标准时间</span></strong></h3><p id="f2dc20bcd4b1ec8addd104b0c97eac47" class="ne-p"><br></p><p id="d2d34a9a44184446cd02719245df29c7" class="ne-p"><span class="ne-text">协调世界时（英：Coordinated Universal Time ，法：Temps Universel Coordonné），又称世界统一时间，世界标准时间，国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称UTC。</span></p><p id="11ef24fd9196495d64c7529bf1353032" class="ne-p"><br></p><h3 id="07e95782"><strong><span class="ne-text">GMT：格林尼治时间</span></strong></h3><p id="6ce5585bf59dc3765fe77ca047ea9740" class="ne-p"><br></p><p id="490bee815e671a05cb33070e3fac9bec" class="ne-p"><span class="ne-text">世界时UT  即格林尼治时间，格林尼治所在地的标准时间。以地球自转为基础的时间计量系统。地球自转的角度可用地方子午线相对于地球上的基本参考点的运动来度量。为了测量地球自转，人们在地球上选取了两个基本参考点：春分点（见分至点）和平太阳，由此确定的时间分别称为恒星时和平太阳时。</span></p><p id="c436589a2e58c892e5273a316df7e27b" class="ne-p"><br></p><h3 id="213f0223"><strong><span class="ne-text">GST：北京时间</span></strong></h3><p id="72d83a4fca718a610f5690fef7d73aad" class="ne-p"><br></p><p id="db6d1fe855e6743050a572e8b5eb5666" class="ne-p"><span class="ne-text">在数据库中存放，或者给用户看的时间都是GST时间</span></p><p id="64bdd6b2d78bd3000f5284d28f5e587b" class="ne-p"><br></p><h3 id="86f348c0"><strong><span class="ne-text">UTC和GST</span></strong></h3><p id="a3aa6246d5073cb7f4973183ea17206f" class="ne-p"><br></p><p id="219f840783b3ff83b068c7f21d59b6db" class="ne-p"><span class="ne-text">中国北京市的时间比UTC</span><strong><span class="ne-text">早</span></strong><span class="ne-text"> 8 小时</span></p><p id="d5f23a90480bbbe4ec2bd2afd274a289" class="ne-p"><br></p><h2 id="871be4c6"><strong><span class="ne-text">二、UTC与GST之间的转换</span></strong></h2><p id="74e97223e5c9be510bf9290b9851d19c" class="ne-p"><br></p><h3 id="ac8a4f56"><span class="ne-text">理解</span></h3><p id="553debbfde8add12847f34445aeb510c" class="ne-p"><br></p><div class="ne-quote"><p id="bb9282fdbc3e966abbd1cde839adaf80" class="ne-p"><span class="ne-text">2020-05-23T01:12:19.602Z</span></p></div><p id="9eaa499c79d29e4c3d4bdd039ec54dd2" class="ne-p"><br></p><ul class="ne-ul"><li id="676a1a3f76863ae0a848cfaedc872431"><span class="ne-text">T：他表示后面跟的时间</span></li><li id="6183113db5a5966d0ab57188975aa088"><span class="ne-text">Z：表示UTC统一时间</span></li><li id="d3af0d669756ee8763c4d79eefb64c54"><span class="ne-text">602：表示毫秒，如果为6020，最后得到的时间，秒会增加1秒。000Z意思就是 0毫秒  utc统一时间</span></li></ul><p id="d2797006e0f8b29e29a89fc88f3ab4c7" class="ne-p"><br></p><h3 id="dc06252c"><span class="ne-text">java实现</span></h3><p id="24ae5ed0f50a0c0acbbeff8b0718cbba" class="ne-p"><br></p><pre data-language="java" id="288fb211" class="ne-codeblock language-java">package website;<p>import java.text.*;<br>import java.util.Date;</p><p>public class UTC_GST {<br>public static void main(String[] args) throws ParseException {<br>String date = “2020-05-23T20:12:19.602Z”;<br>date = date.replace(“Z”, “ UTC”);<br>System.out.println(“输入的 UTC 格式数据为：”+date);<br>SimpleDateFormat format = new SimpleDateFormat(“yyyy-MM-dd’T’HH:mm:ss.SSS Z”);<br>Date d = format.parse(date);<br>System.out.println(“输出的背景格式数据为：”+d);<br>}<br>}</pre><p id="960563780a70e24311a2d92263c509d2" class="ne-p"><br></p><pre data-language="java" id="cb733382" class="ne-codeblock language-java">输入的 UTC 格式数据为：2020-05-23T20:12:19.602 UTC<br>输出的背景格式数据为：Sun May 24 04:12:19 CST 2020</pre><p id="881306f2187ec1f53ec678fe2fe11943" class="ne-p"><br></p><pre data-language="java" id="93fc557e" class="ne-codeblock language-java">package website;</p><p>import java.text.SimpleDateFormat;<br>import java.util.Date;</p><p>public class Format {<br>public static void main(String[] args) {</p><pre><code>    Date ss = new Date();    System.out.println(&quot;一般日期输出：&quot; + ss);    System.out.println(&quot;toString日期输出：&quot; + ss.toString());    System.out.println(&quot;时间戳：&quot; + ss.getTime()+&quot;\n&quot;); // getTime返回的是1970年1月1号至今流逝的时间    //Date aw = Calendar.getInstance().getTime();//获得时间的另一种方式，测试效果一样    SimpleDateFormat format0 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    String time = format0.format(ss.getTime());//这个就是把时间戳经过处理得到期望格式的时间    System.out.println(&quot;格式化结果0：&quot; + time + &quot;\n&quot;);    SimpleDateFormat format1 = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;);    time = format1.format(ss.getTime());    System.out.println(&quot;格式化结果1：&quot; + time + &quot;\n&quot;);&#125;</code></pre><p>}</pre><p id="c99c2436480b0b9dbf0fc97e1cdf24d2" class="ne-p"><br></p><pre data-language="java" id="fd4c89ed" class="ne-codeblock language-java">一般日期输出：Sat May 23 15:03:25 CST 2020<br>toString 日期输出：Sat May 23 15:03:25 CST 2020<br>时间戳：1590217405777</p><p>格式化结果 0：2020-05-23 15:03:25</p><p>格式化结果 1：2020 年 05 月 23 日 15 时 03 分 25 秒</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pandas库使用——基础知识</title>
      <link href="/blog/li8bkt/"/>
      <url>/blog/li8bkt/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="Zj5wq"><span class="ne-text">一、Pandas数据结构</span></h2><pre data-language="python" id="531f71c9" class="ne-codeblock language-python">import pandas as pd</pre><p id="64598c6647357a991a7aeda728c24565" class="ne-p"><br></p><h3 id="Series"><span class="ne-text">Series</span></h3><p id="81a7898e1a18038391463c044043e249" class="ne-p"><br></p><div class="ne-quote"><ol class="ne-ol"><li id="595fc87a6ac842e606abc1431145149d"><span class="ne-text">通过list构建Series</span></li></ol></div><p id="a3b3a6df45405a4e1672bf3546454f28" class="ne-p"><br></p><pre data-language="python" id="238e70a0" class="ne-codeblock language-python">ser_obj = pd.Series(range(10, 20,2))<p>print (type(ser_obj))<br>print(ser_obj)</pre><p id="f462a0c9cba1c8837e2a412c23a602ec" class="ne-p"><br></p><pre data-language="plain" id="c1f6d884" class="ne-codeblock language-plain"><class 'pandas.core.series.Series'><br>0 10<br>1 12<br>2 14<br>3 16<br>4 18<br>dtype: int64</pre><p id="867a54850090293c3454d4d223a1c817" class="ne-p"><br></p><pre data-language="python" id="a9180165" class="ne-codeblock language-python"># 获取数据<br>print (ser_obj.values)</p><h1 id="获取索引"><a href="#获取索引" class="headerlink" title="获取索引"></a>获取索引</h1><p>print (ser_obj.index) #范围索引数据类型</p><h1 id="预览数据"><a href="#预览数据" class="headerlink" title="预览数据"></a>预览数据</h1><p>print (ser_obj.head(3)) #默认输出五行</pre><p id="a16e7e17ba3b650c95491b4694181df3" class="ne-p"><br></p><pre data-language="plain" id="7d59302b" class="ne-codeblock language-plain">[10 12 14 16 18]<br>RangeIndex(start=0, stop=5, step=1)<br>0 10<br>1 12<br>2 14<br>dtype: int64</pre><p id="37bed406f3295d67975e6ee5109d6c29" class="ne-p"><br></p><div class="ne-quote"><ol start="2" class="ne-ol"><li id="6a12031f0d9b708357c35cb2de39abc2"><span class="ne-text">通过 dict 构建 Series</span></li></ol></div><p id="61b2c553c683ae4526c7f464928e9ae8" class="ne-p"><br></p><pre data-language="python" id="88975fdf" class="ne-codeblock language-python">year_data = {2001: 17.8, 2002: 20.1, 2003: 16.5,2004:324,2423:243}<br>ser_obj2 = pd.Series(year_data)<br>print (ser_obj2.head(2))<br>print (ser_obj2.index)<br>print(ser_obj2)</pre><p id="c843671f361878b033c4be85aba57cca" class="ne-p"><br></p><pre data-language="plain" id="a1c581a1" class="ne-codeblock language-plain">2001 17.8<br>2002 20.1<br>dtype: float64<br>Int64Index([2001, 2002, 2003, 2004, 2423], dtype='int64')<br>2001 17.8<br>2002 20.1<br>2003 16.5<br>2004 324.0<br>2423 243.0<br>dtype: float64</pre><p id="c651e2c3276a13d5e8f5f070d19af4c8" class="ne-p"><br></p><pre data-language="python" id="8ca89bc8" class="ne-codeblock language-python"># name 属性【【【【【出问题了！！！】】】】】<br>ser_obj2.name = '钱'<br>ser_obj2.index.name = 'year'<br>print (ser_obj2.head())</pre><p id="ee6934764425275e489856f62ff2ad54" class="ne-p"><br></p><pre data-language="plain" id="1c66198e" class="ne-codeblock language-plain">year<br>2001 17.8<br>2002 20.1<br>2003 16.5<br>2004 324.0<br>2423 243.0<br>Name: 钱, dtype: float64</pre><p id="4256388e88f01a1d5bb186da7ddf17ea" class="ne-p"><br></p><h3 id="DataFrame"><span class="ne-text">DataFrame</span></h3><p id="af86fb91a5ca2fb88f034dbe5866eebb" class="ne-p"><br></p><div class="ne-quote"><ol class="ne-ol"><li id="9e36348a1fe37c2e77344588212ebf88"><span class="ne-text">通过 ndarray 构建 DataFrame</span></li></ol></div><p id="e3c16ed248fb0d5b06fe413dc77eb7f8" class="ne-p"><br></p><pre data-language="python" id="9b7e7e59" class="ne-codeblock language-python">import numpy as np</p><p>array = np.random.rand(5,4)<br>print (array)</p><p>df_obj = pd.DataFrame(array,columns=[‘a’,’b’,’c’,’d’])<br>print (df_obj.head())<br>print(df_obj.sort_values(by=’a’, ascending=False))</pre><p id="52c3155a83e623f4215f5166e1656369" class="ne-p"><br></p><pre data-language="plain" id="673d2cc8" class="ne-codeblock language-plain">[[0.23496522 0.92258429 0.36447462 0.52634697]<br> [0.73743514 0.88175941 0.48944212 0.4173522 ]<br> [0.21214568 0.57148666 0.59496072 0.49490723]<br> [0.7458542  0.74743907 0.70475157 0.28130394]<br> [0.43805937 0.90300134 0.00730653 0.68203725]]<br>a b c d<br>0 0.234965 0.922584 0.364475 0.526347<br>1 0.737435 0.881759 0.489442 0.417352<br>2 0.212146 0.571487 0.594961 0.494907<br>3 0.745854 0.747439 0.704752 0.281304<br>4 0.438059 0.903001 0.007307 0.682037<br>a b c d<br>3 0.745854 0.747439 0.704752 0.281304<br>1 0.737435 0.881759 0.489442 0.417352<br>4 0.438059 0.903001 0.007307 0.682037<br>0 0.234965 0.922584 0.364475 0.526347<br>2 0.212146 0.571487 0.594961 0.494907</pre><p id="37892e6046ec4a72e3651fc6ccf5b91a" class="ne-p"><br></p><div class="ne-quote"><ol start="2" class="ne-ol"><li id="6fd033f73c60a22a7c7856115e2f6294"><span class="ne-text">通过 dict 构建 DataFrame</span></li></ol></div><p id="f1e0fbc6f41eda70e1287a72a742c1fc" class="ne-p"><br></p><pre data-language="python" id="6aede931" class="ne-codeblock language-python">#一个键值对就相当于一列！！但是具体到字典里面的值所用到的一些函数还是不能很清楚<br>dict_data = {'A': 1.,<br>'B': pd.Timestamp('20161217'),<br>'C': pd.Series(1, index=list(range(4)),dtype='float32'),<br>'D': np.array([3] * 4,dtype='int32'),<br>'E' : pd.Categorical(["Python","Java","C++","C#"]),<br>'F' : 'ChinaHadoop' }<br>df_obj2 = pd.DataFrame(dict_data)<br>print (df_obj2.head())</pre><p id="3c92a21f44121ca5734c1601936a901a" class="ne-p"><br></p><pre data-language="plain" id="3da7f2ee" class="ne-codeblock language-plain"> A B C D E F<br>0 1.0 2016-12-17 1.0 3 Python ChinaHadoop<br>1 1.0 2016-12-17 1.0 3 Java ChinaHadoop<br>2 1.0 2016-12-17 1.0 3 C++ ChinaHadoop<br>3 1.0 2016-12-17 1.0 3 C# ChinaHadoop</pre><p id="7d77e458dc5484b333953bb9e9fb40eb" class="ne-p"><br></p><pre data-language="python" id="d8a01968" class="ne-codeblock language-python"># 增加列<br>df_obj2['G'] = df_obj2['D'] + 4<br>print (df_obj2.head())<br>xxx = pd.DataFrame(df_obj2,columns=['A','B','C','D','E','F','G','H'],index=[0,1,2,3,4])<br>print(xxx)</pre><p id="cb400dc63863cf7a006b70f30ff68d40" class="ne-p"><br></p><pre data-language="plain" id="0c80db1b" class="ne-codeblock language-plain"> A B C D E F G<br>0 1.0 2016-12-17 1.0 3 Python ChinaHadoop 7<br>1 1.0 2016-12-17 1.0 3 Java ChinaHadoop 7<br>2 1.0 2016-12-17 1.0 3 C++ ChinaHadoop 7<br>3 1.0 2016-12-17 1.0 3 C# ChinaHadoop 7<br>A B C D E F G H<br>0 1.0 2016-12-17 1.0 3.0 Python ChinaHadoop 7.0 NaN<br>1 1.0 2016-12-17 1.0 3.0 Java ChinaHadoop 7.0 NaN<br>2 1.0 2016-12-17 1.0 3.0 C++ ChinaHadoop 7.0 NaN<br>3 1.0 2016-12-17 1.0 3.0 C# ChinaHadoop 7.0 NaN<br>4 NaN NaT NaN NaN NaN NaN NaN NaN</pre><p id="afee90e9c536669026b735adf77486d9" class="ne-p"><br></p><h3 id="Index"><span class="ne-text">Index</span></h3><p id="aa0dd744f83a8a9e13c0df361272a804" class="ne-p"><br></p><pre data-language="python" id="e55e4f0d" class="ne-codeblock language-python">print (type(ser_obj.index))<br>print (type(df_obj2.index))</p><p>print (df_obj2.index)</pre><p id="7eed9c93342f7efbc7d001b7fe8c03ab" class="ne-p"><br></p><pre data-language="plain" id="5de5ed27" class="ne-codeblock language-plain"><class 'pandas.core.indexes.range.RangeIndex'><br><class 'pandas.core.indexes.numeric.Int64Index'><br>Int64Index([0, 1, 2, 3], dtype='int64')</pre><p id="74087c11e0999852099cdc9ef3d9efff" class="ne-p"><br></p><pre data-language="python" id="427dc620" class="ne-codeblock language-python"># 索引对象不可变<br>df_obj2.index[0] = 2</pre><p id="4f580ce71ad1527d01d87f0ed52c0d59" class="ne-p"><br></p><pre data-language="plain" id="2cb69a7b" class="ne-codeblock language-plain">---------------------------------------------------------------------------</p><p>TypeError Traceback (most recent call last)</p><p><ipython-input-10-6367894e76d8> in <module><br>1 # 索引对象不可变<br>—-&gt; 2 df_obj2.index[0] = 2</p><p>~\Anaconda3\lib\site-packages\pandas\core\indexes\base.py in <strong>setitem</strong>(self, key, value)<br>4258<br>4259 def <strong>setitem</strong>(self, key, value):<br>-&gt; 4260 raise TypeError(“Index does not support mutable operations”)<br>4261<br>4262 def <strong>getitem</strong>(self, key):</p><p>TypeError: Index does not support mutable operations</pre><p id="f1d1b709a9ae55db1577a0d5e804ef2a" class="ne-p"><br></p><span id="python"></span><p id="9f9feacbbe1d6904748682e48d864f9d" class="ne-p"><br></p><h2 id="00f40f54"><span class="ne-text">二、Pandas 数据操作</span></h2><p id="c8145203e9bb082405f112fec0399d80" class="ne-p"><br></p><h3 id="63421879"><span class="ne-text">常用函数总结</span></h3><p id="227fe566e3117c1ad2d257bb135230aa" class="ne-p"><br></p><div class="ne-quote"><p id="030a4cdcd69b7e00d9a772425ccd6c72" class="ne-p"><span class="ne-text">·shape   获取数据的尺寸</span></p></div><p id="c395b366d0c5a8d51b90e47f0e128293" class="ne-p"><br></p><pre data-language="plain" id="f48b3bac" class="ne-codeblock language-plain"> 获得 df 的 size：df.shape<br>获得 df 中的行数：df.shape[0]<br>获得 df 中的列数： df.shape[1]<br>获得行索引信息：df.index<br>获得列索引信息：df.colomns</pre><p id="1764c30a157dbd2c2622f65d511d4466" class="ne-p"><br></p><div class="ne-quote"><p id="4f872c1735a10d292a72d19e28b11e90" class="ne-p"><span class="ne-text">·values   获得 df 中的值===中文没用</span></p></div><p id="b79b055d747cced8a2d5d9c7ed45c5c0" class="ne-p"><br></p><pre data-language="plain" id="1d8cf548" class="ne-codeblock language-plain">df.values === 以列表的形式展现出来，去除了索引===dataframe 类型数据转换成 array 类型</pre><p id="1c74a235565230d15bef5aeb5c7a63b8" class="ne-p"><br></p><div class="ne-quote"><p id="61c69c64f105fa552561967eb4ebd891" class="ne-p"><span class="ne-text">·setindex 和 resetindex</span></p></div><p id="476d0ffe5598a8157c0bf2a747e8e037" class="ne-p"><br></p><pre data-language="plain" id="c34e4894" class="ne-codeblock language-plain">reset_index 可以还原索引，从新变为默认的整型索引<br>DataFrame.reset_index(level=None, drop=False, inplace=False, col_level=0, col_fill=”)<br>level 控制了具体要还原的那个等级的索引<br>drop 为 False 则索引列会被还原为普通列，否则会丢失<br>set_index 方法，设置单索引和复合索引抑或是添加索引。<br>DataFrame.set_index(keys, drop=True, append=False, inplace=False, verify_integrity=False)<br>append 添加新索引，drop 为 False，inplace 为 True 时，索引将会还原为列</pre><p id="3d0b56fa7f6c54be0af81c7da92afb5d" class="ne-p"><br></p><div class="ne-quote"><p id="be9a0c0e9a05e861b67d78e1265ce5ba" class="ne-p"><span class="ne-text">·iterrows（）遍历 DataFrame 中的数据</span></p></div><p id="2085ec4d8885af04f903986e508b0318" class="ne-p"><br></p><pre data-language="plain" id="9d530681" class="ne-codeblock language-plain">for index,row in df.iterrows():</pre><p id="0896b7932167ac4e6881066c2421395f" class="ne-p"><br></p><div class="ne-quote"><p id="e98fb020ffb27d4b399c1df48444ac31" class="ne-p"><span class="ne-text">·split(sep,n,expand=false)</span></p></div><p id="b168adb52493a4e1d42e107f9a70bea9" class="ne-p"><br></p><pre data-language="plain" id="f8152193" class="ne-codeblock language-plain">sep 表示用于分割的字符；n 表格分割成多少列；expand 表示是否展开为数据款，True 输出 Series，False 输出 Dataframe。<br>字段拆分：是指按照固定的字符，拆分已有字符串</pre><p id="1f0bff324cbbc0a706fe24efd2d14f86" class="ne-p"><br></p><pre data-language="python" id="5b25766e" class="ne-codeblock language-python">import pandas as pd<br>import numpy as np</pre><p id="62e68dc6988b91ce15233ab71f8ac8ba" class="ne-p"><br></p><h3 id="548cb2e7"><span class="ne-text">匿名函数应用</span></h3><p id="4d385ea0b72df561c9ede1550790f380" class="ne-p"><br></p><pre data-language="python" id="c17faeee" class="ne-codeblock language-python"># Numpy ufunc 函数<br>df = pd.DataFrame(np.random.randn(5,4) - 1)<br>print (df)</p><p>print (np.abs(df))</pre><p id="bdb01dab77cb0e059bdbb14885331a46" class="ne-p"><br></p><pre data-language="plain" id="89187c85" class="ne-codeblock language-plain"> 0 1 2 3<br>0 0.624016 -2.695175 -1.211426 -0.386151<br>1 -1.335385 -1.315232 -0.305902 -0.361348<br>2 -0.349443 -2.032110 0.075995 -0.966725<br>3 -1.631192 -1.051390 -1.767981 -0.366663<br>4 -0.786178 -0.335846 -0.797992 -0.931216<br>0 1 2 3<br>0 0.624016 2.695175 1.211426 0.386151<br>1 1.335385 1.315232 0.305902 0.361348<br>2 0.349443 2.032110 0.075995 0.966725<br>3 1.631192 1.051390 1.767981 0.366663<br>4 0.786178 0.335846 0.797992 0.931216</pre><p id="282b53ed88d89f06ecccfc583566c5bc" class="ne-p"><br></p><pre data-language="python" id="db3701cc" class="ne-codeblock language-python"># 使用 apply 应用行或列数据<br>f = lambda x : x.max()<br>print (df.apply(f))</pre><p id="a6263942dadc12148255472c4a074ca6" class="ne-p"><br></p><pre data-language="plain" id="5ba3d852" class="ne-codeblock language-plain">0 0.624016<br>1 -0.335846<br>2 0.075995<br>3 -0.361348<br>dtype: float64</pre><p id="6c1efbacd97b957dab5d707e05bb080c" class="ne-p"><br></p><pre data-language="python" id="38019327" class="ne-codeblock language-python"># 指定轴方向<br>print (df.apply(f, axis=1))</pre><p id="895376894be37cc403c587c8306c4a05" class="ne-p"><br></p><pre data-language="plain" id="54c01db0" class="ne-codeblock language-plain">0 0.624016<br>1 -0.305902<br>2 0.075995<br>3 -0.366663<br>4 -0.335846<br>dtype: float64</pre><p id="a1dca7860d574a9bd09099306b4cf69b" class="ne-p"><br></p><pre data-language="python" id="00fcd816" class="ne-codeblock language-python"># 使用 applymap 应用到每个数据<br>f2 = lambda x : '%.2f' % x<br>print (df.applymap(f2))</pre><p id="a0ccbf54ee1222d18a92df19d90b4642" class="ne-p"><br></p><pre data-language="plain" id="9448cc35" class="ne-codeblock language-plain"> 0 1 2 3<br>0 0.62 -2.70 -1.21 -0.39<br>1 -1.34 -1.32 -0.31 -0.36<br>2 -0.35 -2.03 0.08 -0.97<br>3 -1.63 -1.05 -1.77 -0.37<br>4 -0.79 -0.34 -0.80 -0.93</pre><p id="5c58c9b67e870902430c102b72efefc3" class="ne-p"><br></p><h3 id="c360e994"><span class="ne-text">排序</span></h3><p id="fa019d431a8e2900fbaf1cf42eee0f85" class="ne-p"><br></p><pre data-language="python" id="0e7b1320" class="ne-codeblock language-python">s4 = pd.Series(range(10, 15), index = np.random.randint(5, size=5))<br>print (s4)</pre><p id="a9738ba952913a34f56a903262a9e42a" class="ne-p"><br></p><pre data-language="plain" id="6a994618" class="ne-codeblock language-plain">4 10<br>1 11<br>4 12<br>1 13<br>1 14<br>dtype: int64</pre><p id="2d7974e77d711e32ef0d2f173e4e5a42" class="ne-p"><br></p><div class="ne-quote"><ol class="ne-ol"><li id="b787c42fb378cdd230e7f18152d9fc6e"><span class="ne-text">索引排序</span></li></ol></div><p id="361e603592d19c7f51bf6ec830187a07" class="ne-p"><br></p><pre data-language="python" id="62020249" class="ne-codeblock language-python"><br>s4.sort_index()</pre><p id="bce8bb3f2f05af2e6f3b5e82c6d907b5" class="ne-p"><br></p><pre data-language="plain" id="bf351b4f" class="ne-codeblock language-plain">1 11<br>1 13<br>1 14<br>4 10<br>4 12<br>dtype: int64</pre><p id="fdcbe02b1e3e11f97da18f03c09cafc6" class="ne-p"><br></p><pre data-language="python" id="383efb9d" class="ne-codeblock language-python">df4 = pd.DataFrame(np.random.randn(3, 4),<br>index=np.random.randint(3, size=3),<br>columns=np.random.randint(4, size=4))</pre><p id="c4e6e18691e543baf3d74d00fed4b062" class="ne-p"><br></p><pre data-language="python" id="pythondf4" class="ne-codeblock language-python">df4</pre><p id="526a8fb83681027ff62d0ad46d8e5bda" class="ne-p"><br></p><table id="54465905" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="150"></td><td width="150"><p id="u3d60c20c" class="ne-p"><span class="ne-text">2</span></p></td><td width="150"><p id="ua972c94c" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="uacc282b0" class="ne-p"><span class="ne-text">3</span></p></td><td width="150"><p id="ua57c2184" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u7bdafe09" class="ne-p"><span class="ne-text">0</span></p></td><td width="150"><p id="u9e0fb881" class="ne-p"><span class="ne-text">0.007031</span></p></td><td width="150"><p id="u49092440" class="ne-p"><span class="ne-text">1.261990</span></p></td><td width="150"><p id="u66f07d12" class="ne-p"><span class="ne-text">-1.647929</span></p></td><td width="150"><p id="u85a3eb8e" class="ne-p"><span class="ne-text">0.176549</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u4cb2dc62" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="u01e0bde4" class="ne-p"><span class="ne-text">-2.510698</span></p></td><td width="150"><p id="ud88fce81" class="ne-p"><span class="ne-text">-0.207659</span></p></td><td width="150"><p id="u469ebb03" class="ne-p"><span class="ne-text">0.628221</span></p></td><td width="150"><p id="u9170bc0d" class="ne-p"><span class="ne-text">0.441352</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ue2d6a948" class="ne-p"><span class="ne-text">0</span></p></td><td width="150"><p id="u257d4c82" class="ne-p"><span class="ne-text">-0.367051</span></p></td><td width="150"><p id="u4367bd13" class="ne-p"><span class="ne-text">1.536606</span></p></td><td width="150"><p id="uc2aede5c" class="ne-p"><span class="ne-text">0.167158</span></p></td><td width="150"><p id="u8de9c1a3" class="ne-p"><span class="ne-text">-0.236129</span></p></td></tr></tbody></table><p id="13d7a0400e4a39d2d79ad7b303c5920a" class="ne-p"><br></p><pre data-language="python" id="2ede7dcd" class="ne-codeblock language-python">#df4.sort_index(ascending=False)<br>df4.sort_index(axis=1)</pre><p id="2a4ec755389ca2de29727be4924b1904" class="ne-p"><br></p><table id="aae8b8e6" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="150"></td><td width="150"><p id="u48c95b51" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="udf0a3f71" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="uc27cd52b" class="ne-p"><span class="ne-text">2</span></p></td><td width="150"><p id="u308e210e" class="ne-p"><span class="ne-text">3</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ue1fbb30e" class="ne-p"><span class="ne-text">0</span></p></td><td width="150"><p id="u567adc0b" class="ne-p"><span class="ne-text">1.261990</span></p></td><td width="150"><p id="uc597078f" class="ne-p"><span class="ne-text">0.176549</span></p></td><td width="150"><p id="ub1a8ae11" class="ne-p"><span class="ne-text">0.007031</span></p></td><td width="150"><p id="u34935057" class="ne-p"><span class="ne-text">-1.647929</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ua924ba9d" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="ua216e706" class="ne-p"><span class="ne-text">-0.207659</span></p></td><td width="150"><p id="u69a8d6c8" class="ne-p"><span class="ne-text">0.441352</span></p></td><td width="150"><p id="ucbf04447" class="ne-p"><span class="ne-text">-2.510698</span></p></td><td width="150"><p id="u030c1b4b" class="ne-p"><span class="ne-text">0.628221</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u41f66984" class="ne-p"><span class="ne-text">0</span></p></td><td width="150"><p id="u75652155" class="ne-p"><span class="ne-text">1.536606</span></p></td><td width="150"><p id="u79340f36" class="ne-p"><span class="ne-text">-0.236129</span></p></td><td width="150"><p id="u3c43abba" class="ne-p"><span class="ne-text">-0.367051</span></p></td><td width="150"><p id="u541220e8" class="ne-p"><span class="ne-text">0.167158</span></p></td></tr></tbody></table><p id="13be3f79fc3c94206791985e9fec0344" class="ne-p"><br></p><div class="ne-quote"><ol start="2" class="ne-ol"><li id="1805359db39da03074933e07617e6c0c"><span class="ne-text">按值排序</span></li></ol></div><p id="f6084774bc518891332d7a1628637230" class="ne-p"><br></p><pre data-language="python" id="fbf6c04a" class="ne-codeblock language-python"><br>#df.sortvalues(by='a', ascending=False) === 通过 a 的值</p><h1 id="作用是对选定的一列数值（’a’）数据从上往下从小到大进行排序（如果传值没成功-设置本体覆盖，传值覆盖）"><a href="#作用是对选定的一列数值（’a’）数据从上往下从小到大进行排序（如果传值没成功-设置本体覆盖，传值覆盖）" class="headerlink" title="作用是对选定的一列数值（’a’）数据从上往下从小到大进行排序（如果传值没成功===设置本体覆盖，传值覆盖）"></a>作用是对选定的一列数值（’a’）数据从上往下从小到大进行排序（如果传值没成功===设置本体覆盖，传值覆盖）</h1><p>df4.sort_values(by=1)</pre><p id="255ab5286c37fbbc409790403455a290" class="ne-p"><br></p><pre data-language="plain" id="4b4ad6d9" class="ne-codeblock language-plain">---------------------------------------------------------------------------</p><p>ValueError Traceback (most recent call last)</p><p><ipython-input-22-36ffa8ddd07d> in <module><br>2 #df.sortvalues(by=’a’, ascending=False) === 通过 a 的值<br>3 # 作用是对选定的一列数值（’a’）数据从上往下从小到大进行排序（如果传值没成功===设置本体覆盖，传值覆盖）<br>—-&gt; 4 df4.sort_values(by=1)</p><p>~\Anaconda3\lib\site-packages\pandas\core\frame.py in sort_values(self, by, axis, ascending, inplace, kind, na_position)<br>4991<br>4992 by = by[0]<br>-&gt; 4993 k = self._get_label_or_level_values(by, axis=axis)<br>4994<br>4995 if isinstance(ascending, (tuple, list)):</p><p>~\Anaconda3\lib\site-packages\pandas\core\generic.py in _get_label_or_level_values(self, key, axis)<br>1795 key=key,<br>1796 label_axis_name=label_axis_name,<br>-&gt; 1797 multi_message=multi_message,<br>1798 )<br>1799 )</p><p>ValueError: The column label ‘1’ is not unique.</pre><p id="35f1ee2ed50d88c39dfd98e4bf1896d3" class="ne-p"><br></p><span id="python-1"></span></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Numpy库使用</title>
      <link href="/blog/mk2z96/"/>
      <url>/blog/mk2z96/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="5dda6113"><span class="ne-text">一、NumPy</span></h2><h3 id="c974c4cf"><span class="ne-text">ndarray 理解多维数组</span></h3><p id="9f70acbd729b36a9550c3da1acdf3cca" class="ne-p"><br></p><pre data-language="python" id="7081fdac" class="ne-codeblock language-python">import numpy as np<h1 id="生成指定维度的随机多维数据"><a href="#生成指定维度的随机多维数据" class="headerlink" title="生成指定维度的随机多维数据"></a>生成指定维度的随机多维数据</h1><p>#数学建模应该用不到<br>data = np.random.rand(2, 3)<br>print (data)<br>print (type(data))<br>#type 是显示数据类型；shape 显示维度；ndim 维度个数;type 另外的作用</pre><p id="07d42de244aa1fb833b377a8665b3cc1" class="ne-p"><br></p><pre data-language="plain" id="a06ac586" class="ne-codeblock language-plain">[[0.46686682 0.68844304 0.76663872]<br> [0.70747721 0.47887587 0.25943412]]<br><class 'numpy.ndarray'></pre><p id="924326de9382f2a656033f0f039d6643" class="ne-p"><br></p><div class="ne-quote"><p id="da3825b347a4453dee4080f62645940b" class="ne-p"><span class="ne-text">ndim, shape 和 dtype 属性</span></p></div><p id="1444c16d449be0b1f2efbbccab430e2d" class="ne-p"><br></p><pre data-language="python" id="e19d27fc" class="ne-codeblock language-python">print ('维度个数', data.ndim)<br>print ('各维度大小: ', data.shape)<br>print ('数据类型: ', data.dtype)</pre><p id="82aca8ecf8229d0e7c410b658dbe1f6b" class="ne-p"><br></p><pre data-language="plain" id="ef5d4e3a" class="ne-codeblock language-plain">维度个数 2<br>各维度大小: (2, 3)<br>数据类型: float64</pre><p id="33bec1f6cb39ce4363a114d9b2aa6553" class="ne-p"><br></p><h3 id="c774ee7b"><span class="ne-text">创建 ndarray</span></h3><p id="8387622836f4affadaac98f63b7a0c37" class="ne-p"><br></p><pre data-language="python" id="c679f6ce" class="ne-codeblock language-python">'''1. array 创建'''</p><h1 id="list-转换为-ndarray"><a href="#list-转换为-ndarray" class="headerlink" title="list 转换为 ndarray"></a>list 转换为 ndarray</h1><p>l = range(10)<br>data = np.array(l)<br>print (data)<br>print (data.shape)<br>print (data.ndim)</pre><p id="e28071517cf66555a1ba01c9bda0e43e" class="ne-p"><br></p><pre data-language="plain" id="6619c950" class="ne-codeblock language-plain">[0 1 2 3 4 5 6 7 8 9]<br>(10,)<br>1</pre><p id="a470ceb0a563ee753b83f6440d4d275b" class="ne-p"><br></p><pre data-language="python" id="39829142" class="ne-codeblock language-python"># 嵌套序列转换为 ndarray<br>l2 = [range(10), range(10)] #就这样形成了一个数组<br>data = np.array(l2)<br>print (data)<br>print (data.shape)</pre><p id="974aae87a659606e931232d92865e517" class="ne-p"><br></p><pre data-language="plain" id="f001baec" class="ne-codeblock language-plain">[[0 1 2 3 4 5 6 7 8 9]<br> [0 1 2 3 4 5 6 7 8 9]]<br>(2, 10)</pre><p id="3a70740bfdc4ca08738c281a5c097fc9" class="ne-p"><br></p><pre data-language="python" id="2c17344d" class="ne-codeblock language-python">'''2. zeros;ones;empty 创建'''</p><h1 id="np-zeros"><a href="#np-zeros" class="headerlink" title="np.zeros"></a>np.zeros</h1><p>zeros_arr = np.zeros((3, 4)) #注意元组，这里经常报错</p><h1 id="np-ones"><a href="#np-ones" class="headerlink" title="np.ones"></a>np.ones</h1><p>ones_arr = np.ones((2, 3))</p><h1 id="np-empty-不全为零，而且是随机的一些数字"><a href="#np-empty-不全为零，而且是随机的一些数字" class="headerlink" title="np.empty[不全为零，而且是随机的一些数字]"></a>np.empty[不全为零，而且是随机的一些数字]</h1><p>empty_arr = np.empty((3, 3))</p><h1 id="np-empty-指定数据类型"><a href="#np-empty-指定数据类型" class="headerlink" title="np.empty 指定数据类型"></a>np.empty 指定数据类型</h1><p>empty_int_arr = np.empty((3, 3), int)</p><p>print (zeros_arr)<br>print (‘————-‘)<br>print (ones_arr)<br>print (‘————-‘)<br>print (empty_arr)<br>print (‘————-‘)<br>print (empty_int_arr)</pre><p id="ab801385f72967ebf3c91fa514400330" class="ne-p"><br></p><pre data-language="plain" id="b08dec6a" class="ne-codeblock language-plain">[[0. 0. 0. 0.]<br> [0. 0. 0. 0.]<br> [0. 0. 0. 0.]]</p><hr><p>[[1. 1. 1.]<br> [1. 1. 1.]]</p><hr><p>[[0.000e+000 0.000e+000 0.000e+000]<br> [0.000e+000 0.000e+000 2.174e-321]<br> [0.000e+000 0.000e+000 0.000e+000]]</p><hr><p>[[0 0 0]<br> [0 0 0]<br> [0 0 0]]</pre><p id="261d294fc6b68e7ec8a03998dac8cc87" class="ne-p"><br></p><pre data-language="python" id="44003b0f" class="ne-codeblock language-python"># np.arange() #创建一系列连续的数算是 numpy 里面类似 python 里面 range 的功能<br>print (np.arange(10))</pre><p id="d89e37e1e82664c45661497492c93b6b" class="ne-p"><br></p><pre data-language="plain" id="a05403ae" class="ne-codeblock language-plain">[0 1 2 3 4 5 6 7 8 9]</pre><p id="b93b188a587362374f6073381039a19a" class="ne-p"><br></p><h2 id="cedb2184"><span class="ne-text">二、操作 nddarray</span></h2><p id="e85630f7171ce0ac05e544139727e542" class="ne-p"><br></p><h3 id="0e0c1ff0"><span class="ne-text">矢量化 (vectorization)</span></h3><p id="4a2ff1b6092c45db28a61a978b9e2fbd" class="ne-p"><br></p><pre data-language="python" id="6f3f144f" class="ne-codeblock language-python"># 矢量与矢量运算<br>arr = np.array([[1, 2, 3],<br>                [4, 5, 6]])</p><p>print (“元素之间相乘：”) #注意区分矩阵之间的运算。这里的矢量原酸相当于是广播式的运算<br>print (arr * arr)</p><p>print (“矩阵相加：”)<br>print (arr + arr)</pre><p id="081a9aa3cd7e2cf2223a71ee18cf1c5d" class="ne-p"><br></p><pre data-language="plain" id="9ae28759" class="ne-codeblock language-plain">元素之间相乘：<br>[[1  4  9]<br> [16 25 36]]<br>矩阵相加：<br>[[2  4  6]<br> [ 8 10 12]]</pre><p id="3115c158cbe32ab1ef50e2413f48cf4a" class="ne-p"><br></p><pre data-language="python" id="59343366" class="ne-codeblock language-python"># 矢量与标量运算<br>print (1. / arr)<br>print (2. * arr)</pre><p id="97d65a13721f6408e8efee0baaf1f599" class="ne-p"><br></p><pre data-language="plain" id="05e4310d" class="ne-codeblock language-plain">[[1.         0.5        0.33333333]<br> [0.25       0.2        0.16666667]]<br>[[2.  4.  6.]<br> [ 8. 10. 12.]]</pre><p id="5169a002f9b59ecd2c6126932bc57eb7" class="ne-p"><br></p><h3 id="7e64e175"><span class="ne-text">索引与切片</span></h3><p id="7fb186f67058cd0d01b845c64926659d" class="ne-p"><br></p><pre data-language="python" id="b8c86735" class="ne-codeblock language-python"># 一维数组<br>arr1 = np.arange(10)<br>print (arr1)</p><p>print (arr1[2:5])</pre><p id="a0cd79f720336ff7de907a13d1b3535a" class="ne-p"><br></p><pre data-language="plain" id="e2d66b1c" class="ne-codeblock language-plain">[0 1 2 3 4 5 6 7 8 9]<br>[2 3 4]</pre><p id="93bc9543ed6f1f3e1fabd55651fb321c" class="ne-p"><br></p><pre data-language="python" id="f695cd4d" class="ne-codeblock language-python"># 多维数组<br>arr2 = np.arange(12).reshape(3,4) #要学会定义多维数组，arange 是形成 12 个随机数，之后的 reshape 是形成维数 #多维数组的空间含义就是比如：3.4.5=长 4 宽 5 高 3 #还有点数就是应用函数<br>print (arr2)</pre><p id="5c77c9d0d8989e1bb8d0c3ae5d20ba4c" class="ne-p"><br></p><pre data-language="plain" id="4aa0139e" class="ne-codeblock language-plain">[[0  1  2  3]<br> [ 4  5  6  7]<br> [ 8  9 10 11]]</pre><p id="4af02b2bbbc7fac5370aa084a8043520" class="ne-p"><br></p><pre data-language="python" id="18090a1c" class="ne-codeblock language-python">print (arr2[1])</p><p>print (arr2[0:2, 2:])</p><p>print (arr2[:, 1:3])</pre><p id="1a4eb13855ef542288c19a4aab2e4faf" class="ne-p"><br></p><pre data-language="plain" id="09249fff" class="ne-codeblock language-plain">[4 5 6 7]<br>[[2 3]<br> [6 7]]<br>[[1  2]<br> [ 5  6]<br> [ 9 10]]</pre><p id="f7542000dc5d71a98c68b90394782f3c" class="ne-p"><br></p><pre data-language="python" id="70e99858" class="ne-codeblock language-python"># 条件索引</p><h1 id="找出-data-arr-中-2015-年后的数据"><a href="#找出-data-arr-中-2015-年后的数据" class="headerlink" title="找出 data_arr 中 2015 年后的数据"></a>找出 data_arr 中 2015 年后的数据</h1><p>data_arr = np.random.rand(3,3)<br>print (data_arr)</p><p>year_arr = np.array([[2000, 2001, 2000],<br>                     [2005, 2002, 2009],<br>                     [2001, 2003, 2010]])</p><p>is_year_after_2005 = year_arr &gt;= 2005<br>#:他会扩展成同类型的数组<br>print (is_year_after_2005, is_year_after_2005.dtype)</p><p>filtered_arr = data_arr[is_year_after_2005]</p><p>filtered_arr = data_arr[year_arr &gt;= 2005]<br>print (filtered_arr) #中间的一些语句可以删除 #最后生成得是一维数组，进行数据过滤的时候很有用</pre><p id="d9792b1e14647aa72aa727b15c52c8c1" class="ne-p"><br></p><pre data-language="plain" id="a10f4330" class="ne-codeblock language-plain">[[0.61482194 0.0249229  0.28525661]<br> [0.05121173 0.37672803 0.86259463]<br> [0.22648329 0.4581513  0.18620441]]<br>[[False False False]<br> [ True False  True]<br> [False False  True]] bool<br>[0.05121173 0.86259463 0.18620441]</pre><p id="2504498c174d6be38a675139f015eacd" class="ne-p"><br></p><pre data-language="python" id="bcb09835" class="ne-codeblock language-python"># 多个条件& |<br>filtered_arr = data_arr[(year_arr <= 2005) & (year_arr % 2 == 0)]<br>print (filtered_arr)</pre><p id="b8a128a40897d47fbfe5deda15269edf" class="ne-p"><br></p><pre data-language="plain" id="4e071c2c" class="ne-codeblock language-plain">[0.61482194 0.28525661 0.37672803]</pre><p id="64ac8a9c1b3d4e47cf770870a80c8d4d" class="ne-p"><br></p><h3 id="e673cd7d"><span class="ne-text">转置 === transpose</span></h3><p id="66629fa2baf1d46faafac6ea93e30087" class="ne-p"><br></p><pre data-language="python" id="beba6818" class="ne-codeblock language-python">arr = np.random.rand(2,3)<br>print (arr)<br>print (arr.transpose())</pre><p id="3fcbcb528fb9ccc4f3cd3d38034984f5" class="ne-p"><br></p><pre data-language="plain" id="6810fb22" class="ne-codeblock language-plain">[[0.01538974 0.47573964 0.90684253]<br> [0.93683601 0.64306611 0.63846634]]<br>[[0.01538974 0.93683601]<br> [0.47573964 0.64306611]<br> [0.90684253 0.63846634]]</pre><p id="58f6d1c9941dcb2c9fae3d4fbfc5d0b6" class="ne-p"><br></p><pre data-language="python" id="7f792af6" class="ne-codeblock language-python">#高维数组的转换(图像里面会用得到转换维度)</p><p>arr3d = np.random.rand(2,3,4)<br>print (arr3d)<br>print (‘———————-‘)<br>print (arr3d.transpose((1,0,2))) # 多维数组的转置和定义不会</pre><p id="81eb6a8e2b7bb4de3329fefb052cafd0" class="ne-p"><br></p><pre data-language="plain" id="1a8d6436" class="ne-codeblock language-plain">[[[0.18074837 0.64652003 0.80527972 0.67800268]<br>  [0.95766577 0.2498768  0.00304503 0.7058178 ]<br>  [0.12523549 0.18796252 0.72463798 0.15352211]]</p><p>[[0.38808013 0.31075033 0.53082474 0.32254431]<br>  [0.6861262  0.02999367 0.70980993 0.09099878]<br>  [0.14987301 0.78237398 0.90159408 0.82897071]]]</p><hr><p>[[[0.18074837 0.64652003 0.80527972 0.67800268]<br>  [0.38808013 0.31075033 0.53082474 0.32254431]]</p><p>[[0.95766577 0.2498768  0.00304503 0.7058178 ]<br>  [0.6861262  0.02999367 0.70980993 0.09099878]]</p><p>[[0.12523549 0.18796252 0.72463798 0.15352211]<br>  [0.14987301 0.78237398 0.90159408 0.82897071]]]</pre><p id="6ba937e85438ed73cf67c1c075cba1af" class="ne-p"><br></p><h3 id="a43ab641"><span class="ne-text">ndarray 数据类型转化 === astype</span></h3><p id="27511ff0b954eeef5dc8b93620941540" class="ne-p"><br></p><pre data-language="python" id="000baa23" class="ne-codeblock language-python">zeros_float_arr = np.zeros((3, 4), dtype=np.float64)<br>print (zeros_float_arr)<br>print (zeros_float_arr.dtype)</p><h1 id="astype-转换数据类型"><a href="#astype-转换数据类型" class="headerlink" title="astype 转换数据类型"></a>astype 转换数据类型</h1><p>zeros_int_arr = zeros_float_arr.astype(np.int32)<br>print (zeros_int_arr)<br>print (zeros_int_arr.dtype)</pre><p id="b9ad655927fa6bdb2a76d5ec4548ccc0" class="ne-p"><br></p><pre data-language="plain" id="04585d60" class="ne-codeblock language-plain">[[0. 0. 0. 0.]<br> [0. 0. 0. 0.]<br> [0. 0. 0. 0.]]<br>float64<br>[[0 0 0 0]<br> [0 0 0 0]<br> [0 0 0 0]]<br>int32</pre><p id="757cd317887ffaf3a780a53985b17744" class="ne-p"><br></p><h3 id="97a6cf61"><span class="ne-text">文本文件的读取</span></h3><p id="1721f0356b7707fd1fbf1c646c0d9517" class="ne-p"><br></p><pre data-language="python" id="87a7ef69" class="ne-codeblock language-python"># loadtxt<br>filename = './presidential_polls.csv'<br>data_array = np.loadtxt(filename, # 文件名<br>delimiter=',', # 指定里面的元素分隔符<br>dtype=str, # 指定数据类型<br>usecols=(0,2,3)) # 指定读取的列索引号<br>print (data_array, data_array.shape)</pre><p id="36a7e4b1748b43e95fd61d94d5e3729d" class="ne-p"><br></p><pre data-language="plain" id="4eaac5c3" class="ne-codeblock language-plain">[['cycle' 'type' 'matchup']<br> ['2016' '"polls-plus"' '"Clinton vs. Trump vs. Johnson"']<br> ['2016' '"polls-plus"' '"Clinton vs. Trump vs. Johnson"']<br> ...<br> ['2016' '"polls-only"' '"Clinton vs. Trump vs. Johnson"']<br> ['2016' '"polls-only"' '"Clinton vs. Trump vs. Johnson"']<br> ['2016' '"polls-only"' '"Clinton vs. Trump vs. Johnson"']] (10237, 3)</pre><p id="09daec525a69a6e9ad33d1c1247315f6" class="ne-p"><br></p><pre data-language="python" id="3688e3d9" class="ne-codeblock language-python"># loadtxt, 明确指定每列数据的类型<br>filename = './presidential_polls.csv'<br>data_array = np.loadtxt(filename, # 文件名<br>delimiter=',', # 分隔符<br>skiprows=1,<br>dtype={'names':('cycle', 'type', 'matchup'),<br>'formats':('i4', 'S15', 'S50')}, # 数据类型<br>usecols=(0,2,3)) # 指定读取的列索引号</p><p>print (data_array, data_array.shape) # 读取的结果是一维的数组，每个元素是一个元组</pre><p id="c5a02cebaed6802aaa1ce221289ee6aa" class="ne-p"><br></p><pre data-language="plain" id="c813ffb6" class="ne-codeblock language-plain">[(2016, b'"polls-plus"', b'"Clinton vs. Trump vs. Johnson"')<br>(2016, b'"polls-plus"', b'"Clinton vs. Trump vs. Johnson"')<br>(2016, b'"polls-plus"', b'"Clinton vs. Trump vs. Johnson"') ...<br>(2016, b'"polls-only"', b'"Clinton vs. Trump vs. Johnson"')<br>(2016, b'"polls-only"', b'"Clinton vs. Trump vs. Johnson"')<br>(2016, b'"polls-only"', b'"Clinton vs. Trump vs. Johnson"')] (10236,)</pre><p id="d4eed498810fdbe063f7169a55b1f180" class="ne-p"><br></p><span id="python"></span><p id="549871fdea0653e95ae1401bf32b31a6" class="ne-p"><br></p><h2 id="b6028138"><span class="ne-text">三、np 的常用函数</span></h2><p id="6a46ff4930886a44c1837fcb8c6d14b7" class="ne-p"><br></p><h3 id="d21a6be0"><span class="ne-text">转置 transpose</span></h3><p id="8c630ef84a710462e01f55082f978723" class="ne-p"><br></p><pre data-language="python" id="17ec0f83" class="ne-codeblock language-python">import numpy as np</pre><p id="d773c06c8cecad414760f6a234ed033e" class="ne-p"><br></p><pre data-language="python" id="beba6818-1" class="ne-codeblock language-python">arr = np.random.rand(2,3)<br>print (arr)<br>print (arr.transpose())</pre><p id="c7746e1dcfbdd80f24d5255e9a33c1dd" class="ne-p"><br></p><pre data-language="plain" id="ba4fa7be" class="ne-codeblock language-plain">[[0.78485041 0.88817969 0.34809014]<br> [0.32744286 0.97539301 0.94401872]]<br>[[0.78485041 0.32744286]<br> [0.88817969 0.97539301]<br> [0.34809014 0.94401872]]</pre><p id="de7c070ea01893ef6735f2b871cfa537" class="ne-p"><br></p><pre data-language="python" id="17cdd2bc" class="ne-codeblock language-python">#高维数组的转换(图像里面会用得到转换维度) #不懂这里！！！<br>arr3d = np.random.rand(2,3,4)<br>print (arr3d)<br>print ('----------------------')<br>print (arr3d.transpose((1,0,2))) # 多维数组的转置和定义不会</pre><p id="1530b1cc6c147a969a43ae7afa680fea" class="ne-p"><br></p><pre data-language="plain" id="67333865" class="ne-codeblock language-plain">[[[0.28492549 0.60197236 0.45582367 0.21992479]<br>  [0.1747163  0.69201365 0.85460359 0.65311699]<br>  [0.62189644 0.25217555 0.16347156 0.29831219]]</p><p>[[0.42826733 0.81396165 0.187138   0.560564  ]<br>  [0.10162186 0.66419751 0.03261665 0.06969256]<br>  [0.55461652 0.55020586 0.50693591 0.31741807]]]</p><hr><p>[[[0.28492549 0.60197236 0.45582367 0.21992479]<br>  [0.42826733 0.81396165 0.187138   0.560564]]</p><p>[[0.1747163  0.69201365 0.85460359 0.65311699]<br>  [0.10162186 0.66419751 0.03261665 0.06969256]]</p><p>[[0.62189644 0.25217555 0.16347156 0.29831219]<br>  [0.55461652 0.55020586 0.50693591 0.31741807]]]</pre><p id="825ab9d00b376dc87698a24f5ffe9698" class="ne-p"><br></p><h3 id="18eade90"><span class="ne-text">ceil 和 floor 和 rint 和 isnan</span></h3><p id="892edc4cdd1e5eb900cf354256cc8dd9" class="ne-p"><br></p><pre data-language="python" id="e8e19093" class="ne-codeblock language-python">arr = np.random.randn(2,3)</p><p>print (arr)<br>print (np.ceil(arr)) #向上最接近的整数<br>print (np.floor(arr)) #向下最接近的整数<br>print (np.rint(arr)) #四舍五入<br>print (np.isnan(arr)) #判断元素是否为 NaN #笔记上还有其他的函数</pre><p id="1a9198d67ad2be3be0cde1beeb54ce02" class="ne-p"><br></p><pre data-language="plain" id="d97d2306" class="ne-codeblock language-plain">[[0.262106   -1.33680008 -1.08562543]<br> [ 0.3990978   0.1410074   0.64278274]]<br>[[1. -1. -1.]<br> [ 1.  1.  1.]]<br>[[0. -2. -2.]<br> [ 0.  0.  0.]]<br>[[0. -1. -1.]<br> [ 0.  0.  1.]]<br>[[False False False]<br> [False False False]]</pre><p id="5903d43b93728e6ab3d3ad1a7780b817" class="ne-p"><br></p><h3 id="where"><span class="ne-text">where</span></h3><p id="afe557f881019b1acaf9a37fd2193956" class="ne-p"><br></p><pre data-language="python" id="aac0df7c" class="ne-codeblock language-python">arr = np.random.randn(3,4)<br>print (arr)</p><p>np.where(arr &gt; 0, 1, -1) #（条件，满足输出，不满足输出）</pre><p id="a5c05f0a8a80db02cb29c7556b86c773" class="ne-p"><br></p><pre data-language="plain" id="a31ec6fc" class="ne-codeblock language-plain">[[2.04688394  0.48063737  1.20876913 -0.93412937]<br> [-0.43427472 -1.47755481  0.36882256 -0.08943138]<br> [-0.2847686   0.96915893  0.32641235  0.28346922]]</p><p>array([[1,  1,  1, -1],<br>       [-1, -1,  1, -1],<br>       [-1,  1,  1,  1]])</pre><p id="976e237ef644e92c75ffbec317880663" class="ne-p"><br></p><h3 id="sum"><span class="ne-text">sum</span></h3><p id="79468f61a58009af012e522099fc8847" class="ne-p"><br></p><pre data-language="python" id="dfc35b2c" class="ne-codeblock language-python">arr = np.arange(10).reshape(5,2)<br>print (arr)</p><p>print (np.sum(arr))<br>print (np.sum(arr, axis=0))<br>print (np.sum(arr, axis=1))</pre><p id="3fe13e42a996282fb9b6979c915a9064" class="ne-p"><br></p><pre data-language="plain" id="a5835cf7" class="ne-codeblock language-plain">[[0 1]<br> [2 3]<br> [4 5]<br> [6 7]<br> [8 9]]<br>45<br>[20 25]<br>[ 1 5 9 13 17]</pre><p id="15e1dd455c43f93153fd3dc0f9411f35" class="ne-p"><br></p><h3 id="17e0c333"><span class="ne-text">all 和 any</span></h3><p id="a53080753bc8a5b45f56f53ec6dc8ef4" class="ne-p"><br></p><pre data-language="python" id="1a7427e0" class="ne-codeblock language-python">import numpy as np<br>arr = np.random.randn(2,3)<br>print (arr)</p><p>print (np.any(arr &gt; 0)) #有一个就对<br>print (np.all(arr &gt; 0)) #全部对才对<br>‘’’<br>·用处就是判断一组数据当中，是否===有点类似布尔类型的<br>·这个也可以应用在 pandas 中的 DataFrame 中<br>‘’’</pre><p id="f1224f5c917f1d0e83dabc195ce054b8" class="ne-p"><br></p><pre data-language="plain" id="cf173407" class="ne-codeblock language-plain">[[-1.020184   -0.48466272 -0.8496271 ]<br> [ 0.88815825 -0.81911857  0.64570539]]<br>True<br>False</p><p>‘\n·用处就是判断一组数据当中，是否===有点类似布尔类型的\n·这个也可以应用在 pandas 中的 DataFrame 中\n’</pre><p id="83a06a6dcba27602bb418dd8f29239dd" class="ne-p"><br></p><h3 id="unique"><span class="ne-text">unique</span></h3><p id="ac9c26392f1befcc8a8e5da38098b9ce" class="ne-p"><br></p><pre data-language="python" id="92407f3a" class="ne-codeblock language-python">arr = np.array([[1, 2, 1], [2, 3, 4]])<br>print (arr)<br>print (np.unique(arr))</pre><p id="c872745113595a91e903204e1fd5baac" class="ne-p"><br></p><pre data-language="plain" id="a6b3cb69" class="ne-codeblock language-plain">[[1 2 1]<br> [2 3 4]]<br>[1 2 3 4]</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化</title>
      <link href="/blog/kt0kvc/"/>
      <url>/blog/kt0kvc/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h2 id="3b2518f3" data-lake-id="11bbc0e0f8edfd2b6d7fdca29be54d91" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">一、GitHub Juper NoteBook笔记</h2><ul data-lake-id="41a10e0a54ba1530967c5818dfae399b" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="6068469cff9a0367039290a52f7b96cf"><a href="https://github.com/wztlink1013/data-analysis-mining" target="_blank">https://github.com/wztlink1013/data-analysis-mining</a></li></ul><h2 data-lake-id="02f22caebec008bbb3fbae514f12cd61" id="90dgr" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">二、零碎总结</h2><h3 data-lake-id="164b95810e06f70a7cb1d0fff5f1a9dc" id="DA5NE" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">matplotlib调整子图间距，调整整体空白</h3><div data-card-type="block" data-lake-card="codeblock" id="EdBMq" class="lake-card-margin" data-language="python"><div class="lake-codeblock-content" style="border: 1px solid rgb(232, 232, 232); max-width: 750px; color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: rgb(249, 249, 249);"><div class="CodeMirror-sizer" style="color: rgb(89, 89, 89); margin: 0px; padding: 16px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><pre class="cm-s-default" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">fig</span>.<span class="cm-property" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">tight_layout</span>() <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">#调整整体空白</span><p></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">plt</span>.<span class="cm-property" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">subplots_adjust</span>(<span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">wspace</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">=</span><span class="cm-number" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">0</span>, <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">hspace</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">=</span><span class="cm-number" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">0</span>) <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">#调整子图间距</span></span></span></pre></div></div></div><h2 id="d17a0f0b" data-lake-id="6d4a405b6d449bfe903dffc12deaca65" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">参考</h2><ul data-lake-id="31686b2cd9184ef8ce7436b550fe6b82" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="9c06bce30678fc4ffb1868e40c71c60c"><a href="https://mp.weixin.qq.com/s/DaQL6bqr0wu5iYt-cVkz6g" target="_blank">Matplotlib 可视化最有价值的 50 个图表</a></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据的清洗和规整（一）</title>
      <link href="/blog/gvi1hn/"/>
      <url>/blog/gvi1hn/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="2d9fc2b03af5094d5348c0c09fa153eb" class="ne-p"><span class="ne-text">清洗数据：删除指定数据、处理缺失数据etc</span></p><p id="ua0c79517" class="ne-p"><br></p><h2 id="bc91b829"><span class="ne-text">一、数据预览：tail（）、head（）</span></h2><p id="96f3b4dc408392fe46a9b5d268b2bc67" class="ne-p"><br></p><pre data-language="python" id="e8a28435" class="ne-codeblock language-python">import numpy as np<p>import pandas as pd<br>df_obj = pd.DataFrame(np.random.randn(5,4), columns = [‘a’, ‘b’, ‘c’, ‘d’])<br>print(df_obj.tail())# 数据预览尾巴<br>print(df_obj.head())# 数据预览头部</pre><p id="2d4b15e888b5b511f88d6b061e73ad00" class="ne-p"><br></p><pre data-language="plain" id="e81c6600" class="ne-codeblock language-plain"> a b c d<br>0 -0.507788 0.213237 0.003150 -0.777312<br>1 -0.896653 -2.188016 -0.114848 0.167057<br>2 -1.131242 -0.142287 -1.027330 1.861814<br>3 0.369608 0.823453 1.030830 -0.041778<br>4 -0.647625 0.056791 -0.394078 -1.347718<br>a b c d<br>0 -0.507788 0.213237 0.003150 -0.777312<br>1 -0.896653 -2.188016 -0.114848 0.167057<br>2 -1.131242 -0.142287 -1.027330 1.861814<br>3 0.369608 0.823453 1.030830 -0.041778<br>4 -0.647625 0.056791 -0.394078 -1.347718</pre><p id="07243dfeb6b35aea066223e2bc8721a5" class="ne-p"><br></p><h2 id="d2aaa534"><span class="ne-text">二、数据描述：shape、info()</span></h2><p id="d8cc5506d77c9ba0cc8945b0683f2dd1" class="ne-p"><br></p><pre data-language="python" id="a5c3edd8" class="ne-codeblock language-python">print ('数据集有%i 行，%i 列' %(df_obj.shape[0], df_obj.shape[1]))</pre><p id="64fdeb61b3f6d620e09cbc6315339eec" class="ne-p"><br></p><pre data-language="plain" id="36922709" class="ne-codeblock language-plain">数据集有 5 行，4 列</pre><p id="1f70d0bfa86adafd4dec464863d6795e" class="ne-p"><br></p><pre data-language="python" id="cdd03dbe" class="ne-codeblock language-python">print(df_obj.info())</pre><p id="6dedde4942b4c583185f791ce6d363ee" class="ne-p"><br></p><pre data-language="plain" id="c5f2d8ee" class="ne-codeblock language-plain"><class 'pandas.core.frame.DataFrame'><br>RangeIndex: 5 entries, 0 to 4<br>Data columns (total 4 columns):<br>a 5 non-null float64<br>b 5 non-null float64<br>c 5 non-null float64<br>d 5 non-null float64<br>dtypes: float64(4)<br>memory usage: 288.0 bytes<br>None</pre><p id="788ae5c0ae57921fc0e3875e52574b62" class="ne-p"><br></p><h2 id="d34cceb7"><span class="ne-text">三、数据统计：describe()</span></h2><p id="53e8da371e2ff989da6709611903687a" class="ne-p"><br></p><pre data-language="python" id="1e868940" class="ne-codeblock language-python">print(df_obj.describe())</pre><p id="69c0487683cbade5f72bdec2ac0c03a5" class="ne-p"><br></p><pre data-language="plain" id="35156283" class="ne-codeblock language-plain"> a b c d<br>count 5.000000 5.000000 5.000000 5.000000<br>mean -0.562740 -0.247365 -0.100455 -0.027587<br>std 0.573191 1.143294 0.747673 1.215808<br>min -1.131242 -2.188016 -1.027330 -1.347718<br>25% -0.896653 -0.142287 -0.394078 -0.777312<br>50% -0.647625 0.056791 -0.114848 -0.041778<br>75% -0.507788 0.213237 0.003150 0.167057<br>max 0.369608 0.823453 1.030830 1.861814</pre><p id="bc40386ac1dcef875aea89e6100aaf51" class="ne-p"><br></p><h2 id="085506d6"><span class="ne-text">四、pandas 不完全显示行列</span></h2><p id="bc97e93146d1f62dde07f61e6c09c0d0" class="ne-p"><br></p><pre data-language="plain" id="30cdd959" class="ne-codeblock language-plain">pd.set_option('display.max_rows', 100) //显示的最大行数（避免只显示部分行数据）<br>pd.set_option('display.max_columns', 1000) //显示的最大列数（避免列显示不全）<br>pd.set_option("display.max_colwidth", 1000) //每一列最大的宽度（避免属性值或列名显示不全）<br>pd.set_option('display.width', 1000) //每一行的宽度（避免换行）</pre><p id="2732beacf23d67ec4a012fc6b1940909" class="ne-p"><br></p><h2 id="xzrrn"><span class="ne-text">五、删除指定行列数据</span></h2><p id="0d7a05e69e367d5d3519e415aa4d8f30" class="ne-p"><br></p><pre data-language="python" id="5b25766e" class="ne-codeblock language-python">import pandas as pd<br>import numpy as np</pre><p id="a5370a2dd1edaf2d40788c47fcf8de05" class="ne-p"><br></p><pre data-language="python" id="a150b011" class="ne-codeblock language-python">dict_data = {'A': 1.,<br>'B': pd.Timestamp('20161217'),<br>'C': pd.Series(1, index=list(range(4)),dtype='float32'),<br>'D': np.array([3] _ 4,dtype='int32'),<br>'E' : pd.Categorical(["Python","Java","C++","C#"]),<br>'F' : 'ChinaHadoop' }<br>df_obj2 = pd.DataFrame(dict_data)<br>print(df_obj2)</pre><p id="750948187165f98506423c685cfc6611" class="ne-p"><br></p><pre data-language="plain" id="3da7f2ee" class="ne-codeblock language-plain"> A B C D E F<br>0 1.0 2016-12-17 1.0 3 Python ChinaHadoop<br>1 1.0 2016-12-17 1.0 3 Java ChinaHadoop<br>2 1.0 2016-12-17 1.0 3 C++ ChinaHadoop<br>3 1.0 2016-12-17 1.0 3 C# ChinaHadoop</pre><p id="cbf63c3041a807fbb566f8431497843e" class="ne-p"><br></p><h3 id="del"><span class="ne-text">del</span></h3><p id="44a23bc41656701d9c6e9ebe1d53af61" class="ne-p"><br></p><div class="ne-quote"><p id="f722bbce2fdaf6c705b525530a0d5696" class="ne-p"><span class="ne-text">删除列</span></p></div><p id="a5e0adb4343ae3ee7a35a43529e9a060" class="ne-p"><br></p><pre data-language="python" id="b7e50b0b" class="ne-codeblock language-python">del df_obj2['A']<br>print (df_obj2.head())</pre><p id="667133040d7226dcc12dfb386b471f27" class="ne-p"><br></p><pre data-language="plain" id="5df55346" class="ne-codeblock language-plain"> B C D E F<br>0 2016-12-17 1.0 3 Python ChinaHadoop<br>1 2016-12-17 1.0 3 Java ChinaHadoop<br>2 2016-12-17 1.0 3 C++ ChinaHadoop<br>3 2016-12-17 1.0 3 C# ChinaHadoop</pre><p id="2dd53dc59a034f772e80b3819437b585" class="ne-p"><br></p><h3 id="drop"><span class="ne-text">drop</span></h3><p id="5c32368d733a91d16d68de90259769b0" class="ne-p"><br></p><div class="ne-quote"><p id="ba7db11ac2cf703500f94be806f977e5" class="ne-p"><span class="ne-text">删除行/列数据</span></p></div><p id="44bc5b4e6213c581549c0e6d9bf61b57" class="ne-p"><br></p><pre data-language="python" id="c439b4ca" class="ne-codeblock language-python">dict_data = {'A': 1.,<br>'B': pd.Timestamp('20161217'),<br>'C': pd.Series(1, index=list(range(4)),dtype='float32'),<br>'D': np.array([3] _ 4,dtype='int32'),<br>'E' : pd.Categorical(["Python","Java","C++","C#"]),<br>'F' : 'ChinaHadoop' }<br>df_obj3 = pd.DataFrame(dict_data,index = ['sfd','sdfd','wer','rwer'])<br>print (df_obj3.head(7))<br>print(df_obj3.drop('wer'))#删除行<br>print(df_obj3.drop('F',axis=1))#删除列</pre><p id="071fd38e10ce753ac8bf5f74e07702e6" class="ne-p"><br></p><pre data-language="plain" id="8581f311" class="ne-codeblock language-plain"> A B C D E F<br>sfd 1.0 2016-12-17 NaN 3 Python ChinaHadoop<br>sdfd 1.0 2016-12-17 NaN 3 Java ChinaHadoop<br>wer 1.0 2016-12-17 NaN 3 C++ ChinaHadoop<br>rwer 1.0 2016-12-17 NaN 3 C# ChinaHadoop<br>A B C D E F<br>sfd 1.0 2016-12-17 NaN 3 Python ChinaHadoop<br>sdfd 1.0 2016-12-17 NaN 3 Java ChinaHadoop<br>rwer 1.0 2016-12-17 NaN 3 C# ChinaHadoop<br>A B C D E<br>sfd 1.0 2016-12-17 NaN 3 Python<br>sdfd 1.0 2016-12-17 NaN 3 Java<br>wer 1.0 2016-12-17 NaN 3 C++<br>rwer 1.0 2016-12-17 NaN 3 C#</pre><p id="88a23cbadb1e4866303eb9b237777925" class="ne-p"><br></p><h2 id="f844b7ca"><span class="ne-text">六、处理缺失数据</span></h2><p id="d6fab5c357cfb91d163c88df390d144d" class="ne-p"><br></p><pre data-language="python" id="c57479bc" class="ne-codeblock language-python">df_data = pd.DataFrame([np.random.randn(3), [1., np.nan, np.nan],<br>[4., np.nan, np.nan], [1., np.nan, 2.]])<br>df_data.head()</pre><p id="1c635f015daa241973f9633ca872b802" class="ne-p"><br></p><table id="f98d8222" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="ufff03452" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u5c405d15" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="ub3408fb7" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u72ae5465" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u4fbc751d" class="ne-p"><span class="ne-text">-0.702713</span></p></td><td width="187"><p id="u29cca36d" class="ne-p"><span class="ne-text">-0.991383</span></p></td><td width="187"><p id="u45efa7fc" class="ne-p"><span class="ne-text">-1.058464</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u27521e29" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u4c91cc7c" class="ne-p"><span class="ne-text">1.000000</span></p></td><td width="187"><p id="u8a0e1327" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u09f1cf50" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u693a0924" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u3431aae3" class="ne-p"><span class="ne-text">4.000000</span></p></td><td width="187"><p id="u4b44f71a" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u972b14cd" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uf10730f3" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="uc39e96fa" class="ne-p"><span class="ne-text">1.000000</span></p></td><td width="187"><p id="u84129301" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="ub0daba30" class="ne-p"><span class="ne-text">2.000000</span></p></td></tr></tbody></table><p id="1699d63561ae70ebafe6b2b3677a3975" class="ne-p"><br></p><h3 id="e4f95d9e"><span class="ne-text">判断是否存在缺失值</span></h3><p id="fde168bca0e0d5dbea611d39135b38ae" class="ne-p"><br></p><pre data-language="python" id="4bd9893f" class="ne-codeblock language-python">df_data.isnull()</pre><p id="3ba725772307b872ddde1bf9fe457026" class="ne-p"><br></p><table id="2832a2a7" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="u1f2b6405" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u318ad4c7" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="ucda7c6fd" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u95185dea" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u27fb143a" class="ne-p"><span class="ne-text">False</span></p></td><td width="187"><p id="u2bb9ae08" class="ne-p"><span class="ne-text">False</span></p></td><td width="187"><p id="ua611fdfb" class="ne-p"><span class="ne-text">False</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uf03ca756" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="uee5544fd" class="ne-p"><span class="ne-text">False</span></p></td><td width="187"><p id="u9484ee21" class="ne-p"><span class="ne-text">True</span></p></td><td width="187"><p id="u1dc9dbfd" class="ne-p"><span class="ne-text">True</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u066a2fc9" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u6158815d" class="ne-p"><span class="ne-text">False</span></p></td><td width="187"><p id="u59d21081" class="ne-p"><span class="ne-text">True</span></p></td><td width="187"><p id="u42dde343" class="ne-p"><span class="ne-text">True</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ucc30df4c" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="u5b29b2de" class="ne-p"><span class="ne-text">False</span></p></td><td width="187"><p id="u95fd7dd0" class="ne-p"><span class="ne-text">True</span></p></td><td width="187"><p id="ub3cc46eb" class="ne-p"><span class="ne-text">False</span></p></td></tr></tbody></table><p id="82127210ee243b1ba59aa7c20bea8da5" class="ne-p"><br></p><h3 id="f129ed06"><span class="ne-text">丢弃缺失数据</span></h3><p id="097316b7cfa2c3b0c0c7bb419e1565c3" class="ne-p"><br></p><pre data-language="python" id="a6a601d9" class="ne-codeblock language-python">print(df_data.dropna(axis=0))<br>#0 是行；1 是列</pre><p id="debac196834b73c507501794a128dce5" class="ne-p"><br></p><pre data-language="plain" id="9a54050e" class="ne-codeblock language-plain"> 0 1 2<br>0 -0.702713 -0.991383 -1.058464</pre><p id="daaede3e28a1a38ab5329b3831f7a12d" class="ne-p"><br></p><h3 id="90e6feb8"><span class="ne-text">填充缺失数据</span></h3><p id="3c622806d1b3f497125a0d9ace44d3c5" class="ne-p"><br></p><pre data-language="python" id="d7abd0bd" class="ne-codeblock language-python">df_data.fillna(-100.)</pre><p id="80489ca4f8406f1562538f6ae016cbd5" class="ne-p"><br></p><table id="184c1433" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="u3e724e83" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="uf3ea97f2" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u18a56e83" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uf0822b36" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u388ad21e" class="ne-p"><span class="ne-text">-0.702713</span></p></td><td width="187"><p id="u5b07ba46" class="ne-p"><span class="ne-text">-0.991383</span></p></td><td width="187"><p id="uc675abdc" class="ne-p"><span class="ne-text">-1.058464</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u8ccab074" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u714799b2" class="ne-p"><span class="ne-text">1.000000</span></p></td><td width="187"><p id="ud8abf9dd" class="ne-p"><span class="ne-text">-100.000000</span></p></td><td width="187"><p id="uaea41179" class="ne-p"><span class="ne-text">-100.000000</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uf9749a17" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u549ed89a" class="ne-p"><span class="ne-text">4.000000</span></p></td><td width="187"><p id="ufff1f276" class="ne-p"><span class="ne-text">-100.000000</span></p></td><td width="187"><p id="u5fb7444f" class="ne-p"><span class="ne-text">-100.000000</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u3ec43b61" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="u512f8909" class="ne-p"><span class="ne-text">1.000000</span></p></td><td width="187"><p id="uf9f8153a" class="ne-p"><span class="ne-text">-100.000000</span></p></td><td width="187"><p id="ua64bf884" class="ne-p"><span class="ne-text">2.000000</span></p></td></tr></tbody></table><p id="410d3226004878274076168e1678f567" class="ne-p"><br></p><h2 id="e2adcb7f"></h2></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据的清洗和规整（二）</title>
      <link href="/blog/dggm37/"/>
      <url>/blog/dggm37/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="97ef088b442e4d2142d29a2e13b8d1de" class="ne-p"><span class="ne-text">规整数据：连接、合并、重构、转换etc</span></p><h2 id="vEPCg"><span class="ne-text">三、数据规整-连接-含索引</span></h2><p id="a1bbb91372d002f331fde0656b4cc56a" class="ne-p"><br></p><ul class="ne-ul"><li id="442526d957c5fb17cab73e321b572dfa"><span class="ne-text">数据连接 merge</span></li></ul><p id="3ed571a27f671d77436a0e8c85505146" class="ne-p"><br></p><pre data-language="python" id="5b25766e-1" class="ne-codeblock language-python">import pandas as pd<p>import numpy as np</pre><p id="07952fd692f716395bf5e1b3cf8a0099" class="ne-p"><br></p><pre data-language="python" id="798a5134" class="ne-codeblock language-python">df_obj1 = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],<br>'data1' : ['sfd','fdsf','we',24,3253,234,23]})<br>df_obj2 = pd.DataFrame({'key': ['a', 'b', 'd'],<br>'data2' : np.random.randint(0,10,3)})</p><p>print (df_obj1)<br>print (df_obj2)</pre><p id="5691e0ea0261fff8e49759f14021d6ea" class="ne-p"><br></p><pre data-language="plain" id="1eb01d28" class="ne-codeblock language-plain"> key data1<br>0 b sfd<br>1 b fdsf<br>2 a we<br>3 c 24<br>4 a 3253<br>5 a 234<br>6 b 23<br>key data2<br>0 a 0<br>1 b 6<br>2 d 6</pre><p id="e09f6a427b8f74efffb99ae32ddb18a0" class="ne-p"><br></p><h3 id="d0056c72"><span class="ne-text">merge 和 on</span></h3><p id="f9dd2e2d0d23aae3cf45c7b972556467" class="ne-p"><br></p><div class="ne-quote"><p id="4a2557b15dbc0d2dd180f6cb2c1d6d02" class="ne-p"><span class="ne-text">默认将重叠列的列名作为“外键”进行连接</span></p></div><p id="3a2d6c142e690e074bda76238f9b89e5" class="ne-p"><br></p><pre data-language="python" id="3ce979d5" class="ne-codeblock language-python">pd.merge(df_obj1, df_obj2)</pre><p id="3c48bf0324fce9a28d5c3344079b6ccd" class="ne-p"><br></p><table id="fa6fdee9" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="u81c7f678" class="ne-p"><span class="ne-text">key</span></p></td><td width="187"><p id="u47cc03c9" class="ne-p"><span class="ne-text">data1</span></p></td><td width="187"><p id="uad64b95c" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u9e853297" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u7fae4863" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="u8fbc2b26" class="ne-p"><span class="ne-text">sfd</span></p></td><td width="187"><p id="u45459c4e" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u7a799426" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="ue933ed11" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="uf60692d6" class="ne-p"><span class="ne-text">fdsf</span></p></td><td width="187"><p id="u1d4182bb" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u9af03cc1" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="ud93fd487" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="uc69a1da8" class="ne-p"><span class="ne-text">23</span></p></td><td width="187"><p id="u38b73542" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ufa297162" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="u993abd3e" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u01b435c1" class="ne-p"><span class="ne-text">we</span></p></td><td width="187"><p id="uc8ce293f" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ufa7c8400" class="ne-p"><span class="ne-text">4</span></p></td><td width="187"><p id="u020cedbb" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u06a7ac18" class="ne-p"><span class="ne-text">3253</span></p></td><td width="187"><p id="u0215a34d" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u6dc25070" class="ne-p"><span class="ne-text">5</span></p></td><td width="187"><p id="u81a2de26" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u71c4b61e" class="ne-p"><span class="ne-text">234</span></p></td><td width="187"><p id="uce4a9e8e" class="ne-p"><span class="ne-text">0</span></p></td></tr></tbody></table><p id="fed4089a44edfd08f93ffcb4987f64d0" class="ne-p"><br></p><pre data-language="python" id="7ba391ad" class="ne-codeblock language-python"># on 显示指定“外键”<br>pd.merge(df_obj1, df_obj2, on='key')</pre><p id="ea17b24616d7207d5ce90012a1fb671c" class="ne-p"><br></p><table id="fa6fdee9-1" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="u7fe1b3fa" class="ne-p"><span class="ne-text">key</span></p></td><td width="187"><p id="u122e90f3" class="ne-p"><span class="ne-text">data1</span></p></td><td width="187"><p id="u99351a52" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ue2faa1ca" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u5c4c597b" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="ua544cc9f" class="ne-p"><span class="ne-text">sfd</span></p></td><td width="187"><p id="udf59bbc2" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ueb229588" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u9dc8007c" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="u656a787d" class="ne-p"><span class="ne-text">fdsf</span></p></td><td width="187"><p id="u826baaa4" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u5807e653" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u816d0966" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="uf6d9f8c9" class="ne-p"><span class="ne-text">23</span></p></td><td width="187"><p id="ub107dba1" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u41659a36" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="ucc46c302" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u626b47da" class="ne-p"><span class="ne-text">we</span></p></td><td width="187"><p id="u0e3b3b67" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u550ff022" class="ne-p"><span class="ne-text">4</span></p></td><td width="187"><p id="u004f7a57" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="ue8f1adea" class="ne-p"><span class="ne-text">3253</span></p></td><td width="187"><p id="u5c718f9f" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ud676974f" class="ne-p"><span class="ne-text">5</span></p></td><td width="187"><p id="u6f743d5e" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u23413843" class="ne-p"><span class="ne-text">234</span></p></td><td width="187"><p id="u1fea02fd" class="ne-p"><span class="ne-text">0</span></p></td></tr></tbody></table><p id="6386a653f3be049e7f0f6aebfc469eef" class="ne-p"><br></p><h3 id="fde24c2a"><span class="ne-text">left-on 和 right-on</span></h3><p id="594d00f819eb667ccf7ca0de6d006a3c" class="ne-p"><br></p><pre data-language="python" id="29ec4548" class="ne-codeblock language-python"># left_on，right_on 分别指定左侧数据和右侧数据的“外键”</p><h1 id="更改列名"><a href="#更改列名" class="headerlink" title="更改列名"></a>更改列名</h1><p>df_obj1 = df_obj1.rename(columns={‘key’:’key1’})<br>df_obj2 = df_obj2.rename(columns={‘key’:’key2’})</pre><p id="d5ff1a530532c6bb8601fbf92ca3d57d" class="ne-p"><br></p><pre data-language="python" id="934cfb11" class="ne-codeblock language-python">print(df_obj1)<br>print(df_obj2)</pre><p id="71109d928c3ae48fb908a9ed414771c4" class="ne-p"><br></p><pre data-language="plain" id="c7e0d06a" class="ne-codeblock language-plain"> key1 data1<br>0 b sfd<br>1 b fdsf<br>2 a we<br>3 c 24<br>4 a 3253<br>5 a 234<br>6 b 23<br>key2 data2<br>0 a 0<br>1 b 6<br>2 d 6</pre><p id="b4e360316db744a782b5f7fc3e0b6ae0" class="ne-p"><br></p><pre data-language="python" id="9c5ec533" class="ne-codeblock language-python">pd.merge(df_obj1, df_obj2, left_on='key1', right_on='key2')</pre><p id="95130cbb4e261528bb2343d18add2102" class="ne-p"><br></p><table id="8bca1abb" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="150"></td><td width="150"><p id="u06054f28" class="ne-p"><span class="ne-text">key1</span></p></td><td width="150"><p id="u9247a866" class="ne-p"><span class="ne-text">data1</span></p></td><td width="150"><p id="u7c6ce5a4" class="ne-p"><span class="ne-text">key2</span></p></td><td width="150"><p id="u7237f8b6" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ubcb21996" class="ne-p"><span class="ne-text">0</span></p></td><td width="150"><p id="ue30ad954" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u9ee91e7a" class="ne-p"><span class="ne-text">sfd</span></p></td><td width="150"><p id="u415e3cea" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u93c4f0bc" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u9cf2aa12" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="u1750e3d9" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u61b465c1" class="ne-p"><span class="ne-text">fdsf</span></p></td><td width="150"><p id="u41baefeb" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u49391f29" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u4fb2ab16" class="ne-p"><span class="ne-text">2</span></p></td><td width="150"><p id="ub7cef164" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u526066bd" class="ne-p"><span class="ne-text">23</span></p></td><td width="150"><p id="ud8d82bc9" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="uba43d188" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u1cf0af8d" class="ne-p"><span class="ne-text">3</span></p></td><td width="150"><p id="uf3b015e1" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="ud650d4e7" class="ne-p"><span class="ne-text">we</span></p></td><td width="150"><p id="u24de2110" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="uadaff155" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ue8fbb8ad" class="ne-p"><span class="ne-text">4</span></p></td><td width="150"><p id="u195aa35c" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="ue3d47ced" class="ne-p"><span class="ne-text">3253</span></p></td><td width="150"><p id="u652aef25" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="uc089db0c" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="uedad1fbf" class="ne-p"><span class="ne-text">5</span></p></td><td width="150"><p id="u4abb0a43" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u65e75755" class="ne-p"><span class="ne-text">234</span></p></td><td width="150"><p id="u4a85a1f9" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u098f7dca" class="ne-p"><span class="ne-text">0</span></p></td></tr></tbody></table><p id="ccae74a66be4389d93d7cb06bc608c98" class="ne-p"><br></p><h3 id="how"><span class="ne-text">how</span></h3><p id="149802a1efddfff49fbad25750572f02" class="ne-p"><br></p><pre data-language="python" id="c244b13e" class="ne-codeblock language-python"># “外连接”<br>pd.merge(df_obj1, df_obj2, left_on='key1', right_on='key2', how='outer')</pre><p id="8d62b2ca602aec2ae5f89e8a2144b7eb" class="ne-p"><br></p><table id="726ff191" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="150"></td><td width="150"><p id="ud5b7b797" class="ne-p"><span class="ne-text">key1</span></p></td><td width="150"><p id="u1a488068" class="ne-p"><span class="ne-text">data1</span></p></td><td width="150"><p id="uc39e995e" class="ne-p"><span class="ne-text">key2</span></p></td><td width="150"><p id="ubee6378f" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u14078539" class="ne-p"><span class="ne-text">0</span></p></td><td width="150"><p id="u9d3a854d" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u0e13c750" class="ne-p"><span class="ne-text">sfd</span></p></td><td width="150"><p id="u4a0b5b0f" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="uc19cea51" class="ne-p"><span class="ne-text">6.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="uff06689c" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="ueffc61ed" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u54b586cb" class="ne-p"><span class="ne-text">fdsf</span></p></td><td width="150"><p id="u1854d84f" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="ubc9c3e92" class="ne-p"><span class="ne-text">6.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u1654d75c" class="ne-p"><span class="ne-text">2</span></p></td><td width="150"><p id="ufa1b5463" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u053b68ff" class="ne-p"><span class="ne-text">23</span></p></td><td width="150"><p id="ubab1b60b" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="uc168d932" class="ne-p"><span class="ne-text">6.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u03e6d48c" class="ne-p"><span class="ne-text">3</span></p></td><td width="150"><p id="u9228a865" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u8d0b8d13" class="ne-p"><span class="ne-text">we</span></p></td><td width="150"><p id="u9d151a6a" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="udb82c967" class="ne-p"><span class="ne-text">0.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u50423c41" class="ne-p"><span class="ne-text">4</span></p></td><td width="150"><p id="u39f1fb57" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="ube53939a" class="ne-p"><span class="ne-text">3253</span></p></td><td width="150"><p id="ufbd76739" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u2e144b7d" class="ne-p"><span class="ne-text">0.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u449be90a" class="ne-p"><span class="ne-text">5</span></p></td><td width="150"><p id="u077a087a" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="uc91cb1f1" class="ne-p"><span class="ne-text">234</span></p></td><td width="150"><p id="u8b92efd9" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u4af471dd" class="ne-p"><span class="ne-text">0.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ud35b0d1d" class="ne-p"><span class="ne-text">6</span></p></td><td width="150"><p id="u30854da3" class="ne-p"><span class="ne-text">c</span></p></td><td width="150"><p id="ubdaca31c" class="ne-p"><span class="ne-text">24</span></p></td><td width="150"><p id="u5f0c01fa" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u6d412986" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="uaf87fe4d" class="ne-p"><span class="ne-text">7</span></p></td><td width="150"><p id="uaa605f48" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="uf945c8b0" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="uce1bcf75" class="ne-p"><span class="ne-text">d</span></p></td><td width="150"><p id="ueeb4b365" class="ne-p"><span class="ne-text">6.0</span></p></td></tr></tbody></table><p id="7d128243f99f1148c8232d032b1f703a" class="ne-p"><br></p><pre data-language="python" id="28241de4" class="ne-codeblock language-python"># 左连接<br>pd.merge(df_obj1, df_obj2, left_on='key1', right_on='key2', how='left')</pre><p id="e7ff97059482740d29c9bac0032eae52" class="ne-p"><br></p><table id="a5cfc142" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="150"></td><td width="150"><p id="u63c99f94" class="ne-p"><span class="ne-text">key1</span></p></td><td width="150"><p id="ubdd125ab" class="ne-p"><span class="ne-text">data1</span></p></td><td width="150"><p id="u6421ee8e" class="ne-p"><span class="ne-text">key2</span></p></td><td width="150"><p id="u9fc23289" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u7f1006fe" class="ne-p"><span class="ne-text">0</span></p></td><td width="150"><p id="uf196dabb" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u41a20ef9" class="ne-p"><span class="ne-text">sfd</span></p></td><td width="150"><p id="uc3a0fadb" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u4a05892f" class="ne-p"><span class="ne-text">6.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u8cae5ac7" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="uc598fb00" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u089b308f" class="ne-p"><span class="ne-text">fdsf</span></p></td><td width="150"><p id="uf7ee4ade" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u14a13cfa" class="ne-p"><span class="ne-text">6.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u7bd97d12" class="ne-p"><span class="ne-text">2</span></p></td><td width="150"><p id="ua3b58d74" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u8f4e5089" class="ne-p"><span class="ne-text">we</span></p></td><td width="150"><p id="u2c17af4e" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="udc3d9c6e" class="ne-p"><span class="ne-text">0.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ua7ff1057" class="ne-p"><span class="ne-text">3</span></p></td><td width="150"><p id="ud718c670" class="ne-p"><span class="ne-text">c</span></p></td><td width="150"><p id="u2c266203" class="ne-p"><span class="ne-text">24</span></p></td><td width="150"><p id="u321cd0ce" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u8b086260" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="uca2089c3" class="ne-p"><span class="ne-text">4</span></p></td><td width="150"><p id="u19ce949e" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="ua92ceec6" class="ne-p"><span class="ne-text">3253</span></p></td><td width="150"><p id="ub0d07af1" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u4d4af551" class="ne-p"><span class="ne-text">0.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ua633e260" class="ne-p"><span class="ne-text">5</span></p></td><td width="150"><p id="u202ea6ca" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u0e252d6b" class="ne-p"><span class="ne-text">234</span></p></td><td width="150"><p id="u30087809" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="ua46ba011" class="ne-p"><span class="ne-text">0.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ue7928f90" class="ne-p"><span class="ne-text">6</span></p></td><td width="150"><p id="u7b35c690" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="uda1ad5f6" class="ne-p"><span class="ne-text">23</span></p></td><td width="150"><p id="ud6bd06dc" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u18765b13" class="ne-p"><span class="ne-text">6.0</span></p></td></tr></tbody></table><p id="c27ff2da229f5c41d9452afc6596e283" class="ne-p"><br></p><pre data-language="python" id="244ee9cb" class="ne-codeblock language-python"># 右连接<br>pd.merge(df_obj1, df_obj2, left_on='key1', right_on='key2', how='right')</pre><p id="c99867ca36cc05595165c7f88d7177dd" class="ne-p"><br></p><table id="89ba0ef8" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="150"></td><td width="150"><p id="u1b72c8f6" class="ne-p"><span class="ne-text">key1</span></p></td><td width="150"><p id="u13578791" class="ne-p"><span class="ne-text">data1</span></p></td><td width="150"><p id="ube4e68a3" class="ne-p"><span class="ne-text">key2</span></p></td><td width="150"><p id="u4c6bef6a" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u850b96bd" class="ne-p"><span class="ne-text">0</span></p></td><td width="150"><p id="ufd624173" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="ube886771" class="ne-p"><span class="ne-text">sfd</span></p></td><td width="150"><p id="u2adafbae" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u88182e42" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u72a1c694" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="uad77ad88" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="ub1c05071" class="ne-p"><span class="ne-text">fdsf</span></p></td><td width="150"><p id="ua0c89301" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="ubeb4aa02" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u1cced7c1" class="ne-p"><span class="ne-text">2</span></p></td><td width="150"><p id="uddf830d2" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u8932a4a3" class="ne-p"><span class="ne-text">23</span></p></td><td width="150"><p id="u22034050" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u4a657573" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u9bc615fc" class="ne-p"><span class="ne-text">3</span></p></td><td width="150"><p id="u14060d29" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u95a7baf1" class="ne-p"><span class="ne-text">we</span></p></td><td width="150"><p id="ub78508cb" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u5a3df887" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u4b390fe9" class="ne-p"><span class="ne-text">4</span></p></td><td width="150"><p id="u20e5a6a2" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="uf4629209" class="ne-p"><span class="ne-text">3253</span></p></td><td width="150"><p id="u60f55919" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u72a875b4" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u557bb0a4" class="ne-p"><span class="ne-text">5</span></p></td><td width="150"><p id="u187c0608" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="ua92550d1" class="ne-p"><span class="ne-text">234</span></p></td><td width="150"><p id="u4bcf382e" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="uea179258" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ubf0ad0fc" class="ne-p"><span class="ne-text">6</span></p></td><td width="150"><p id="u9a3d76ab" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u7aea8edf" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u3aeb1d5e" class="ne-p"><span class="ne-text">d</span></p></td><td width="150"><p id="ufc1fc8d0" class="ne-p"><span class="ne-text">6</span></p></td></tr></tbody></table><p id="11112ec21536f2c1ab276f8aec610529" class="ne-p"><br></p><h3 id="661c28ad"><span class="ne-text">处理重复列名 suffixes</span></h3><p id="4e0f222c017990f038c3ec9ea9e0e1d2" class="ne-p"><br></p><pre data-language="python" id="0d38ce36" class="ne-codeblock language-python"># 处理重复列名<br>df_obj1 = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],<br>'data' : np.random.randint(0,10,7)})<br>df_obj2 = pd.DataFrame({'key': ['a', 'b', 'd'],<br>'data' : np.random.randint(0,10,3)})</p><p>pd.merge(df_obj1, df_obj2, on=’key’, suffixes=(‘_left’, ‘_right’))</pre><p id="b6b4547a314821c4c01a1dc7018d74ff" class="ne-p"><br></p><table id="e549a09a" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="u4a7e6604" class="ne-p"><span class="ne-text">key</span></p></td><td width="187"><p id="uf5cc2932" class="ne-p"><span class="ne-text">data_left</span></p></td><td width="187"><p id="u3c649438" class="ne-p"><span class="ne-text">data_right</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u9010976f" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="uf5846ba0" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="ueba6a795" class="ne-p"><span class="ne-text">9</span></p></td><td width="187"><p id="u3c282e9e" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uc2575b0c" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="ub7a980b1" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="u04a43efb" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u38130794" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u51b27135" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u28efdd29" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="u1c8e4402" class="ne-p"><span class="ne-text">6</span></p></td><td width="187"><p id="u7bbc7107" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uf8d7f6a9" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="u29c2763c" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u3b68162b" class="ne-p"><span class="ne-text">7</span></p></td><td width="187"><p id="ued6e6d1b" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ue5500bd4" class="ne-p"><span class="ne-text">4</span></p></td><td width="187"><p id="ub942bbdb" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u72e7f305" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="uad3535ca" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u1432cbbe" class="ne-p"><span class="ne-text">5</span></p></td><td width="187"><p id="uf5fe005d" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u4d9ccf9e" class="ne-p"><span class="ne-text">4</span></p></td><td width="187"><p id="ued5648dc" class="ne-p"><span class="ne-text">1</span></p></td></tr></tbody></table><p id="d9ff3f0273fafbf1a39678bd76e0137c" class="ne-p"><br></p><pre data-language="python" id="53734adc" class="ne-codeblock language-python"># 按索引连接<br>df_obj3 = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],<br>'data1' : np.random.randint(0,10,7)})<br>df_obj4 = pd.DataFrame({'data2' : np.random.randint(0,10,3)}, index=['a', 'b', 'd'])</pre><p id="3f46b4f7a30dc33710afecd7d7bee118" class="ne-p"><br></p><pre data-language="python" id="f4d18927" class="ne-codeblock language-python">print(df_obj3)<br>print(df_obj4)</pre><p id="4c1535115414f3abd8f35720a1efd400" class="ne-p"><br></p><pre data-language="plain" id="41a9d824" class="ne-codeblock language-plain"> key data1<br>0 b 7<br>1 b 4<br>2 a 1<br>3 c 9<br>4 a 2<br>5 a 9<br>6 b 7<br>data2<br>a 9<br>b 4<br>d 0</pre><p id="ba5cadd765601d9c81d3336139cf0825" class="ne-p"><br></p><pre data-language="python" id="34262285" class="ne-codeblock language-python">pd.merge(df_obj3, df_obj4, left_on='key', right_index=True)</pre><p id="3f8d7431b2331010ffc772e2f3cf0a85" class="ne-p"><br></p><table id="71c4d53b" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="ue676d06d" class="ne-p"><span class="ne-text">key</span></p></td><td width="187"><p id="u773ee3bd" class="ne-p"><span class="ne-text">data1</span></p></td><td width="187"><p id="u98abc2b3" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u7b12e514" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u96db1dff" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="u01b1f3a6" class="ne-p"><span class="ne-text">7</span></p></td><td width="187"><p id="u8723a135" class="ne-p"><span class="ne-text">4</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ud62cb7ec" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u4ce39eed" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="uc03e835c" class="ne-p"><span class="ne-text">4</span></p></td><td width="187"><p id="ua2ac0b60" class="ne-p"><span class="ne-text">4</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u4f48427b" class="ne-p"><span class="ne-text">6</span></p></td><td width="187"><p id="ub55f40e5" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="ufc6c45c9" class="ne-p"><span class="ne-text">7</span></p></td><td width="187"><p id="u217a4a0d" class="ne-p"><span class="ne-text">4</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u8df3b809" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u90b38f13" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u800bb8a5" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u1ec27293" class="ne-p"><span class="ne-text">9</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ub83510f3" class="ne-p"><span class="ne-text">4</span></p></td><td width="187"><p id="ua44e4b57" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u9ec1582c" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u609d6fc7" class="ne-p"><span class="ne-text">9</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ud2af22e4" class="ne-p"><span class="ne-text">5</span></p></td><td width="187"><p id="ue92a7dd3" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u2096078f" class="ne-p"><span class="ne-text">9</span></p></td><td width="187"><p id="u9b74a610" class="ne-p"><span class="ne-text">9</span></p></td></tr></tbody></table><p id="5a05660a53754f05ff35c456740b9b51" class="ne-p"><br></p><h3 id="49f47e6d"><span class="ne-text">按索引连接 right_index</span></h3><p id="fbdbcd0395d391083d8cba07df975b14" class="ne-p"><br></p><pre data-language="python" id="069c5bde" class="ne-codeblock language-python"># 按索引连接<br>df_obj1 = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],<br>'data1' : np.random.randint(0,10,7)})<br>df_obj2 = pd.DataFrame({'data2' : np.random.randint(0,10,3)}, index=['a', 'b', 'd'])</pre><p id="71b3c11c2b0e69ca9f4e23331b1485a0" class="ne-p"><br></p><pre data-language="python" id="934cfb11-1" class="ne-codeblock language-python">print(df_obj1)<br>print(df_obj2)</pre><p id="24292a6a36afdb16eaf0beb4b0307ac6" class="ne-p"><br></p><pre data-language="plain" id="cd70d572" class="ne-codeblock language-plain"> key data1<br>0 b 0<br>1 b 2<br>2 a 7<br>3 c 3<br>4 a 1<br>5 a 1<br>6 b 6<br>data2<br>a 2<br>b 1<br>d 1</pre><p id="76c85f57d29e2e47f13bb1002394a92e" class="ne-p"><br></p><pre data-language="python" id="2183c7e4" class="ne-codeblock language-python">pd.merge(df_obj1, df_obj2, left_on='key', right_index=True)</pre><p id="9207b0b94ba6c1704d694ae6091c45b5" class="ne-p"><br></p><table id="5bb8d65c" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="uf3bbccca" class="ne-p"><span class="ne-text">key</span></p></td><td width="187"><p id="ub0f7d646" class="ne-p"><span class="ne-text">data1</span></p></td><td width="187"><p id="u3c2a3cee" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u50247be0" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u8a9a7c9f" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="u2613d70c" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u8fe6d22c" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uc9eb80e3" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="uf478f8ad" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="u517918ba" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u906a3b22" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u489501df" class="ne-p"><span class="ne-text">6</span></p></td><td width="187"><p id="u807e05c2" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="u8e45dee3" class="ne-p"><span class="ne-text">6</span></p></td><td width="187"><p id="ue4a8525d" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="udc9495fe" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u195f6007" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u563e1529" class="ne-p"><span class="ne-text">7</span></p></td><td width="187"><p id="u407404da" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u9785691e" class="ne-p"><span class="ne-text">4</span></p></td><td width="187"><p id="ue5d3ee74" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u2c0116bf" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="ua8bb2afa" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uc7e474cc" class="ne-p"><span class="ne-text">5</span></p></td><td width="187"><p id="u8d2a21f6" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="ud80ce599" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u4d897f62" class="ne-p"><span class="ne-text">2</span></p></td></tr></tbody></table><p id="77a619e17ed30f0aa7e15d95a32210ed" class="ne-p"><br></p><h2 id="9b60fc97"><span class="ne-text">四、数据合并</span></h2><p id="18edee4592a49ccf3ae67cced40b6cfa" class="ne-p"><br></p><ul class="ne-ul"><li id="77625b8c9b2ecf5eb6d780abee640b86"><span class="ne-text">数据合并 concat</span></li><li id="2b0cdfced0b3ad2f4227beea1b9c79d2"><span class="ne-text">按索引连接===right_index</span></li></ul><p id="ed6338172bda2d4a9c6507d9cda3239a" class="ne-p"><br></p><pre data-language="python" id="379f4f72" class="ne-codeblock language-python">import numpy as np<br>import pandas as pd</pre><p id="0b775728997e70e0f93d3a375db538ff" class="ne-p"><br></p><h3 id="49dc343d"><span class="ne-text">numpy 的 concat</span></h3><p id="c95569105529e86f35e53a62889ab33d" class="ne-p"><br></p><pre data-language="python" id="108b072e" class="ne-codeblock language-python">arr1 = np.random.randint(0, 10, (3, 4))<br>arr2 = np.random.randint(0, 10, (3, 4))</p><p>print (arr1)<br>print (arr2)</pre><p id="4a735d281237eaa1531b33085dd1f7fb" class="ne-p"><br></p><pre data-language="plain" id="3a9d7b08" class="ne-codeblock language-plain">[[6 0 3 2]<br> [5 7 9 8]<br> [5 8 0 3]]<br>[[6 5 7 9]<br> [0 1 0 0]<br> [1 1 1 7]]</pre><p id="02900d627a5f4e09d8afb126589748c1" class="ne-p"><br></p><pre data-language="python" id="c5a39461" class="ne-codeblock language-python">np.concatenate([arr1, arr2])</pre><p id="2769aa5948ecc8ea89d8e26b7355e256" class="ne-p"><br></p><pre data-language="plain" id="34d42d27" class="ne-codeblock language-plain">array([[6, 0, 3, 2],<br>       [5, 7, 9, 8],<br>       [5, 8, 0, 3],<br>       [6, 5, 7, 9],<br>       [0, 1, 0, 0],<br>       [1, 1, 1, 7]])</pre><p id="14a136369610593e3e3f358328c7088d" class="ne-p"><br></p><pre data-language="python" id="f9edaf69" class="ne-codeblock language-python">np.concatenate([arr1, arr2], axis=1)</pre><p id="78ccf6f53e5fc87cba6face79f6057dc" class="ne-p"><br></p><pre data-language="plain" id="27d56b4d" class="ne-codeblock language-plain">array([[6, 0, 3, 2, 6, 5, 7, 9],<br>       [5, 7, 9, 8, 0, 1, 0, 0],<br>       [5, 8, 0, 3, 1, 1, 1, 7]])</pre><p id="512de7ce3af3c665b29a990bdaf86ceb" class="ne-p"><br></p><h3 id="e971060d"><span class="ne-text">series 上的 concat</span></h3><p id="dc665ce85f0e8c991214924a6ff21333" class="ne-p"><br></p><pre data-language="python" id="67ed1834" class="ne-codeblock language-python"># index 没有重复的情况<br>ser_obj1 = pd.Series(np.random.randint(0, 10, 5), index=range(0,5))<br>ser_obj2 = pd.Series(np.random.randint(0, 10, 4), index=range(5,9))<br>ser_obj3 = pd.Series(np.random.randint(0, 10, 3), index=range(9,12))</pre><p id="9375174b7428570213a03c2869e85e79" class="ne-p"><br></p><pre data-language="python" id="bba74a3b" class="ne-codeblock language-python">pd.concat([ser_obj1, ser_obj2, ser_obj3])</pre><p id="2b5423ebc29fbb43211fa4a94cdc6482" class="ne-p"><br></p><pre data-language="plain" id="8acc3736" class="ne-codeblock language-plain">0 0<br>1 4<br>2 5<br>3 1<br>4 9<br>5 7<br>6 8<br>7 5<br>8 0<br>9 5<br>10 9<br>11 0<br>dtype: int32</pre><p id="7a2aacd43d6294ea263f999cb56cdb6b" class="ne-p"><br></p><pre data-language="python" id="c4a1b3d7" class="ne-codeblock language-python">pd.concat([ser_obj1, ser_obj2, ser_obj3], axis=1)</pre><p id="04a2ff893e8f69d45ea62966d979756b" class="ne-p"><br></p><table id="8427a3c9" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="u68272f85" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u9f251536" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="ua0c573b4" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u2cb3f6be" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u64a4ba24" class="ne-p"><span class="ne-text">0.0</span></p></td><td width="187"><p id="ub35b7657" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u9259d2e3" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u974efbdd" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u9f73e4f3" class="ne-p"><span class="ne-text">4.0</span></p></td><td width="187"><p id="u598ff12c" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u9bcf9b46" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ufc476255" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u2a31a0b6" class="ne-p"><span class="ne-text">5.0</span></p></td><td width="187"><p id="ubc01f667" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u29df66d5" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ua6f10e9f" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="u32b9d10e" class="ne-p"><span class="ne-text">1.0</span></p></td><td width="187"><p id="uf366b326" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="ub37a92a6" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u573469cf" class="ne-p"><span class="ne-text">4</span></p></td><td width="187"><p id="u3365dbc7" class="ne-p"><span class="ne-text">9.0</span></p></td><td width="187"><p id="u46f1e3b7" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u552073d8" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ue83b0001" class="ne-p"><span class="ne-text">5</span></p></td><td width="187"><p id="ubf5df2de" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="ufd454cbd" class="ne-p"><span class="ne-text">7.0</span></p></td><td width="187"><p id="uf3048786" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u6d2a712f" class="ne-p"><span class="ne-text">6</span></p></td><td width="187"><p id="u3d847a81" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u9086dcfe" class="ne-p"><span class="ne-text">8.0</span></p></td><td width="187"><p id="u263cd9b8" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uf9426871" class="ne-p"><span class="ne-text">7</span></p></td><td width="187"><p id="u418435d4" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u20bb670f" class="ne-p"><span class="ne-text">5.0</span></p></td><td width="187"><p id="uc920091e" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uad32547e" class="ne-p"><span class="ne-text">8</span></p></td><td width="187"><p id="u15cc9d57" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u234eee7b" class="ne-p"><span class="ne-text">0.0</span></p></td><td width="187"><p id="uc6b9510f" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u07396bb2" class="ne-p"><span class="ne-text">9</span></p></td><td width="187"><p id="u066a5866" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u7a34e029" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u4916b5a6" class="ne-p"><span class="ne-text">5.0</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uaf35c6b0" class="ne-p"><span class="ne-text">10</span></p></td><td width="187"><p id="u8ace6b4e" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="uf4e1c731" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="ue24c1d5e" class="ne-p"><span class="ne-text">9.0</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uc869a91e" class="ne-p"><span class="ne-text">11</span></p></td><td width="187"><p id="u424909af" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u24805868" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u4a968f40" class="ne-p"><span class="ne-text">0.0</span></p></td></tr></tbody></table><p id="12a40b9035ba00eb3d255135cc6f03cf" class="ne-p"><br></p><pre data-language="python" id="192f82a7" class="ne-codeblock language-python"># index 有重复的情况<br>ser_obj1 = pd.Series(np.random.randint(0, 10, 5), index=range(5))<br>ser_obj2 = pd.Series(np.random.randint(0, 10, 4), index=range(4))<br>ser_obj3 = pd.Series(np.random.randint(0, 10, 3), index=range(3))</p><p>print (ser_obj1)<br>print (ser_obj2)<br>print (ser_obj3)</pre><p id="65f2989eec41d9e3edbf15829d050c4b" class="ne-p"><br></p><pre data-language="plain" id="c2e3fffd" class="ne-codeblock language-plain">0 5<br>1 3<br>2 0<br>3 8<br>4 3<br>dtype: int32<br>0 5<br>1 3<br>2 2<br>3 1<br>dtype: int32<br>0 5<br>1 8<br>2 6<br>dtype: int32</pre><p id="43e0399af1da657ae037dbcfa7ece246" class="ne-p"><br></p><pre data-language="python" id="bba74a3b-1" class="ne-codeblock language-python">pd.concat([ser_obj1, ser_obj2, ser_obj3])</pre><p id="f0815a23c01cd10d1fa91c689cc8d459" class="ne-p"><br></p><pre data-language="plain" id="bd9d04ac" class="ne-codeblock language-plain">0 5<br>1 3<br>2 0<br>3 8<br>4 3<br>0 5<br>1 3<br>2 2<br>3 1<br>0 5<br>1 8<br>2 6<br>dtype: int32</pre><p id="0d5c7ae2b016bcb65ea90fd972d2175f" class="ne-p"><br></p><pre data-language="python" id="774cffe6" class="ne-codeblock language-python">pd.concat([ser_obj1, ser_obj2, ser_obj3], axis=1, join='inner')</pre><p id="12b98ea80373f2aa707dcb8965a4766a" class="ne-p"><br></p><table id="e22433b0" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="u4ca4c7f7" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="uf38912d4" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u4b7040a9" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u5b8f08c7" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u2824847e" class="ne-p"><span class="ne-text">5</span></p></td><td width="187"><p id="u187ea68a" class="ne-p"><span class="ne-text">5</span></p></td><td width="187"><p id="u3ca97659" class="ne-p"><span class="ne-text">5</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ue07e43b3" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="ua2cd5759" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="u72b9b04e" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="u61b41737" class="ne-p"><span class="ne-text">8</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u76ff3900" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u82306db4" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u718c4f3a" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u3aa8d31a" class="ne-p"><span class="ne-text">6</span></p></td></tr></tbody></table><p id="919e295539e5d4ce048d1068bf02fc40" class="ne-p"><br></p><h3 id="335f7ae5"><span class="ne-text">dataframe 上的 concat</span></h3><p id="c4e24097651cc85c44624174455debf9" class="ne-p"><br></p><pre data-language="python" id="c4cd0e53" class="ne-codeblock language-python">df_obj1 = pd.DataFrame(np.random.randint(0, 10, (3, 2)), index=['a', 'b', 'c'],<br>columns=['A', 'B'])<br>df_obj2 = pd.DataFrame(np.random.randint(0, 10, (2, 2)), index=['a', 'b'],<br>columns=['C', 'D'])<br>print (df_obj1)<br>print (df_obj2)</pre><p id="c3eddd7d60ed23308ecc08a06554c379" class="ne-p"><br></p><pre data-language="plain" id="2cb814ca" class="ne-codeblock language-plain"> A B<br>a 4 3<br>b 8 1<br>c 6 3<br>C D<br>a 1 3<br>b 8 2</pre><p id="ed2fdeecaa0daa34d97a7d590aa87af5" class="ne-p"><br></p><pre data-language="python" id="1582b91e" class="ne-codeblock language-python">pd.concat([df_obj1, df_obj2])</pre><p id="077f4b0cfaf1fecffca7302f73362348" class="ne-p"><br></p><pre data-language="plain" id="b69c93f9" class="ne-codeblock language-plain">C:\Users\wztli\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version<br>of pandas will change to not sort by default.</p><p>To accept the future behavior, pass ‘sort=False’.</p><p>To retain the current behavior and silence the warning, pass ‘sort=True’.</p><p>“””Entry point for launching an IPython kernel.</pre><p id="fc316cf85cde91be2757489ae12b9135" class="ne-p"><br></p><table id="ac00ad54" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="150"></td><td width="150"><p id="uab796b30" class="ne-p"><span class="ne-text">A</span></p></td><td width="150"><p id="ue12b0137" class="ne-p"><span class="ne-text">B</span></p></td><td width="150"><p id="u271a66f0" class="ne-p"><span class="ne-text">C</span></p></td><td width="150"><p id="u6068b22c" class="ne-p"><span class="ne-text">D</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ub830ccf8" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u266f71bd" class="ne-p"><span class="ne-text">4.0</span></p></td><td width="150"><p id="u7542c263" class="ne-p"><span class="ne-text">3.0</span></p></td><td width="150"><p id="ubd7e4c4e" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="ua283a993" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u529832e3" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="ued5ad518" class="ne-p"><span class="ne-text">8.0</span></p></td><td width="150"><p id="u0557f4f4" class="ne-p"><span class="ne-text">1.0</span></p></td><td width="150"><p id="u1781a84c" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u7e92786c" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="uae87b9fb" class="ne-p"><span class="ne-text">c</span></p></td><td width="150"><p id="u8c99268a" class="ne-p"><span class="ne-text">6.0</span></p></td><td width="150"><p id="u90adcf59" class="ne-p"><span class="ne-text">3.0</span></p></td><td width="150"><p id="ua2020bd0" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u1fe0774d" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u92a7afd0" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u2dcb7440" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u79a8b449" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u306e4273" class="ne-p"><span class="ne-text">1.0</span></p></td><td width="150"><p id="uf3df0c17" class="ne-p"><span class="ne-text">3.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="uaed95ed2" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u6c477b1d" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u14989056" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u739f66ee" class="ne-p"><span class="ne-text">8.0</span></p></td><td width="150"><p id="u81b88095" class="ne-p"><span class="ne-text">2.0</span></p></td></tr></tbody></table><p id="67a9d50c87f86671b30abe750ad1c0b3" class="ne-p"><br></p><pre data-language="python" id="4ef72bdb" class="ne-codeblock language-python">pd.concat([df_obj1, df_obj2], axis=1)</pre><p id="9fbaee2702102560b31ed7ed296bd607" class="ne-p"><br></p><pre data-language="plain" id="b69c93f9-1" class="ne-codeblock language-plain">C:\Users\wztli\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version<br>of pandas will change to not sort by default.</p><p>To accept the future behavior, pass ‘sort=False’.</p><p>To retain the current behavior and silence the warning, pass ‘sort=True’.</p><p>“””Entry point for launching an IPython kernel.</pre><p id="40b9f3d4ca1045b61eb9d93d25f1dd72" class="ne-p"><br></p><table id="8a43a84b" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="150"></td><td width="150"><p id="u02e408f2" class="ne-p"><span class="ne-text">A</span></p></td><td width="150"><p id="u6d20e4f5" class="ne-p"><span class="ne-text">B</span></p></td><td width="150"><p id="u03bdd708" class="ne-p"><span class="ne-text">C</span></p></td><td width="150"><p id="ub2b48fa4" class="ne-p"><span class="ne-text">D</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u8143ea69" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="ub12fb30e" class="ne-p"><span class="ne-text">4</span></p></td><td width="150"><p id="ud80ebe28" class="ne-p"><span class="ne-text">3</span></p></td><td width="150"><p id="u7b61c426" class="ne-p"><span class="ne-text">1.0</span></p></td><td width="150"><p id="ub409f483" class="ne-p"><span class="ne-text">3.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="uae898043" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="ua563c8cd" class="ne-p"><span class="ne-text">8</span></p></td><td width="150"><p id="u63ce1413" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="u997b869a" class="ne-p"><span class="ne-text">8.0</span></p></td><td width="150"><p id="u8e61c765" class="ne-p"><span class="ne-text">2.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u2789d61f" class="ne-p"><span class="ne-text">c</span></p></td><td width="150"><p id="u7bc2332c" class="ne-p"><span class="ne-text">6</span></p></td><td width="150"><p id="u4498fc92" class="ne-p"><span class="ne-text">3</span></p></td><td width="150"><p id="ub5bb1127" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="uc0abec00" class="ne-p"><span class="ne-text">NaN</span></p></td></tr></tbody></table><p id="8bfb15bac0ecf1b8c787dc7a01c2a028" class="ne-p"><br></p><h2 id="aaabb73c"><span class="ne-text">五、数据重构</span></h2><p id="09679efbcf9f47e02fee9a1a6d039b6a" class="ne-p"><br></p><pre data-language="python" id="379f4f72-1" class="ne-codeblock language-python">import numpy as np<br>import pandas as pd</pre><p id="6200b93aabb7c246f4f1f1fb4525e67f" class="ne-p"><br></p><h3 id="stack"><span class="ne-text">stack</span></h3><p id="5206bb1c95588434110c48ed5dcfa6aa" class="ne-p"><br></p><pre data-language="python" id="fa002eeb" class="ne-codeblock language-python">df_obj = pd.DataFrame(np.random.randint(0,10, (5,2)), columns=['data1', 'data2'])<br>df_obj</pre><p id="a837b226492db97471958ac9903b4432" class="ne-p"><br></p><table id="91086468" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"></td><td width="250"><p id="uc9e2ebb3" class="ne-p"><span class="ne-text">data1</span></p></td><td width="250"><p id="u8db106c0" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u44268a4a" class="ne-p"><span class="ne-text">0</span></p></td><td width="250"><p id="udb7beff3" class="ne-p"><span class="ne-text">0</span></p></td><td width="250"><p id="udbfad175" class="ne-p"><span class="ne-text">4</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ufacb442c" class="ne-p"><span class="ne-text">1</span></p></td><td width="250"><p id="u08cff539" class="ne-p"><span class="ne-text">6</span></p></td><td width="250"><p id="ubd9a116a" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u08ee48c6" class="ne-p"><span class="ne-text">2</span></p></td><td width="250"><p id="uc383920b" class="ne-p"><span class="ne-text">9</span></p></td><td width="250"><p id="u542ab240" class="ne-p"><span class="ne-text">8</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u5cc68de2" class="ne-p"><span class="ne-text">3</span></p></td><td width="250"><p id="u636e6bb5" class="ne-p"><span class="ne-text">7</span></p></td><td width="250"><p id="uf1d60ada" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u8025f01a" class="ne-p"><span class="ne-text">4</span></p></td><td width="250"><p id="u03306ab8" class="ne-p"><span class="ne-text">3</span></p></td><td width="250"><p id="u1006e986" class="ne-p"><span class="ne-text">1</span></p></td></tr></tbody></table><p id="59f7ab51fb7b67a21d7164f545943fb5" class="ne-p"><br></p><pre data-language="python" id="4da7dd95" class="ne-codeblock language-python">stacked = df_obj.stack()<br>print (stacked)</pre><p id="7236f683db3fda28b0c683af2ce355b8" class="ne-p"><br></p><pre data-language="plain" id="61346a5e" class="ne-codeblock language-plain">0 data1 0<br>data2 4<br>1 data1 6<br>data2 2<br>2 data1 9<br>data2 8<br>3 data1 7<br>data2 0<br>4 data1 3<br>data2 1<br>dtype: int32</pre><p id="0ed95166cddf4c254591d38d6d8d3ecb" class="ne-p"><br></p><pre data-language="python" id="156b5ea4" class="ne-codeblock language-python">print (type(stacked))<br>print (type(stacked.index))</pre><p id="a0f97e379854a606e012448962686ef5" class="ne-p"><br></p><pre data-language="plain" id="314a292c" class="ne-codeblock language-plain"><class 'pandas.core.series.Series'><br><class 'pandas.core.indexes.multi.MultiIndex'></pre><p id="c14a7b185435507ea54db3144176f42e" class="ne-p"><br></p><h3 id="unstack"><span class="ne-text">unstack</span></h3><p id="289adf4c5e7a257346bc39676ca3849f" class="ne-p"><br></p><pre data-language="python" id="28db94e9" class="ne-codeblock language-python"># 默认操作内层索引<br>stacked.unstack()</pre><p id="25917fddfb9e9ef38ac7b69c0493ba5d" class="ne-p"><br></p><table id="91086468-1" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"></td><td width="250"><p id="u81e4bf05" class="ne-p"><span class="ne-text">data1</span></p></td><td width="250"><p id="ub06599cb" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u07bbb3c4" class="ne-p"><span class="ne-text">0</span></p></td><td width="250"><p id="u2d4d6069" class="ne-p"><span class="ne-text">0</span></p></td><td width="250"><p id="ue44d5fa9" class="ne-p"><span class="ne-text">4</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ua1ad5523" class="ne-p"><span class="ne-text">1</span></p></td><td width="250"><p id="uf65a0b11" class="ne-p"><span class="ne-text">6</span></p></td><td width="250"><p id="u6b0d2066" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u8603d2a8" class="ne-p"><span class="ne-text">2</span></p></td><td width="250"><p id="u858ad280" class="ne-p"><span class="ne-text">9</span></p></td><td width="250"><p id="u209b4b73" class="ne-p"><span class="ne-text">8</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u718c743b" class="ne-p"><span class="ne-text">3</span></p></td><td width="250"><p id="u376daae7" class="ne-p"><span class="ne-text">7</span></p></td><td width="250"><p id="u773270ad" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u095b98a1" class="ne-p"><span class="ne-text">4</span></p></td><td width="250"><p id="ue3ac7448" class="ne-p"><span class="ne-text">3</span></p></td><td width="250"><p id="u249cb31f" class="ne-p"><span class="ne-text">1</span></p></td></tr></tbody></table><p id="82baa61bc650bac43fe315afe791d962" class="ne-p"><br></p><pre data-language="python" id="4085d62b" class="ne-codeblock language-python"># 通过 level 指定操作索引的级别<br>stacked.unstack(level=0)</pre><p id="d7e58703c322b81ee262bfede7ac4a5f" class="ne-p"><br></p><table id="2ff17a10" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="125"></td><td width="125"><p id="u8209af75" class="ne-p"><span class="ne-text">0</span></p></td><td width="125"><p id="u30cc3d16" class="ne-p"><span class="ne-text">1</span></p></td><td width="125"><p id="u5f8f0599" class="ne-p"><span class="ne-text">2</span></p></td><td width="125"><p id="u5df48f31" class="ne-p"><span class="ne-text">3</span></p></td><td width="125"><p id="u5a1b07ff" class="ne-p"><span class="ne-text">4</span></p></td></tr><tr style="height: 33px"><td width="125"><p id="uf7e9d9e7" class="ne-p"><span class="ne-text">data1</span></p></td><td width="125"><p id="uab1b1305" class="ne-p"><span class="ne-text">0</span></p></td><td width="125"><p id="u34b7f6c6" class="ne-p"><span class="ne-text">6</span></p></td><td width="125"><p id="u4e1d9e66" class="ne-p"><span class="ne-text">9</span></p></td><td width="125"><p id="ua84a0995" class="ne-p"><span class="ne-text">7</span></p></td><td width="125"><p id="uc02cc941" class="ne-p"><span class="ne-text">3</span></p></td></tr><tr style="height: 33px"><td width="125"><p id="u49b9b876" class="ne-p"><span class="ne-text">data2</span></p></td><td width="125"><p id="uf54625a0" class="ne-p"><span class="ne-text">4</span></p></td><td width="125"><p id="u848b644a" class="ne-p"><span class="ne-text">2</span></p></td><td width="125"><p id="udbac930f" class="ne-p"><span class="ne-text">8</span></p></td><td width="125"><p id="u8560deaa" class="ne-p"><span class="ne-text">0</span></p></td><td width="125"><p id="u1409f450" class="ne-p"><span class="ne-text">1</span></p></td></tr></tbody></table><p id="c3c3d38f0736bc7689d61d97fc990b67" class="ne-p"><br></p><h2 id="8b734d80"><span class="ne-text">六、数据转换</span></h2><p id="dd7c210c859d5825a6fc3a6970eeb989" class="ne-p"><br></p><pre data-language="python" id="379f4f72-2" class="ne-codeblock language-python">import numpy as np<br>import pandas as pd</pre><p id="1de42d69bb5e55f7742fe670a84e4017" class="ne-p"><br></p><h3 id="733c6e83"><span class="ne-text">重复数据 duplicates 函数</span></h3><p id="962a64b299d0f2297960980e1f901514" class="ne-p"><br></p><pre data-language="python" id="23bc48e7" class="ne-codeblock language-python">df_obj = pd.DataFrame({'data1' : ['a'] _ 4 + ['b'] _ 4,<br>'data2' : np.random.randint(0, 4, 8)})<br>df_obj</pre><p id="6f619776294030ce1be0072f00a19853" class="ne-p"><br></p><table id="e04f5215" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"></td><td width="250"><p id="u29addf64" class="ne-p"><span class="ne-text">data1</span></p></td><td width="250"><p id="uf4c1bc65" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u6da35f6c" class="ne-p"><span class="ne-text">0</span></p></td><td width="250"><p id="uac616efa" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="ub8202c56" class="ne-p"><span class="ne-text">3</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u155bfe0c" class="ne-p"><span class="ne-text">1</span></p></td><td width="250"><p id="ub284bbba" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="u1e5f62f4" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="uf650c2c9" class="ne-p"><span class="ne-text">2</span></p></td><td width="250"><p id="ua8c0d965" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="ud6e1ddc2" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u6928d329" class="ne-p"><span class="ne-text">3</span></p></td><td width="250"><p id="u4ece4166" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="u5308bb48" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u5eca0bb9" class="ne-p"><span class="ne-text">4</span></p></td><td width="250"><p id="u60f0a88d" class="ne-p"><span class="ne-text">b</span></p></td><td width="250"><p id="ueb83b479" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u6c220b40" class="ne-p"><span class="ne-text">5</span></p></td><td width="250"><p id="uf15379a7" class="ne-p"><span class="ne-text">b</span></p></td><td width="250"><p id="u1f68bac9" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ue49eff14" class="ne-p"><span class="ne-text">6</span></p></td><td width="250"><p id="ua4b7ebc3" class="ne-p"><span class="ne-text">b</span></p></td><td width="250"><p id="udd5752c2" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ub1a2a5f1" class="ne-p"><span class="ne-text">7</span></p></td><td width="250"><p id="u60398876" class="ne-p"><span class="ne-text">b</span></p></td><td width="250"><p id="u206db7c0" class="ne-p"><span class="ne-text">1</span></p></td></tr></tbody></table><p id="5faea08b4e3bbc7b5a2ee0960b926599" class="ne-p"><br></p><pre data-language="python" id="2adb2765" class="ne-codeblock language-python">df_obj.duplicated()</pre><p id="2327004780c08df0e8ad8280ae74a217" class="ne-p"><br></p><pre data-language="plain" id="263fe025" class="ne-codeblock language-plain">0 False<br>1 False<br>2 True<br>3 False<br>4 False<br>5 False<br>6 True<br>7 False<br>dtype: bool</pre><p id="7b51935ce28e051cf9e03153030e9bba" class="ne-p"><br></p><pre data-language="python" id="9f84e5e9" class="ne-codeblock language-python">df_obj.drop_duplicates()</pre><p id="42e64d2366041ba4f6a8abf12afc225e" class="ne-p"><br></p><table id="60f15592" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"></td><td width="250"><p id="u6ef0f98b" class="ne-p"><span class="ne-text">data1</span></p></td><td width="250"><p id="uce9c2d07" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="uea5fc425" class="ne-p"><span class="ne-text">0</span></p></td><td width="250"><p id="u0ec2791f" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="u00a07693" class="ne-p"><span class="ne-text">3</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u41e18df0" class="ne-p"><span class="ne-text">1</span></p></td><td width="250"><p id="ud2250003" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="u383b7309" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="uf36ee208" class="ne-p"><span class="ne-text">3</span></p></td><td width="250"><p id="u0f4b3c9f" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="uf1ef6594" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u0dffc0ed" class="ne-p"><span class="ne-text">4</span></p></td><td width="250"><p id="u14b2a985" class="ne-p"><span class="ne-text">b</span></p></td><td width="250"><p id="u2f08f83f" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="uf8354273" class="ne-p"><span class="ne-text">5</span></p></td><td width="250"><p id="u85a7d9e0" class="ne-p"><span class="ne-text">b</span></p></td><td width="250"><p id="u44b593ca" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ua7d4d6bd" class="ne-p"><span class="ne-text">7</span></p></td><td width="250"><p id="u76e6704e" class="ne-p"><span class="ne-text">b</span></p></td><td width="250"><p id="u0a63610f" class="ne-p"><span class="ne-text">1</span></p></td></tr></tbody></table><p id="286808f0af9855277d74f3310fdfdee0" class="ne-p"><br></p><pre data-language="python" id="883df7a7" class="ne-codeblock language-python">df_obj.drop_duplicates('data2')</pre><p id="5ef194d891497497b7d9d24d10c447d9" class="ne-p"><br></p><table id="377e3648" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"></td><td width="250"><p id="u5dfa3cff" class="ne-p"><span class="ne-text">data1</span></p></td><td width="250"><p id="u20afa825" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="uab7ba142" class="ne-p"><span class="ne-text">0</span></p></td><td width="250"><p id="u4b24c996" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="ub0e38445" class="ne-p"><span class="ne-text">3</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ua2dda83e" class="ne-p"><span class="ne-text">1</span></p></td><td width="250"><p id="ud09c3c1c" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="u09b7e036" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ub942c0eb" class="ne-p"><span class="ne-text">3</span></p></td><td width="250"><p id="u92494f3f" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="u55a6f46a" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="uc494eb8b" class="ne-p"><span class="ne-text">4</span></p></td><td width="250"><p id="ub9808a69" class="ne-p"><span class="ne-text">b</span></p></td><td width="250"><p id="uf67e7889" class="ne-p"><span class="ne-text">0</span></p></td></tr></tbody></table><p id="6fb8ac6cc72bbf4d459ca4323c3369cf" class="ne-p"><br></p><h3 id="207de4ba"><span class="ne-text">map 函数</span></h3><p id="0b852b014c420dfa44de29a2094f36bc" class="ne-p"><br></p><pre data-language="python" id="e66db930" class="ne-codeblock language-python">ser_obj = pd.Series(np.random.randint(0,10,10))<br>ser_obj</pre><p id="20f3b3fe6db7de5d960e0f9f3e5daa5c" class="ne-p"><br></p><pre data-language="plain" id="883103db" class="ne-codeblock language-plain">0 1<br>1 9<br>2 1<br>3 2<br>4 7<br>5 2<br>6 4<br>7 5<br>8 4<br>9 6<br>dtype: int32</pre><p id="417b03bd67025a010d552a47f2557d9f" class="ne-p"><br></p><pre data-language="python" id="15248bd2" class="ne-codeblock language-python">ser_obj.map(lambda x : x ** 2)</pre><p id="1e8c432b1337e249a62dd72a98a9bd65" class="ne-p"><br></p><pre data-language="plain" id="a2279e5a" class="ne-codeblock language-plain">0 1<br>1 81<br>2 1<br>3 4<br>4 49<br>5 4<br>6 16<br>7 25<br>8 16<br>9 36<br>dtype: int64</pre><p id="1e529b753a515a1b0e602cd47d91e556" class="ne-p"><br></p><h3 id="1584db2b"><span class="ne-text">数据替换 repalce</span></h3><p id="8110e898e645923cf5bdb0698a0ba85e" class="ne-p"><br></p><pre data-language="python" id="9379d450" class="ne-codeblock language-python"># 替换单个值<br>ser_obj.replace(0, -100)</pre><p id="8acd89d411f1fe553a62e07956358d97" class="ne-p"><br></p><pre data-language="plain" id="883103db-1" class="ne-codeblock language-plain">0 1<br>1 9<br>2 1<br>3 2<br>4 7<br>5 2<br>6 4<br>7 5<br>8 4<br>9 6<br>dtype: int32</pre><p id="b54c66d8f7e43413c0b8cf2346183aa0" class="ne-p"><br></p><pre data-language="python" id="7a6be364" class="ne-codeblock language-python"># 替换多个值<br>ser_obj.replace([0, 2], -100)</pre><p id="ecfa1ac314577c38da677bf50befe650" class="ne-p"><br></p><pre data-language="plain" id="10f50805" class="ne-codeblock language-plain">0 1<br>1 9<br>2 1<br>3 -100<br>4 7<br>5 -100<br>6 4<br>7 5<br>8 4<br>9 6<br>dtype: int32</pre><p id="068d5496b45003de6a59b69f9d88ef82" class="ne-p"><br></p><pre data-language="python" id="788607ac" class="ne-codeblock language-python"># 替换多个值<br>ser_obj.replace([0, 2], [-100, -200])</pre><p id="72422fede5e8faea414154c40133d57f" class="ne-p"><br></p><pre data-language="plain" id="7388dc30" class="ne-codeblock language-plain">0 1<br>1 9<br>2 1<br>3 -200<br>4 7<br>5 -200<br>6 4<br>7 5<br>8 4<br>9 6<br>dtype: int64</pre><p id="d65e0ebb83ebe63c7e11dc2777c3e2cc" class="ne-p"><br></p><pre data-language="python" id="512b24b5" class="ne-codeblock language-python">ser_obj.map(lambda x : x ** 2)</p><h4 id="3-数据替换-repalce"><a href="#3-数据替换-repalce" class="headerlink" title="3. 数据替换 repalce"></a>3. 数据替换 repalce</h4><h1 id="替换单个值"><a href="#替换单个值" class="headerlink" title="替换单个值"></a>替换单个值</h1><p>ser_obj.replace(0, -100)</p><h1 id="替换多个值"><a href="#替换多个值" class="headerlink" title="替换多个值"></a>替换多个值</h1><p>ser_obj.replace([0, 2], -100)</p><h1 id="替换多个值-1"><a href="#替换多个值-1" class="headerlink" title="替换多个值"></a>替换多个值</h1><p>ser_obj.replace([0, 2], [-100, -200])</pre><p id="ec9881a62ad4fb02d90aa9fa8ea52c70" class="ne-p"><br></p><pre data-language="plain" id="7388dc30-1" class="ne-codeblock language-plain">0 1<br>1 9<br>2 1<br>3 -200<br>4 7<br>5 -200<br>6 4<br>7 5<br>8 4<br>9 6<br>dtype: int64</pre></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python的本地各类数据读取</title>
      <link href="/blog/lb8ugs/"/>
      <url>/blog/lb8ugs/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="hySBP"><span class="ne-text">一、TXT文件操作</span></h2><p id="1c9b06a4e45017a35246f5a956dbff9f" class="ne-p"><br></p><h3 id="fc1ffaa9"><span class="ne-text">读取全部内容</span></h3><p id="f8b3b85cbf63cd7d657993e7c313dea0" class="ne-p"><br></p><pre data-language="python" id="379f4f72" class="ne-codeblock language-python">import numpy as np<p>import pandas as pd</pre><p id="2ef521d6e78e5bd3c4b078614ecda820" class="ne-p"><br></p><pre data-language="python" id="39f55fdf" class="ne-codeblock language-python">txt_filename = './files/python_wiki.txt'</p><h1 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h1><p>file_obj = open(txt_filename,’r’)</p><h1 id="读取整个文件内容"><a href="#读取整个文件内容" class="headerlink" title="读取整个文件内容"></a>读取整个文件内容</h1><p>all_content = file_obj.read()</p><h1 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h1><p>file_obj.close()</p><p>print (all_content)</pre><p id="ab2d0261ee3db68b4444bcaed3276ee7" class="ne-p"><br></p><pre data-language="plain" id="a78c72cd" class="ne-codeblock language-plain">Python is a widely used high-level, general-purpose, interpreted, dynamic programming language.[24][25] Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than possible in languages such as C++ or Java.[26][27] The language provides constructs intended to enable writing clear programs on both a small and large scale.[28]<br>Python supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. It features a dynamic type system and automatic memory management and has a large and comprehensive standard library.[29]<br>Python interpreters are available for many operating systems, allowing Python code to run on a wide variety of systems. CPython, the reference implementation of Python, is open source software[30] and has a community-based development model, as do nearly all of its variant implementations. CPython is managed by the non-profit Python Software Foundation.</pre><p id="e129906e27765b599f204b1b8169af57" class="ne-p"><br></p><h3 id="860fcf92"><span class="ne-text">逐行读取</span></h3><p id="f00ce072fcafc401962a7c1589be41f8" class="ne-p"><br></p><pre data-language="python" id="32a11f04" class="ne-codeblock language-python">txt_filename = './files/python_wiki.txt'</p><h1 id="打开文件-1"><a href="#打开文件-1" class="headerlink" title="打开文件"></a>打开文件</h1><p>file_obj = open(txt_filename, ‘r’)</p><h1 id="逐行读取"><a href="#逐行读取" class="headerlink" title="逐行读取"></a>逐行读取</h1><p>line1 = file_obj.readline()<br>print (line1)</pre><p id="08164aae7ba5f46e00c7c3de7c78a689" class="ne-p"><br></p><pre data-language="plain" id="5b09e668" class="ne-codeblock language-plain">Python is a widely used high-level, general-purpose, interpreted, dynamic programming language.[24][25] Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than possible in languages such as C++ or Java.[26][27] The language provides constructs intended to enable writing clear programs on both a small and large scale.[28]</pre><p id="69c6e7752fe1dea536ca1121a52939e9" class="ne-p"><br></p><pre data-language="python" id="479a85a9" class="ne-codeblock language-python"># 继续读下一行【不会全部读完】<br>line2 = file_obj.readline()<br>print (line2)</p><h1 id="关闭文件-1"><a href="#关闭文件-1" class="headerlink" title="关闭文件"></a>关闭文件</h1><p>file_obj.close()</pre><p id="3f2e8b02a7ed006a6d01deff9a3bac9a" class="ne-p"><br></p><pre data-language="plain" id="0d08617c" class="ne-codeblock language-plain">Python supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. It features a dynamic type system and automatic memory management and has a large and comprehensive standard library.[29]</pre><p id="8c4d59e7927553b74a20906863242be2" class="ne-p"><br></p><h3 id="6d74200a"><span class="ne-text">读取全部内容，返回列表</span></h3><p id="fa2bcf2fcb6e146fe78f834a79cc9287" class="ne-p"><br></p><pre data-language="python" id="224164d3" class="ne-codeblock language-python">txt_filename = './files/python_wiki.txt'</p><h1 id="打开文件-2"><a href="#打开文件-2" class="headerlink" title="打开文件"></a>打开文件</h1><p>file_obj = open(txt_filename, ‘r’)</p><p>lines = file_obj.readlines()</p><p>for i, line in enumerate(lines):<br>print (‘%i: %s’ %(i, line))</p><h1 id="关闭文件-2"><a href="#关闭文件-2" class="headerlink" title="关闭文件"></a>关闭文件</h1><p>file_obj.close()</pre><p id="506b5bc3702daaa64b6c95ca566be89e" class="ne-p"><br></p><pre data-language="plain" id="b6f2212e" class="ne-codeblock language-plain">0: Python is a widely used high-level, general-purpose, interpreted, dynamic programming language.[24][25] Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than possible in languages such as C++ or Java.[26][27] The language provides constructs intended to enable writing clear programs on both a small and large scale.[28]</p><p>1: Python supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. It features a dynamic type system and automatic memory management and has a large and comprehensive standard library.[29]</p><p>2: Python interpreters are available for many operating systems, allowing Python code to run on a wide variety of systems. CPython, the reference implementation of Python, is open source software[30] and has a community-based development model, as do nearly all of its variant implementations. CPython is managed by the non-profit Python Software Foundation.</pre><p id="3a7861dc4373f577ad38e1d05f0d0269" class="ne-p"><br></p><h3 id="a6abfd3f"><span class="ne-text">写操作</span></h3><p id="159ed0fa4aba36e6e9495976d4a7fe97" class="ne-p"><br></p><pre data-language="python" id="6fc0313e" class="ne-codeblock language-python">txt_filename = './files/test_write.txt'</p><h1 id="打开文件-3"><a href="#打开文件-3" class="headerlink" title="打开文件"></a>打开文件</h1><p>file_obj = open(txt_filename, ‘w’)</p><h1 id="写入全部内容"><a href="#写入全部内容" class="headerlink" title="写入全部内容"></a>写入全部内容</h1><p>file_obj.write(“《Python 数据分析》”)<br>file_obj.close()</pre><p id="b83ffa419fcf75c8aad6deafabb58d8b" class="ne-p"><br></p><pre data-language="python" id="e5bd7d49" class="ne-codeblock language-python">txt_filename = './files/test_write.txt'</p><h1 id="打开文件-4"><a href="#打开文件-4" class="headerlink" title="打开文件"></a>打开文件</h1><p>file_obj = open(txt_filename, ‘w’)</p><h1 id="写入字符串列表"><a href="#写入字符串列表" class="headerlink" title="写入字符串列表"></a>写入字符串列表</h1><p>lines = [‘这是第%i 行\n’ %n for n in range(10)]<br>file_obj.writelines(lines)<br>file_obj.close()</pre><p id="d06bef75376975bd3bc0a0d155127988" class="ne-p"><br></p><h3 id="ece39eee"><span class="ne-text">with 语句</span></h3><p id="be6c4c96a3fdfed287890aa5f5cb58e7" class="ne-p"><br></p><pre data-language="python" id="2aa4cc29" class="ne-codeblock language-python">txt_filename = './files/test_write.txt'<br>with open(txt_filename, 'r') as f_obj:<br>print (f_obj.read())</pre><p id="20da9e61a49a7df4edf7f2b593ca2a54" class="ne-p"><br></p><pre data-language="plain" id="e669114d" class="ne-codeblock language-plain">这是第 0 行<br>这是第 1 行<br>这是第 2 行<br>这是第 3 行<br>这是第 4 行<br>这是第 5 行<br>这是第 6 行<br>这是第 7 行<br>这是第 8 行<br>这是第 9 行</pre><p id="6cde88e7c1102a0f9a40735637acec60" class="ne-p"><br></p><h2 id="3a91feb2"><span class="ne-text">二、CSV 文件操作</span></h2><p id="5a4f81942757a22fa388b6c0b4af6298" class="ne-p"><br></p><h3 id="dfca1c51"><span class="ne-text">pandas 读 csv 文件</span></h3><p id="04d24e7b60414a9109ef046e9e9e6745" class="ne-p"><br></p><div class="ne-quote"><p id="04734f996dc385c7f7a3219efc22d369" class="ne-p"><span class="ne-text">根据路径导入数据以及指定的列</span></p></div><p id="a334378bf4e6d817955aa5f6b784ad2c" class="ne-p"><br></p><pre data-language="python" id="1f6ef0f6" class="ne-codeblock language-python">import pandas as pd<br>filename = './files/presidential_polls.csv'<br>df = pd.read_csv(filename, usecols=['cycle', 'type', 'startdate'])#导入指定列<br>print (type(df))<br>print (df.head())</pre><p id="e99007d2ec0f37f2563be81f597cc2c0" class="ne-p"><br></p><pre data-language="plain" id="a8cb0773" class="ne-codeblock language-plain"><class 'pandas.core.frame.DataFrame'><br>cycle type startdate<br>0 2016 polls-plus 10/25/2016<br>1 2016 polls-plus 10/27/2016<br>2 2016 polls-plus 10/27/2016<br>3 2016 polls-plus 10/20/2016<br>4 2016 polls-plus 10/20/2016</pre><p id="0fdaeaa72fecc96be92e86c9e23edbfa" class="ne-p"><br></p><div class="ne-quote"><p id="4106cad5392914f7900a5edea9ac1b28" class="ne-p"><span class="ne-text">引用指定的列</span></p></div><p id="79cccf8e9be9ef03ac67a917b2534c9f" class="ne-p"><br></p><pre data-language="python" id="37d6fcf9" class="ne-codeblock language-python">cycle_se = df['cycle']<br>print (type(cycle_se))<br>print (cycle_se.head())</pre><p id="14f96d9c6ceb9804fdc8a4761b1adb9c" class="ne-p"><br></p><pre data-language="plain" id="a666b6cc" class="ne-codeblock language-plain"><class 'pandas.core.series.Series'><br>0 2016<br>1 2016<br>2 2016<br>3 2016<br>4 2016<br>Name: cycle, dtype: int64</pre><p id="e84f6bea4b935b931b7e234518bd1ef2" class="ne-p"><br></p><div class="ne-quote"><p id="d98a82f4c9a4bfa87fdc429c9e3e4ac5" class="ne-p"><span class="ne-text">多层索引成 dataframe 类型</span></p></div><p id="70fdea5cf6a5a49d2d47b7bf47f1206b" class="ne-p"><br></p><pre data-language="python" id="9f8ca917" class="ne-codeblock language-python">filename = './files/presidential_polls.csv'<br>df1 = pd.read_csv(filename,usecols=['cycle', 'type', 'startdate','state','grade'],index_col = ['state','grade'])<br>print(df1.head())</pre><p id="aff7543c7487ecd2c86604de3c379216" class="ne-p"><br></p><pre data-language="plain" id="0fcd19b1" class="ne-codeblock language-plain"> cycle type startdate<br>state grade<br>U.S. B 2016 polls-plus 10/25/2016<br>A+ 2016 polls-plus 10/27/2016<br>Virginia A+ 2016 polls-plus 10/27/2016<br>Florida A 2016 polls-plus 10/20/2016<br>U.S. B+ 2016 polls-plus 10/20/2016</pre><p id="18fe5de52d442afbe9772aa7955c12fd" class="ne-p"><br></p><div class="ne-quote"><p id="13314ed439c33a5fe4922bde8d9a8c78" class="ne-p"><span class="ne-text">跳过指定的行</span></p></div><p id="ff64956c6963c2664b162d2083b73443" class="ne-p"><br></p><pre data-language="python" id="4dfbd90a" class="ne-codeblock language-python">filename = './files/presidential_polls.csv'<br>df2 = pd.read_csv(filename,usecols=['cycle', 'type', 'startdate','state','grade'],skiprows=[1, 2, 3])<br>print(df2.head())</pre><p id="6a053627e1226f45edce047e5eea3099" class="ne-p"><br></p><pre data-language="plain" id="5a843125" class="ne-codeblock language-plain"> cycle type state startdate grade<br>0 2016 polls-plus Florida 10/20/2016 A<br>1 2016 polls-plus U.S. 10/20/2016 B+<br>2 2016 polls-plus U.S. 10/22/2016 A<br>3 2016 polls-plus U.S. 10/26/2016 A-<br>4 2016 polls-plus Pennsylvania 10/25/2016 B-</pre><p id="3048a9d40f77221188429b68c772df3d" class="ne-p"><br></p><h3 id="896b1553"><span class="ne-text">pandas 写 csv 文件</span></h3><p id="cfefff088e31631da34fbb16c2dde3ef" class="ne-p"><br></p><div class="ne-quote"><p id="e716063f9215d4cf52dddb31221423e1" class="ne-p"><span class="ne-text">·to_csv 里面的 index 参数作用？===可能是不要索引的意思。</span></p></div><p id="efae2139ae49d34ef186b80471b67531" class="ne-p"><br></p><pre data-language="python" id="091b1841" class="ne-codeblock language-python">filename = './files/pandas_output.csv'<br>df.to_csv(filename, index=None)</pre><p id="777151de6c4351819f024109e6406d9d" class="ne-p"><br></p><h2 id="6832156e"><span class="ne-text">三、JSON 文件操作</span></h2><p id="2031561c5a224041b84b08e29f06a472" class="ne-p"><br></p><h3 id="0fefaed0"><span class="ne-text">json 读操作</span></h3><p id="10bf27a11c1b1734918c2b60c6cc076a" class="ne-p"><br></p><pre data-language="python" id="c6472f15" class="ne-codeblock language-python">import json</p><p>filename = ‘./files/global_temperature.json’<br>with open(filename, ‘r’) as f_obj:<br>json_data = json.load(f_obj)</p><h1 id="返回值是-dict-类型"><a href="#返回值是-dict-类型" class="headerlink" title="返回值是 dict 类型"></a>返回值是 dict 类型</h1><p>print (type(json_data))</pre><p id="04cbdd67a6fc9ffe61a152ff1194db6a" class="ne-p"><br></p><pre data-language="plain" id="ec1d5cc4" class="ne-codeblock language-plain"><class 'dict'></pre><p id="1156617fa842af2a7070c342e7920a16" class="ne-p"><br></p><pre data-language="python" id="517f955b" class="ne-codeblock language-python">print (json_data.keys())</pre><p id="95c158ff6cfe1900ad15a95e17b299dd" class="ne-p"><br></p><pre data-language="plain" id="4690b060" class="ne-codeblock language-plain">dict_keys(['description', 'data'])</pre><p id="bb111a55ee5d5d4e11636eba951f1a91" class="ne-p"><br></p><h3 id="b95c783a"><span class="ne-text">json 转 CSV</span></h3><p id="13e42db0ba90e22adafbcc53d51c1e6b" class="ne-p"><br></p><pre data-language="python" id="6e971164" class="ne-codeblock language-python">#print json_data['data'].keys()<br>print (json_data['data'].values())</pre><p id="256c1b572f61798c06fd44efb1ca8c97" class="ne-p"><br></p><pre data-language="plain" id="c092c636" class="ne-codeblock language-plain">dict_values(['-0.1247', '-0.0707', '-0.0710', '-0.1481', '-0.2099', '-0.2220', '-0.2101', '-0.2559', '-0.1541', '-0.1032', '-0.3233', '-0.2552', '-0.3079', '-0.3221', '-0.2828', '-0.2279', '-0.0971', '-0.1232', '-0.2578', '-0.1172', '-0.0704', '-0.1471', '-0.2535', '-0.3442', '-0.4240', '-0.2967', '-0.2208', '-0.3767', '-0.4441', '-0.4332', '-0.3862', '-0.4367', '-0.3318', '-0.3205', '-0.1444', '-0.0747', '-0.2979', '-0.3193', '-0.2118', '-0.2082', '-0.2152', '-0.1517', '-0.2318', '-0.2161', '-0.2510', '-0.1464', '-0.0618', '-0.1506', '-0.1749', '-0.2982', '-0.1016', '-0.0714', '-0.1214', '-0.2481', '-0.1075', '-0.1445', '-0.1173', '-0.0204', '-0.0318', '-0.0157', '0.0927', '0.1974', '0.1549', '0.1598', '0.2948', '0.1754', '-0.0013', '-0.0455', '-0.0471', '-0.0550', '-0.1579', '-0.0095', '0.0288', '0.0997', '-0.1118', '-0.1305', '-0.1945', '0.0538', '0.1145', '0.0640', '0.0252', '0.0818', '0.0924', '0.1100', '-0.1461', '-0.0752', '-0.0204', '-0.0112', '-0.0282', '0.0937', '0.0383', '-0.0775', '0.0280', '0.1654', '-0.0698', '0.0060', '-0.0769', '0.1996', '0.1139', '0.2288', '0.2651', '0.3024', '0.1836', '0.3429', '0.1510', '0.1357', '0.2308', '0.3710', '0.3770', '0.2982', '0.4350', '0.4079', '0.2583', '0.2857', '0.3420', '0.4593', '0.3225', '0.5185', '0.6335', '0.4427', '0.4255', '0.5455', '0.6018', '0.6145', '0.5806', '0.6583', '0.6139', '0.6113', '0.5415', '0.6354', '0.7008', '0.5759', '0.6219', '0.6687', '0.7402', '0.8990'])</pre><p id="8acd6f2f6686a2424f8d17e0ac95a049" class="ne-p"><br></p><pre data-language="python" id="84fe47e9" class="ne-codeblock language-python"># 转换 key<br>year_str_lst = json_data['data'].keys()<br>year_lst = [int(year_str) for year_str in year_str_lst]<br>print (year_lst)</pre><p id="4f5fe92ae245e12848eb2911b1b91d90" class="ne-p"><br></p><pre data-language="plain" id="e50f2ae5" class="ne-codeblock language-plain">[1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015]</pre><p id="5382a951b36086d4ee93fba19a12fd3f" class="ne-p"><br></p><pre data-language="python" id="b737a009" class="ne-codeblock language-python"># 转换 value<br>temp_str_lst = json_data['data'].values()<br>temp_lst = [float(temp_str) for temp_str in temp_str_lst]<br>print (temp_lst)</pre><p id="e6ce978a209f8e1ff180bebed920d286" class="ne-p"><br></p><pre data-language="plain" id="f73c5418" class="ne-codeblock language-plain">[-0.1247, -0.0707, -0.071, -0.1481, -0.2099, -0.222, -0.2101, -0.2559, -0.1541, -0.1032, -0.3233, -0.2552, -0.3079, -0.3221, -0.2828, -0.2279, -0.0971, -0.1232, -0.2578, -0.1172, -0.0704, -0.1471, -0.2535, -0.3442, -0.424, -0.2967, -0.2208, -0.3767, -0.4441, -0.4332, -0.3862, -0.4367, -0.3318, -0.3205, -0.1444, -0.0747, -0.2979, -0.3193, -0.2118, -0.2082, -0.2152, -0.1517, -0.2318, -0.2161, -0.251, -0.1464, -0.0618, -0.1506, -0.1749, -0.2982, -0.1016, -0.0714, -0.1214, -0.2481, -0.1075, -0.1445, -0.1173, -0.0204, -0.0318, -0.0157, 0.0927, 0.1974, 0.1549, 0.1598, 0.2948, 0.1754, -0.0013, -0.0455, -0.0471, -0.055, -0.1579, -0.0095, 0.0288, 0.0997, -0.1118, -0.1305, -0.1945, 0.0538, 0.1145, 0.064, 0.0252, 0.0818, 0.0924, 0.11, -0.1461, -0.0752, -0.0204, -0.0112, -0.0282, 0.0937, 0.0383, -0.0775, 0.028, 0.1654, -0.0698, 0.006, -0.0769, 0.1996, 0.1139, 0.2288, 0.2651, 0.3024, 0.1836, 0.3429, 0.151, 0.1357, 0.2308, 0.371, 0.377, 0.2982, 0.435, 0.4079, 0.2583, 0.2857, 0.342, 0.4593, 0.3225, 0.5185, 0.6335, 0.4427, 0.4255, 0.5455, 0.6018, 0.6145, 0.5806, 0.6583, 0.6139, 0.6113, 0.5415, 0.6354, 0.7008, 0.5759, 0.6219, 0.6687, 0.7402, 0.899]</pre><p id="f3d86cbf3e1555be8b8f2276b2c878a9" class="ne-p"><br></p><pre data-language="python" id="720be263" class="ne-codeblock language-python">import pandas as pd</p><h1 id="构建-dataframe"><a href="#构建-dataframe" class="headerlink" title="构建 dataframe"></a>构建 dataframe</h1><p>year_se = pd.Series(year_lst, name = ‘year’)<br>temp_se = pd.Series(temp_lst, name = ‘temperature’)<br>result_df = pd.concat([year_se, temp_se], axis = 1)<br>print (result_df.head())</p><h1 id="保存-csv"><a href="#保存-csv" class="headerlink" title="保存 csv"></a>保存 csv</h1><p>result_df.to_csv(‘./files/json_to_csv.csv’, index = None)</pre><p id="66213c9d50b791c5fb81465766ba1567" class="ne-p"><br></p><pre data-language="plain" id="07bbf5ac" class="ne-codeblock language-plain"> year temperature<br>0 1880 -0.1247<br>1 1881 -0.0707<br>2 1882 -0.0710<br>3 1883 -0.1481<br>4 1884 -0.2099</pre><p id="4e2627fb42b99e36edb796ea2391053f" class="ne-p"><br></p><h3 id="f39917fb"><span class="ne-text">写 json 操作</span></h3><p id="e3e0c809313dd9acc8efdfe28109da6e" class="ne-p"><br></p><pre data-language="python" id="08be5d12" class="ne-codeblock language-python">book_dict = [{'书名':'无声告白', '作者':'伍绮诗'}, {'书名':'我不是潘金莲', '作者':'刘震云'}, {'书名':'沉默的大多数 (王小波集)', '作者':'王小波'}]</p><p>filename = ‘./files/json_output.json’<br>with open(filename, ‘w’) as f_obj:<br>f_obj.write(json.dumps(book_dict, ensure_ascii=False))</p><h1 id="不需要加-encoding-’utf-8’参数四、SQLite-基本操作连接数据库import-sqlite3"><a href="#不需要加-encoding-’utf-8’参数四、SQLite-基本操作连接数据库import-sqlite3" class="headerlink" title="不需要加, encoding=’utf-8’参数四、SQLite 基本操作连接数据库import sqlite3"></a>不需要加, encoding=’utf-8’参数</pre><p id="e0838705451009103208b8a8306257bd" class="ne-p"><br></p><h2 id="5f1a3adb"><span class="ne-text">四、SQLite 基本操作</span></h2><p id="3d4ad084b1d1f36784fd7f7a615be5be" class="ne-p"><br></p><h3 id="a29c5a85"><span class="ne-text">连接数据库</span></h3><p id="9fb26e4428f21542bdfb2463bddd0ad8" class="ne-p"><br></p><pre data-language="python" id="d5d2269a" class="ne-codeblock language-python">import sqlite3</h1><p>db_path = ‘./files/test.sqlite’</p><p>conn = sqlite3.connect(db_path)<br>cur = conn.cursor()<br>conn.text_factory = str # 处理中文</pre><p id="64dfb468bc2cc7c05ca18b5b16005def" class="ne-p"><br></p><h3 id="9c5e1e6b"><span class="ne-text">获取基本信息</span></h3><p id="da9e0348ebe33d1ac1eb74266dcba47c" class="ne-p"><br></p><pre data-language="python" id="469d373e" class="ne-codeblock language-python">cur.execute('SELECT SQLITE_VERSION()')</p><p>print (‘SQLite 版本：%s’ %str(cur.fetchone()[0]))</pre><p id="b88625a36beae1e4f63b766b42737e8d" class="ne-p"><br></p><pre data-language="plain" id="6a13da4d" class="ne-codeblock language-plain">SQLite 版本：3.30.0</pre><p id="e6d2ea5de28ce8a42ead8c83a00f210b" class="ne-p"><br></p><h3 id="643f6530"><span class="ne-text">逐条插入数据</span></h3><p id="743378636855064d52fabb5891f290f5" class="ne-p"><br></p><pre data-language="python" id="42474b68" class="ne-codeblock language-python">cur.execute("DROP TABLE IF EXISTS book")<br>cur.execute("CREATE TABLE book(id INT, name TEXT, price DOUBLE)")<br>cur.execute("INSERT INTO book VALUES(1,'肖秀荣考研书系列:肖秀荣(2017)考研政治命题人终极预测 4 套卷',14.40)")<br>cur.execute("INSERT INTO book VALUES(2,'法医秦明作品集:幸存者+清道夫+尸语者+无声的证词+第十一根手指(套装共 5 册) (两种封面随机发货)',100.00)")<br>cur.execute("INSERT INTO book VALUES(3,'活着本来单纯:丰子恺散文漫画精品集(收藏本)',30.90)")<br>cur.execute("INSERT INTO book VALUES(4,'自在独行:贾平凹的独行世界',26.80)")<br>cur.execute("INSERT INTO book VALUES(5,'当你的才华还撑不起你的梦想时',23.00)")<br>cur.execute("INSERT INTO book VALUES(6,'巨人的陨落(套装共 3 册)',84.90)")<br>cur.execute("INSERT INTO book VALUES(7,'孤独深处(收录雨果奖获奖作品《北京折叠》)',21.90)")<br>cur.execute("INSERT INTO book VALUES(8,'世界知名企业员工指定培训教材:所谓情商高,就是会说话',22.00)")</pre><p id="72f155b7e9e126c5f6de6a1322fb71e6" class="ne-p"><br></p><pre data-language="plain" id="21321870" class="ne-codeblock language-plain"><sqlite3.Cursor at 0x2d2d64e7c00></pre><p id="3a7e4394465571d270a424d80997ad59" class="ne-p"><br></p><h3 id="c7bf12ad"><span class="ne-text">批量插入数据</span></h3><p id="21584e43999c4894c95585c3400bc9c6" class="ne-p"><br></p><pre data-language="python" id="665ad742" class="ne-codeblock language-python">books = (<br>(9, '人间草木', 30.00),<br>(10,'你的善良必须有点锋芒', 20.50),<br>(11, '这么慢,那么美', 24.80),<br>(12, '考拉小巫的英语学习日记:写给为梦想而奋斗的人(全新修订版)', 23.90)<br>)<br>cur.executemany("INSERT INTO book VALUES(?, ?, ?)", books)</pre><p id="cae013fc137fc8e5d932916b8f9426ff" class="ne-p"><br></p><pre data-language="plain" id="21321870-1" class="ne-codeblock language-plain"><sqlite3.Cursor at 0x2d2d64e7c00></pre><p id="b002caadd88cb08679ebba31474cf6d8" class="ne-p"><br></p><pre data-language="python" id="c5da2d1c" class="ne-codeblock language-python">conn.commit()</pre><p id="29689200a72fa76db97529a512910fa7" class="ne-p"><br></p><h3 id="0a7fa4b6"><span class="ne-text">查找数据</span></h3><p id="93b6ff223e905572d848e99218baea59" class="ne-p"><br></p><pre data-language="python" id="167dea04" class="ne-codeblock language-python">cur.execute('SELECT * FROM book')<br>rows = cur.fetchall()</p><h1 id="通过索引号访问"><a href="#通过索引号访问" class="headerlink" title="通过索引号访问"></a>通过索引号访问</h1><p>for row in rows:<br>print (‘序号: %i, 书名: %s, 价格: %.2f’ %(row[0], row[1], row[2]))</pre><p id="fb67befb2847144a0846520ff6798e2a" class="ne-p"><br></p><pre data-language="plain" id="6a334836" class="ne-codeblock language-plain">序号: 1, 书名: 肖秀荣考研书系列:肖秀荣(2017)考研政治命题人终极预测 4 套卷, 价格: 14.40<br>序号: 2, 书名: 法医秦明作品集:幸存者+清道夫+尸语者+无声的证词+第十一根手指(套装共 5 册) (两种封面随机发货), 价格: 100.00<br>序号: 3, 书名: 活着本来单纯:丰子恺散文漫画精品集(收藏本), 价格: 30.90<br>序号: 4, 书名: 自在独行:贾平凹的独行世界, 价格: 26.80<br>序号: 5, 书名: 当你的才华还撑不起你的梦想时, 价格: 23.00<br>序号: 6, 书名: 巨人的陨落(套装共 3 册), 价格: 84.90<br>序号: 7, 书名: 孤独深处(收录雨果奖获奖作品《北京折叠》), 价格: 21.90<br>序号: 8, 书名: 世界知名企业员工指定培训教材:所谓情商高,就是会说话, 价格: 22.00<br>序号: 9, 书名: 人间草木, 价格: 30.00<br>序号: 10, 书名: 你的善良必须有点锋芒, 价格: 20.50<br>序号: 11, 书名: 这么慢,那么美, 价格: 24.80<br>序号: 12, 书名: 考拉小巫的英语学习日记:写给为梦想而奋斗的人(全新修订版), 价格: 23.90</pre><p id="86607338499ad4af24c5712c9311b068" class="ne-p"><br></p><pre data-language="python" id="0487b4c3" class="ne-codeblock language-python">conn.row_factory = sqlite3.Row<br>cur = conn.cursor()<br>cur.execute('SELECT * FROM book')<br>rows = cur.fetchall()</p><h1 id="通过列名访问"><a href="#通过列名访问" class="headerlink" title="通过列名访问"></a>通过列名访问</h1><p>for row in rows:<br>print (‘序号: %i, 书名: %s, 价格: %.2f’ %(row[‘id’], row[‘name’], row[‘price’]))</pre><p id="661f1f35d17a9883ed1ac16478fb23f4" class="ne-p"><br></p><pre data-language="plain" id="6a334836-1" class="ne-codeblock language-plain">序号: 1, 书名: 肖秀荣考研书系列:肖秀荣(2017)考研政治命题人终极预测 4 套卷, 价格: 14.40<br>序号: 2, 书名: 法医秦明作品集:幸存者+清道夫+尸语者+无声的证词+第十一根手指(套装共 5 册) (两种封面随机发货), 价格: 100.00<br>序号: 3, 书名: 活着本来单纯:丰子恺散文漫画精品集(收藏本), 价格: 30.90<br>序号: 4, 书名: 自在独行:贾平凹的独行世界, 价格: 26.80<br>序号: 5, 书名: 当你的才华还撑不起你的梦想时, 价格: 23.00<br>序号: 6, 书名: 巨人的陨落(套装共 3 册), 价格: 84.90<br>序号: 7, 书名: 孤独深处(收录雨果奖获奖作品《北京折叠》), 价格: 21.90<br>序号: 8, 书名: 世界知名企业员工指定培训教材:所谓情商高,就是会说话, 价格: 22.00<br>序号: 9, 书名: 人间草木, 价格: 30.00<br>序号: 10, 书名: 你的善良必须有点锋芒, 价格: 20.50<br>序号: 11, 书名: 这么慢,那么美, 价格: 24.80<br>序号: 12, 书名: 考拉小巫的英语学习日记:写给为梦想而奋斗的人(全新修订版), 价格: 23.90</pre><p id="77e213762f65e51405edb0591de67abe" class="ne-p"><br></p><pre data-language="python" id="0c357bf2" class="ne-codeblock language-python">conn.close()</pre><p id="acf11068e3023a2453b028cb0b86380a" class="ne-p"><br></p><h2 id="64a963be"><span class="ne-text">五、SQLite_json 操作</span></h2><p id="a6df6bd6d976702e0184110c53638a98" class="ne-p"><br></p><pre data-language="python" id="d052ff92" class="ne-codeblock language-python">import sqlite3</p><p>db_path = ‘./files/test_join.sqlite’</p><p>conn = sqlite3.connect(db_path)<br>cur = conn.cursor()</pre><p id="fbaf5cc8414e55c9d27b8e8061cd9ad7" class="ne-p"><br></p><pre data-language="python" id="ed3623a3" class="ne-codeblock language-python"># 建 depaetment 表，并插入数据<br>cur.execute("DROP TABLE IF EXISTS department")<br>cur.execute("CREATE TABLE department(<br> id INT PRIMARY KEY NOT NULL, <br> dept CHAR(50) NOT NULL, <br> emp_id INT NOT NULL)")<br>depts = (<br>(1, 'IT Builing', 1),<br>(2, 'Engineerin', 2),<br>(3, 'Finance', 7)<br>)<br>cur.executemany("INSERT INTO department VALUES(?, ?, ?)", depts)</pre><p id="cf7e6e276db7e56014292ee1011dd2b7" class="ne-p"><br></p><pre data-language="plain" id="247240d5" class="ne-codeblock language-plain"><sqlite3.Cursor at 0x2d2d64f70a0></pre><p id="6ecb5c7f01bf2bf88bbfdf94ba2c2b7f" class="ne-p"><br></p><pre data-language="python" id="c5da2d1c-1" class="ne-codeblock language-python">conn.commit()</pre><p id="e1a4c39e0f1d9f270ab255517b48b711" class="ne-p"><br></p><h3 id="6da83b0f"><span class="ne-text">CROSS JOIN 交叉连接</span></h3><p id="1201739ff173575db939edbdadad9e41" class="ne-p"><br></p><pre data-language="python" id="59d756e0" class="ne-codeblock language-python">cur.execute("SELECT emp_id, name, dept FROM company CROSS JOIN department;")<br>rows = cur.fetchall()<br>for row in rows:<br>print (row)</pre><p id="b370338fa779f887e3ad297a1f7c7f99" class="ne-p"><br></p><pre data-language="python" id="074c4f37" class="ne-codeblock language-python"># 建 company 表，并插入数据<br>cur.execute("DROP TABLE IF EXISTS company")<br>cur.execute("CREATE TABLE company(<br> id INT PRIMARY KEY NOT NULL, <br> name CHAR(50) NOT NULL, <br> age INT NOT NULL, <br> address CHAR(50) NOT NULL,<br> salary DOUBLE NOT NULL)")<br>companies = (<br>(1, 'Paul', 32, 'California', 20000.0),<br>(2, 'Allen', 25, 'Texas', 15000.0),<br>(3, 'Teddy', 23, 'Norway', 20000.0),<br>(4, 'Mark', 25, 'Rich-Mond', 65000.0),<br>(5, 'David', 27, 'Texas', 85000.0),<br>(6, 'Kim', 22, 'South-Hall', 45000.0),<br>(7, 'James', 24, 'Houston', 10000.0)<br>)<br>cur.executemany("INSERT INTO company VALUES (?, ?, ?, ?, ?)", companies)</pre><p id="d10582cdd4b393b27bdc85249652b979" class="ne-p"><br></p><pre data-language="plain" id="247240d5-1" class="ne-codeblock language-plain"><sqlite3.Cursor at 0x2d2d64f70a0></pre><p id="08388108de85d7f2aad79ca56896edaf" class="ne-p"><br></p><h3 id="041fd6a0"><span class="ne-text">INNER JOIN 内连接</span></h3><p id="55c4df77f06ee19d2d03ec193ddecdae" class="ne-p"><br></p><pre data-language="python" id="a7f88219" class="ne-codeblock language-python">cur.execute("SELECT emp_id, name, dept FROM company INNER JOIN department <br> ON company.id = department.emp_id;")<br>rows = cur.fetchall()<br>for row in rows:<br>print (row)</pre><p id="159c28575d995e87710d4c0987bd8ebf" class="ne-p"><br></p><pre data-language="plain" id="d381d69b" class="ne-codeblock language-plain">(1, 'Paul', 'IT Builing')<br>(2, 'Allen', 'Engineerin')<br>(7, 'James', 'Finance')</pre><p id="07b1dcc13e66053f6f9bd421abc034d5" class="ne-p"><br></p><h3 id="56d30f7a"><span class="ne-text">OUTER JOIN 外连接</span></h3><p id="6dcf2de73bab0a6ddc8d1395cb4ff6f4" class="ne-p"><br></p><pre data-language="python" id="be67cc6e" class="ne-codeblock language-python"># 左连接<br>cur.execute("SELECT emp_id, name, dept FROM company LEFT OUTER JOIN department <br> ON company.id = department.emp_id;")<br>rows = cur.fetchall()<br>for row in rows:<br>print (row)</pre><p id="344a0d86c63e00e9b8b821225910f37f" class="ne-p"><br></p><pre data-language="plain" id="e36c72c9" class="ne-codeblock language-plain">(1, 'Paul', 'IT Builing')<br>(2, 'Allen', 'Engineerin')<br>(None, 'Teddy', None)<br>(None, 'Mark', None)<br>(None, 'David', None)<br>(None, 'Kim', None)<br>(7, 'James', 'Finance')</pre><p id="bd281f97894372cf2f75e298e8352cec" class="ne-p"><br></p><pre data-language="python" id="1602ca22" class="ne-codeblock language-python"># 右连接 （目前不支持）<br>cur.execute("SELECT emp_id, name, dept FROM company RIGHT OUTER JOIN department <br> ON company.id = department.emp_id;")<br>rows = cur.fetchall()<br>for row in rows:<br>print (row)</pre><p id="1159245337aa7d8b5c8bb7282c6f3e33" class="ne-p"><br></p><pre data-language="plain" id="a2e5f734" class="ne-codeblock language-plain">---------------------------------------------------------------------------</p><p>OperationalError Traceback (most recent call last)</p><p><ipython-input-41-ce0fc573748b> in <module><br>1 # 右连接 （目前不支持）<br>2 cur.execute(“SELECT emp_id, name, dept FROM company RIGHT OUTER JOIN department <br>—-&gt; 3 ON company.id = department.emp_id;”)<br>4 rows = cur.fetchall()<br>5 for row in rows:</p><p>OperationalError: RIGHT and FULL OUTER JOINs are not currently supported</pre><p id="3fce303448a175e15da0e7b0659114fc" class="ne-p"><br></p><pre data-language="python" id="7b230f0d" class="ne-codeblock language-python"># 右连接，交换两张表<br>cur.execute("SELECT emp_id, name, dept FROM department LEFT OUTER JOIN company <br> ON company.id = department.emp_id;")<br>rows = cur.fetchall()<br>for row in rows:<br>print (row)</pre><p id="55d317470f2ba1437cddb7a4ac6d2c7b" class="ne-p"><br></p><pre data-language="plain" id="d381d69b-1" class="ne-codeblock language-plain">(1, 'Paul', 'IT Builing')<br>(2, 'Allen', 'Engineerin')<br>(7, 'James', 'Finance')</pre><p id="f4413322e07b15405faa6c5665502c28" class="ne-p"><br></p><pre data-language="python" id="71109b9c" class="ne-codeblock language-python">sqlite> SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT<br>ON COMPANY.ID = DEPARTMENT.EMP_ID;</pre><p id="255e497ca09a1374e370ccd6db61e5e7" class="ne-p"><br></p><pre data-language="plain" id="3edef9f3" class="ne-codeblock language-plain"> File "<ipython-input-43-a0833b733075>", line 1<br>sqlite> SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT<br>^<br>SyntaxError: invalid syntax</pre><p id="4de1a5b99162c916349425351210857c" class="ne-p"><br></p><h2 id="e0f028b0"><span class="ne-text">六、Excel 文件操作</span></h2><p id="d446132460121d9b70c2511f4eada161" class="ne-p"><br></p><p id="64c8dfa7fa2314d25ded610d9964640c" class="ne-p"><span class="ne-text">pandas.read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, verbose=False, parse_dates=False, date_parser=None, thousands=None, comment=None, skipfooter=0, convert_float=True, mangle_dupe_cols=True, **kwds)</span></p><p id="fa4f2975bd2ebe26f50a686e881357ad" class="ne-p"><br></p><p id="c11ff7f18ef55582a5c6a341a41cd2d7" class="ne-p"><span class="ne-text">df_fujian = pd.read_excel(“./datafiles/fujian.xlsx”,sheet_name=’日数据’)</span></p><p id="u48cdb6d9" class="ne-p"><span class="ne-text"></span></p><p id="ue4376dab" class="ne-p"><span class="ne-text"></span></p><h2 id="BPavn"><span class="ne-text">Jupyter Notebook 的安装</span></h2><p id="u5ad7d5d0" class="ne-p"><span class="ne-text"></span></p><p id="ue271b7ca" class="ne-p"><span class="ne-text">一般有两种方法，第一种是下载 Anaconda，自带 python 环境以及 Jupyter Notebook 环境，但这一般都是刚学机器学习那会的集成安装方式，</span><span class="ne-text" style="text-decoration: line-through">最主要的劝退原因是所占体积较大，所以这里介绍原生的安装方式，在纯 Python 环境下，使用自带的 pip 包管理工具下载，类似地像 Pandas、Numpy 等包也可以以此种方式安装</span><span class="ne-text">。</span></p><p id="u4d808c14" class="ne-p"><span class="ne-text"></span></p><p id="u97bce6d7" class="ne-p"><span class="ne-text">打脸 YYDS，收回上面画斜线的文字，因为自己以前的笔记里面，有许多其他库，一个一个安装太繁杂了，所以还是下载 Anaconda 集成环境吧。</span></p><p id="ud6a0f5ad" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1640601860364-c314af96-93ca-44c7-a1f3-f56281bc0358.jpeg" width="52" id="JxlHZ" class="ne-image"></p><p id="ue9991ea5" class="ne-p"><span class="ne-text">具体下载配置参考之前的文章：</span><a href="https://www.wztlink1013.com/blog/mv7tir/" data-href="https://www.wztlink1013.com/blog/mv7tir/" target="_blank" class="ne-link"><span class="ne-text">Pycharm,Anaconda,JetBrains 系列 app 相关总结 | 尼采般地抒情</span></a></p><p id="u64769e0e" class="ne-p"><span class="ne-text"></span></p><h3 id="f96oI"><span class="ne-text">安装 python</span></h3><p id="u10ed1ff2" class="ne-p"><span class="ne-text">地址：</span><a href="https://www.python.org/downloads/windows/" data-href="https://www.python.org/downloads/windows/" target="_blank" class="ne-link"><span class="ne-text">https://www.python.org/downloads/windows/</span></a></p><p id="udb709210" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640599312775-072daad3-4d63-44a3-9d12-f01c4bbf8e94.png" width="364" id="u9139fb50" class="ne-image"></p><p id="ucb9754ce" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640599331716-24f74d29-d0d3-48d3-8ac8-98677a0a7f02.png" width="659.5" id="u67f784d6" class="ne-image"></p><p id="u0e08ea89" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640599684114-22e00be7-1d4d-4429-89a3-749721cc6dc9.png" width="498.5" id="u77942fec" class="ne-image"></p><p id="u8017f8c2" class="ne-p"><span class="ne-text">安装完之后进入 cmd 查看</span></p><p id="u2fc63e69" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640599838509-509dc0d6-0ead-4d97-8c9a-c99b9ee2451d.png" width="720" id="ubc4fd658" class="ne-image"></p><h3 id="lfC1n"><span class="ne-text">安装 jupyter</span></h3><pre data-language="powershell" id="qlVOr" class="ne-codeblock language-powershell">pip install jupyter</pre><p id="ua6360957" class="ne-p"><span class="ne-text">安装成功之后，在项目文件夹下，打开 powershell 终端输入：jupyter notebook</span></p><p id="u718d4b67" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640601099229-bf7d396d-3c7c-4971-9552-459fccf9b37a.png" width="720" id="u525810b2" class="ne-image"></p><h2 id="i67WN"><span class="ne-text">报错</span></h2><h3 id="JXf6m"><span class="ne-text">ValueError: check_hostname requires server_hostname</span></h3><p id="u3d78a6d7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640600263157-e7be09d6-1de3-4a8e-8387-5711d8c0814b.png" width="947" id="ue7f0bb3a" class="ne-image"></p><p id="u8cdf7c88" class="ne-p"><span class="ne-text">关掉 tizi</span></p><h3 id="CESew"><span class="ne-text">ReadTimeoutError: HTTPSConnectionPool(host=’files.pythonhosted.org’, port=443): Read timed out.</span></h3><p id="uaa2d37ff" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640600450333-c5b616f4-6f9c-41d5-ac8b-ad6a3a0cd5ad.png" width="782.5" id="u99c9113d" class="ne-image"></p><p id="u1b9a7409" class="ne-p"><span class="ne-text">按照报错信息，更新 pip</span></p><p id="u2c890fd9" class="ne-p"><span class="ne-text"></span></p><h2 id="Mv5up"><span class="ne-text">数据分析</span></h2><p id="ucaad7850" class="ne-p"><span class="ne-text">本地数据的读取</span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程习惯</title>
      <link href="/blog/ml46ei/"/>
      <url>/blog/ml46ei/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="cRcAi"><span class="ne-text">一、代码</span></h2><h3 id="a3d10465"><span class="ne-text">命名规范</span></h3><p id="u3ea2d7ee" class="ne-p"><br></p><p id="u2d8c5609" class="ne-p"><br></p><ul class="ne-ul"><li id="fa8cc678541c1b68b79893e8eb257f3e"><span class="ne-text">项目：小写字母    </span><code class="ne-code"><span class="ne-text">datastructure</span></code></li><li id="990994f9df02a6a64e43decb24f663f4"><span class="ne-text">包：</span><code class="ne-code"><span class="ne-text">com.公司名.项目名.模块名....</span></code><span class="ne-text">（其中模块名可以按照功能/逻辑来分）</span></li><li id="5d238a78c50acd49a5715377e0e122f6"><span class="ne-text">类：全部首字母大写，一般驼峰式命名 </span><code class="ne-code"><span class="ne-text">public class TestBan&#123;&#125;</span></code></li><li id="c88eb1339b67bc45c63c9f7ca90df614"><span class="ne-text">常量：全部大写字母 </span><code class="ne-code"><span class="ne-text">String RE_PRI = ‘wztlink’</span></code></li><li id="5b3d7da274102fd501d449a341d2d0c6"><span class="ne-text">变量：下划线方式  </span><code class="ne-code"><span class="ne-text">int pri_const</span></code></li><li id="5db8d22fbea6ce8e0e35aa3fa0877f70"><span class="ne-text">方法：首字母小写，如果有多个单词，单词首字母大写 </span><code class="ne-code"><span class="ne-text">public void toString()&#123;&#125;</span></code></li></ul><h3 id="f37651eb"><span class="ne-text">注释规范</span></h3><div data-type="info" class="ne-alert"><p id="u3be7ed8e" class="ne-p"><span class="ne-text">文件注释</span></p></div><p id="eaa3d0eeab2ef36eb453110b5e709dcc" class="ne-p"><br></p><pre data-language="java" id="33698156" class="ne-codeblock language-java">  / *<pre><code>* 文件名：[文件名]* 作者：〈版权〉* 描述：〈描述〉* 修改人：Wu ZuTao* 修改时间：2020-06-06* 修改内容：新增X方法* 修改人：Wu ZuTao* 修改时间：2020-07-01* 修改内容：修改B模块* /&lt;/pre&gt;&lt;p id=&quot;uf4c216fb&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;div data-type=&quot;info&quot; class=&quot;ne-alert&quot;&gt;&lt;p id=&quot;cedfb0413a7c30691786a2cea4475732&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;类和接口的注释：该注释放在class定义之前，using或package关键字之后。&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;p id=&quot;d93dd9b8ab3fbd352b2f943b687da803&quot; class=&quot;ne-p&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;pre data-language=&quot;java&quot; id=&quot;8f60b021&quot; class=&quot;ne-codeblock language-java&quot;&gt;package com.wztlink.xxx;</code></pre><p>/**</p><ul><li>注释内容<br>_/<br>public class XxxManager</pre><p id="be1cafa2a3743e5a147fa5ac2e132638" class="ne-p"><br></p><pre data-language="java" id="4473200f" class="ne-codeblock language-java">/ _</li><li>〈一句话功能简述〉</li><li>〈功能详细描述〉</li><li>@author [作者]</li><li>@version [版本号, YYYY-MM-DD]</li><li>@see [相关类/方法]</li><li>@since [产品/模块版本]</li><li>@deprecated<br>_/</pre><p id="b24e8ba5eb73c3ae4150735f32490e52" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u98762170" class="ne-p"><span class="ne-text">函数注释</span></p></div><p id="ebfa6c1305f820b434a51bfbc59b9651" class="ne-p"><br></p><pre data-language="java" id="dca650d5" class="ne-codeblock language-java"> /**<br>_ 类方法的详细使用说明 *<br>_ @param 参数 1 参数 1 的使用说明<br>_ @return 返回结果的说明<br>_ @throws 异常类型.错误代码 注明从此类方法中抛出异常的说明<br>_/</pre><p id="f55eca77ab1c939509965c3362f36548" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u74773b75" class="ne-p"><span class="ne-text">方法内部、属性、必要语句</span></p></div><p id="b670d64f5b5600eccf71ddd6bf767261" class="ne-p"><br></p><pre data-language="java" id="a55e1a46" class="ne-codeblock language-java">// 注释内容<br>private String logType</pre><p id="00b5605c329d40945d3b1548aec0bf3a" class="ne-p"><br></p><div data-type="danger" class="ne-alert"><p id="u27dc6cac" class="ne-p"><span class="ne-text">注意事项</span></p></div><p id="b227d59673af19282388c323dcb4de3e" class="ne-p"><br></p><ul class="ne-ul"><li id="8777d6cbf19fcf281111c570ac743599"><span class="ne-text" style="text-decoration: underline">边写代码边注释，修改代码同时修改相应的注释</span><span class="ne-text">，以保证注释与代码的一致性。不再有用的注释要删除。</span></li><li id="df25634f9e421b0101e3c1c071a1c065"><span class="ne-text">避免在注释中使用缩写，特别是不常用缩写。说明：在使用缩写时或之前，应对缩写进行必要的说明。 注释应该放在被注释的代码前面，分行展示，但中间不留空行。</span></li><li id="8a2836894421a5b334f4a72d77791d95"><a href="https://blog.csdn.net/vbirdbest/article/details/80296136" data-href="https://blog.csdn.net/vbirdbest/article/details/80296136" target="_blank" class="ne-link"><span class="ne-text">javadoc 使用规范</span></a></li></ul><h3 id="paZMo"><span class="ne-text">函数</span></h3><p id="3411d0d350dc604884013815e38afd0d" class="ne-p"><span class="ne-text">主入口函数和其他功能函数分开，如果是功能性函数，全部放到一个 </span><code class="ne-code"><span class="ne-text">Tools</span></code><span class="ne-text"> </span><span class="ne-text">函数里面</span></p><h3 id="d0oWP"><span class="ne-text">类</span></h3><p id="dc2ae38a4f68d1af60cdd7719b30e234" class="ne-p"><span class="ne-text">不要在自己类下定义自己的对象</span></p><h2 id="e066f6cd"><span class="ne-text">二、项目</span></h2><h3 id="mYCBV"><span class="ne-text" style="color: #000000">解决写不出代码的方法</span></h3><div class="ne-quote"><p id="ud814f11e" class="ne-p"><span class="ne-text">参考：</span><a href="https://www.cnblogs.com/luchuangao/p/6821210.html" data-href="https://www.cnblogs.com/luchuangao/p/6821210.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/luchuangao/p/6821210.html</span></a></p></div><p id="ub4b1da34" class="ne-p"><br></p><div class="ne-quote"><p id="039b8286126aaef433a126c8c308aa43" class="ne-p"><span class="ne-text" style="color: #0000FF">1、先分析实现的思路</span></p></div><p id="d9acb171f6a66414f5ff5c6750c7bc3e" class="ne-p"><span class="ne-text">拿到作业，按照要实现的功能，先分析去实现的思路。</span></p><p id="14919e736d2de8727f653dfefdb0833e" class="ne-p"><span class="ne-text">如果完全不知道该怎么去实现，一头雾水，最好先看看其他人事如何实现的，或者与老师或同学讨论。</span></p><p id="1737d97e845755d3196a8e60f158acf8" class="ne-p"><span class="ne-text">重点是要找到解决问题的办法，理清实现的思路。</span></p><p id="ae3ba1d67f148b26fa9611ae4f04a4ab" class="ne-p"><span class="ne-text">如果自己能想出几步来，那就先把这几步记录下来，然后重复上面的步骤。</span></p><div class="ne-quote"><p id="2e85eb844117437486f9f7d020152340" class="ne-p"><span class="ne-text" style="color: #0000FF">2、把实现的思路边分析边记录下来。</span></p></div><p id="b5ba506f0ed014a0dc5ca77ef6c44acf" class="ne-p"><span class="ne-text">在分析实现思路的时候，边分析，边写出来，使用中文写，写得详细点。</span></p><p id="3e68e22ad17e7a82753c3bf09748afbe" class="ne-p"><span class="ne-text">如果在编程工具里面写的话，直接写成注释，比如：</span></p><p id="cb8e19258bf48fc6d157bd7a3d41cab0" class="ne-p"><span class="ne-text">第一步是要干上面</span></p><p id="73726efd0a16a2d72e618c4519128ac2" class="ne-p"><span class="ne-text">第 1.1 要做什么</span></p><p id="f6ebcbfe90ef4cae981788fd004c7bf4" class="ne-p"><span class="ne-text">第 1.2 要做什么</span></p><p id="c25700e4692d8e38b80250c9e8df46b3" class="ne-p"><span class="ne-text">第二步是要干上面</span></p><p id="722e0082cd53d9fc0ec1504a059d6d87" class="ne-p"><span class="ne-text">第 2.1 要做什么</span></p><p id="4f7b095c857315709d00f58a6e4974b3" class="ne-p"><span class="ne-text">第 2.2 要做什么</span></p><p id="8385e3def47a35d9377da9ca74a708fe" class="ne-p"><span class="ne-text">…以此类推</span></p><p id="2ac109e78daf5b02eedd49c9ada7435a" class="ne-p"><span class="ne-text">遇到写不下去的地方，先看看是没有思路还是前面的思路没有想清楚</span></p><p id="f6b096db0c73ddeb7a7e45ef6794bfe0" class="ne-p"><span class="ne-text">如果是没有思路了，参见第一条处理。</span></p><p id="804b5277914b7549f05d1e9663161c9f" class="ne-p"><span class="ne-text">如果是前面的思路没有想清楚，那就返回来重新思考，一定要考虑明白。</span></p><p id="00cf76c60c17d1982df8ad4792715cff" class="ne-p"><span class="ne-text">这其实也是这个方法一个额外的好处，那就是能强迫你思考，并进行细致考虑。</span></p><div class="ne-quote"><p id="266f0ef294444190e2f60e3e8b4117e0" class="ne-p"><span class="ne-text" style="color: #0000FF">3、写实现代码</span></p></div><p id="561df27fed88fcd4d6ef33b28a6ac814" class="ne-p"><span class="ne-text">如果思路整理清楚了，实现思路的步骤也整理好了，这个时候再写代码，</span></p><p id="e9e7691aec2f4a0c3b35e8df59386cd3" class="ne-p"><span class="ne-text">几乎就是个翻译的过程，很容易实现。</span></p><p id="624c26a8687e91b99ef56005aa2dac00" class="ne-p"><span class="ne-text">如果只是几步思路清楚了，也没有关系，想清楚多少，就写多少代码，慢慢来。</span></p><div class="ne-quote"><p id="a2063cb0df7a9ba4d8d87663358dd216" class="ne-p"><span class="ne-text" style="color: #0000FF">4、有思路但是写不出代码的解决方法</span></p></div><p id="2fe670b17dd2b1efaa7bf0877d45402a" class="ne-p"><span class="ne-text">这种情况常出现在初学者身上，主要是代码写少了。（</span><span class="ne-text" style="color: #FF0000">这种情况需每日练习两百到三百行代码</span><span class="ne-text">）</span></p><p id="60d625798d2779c8811e6bdffe0b61b7" class="ne-p"><span class="ne-text">建议多看看别人怎么写的，积累代码的写法，这一次不会写不要紧。</span></p><p id="ebd969334a697151fd12287f198e690b" class="ne-p"><span class="ne-text">见过一回，下次会写九可以了，积少成多，写得多了，自己能实现的也就多了。</span></p><div class="ne-quote"><p id="8c4cab6cda7439751fda3419d742fc74" class="ne-p"><span class="ne-text" style="color: #0000FF">5、方法不一定照搬，可以变通使用</span></p></div><p id="63bb310237a72a774f6ed95f6120f92a" class="ne-p"><span class="ne-text">比如边分析、边写思路然后就编写代码也是可以的，只要能有助你思考，都可以。</span></p><div class="ne-quote"><p id="1b3d70d33840bed04489207c6d30913a" class="ne-p"><span class="ne-text" style="color: #0000FF">6、写不出代码</span></p></div><p id="a23fd97540c95215338e861627577b37" class="ne-p"><span class="ne-text">大多数人在写不出代码的时候，都不是完全写不出来，也不是一点都写不出来，请尽量把会的、能写出来的先写出来，多按照本文介绍的方法去练习，量变到质变，很快就能自己写出实现代码来。</span></p><p id="uc19156f2" class="ne-p"><br></p><h3 id="8Gbog"><span class="ne-text">提高代码阅读能力</span></h3><p id="6d73ca8d411a5fcd7bb87775b6cb7191" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593438617-6e64c23d-0230-4104-b1b5-6ccd512ad999.png" width="508.5" id="R0FDZ" class="ne-image"></p><p id="e1a3dd811264c066d8b04de630ef8967" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593456351-275ca8e5-583b-499b-aca4-e4295b312c55.png" width="504" id="T4RUm" class="ne-image"></p><p id="bec0e7d4d7a3420eb2e8361bd192d706" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593476552-c6a6f01f-1d45-40e7-93b5-be56bc08e0c7.png" width="505" id="GkcIC" class="ne-image"></p><p id="96a0cf20c790b982de4bc284f5f9ba63" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593492992-c4a224fc-10e7-478e-9424-c90da2b4805a.png" width="498" id="IOPvY" class="ne-image"></p><p id="163abbe7afbcec86d2dd62f3c3024982" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593510079-399972ba-bee4-4dbc-81c9-ae619486f7da.png" width="498" id="NibYg" class="ne-image"></p><p id="57229a2c5a5d64e3c7c415ac9ea2cfc3" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593528314-e583f78d-6f87-46d1-826d-841629871530.png" width="506.5" id="rKWh8" class="ne-image"></p><p id="eb2d25ec84ca119bc8a07317e41b52f1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593547023-cbcc3eac-6350-4b92-856d-0cfd2a1ccf75.png" width="505.5" id="z7WrI" class="ne-image"></p><p id="44805dcc75484962ee5dac9752fc6db5" class="ne-p"><br></p><p id="9bf6738be659fb42d0c84b5f29f20889" class="ne-p"><br></p><p id="0148e6c74dd0f3bf64ad9a021219405b" class="ne-p"><br></p><p id="ab427e443d198d19d38dc400ed3bf103" class="ne-p"><br></p><p id="655894acfc8c083fe0b51e9bf8c20c36" class="ne-p"><br></p><p id="a975dd86ea240d66062e922f1b36a8a2" class="ne-p"><br></p><p id="0afe58cb877893cbeb19b19e7d8df9ec" class="ne-p"><br></p><p id="f83b7ac5ffc06f0e7ed980785a29ebeb" class="ne-p"><br></p><p id="6c63fcfd856169d0ff1652abd3d80504" class="ne-p"><br></p><p id="01f92f4dc440a41237e3b9e04b7d3e9e" class="ne-p"><br></p><p id="6b96f10752cee1322c85e39931c994b6" class="ne-p"><br></p><p id="af7801aae04291001008d90578276034" class="ne-p"><br></p></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>调试解决总结</title>
      <link href="/blog/mtigbx/"/>
      <url>/blog/mtigbx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="YGnJL"><span class="ne-text">一、关于bug</span></h2><p id="66012c2a502d808da244fa38db6df37e" class="ne-p"><br></p><p id="fa505e242c51dbbd7113b962fa3cd800" class="ne-p"><span class="ne-text">在编写程序过程中，总会出现各种各样的bug，按bug得类型来分的话</span></p><p id="266294a03ba9f15d4897ee3167f31ec7" class="ne-p"><br></p><ul class="ne-ul"><li id="9aef971c2ad20eb4a569c5d6d4269b46"><span class="ne-text">程序的逻辑出错</span></li><li id="1c1003e8459e3e99cc5c736d2466438d"><span class="ne-text">程序语法出错编译器不能通过</span></li></ul><p id="332cd143c0eae528f9d7e48c3aa132ab" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1656489641864-8b7034fc-63aa-437e-ad29-db2d35dcc3d1.png" width="533" id="u5afa8d31" class="ne-image"></p><p id="c4e09377af13ae0c178dd46ae487b7e7" class="ne-p"><span class="ne-text">对待bug，心态端正，不抵触不畏惧不怕麻烦，要想着解bug就是这个职业的要务之一，有耐心，积极主动的去解决问题。一步一步的解决问题，所有的技术都是熟能生巧、</span></p><p id="009777801ce9462eb82f040a37b8aa84" class="ne-p"><br></p><h2 id="a6d0ba1a"><span class="ne-text">二、解决bug的一些方法</span></h2><p id="7366d2c45257eee8b3b8bbc4b0acbb77" class="ne-p"><br></p><h3 id="ecf497ea"><span class="ne-text">报错信息+理论知识</span></h3><p id="f562d8f51d6075cf014dec24400e0881" class="ne-p"><br></p><p id="86a4e7e83965f1fd620c639ad954e29f" class="ne-p"><span class="ne-text">当一个bug摆在面前，首先要做的就是要认真阅读展现出来的出错信息，这里面有几点需要注意</span></p><p id="ad16d0a5ed7d9cfbd52a98c5d0b6e555" class="ne-p"><br></p><div class="ne-quote"><p id="4a6d27cbd70ef87f805fd7ffa4c46ef4" class="ne-p"><strong><span class="ne-text">提高英语</span></strong></p></div><p id="e7a0f770d6e48199a40e2094714fd359" class="ne-p"><br></p><p id="13c68afd375310ce86763282284ecd86" class="ne-p"><span class="ne-text">专业词汇的积累、阅读能力等</span></p><p id="34ffd890072182c6be946e8b451c392c" class="ne-p"><br></p><div class="ne-quote"><p id="67177d46e876d536b33cf7409ab50796" class="ne-p"><strong><span class="ne-text">运用底层知识</span></strong></p></div><p id="cdeb4af40a04b3dcfe35f1b2cd713d86" class="ne-p"><br></p><p id="9416d9d9983f9f6e4014e7f576397484" class="ne-p"><span class="ne-text">学会运行所学过的理论知识，比如在编程过程中，出现路径相关的错误，首先是根据报错可以直接在代码里面更改为正确可运行代码，然后可以利用所学过的操作系统相关文件管理知识等来进一步底层分析之，最后可以旁通自己之前搭建环境过程种总是要配的环境变量，一起思考一起分析，发散性思考，触类旁通所学知识，运用之</span></p><p id="b904e53d2c79a3b602cf9064c37bb55b" class="ne-p"><br></p><div class="ne-quote"><p id="a479ea612710ccc5bdc81bbfc0187551" class="ne-p"><strong><span class="ne-text">IDE的Debug或print通法</span></strong></p></div><p id="7d5ad34d676803133af4250e174facc1" class="ne-p"><br></p><p id="65c0cca9629fc6c64f266256ae32322d" class="ne-p"><span class="ne-text">熟悉各种开发环境的debug</span></p><p id="af280d3b5ce6497c8a248dcd8cc1077c" class="ne-p"><br></p><h3 id="a20a4b60"><span class="ne-text">搜索引擎</span></h3><p id="6afa697d2e4eaa8c15893ae4d1682603" class="ne-p"><br></p><div class="ne-quote"><p id="ba082da2289a4b72bd190a3743cc7512" class="ne-p"><strong><span class="ne-text">一个原则</span></strong><span class="ne-text">：“遇事不决，大事谷歌，小事百度”</span></p></div><p id="b49c72eb4fd1dbccb559fcef585497dc" class="ne-p"><br></p><ul class="ne-ul"><li id="79d6dd0734b32d986af88cc133da5a84"><span class="ne-text">谷歌需要一些手段才能进行，总结下来就是</span><strong><span class="ne-text">搭建一个机场</span></strong><span class="ne-text">，方便，安全</span></li><li id="d6669d3d3e2eaeabcdbc0dacc3449086"><span class="ne-text">百度解决一些小问题，抑或是 </span><strong><span class="ne-text">“烂大街的易错知识”</span></strong></li><li id="1e231efa10bddb8a2423aa6b4c6b81a6"><span class="ne-text">相关编程论坛，比如Stack Overflow、CSDN、博客园等（还是要用谷歌）</span></li></ul><p id="1510c456f165ca97209f13470b88b2f7" class="ne-p"><br></p><div class="ne-quote"><p id="02c4fca7045aab418a5b8c2b718e4a96" class="ne-p"><strong><span class="ne-text">结果择优原则</span></strong></p></div><p id="cbc56dc437f7698c57265413de3057e2" class="ne-p"><br></p><ul class="ne-ul"><li id="e14d6472fad102501aa6c90250dc75bb"><span class="ne-text">环境统一：解决办法的环境需要和自己的bug的环境需要一致</span></li><li id="e4a7e577981d84131542492f30be1619"><span class="ne-text">非毁灭性原则：尽量不要做全局性的修改，比如用命令删除git的两个文件来改一个小bug，属实挖坑</span></li></ul><p id="95914e3345a7eb87c42510d8ce45dafd" class="ne-p"><br></p><div class="ne-quote"><p id="4ba9289640c46f626de3ff39ea99fcea" class="ne-p"><strong><span class="ne-text">擅用官方文档</span></strong></p></div><p id="930b92cda3ce5e3f1848d09ce5f31f18" class="ne-p"><br></p><p id="b50d178afb3e66cbb5cd07c495355a40" class="ne-p"><span class="ne-text">如果说出现的bug抑或是，使用某个知识出错，是在官方文档中能查到的，优先选择官方文档</span></p><p id="b2d23b46b0365005e51ef5d88b394370" class="ne-p"><br></p><p id="0bd80d3a26e67ba403b59c13f1be1d96" class="ne-p"><span class="ne-text">就比如在使用python数据分析的时候，许多时候，很多包（pandas、numpy、matplotlib等）更新比较快，而网上找的一般都是旧版本的指导。同时</span></p><p id="5860cd5a82a4b5d706a5d33e1d8fcd2b" class="ne-p"><span class="ne-text">官方文档讲解更加全面，不过这过程中，要注意提高自身英语水平！</span></p><p id="1daa677d49b38d4e0d29bb999737cc7f" class="ne-p"><br></p><h3 id="6365e864"><span class="ne-text">复盘与重构</span></h3><p id="cf6f698490fb9316336fc0b1a8fd3dc3" class="ne-p"><br></p><div class="ne-quote"><p id="19868e23b5dc6d3464647aa95f97e033" class="ne-p"><strong><span class="ne-text">复盘</span></strong></p></div><p id="1753d0d84e708130f476336b1fc3881d" class="ne-p"><br></p><p id="d1ee00a6d47db55e918320e4fd0691ee" class="ne-p"><span class="ne-text">去复现一个学习（复现代码）过程，</span><strong><span class="ne-text">复盘</span></strong><span class="ne-text">bug之前的工作，来从中找出可能有哪些细节会导致出现该bug。</span></p><p id="e40953d6d34cb8f504a415ba0fabd448" class="ne-p"><br></p><div class="ne-quote"><p id="89e5b7817af0268d5f85c10478ac7713" class="ne-p"><strong><span class="ne-text">重构</span></strong></p></div><p id="ffd8496993a2404cc6782cd131146a01" class="ne-p"><br></p><p id="e2769b91984adad643f1152fcd2b54c6" class="ne-p"><span class="ne-text">按照思路重写代码！再不行重装系统！</span></p><p id="bceb9f1fd543e4be7be7eb1f0c9dfb3b" class="ne-p"><br></p><p id="b1253e144af63d731f62c5d6c086c549" class="ne-p"><span class="ne-text">重构，让你的代码更优美和简洁~</span></p><p id="e1e87312accd7bc185fa5169ac812f19" class="ne-p"><br></p><p id="305c83708f6f5e0cdb45ebdb81da298a" class="ne-p"><span class="ne-text">重装，让你的世界焕然一新~</span></p><p id="e2f873428831e076541f35642d316093" class="ne-p"><br></p><h2 id="3801f7d3"><span class="ne-text">三、多记录多总结多仔细</span></h2><p id="6d1a3dba1c256003d91a8df37c003cda" class="ne-p"><br></p><div class="ne-quote"><p id="4105fed0a371f0e3cdfdc129a62cfbfd" class="ne-p"><span class="ne-text">bug遇见的多了，也就由“形同陌路”转变为“日久生情”了!</span></p><p id="0030fcc5949d9154c97521a40448aa8a" class="ne-p"><span class="ne-text">良好的编程习惯加快解决速度</span></p></div><p id="f8a2c372038e57aafa01615ab8dbad00" class="ne-p"><br></p><p id="e021c052bebc531c7d2d377b78f2219f" class="ne-p"><span class="ne-text">做事情还是粗心，百分之九十的bug都来源于粗心，</span></p><p id="b324a1c2477d0cb81e5b7af58dc78a8b" class="ne-p"><br></p><h2 id="f7152be2"><span class="ne-text">四、持续补充</span></h2><p id="30115e5ac7c72c18fe104caaed532e49" class="ne-p"><br></p><ul class="ne-ul"><li id="4cddd454664947d5295828475ba35e37"><span class="ne-text">在利用搜索引擎找到解决办法时候，不要 </span><strong><span class="ne-text">吃着嘴里的，想着锅里的</span></strong><span class="ne-text"> ，找到一个办法，先将其解决办法看懂看透彻，不要这个方法还没看透彻就看下一个答案。</span></li><li id="a5688fd49be2d52fd5bfe7b77235e13f"><span class="ne-text">学会提取关键词来搜索，能提高很大效率</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫架构和Scrapy框架使用</title>
      <link href="/blog/zsvfxg/"/>
      <url>/blog/zsvfxg/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="06LW1"><span class="ne-text">一、爬虫基本架构</span></h2><h3 id="Lnbo2"><span class="ne-text">url管理模块</span></h3><ul class="ne-ul"><li id="19b318d6f7fd8f8ef5a4ed73dfa68f6b"><span class="ne-text">就是管理自己爬取的的网页不要重复爬取，避免爬取进入死循环</span></li><li id="04120bef43a32c763758ea51f2479fc4"><span class="ne-text">使用python当中的set数据结构</span></li></ul><h3 id="U9qGR"><span class="ne-text">网页下载模块</span></h3><div class="ne-quote"><p id="bc7a779a7eb5fde0eb46e87dd07fc4d4" class="ne-p"><span class="ne-text">将对应的url模块下载到本地或者读入内存</span></p></div><p id="cac49967d535765660d56c08516394ab" class="ne-p"><br></p><div class="ne-quote"><p id="4a9c20a474a0314b7b4bb94f6824ffc8" class="ne-p"><span class="ne-text">实现方式</span></p></div><ul class="ne-ul"><li id="8b4046fbcbd284db8abbe8ec32a4c45d"><span class="ne-text">通过url下载</span></li></ul><pre data-language="python" id="5103da8b" class="ne-codeblock language-python">from urllib.request import urlopen<p>test_url = “<a href="https://wztlink1013.github.io&quot;/">https://wztlink1013.github.io&quot;</a><br>response = urlopen(test_url)<br>print (response.getcode()) # 200 表示访问成功<br>print (response.read())</pre><ul class="ne-ul"><li id="95a3ec36da8492c0b7fea2718ecb7282"><span class="ne-text">通过 Request 访问</span></li><li id="b23b0ffd885f0c37b378ebbcbf78b787"><span class="ne-text">通过 cookie 访问</span></li></ul><p id="4e82d816665971fb64def6bc2af007c2" class="ne-p"><br></p><h3 id="iH9BG"><span class="ne-text">网页解析模块</span></h3><div class="ne-quote"><p id="72408694e243bad0945cc164ac6203ac" class="ne-p"><span class="ne-text">从已经下载的网页中爬取数据，实现方式有：</span></p></div><ol class="ne-ol"><li id="95c8e6c9119a4b33497ce91fde5ff74d"><span class="ne-text">正则表达式</span></li><li id="a9af89ac8976afb1f4c5801df855b4b4"><span class="ne-text">html.parser</span></li><li id="8f47ba6d9424236e51498ed25775c50d"><strong><span class="ne-text">BeautifulSoup：结构化解析网页</span></strong></li><li id="3149a17d706dbdbc44ea96f01c26b1e7"><span class="ne-text">lxml</span></li><li id="eaabbd078ae950f3de098414f5096137"><span class="ne-text">结构化解析</span></li><li id="b0916f7269d3364f802e0393c1bb2f17"><span class="ne-text">DOM（Document Object Model），树形结构，就是 html 的基本骨架</span></li></ol><p id="5a1eab7c490d7413d08453bfe3e09504" class="ne-p"><br></p><h2 id="ivaaO"><span class="ne-text">二、BeautifulSoup 解析网页</span></h2><h2 id="zd9oc"><span class="ne-text">三、Scrapy</span></h2><p id="b5047b1b914ad4550b4bfc75a04fe7fd" class="ne-p"><br></p><h3 id="f7040a32"><span class="ne-text">Scrapy 基础</span></h3><ul class="ne-ul"><li id="5b44ec9293778c8fae12fbedfcef93c7"><span class="ne-text">是一个爬虫框架，同时易扩展，可以添加新的模块达到自定义扩展</span></li><li id="2341b509da69658e22d737addf0873aa"><span class="ne-text">输出格式多样：json，csv，xml 等</span></li><li id="67cb41a49a7c88245dcee57590193045"><span class="ne-text">自动处理编码</span></li></ul><h3 id="e33875a5"><span class="ne-text">Scrapy 框架架构图</span></h3><p id="a23b92b4878be1105e06a8a244f3c9f3" class="ne-p"><br></p><p id="310421e7be95c076c8d9262d10a11d9a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/webp/1484158/1598673193957-7a7456b0-3de1-4c77-b849-cc2572555ed5.webp" width="416" id="K9ZSV" class="ne-image"></p><p id="871904825a7d4aa34f0fb0d809f19c46" class="ne-p"><br></p><div class="ne-quote"><p id="d5c4a911fc742c534f47046fadf1fc52" class="ne-p"><span class="ne-text">下载方法以及问题，在 anaconda 博客中</span></p></div><p id="78ee0bfdbb409439d11827606ee4b5bf" class="ne-p"><br></p><h2 id="4886ac04"><span class="ne-text">四、Scrapy 使用</span></h2><p id="8bd2517d845e52d7b068dbcbedd6c09c" class="ne-p"><br></p><h3 id="5dda7f34"><span class="ne-text">使用 SOP</span></h3><p id="cac70e819ecdfb307685840ea1df6aef" class="ne-p"><br></p><ul class="ne-ul"><li id="a7e587483a4f973721d7d61e06235f09"><span class="ne-text">创建工程</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ce7ef66ed1893a8502764221d10cb650"><span class="ne-text">键入</span><code class="ne-code"><span class="ne-text">cmd</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">cd</span></code><span class="ne-text">到需要下载的目录下</span></li><li id="89b9fb982da6633a2eec31a939d4fd39"><span class="ne-text">输入</span><code class="ne-code"><span class="ne-text">scrapy startproject tutorial</span></code><span class="ne-text">（最后是项目名字）</span></li><li id="d39840093ac58c2d8e16d82987c231d3"><strong><span class="ne-text">!此后所有有关命令的操作，均在下一级文件夹下，也有是有 cfg 文件后缀的文件夹下</span></strong></li></ul></ul><ul class="ne-ul"><li id="220af3c14c2e7fa391e1e48ec760dd62"><span class="ne-text">定义 Item，构造爬取的对象</span></li><li id="07179dbb9fe248016bda6814d5428f93"><span class="ne-text">编写 spider，爬虫主体</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="81c52aa0df49ac00c0a09a29e3d7813b"><code class="ne-code"><span class="ne-text">scrapy genspider amazon_spider https://……</span></code></li></ul></ul><ul class="ne-ul"><li id="5e122733b3ff5a1db7fee5a033659c55"><span class="ne-text">pipelines，默认 return item</span></li><li id="9bd2919e24d9fe624e06cbf4edfac4f6"><span class="ne-text">编写其他配置，其中 pipeline 用于处理爬取后所得到的结果</span></li><li id="020b11e833e52ff2003cac307a4cde09"><span class="ne-text">执行爬虫</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="140653cb451df1cf8fe965dca313f502"><code class="ne-code"><span class="ne-text">scrapy crawl amazon_spider</span></code></li></ul></ul><p id="bfa429401fe58953696b70f20a9f9d4e" class="ne-p"><br></p><h3 id="0dfbe902"><span class="ne-text">常用命令</span></h3><p id="c3c0738842ed3c37f6c5346281151043" class="ne-p"><br></p><h2 id="d17a0f0b"><span class="ne-text">参考</span></h2><p id="8af02097f08afc09430e0c63d28bce80" class="ne-p"><br></p><ul class="ne-ul"><li id="4e3ac598ec52649c64ff69b47941aa12"><span class="ne-text">查看其官方文档</span></li><li id="bac5e2f7c72a396ed88bd26637575e28"><a href="https://www.jianshu.com/p/8023fccd7206" data-href="https://www.jianshu.com/p/8023fccd7206" target="_blank" class="ne-link"><span class="ne-text">简书</span></a></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb学习笔记</title>
      <link href="/blog/tb3der/"/>
      <url>/blog/tb3der/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="2b970f1c70e7ae9cb2afb82805851484" class="ne-p"><span class="ne-text">大二下学期上课笔记</span></p></div><h1 id="Xur3R"><span class="ne-text">【第二章】JavaWeb概述</span></h1><h2 id="m8YWz"><span class="ne-text">一、XML</span></h2><p id="5e84886553b81a7eef0d1f572cf8b05c" class="ne-p"><br></p><p id="87019e12185ae093cec61bc4ebace559" class="ne-p"><code class="ne-code"><span class="ne-text">XML</span></code><span class="ne-text"> 是一种标记性语言，但是不同于 </span><code class="ne-code"><span class="ne-text">HTML</span></code><span class="ne-text"> ，目的其实就是用于传输数据，但是 </span><code class="ne-code"><span class="ne-text">HTML</span></code><span class="ne-text"> 的目的可以理解为展示</span></p><p id="1e17317244bf552bd7895485c9888795" class="ne-p"><br></p><div class="ne-quote"><p id="3ce07d60c8d777f97548e7641f2f15a3" class="ne-p"><span class="ne-text">网站建好之后，需要将自己的文章链接提交到百度/谷歌，通过部署生成的</span><code class="ne-code"><span class="ne-text">baidusitemap.xml</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">sitemap.xml</span></code><span class="ne-text">文件，sitemap提交方式提交以达到目的。</span></p></div><p id="20db2d468e5a07f5b805e35b176d64dd" class="ne-p"><br></p><h3 id="d5f7f7a8"><span class="ne-text">XML语法</span></h3><p id="c7568c8dfcb43e50e16854541317521c" class="ne-p"><br></p><p id="cd3563e451b0195a771cea207a59d82a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375381-0e3b13a8-6a22-47fb-8e8f-32c203fbf25d.png" width="461" id="LTz93" class="ne-image"></p><ul class="ne-ul"><li id="16e405cd46e8ce7b5ec04a78b69d74ea"><span class="ne-text">文档声明：图中最上面一行</span></li><li id="08af62f32648e7a1a20c00a6a80cf207"><span class="ne-text">元素定义：形式相当于 </span><code class="ne-code"><span class="ne-text">HTML</span></code><span class="ne-text"> 当中的标签，但不是标签，有根元素（一般只有一个），空元素等之分</span></li><li id="fd5b43a21022c0aac3738384aad6bcbc"><span class="ne-text">属性定义：其中值需要用双引号或者单引号括起来</span></li><li id="9b13df05c038161d71f89f266b913434"><span class="ne-text">注释：和 </span><code class="ne-code"><span class="ne-text">HTML</span></code><span class="ne-text"> 一样</span></li></ul><p id="68df66cfd5036c517446100a57724015" class="ne-p"><br></p><h3 id="19db8bdb"><span class="ne-text">DTD和Schema约束</span></h3><p id="8197464dbbc7634915a8829f4cdda8be" class="ne-p"><span class="ne-text">有些时候文档内可能内容语义有歧义，所以需要对其xml文件内容尽可能的加以约束，DTD和Schema两种方式</span></p><p id="197d6691e1c1c0057200a51c2c429d79" class="ne-p"><br></p><h2 id="b3e3926d"><span class="ne-text">二、HTTP协议</span></h2><div class="ne-quote"><p id="94ff31831f4f4069d3208899e8dee87d" class="ne-p"><span class="ne-text">生成的web项目和服务器之间的传输协议</span></p></div><p id="3281225c778b10bba1771b3dfa3c9371" class="ne-p"><br></p><p id="8c9fe41c2100e65508ae99e9e147c343" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375263-a1f1c0c1-0d94-4f9d-97ed-9d8e7e1d2495.png" width="305" id="z1db2" class="ne-image"></p><p id="a61cf3f91a1d24c407f42c2d197d9702" class="ne-p"><br></p><div class="ne-quote"><p id="3db1dc8507a46cd132cc86f0abd87703" class="ne-p"><span class="ne-text">其中http1.1版本比1.0版本优化的是对http请求可以同时进行多个请求和响应</span></p></div><p id="37b60c27b7e7d71c61fd580db6044d03" class="ne-p"><br></p><h3 id="74341368"><span class="ne-text">HTTP请求消息</span></h3><div class="ne-quote"><p id="45ff24ceedb95005a8da686d1bbe9eb3" class="ne-p"><span class="ne-text">客户端（web浏览器）向服务器发送请求，通常由请求行、请求头、实体内容三部分组成</span></p></div><ul class="ne-ul"><li id="f3cbc5748099a2e4336dc07e94d072af"><span class="ne-text">请求行：请求方式，资源路径，http协议版本三部分组成。请求方式又有GET（所请求内容会在资源路径后面带上参数值，会有大小限制）和POST（安全，无大小限制）等方式</span></li></ul><p id="091428cb3248c27150c8ebd09f11a1f3" class="ne-p"><br></p><h3 id="a0aa718a"><span class="ne-text">HTTP响应消息</span></h3><div class="ne-quote"><p id="bfdf7deb8b4e50c931e3709b8bbd00ff" class="ne-p"><span class="ne-text">也由三部分组成，有资源状态行、响应消息头、实体内容</span></p></div><ul class="ne-ul"><li id="8ebd3a6f81084526eb14de6cde865bc5"><span class="ne-text">资源状态行：协议版本 状态码 状态描述三部分组成。其中状态码有多种，常见的404就是服务器找不到相应请求的的资源</span></li></ul><p id="d3967797a81b179fa7781a95e5622f84" class="ne-p"><br></p><h2 id="c5519c96"><span class="ne-text">三、Tomcat</span></h2><p id="5b15d91aa7437eba9d7c3397ab87a61c" class="ne-p"><br></p><h3 id="0723454f"><span class="ne-text">关于Tomcat</span></h3><p id="a6f706e28806c009060db022b01b9419" class="ne-p"><br></p><p id="3c2ae53f11b96f047cba0dd475f452f6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375411-c8675707-4396-48f4-b181-07310231b868.png" width="588" id="EMayQ" class="ne-image"></p><p id="db5bd98307e62954c0cb413e4c62fc29" class="ne-p"><br></p><h3 id="d783fe4f"><span class="ne-text">下载安装Tomcat</span></h3><p id="0ddd08390a0a5cd87d29cac1a36bf7ba" class="ne-p"><br></p><p id="2415b4dc7e0f9e2088030f1a6a6ee784" class="ne-p"><span class="ne-text">安装等方式参考博客</span></p><p id="0edcf51bdf0ac9033c4f08dd95e05fe5" class="ne-p"><br></p><h2 id="0d9aaaf8"><span class="ne-text">四、Web应用</span></h2><p id="5648f5018a79419e4e2d5d2ac3ff715b" class="ne-p"><br></p><h3 id="59683fbc"><span class="ne-text">简述</span></h3><p id="6c55ed41e02954fe2baf54f38d12ed74" class="ne-p"><br></p><div class="ne-quote"><p id="7c20ac0048449fb1032b61b1f0374494" class="ne-p"><span class="ne-text">web应用，就是一项工程，在编写web项目过程中，对文件按照“合乎规矩”的方式放置</span></p></div><p id="1b9f04ff208e3e0946d3ec3b7d5c31a2" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375598-ac6ece9f-6982-4a1d-a7d8-bc3c8b4ce0f7.png" width="476" id="IGXbX" class="ne-image"></p><p id="9aa181859e93263c04679bda12e5ab71" class="ne-p"><br></p><h3 id="dbcbbdea"><span class="ne-text">IDEA配置Tomcat</span></h3><p id="371201dc696e928fb7d7e3122e1e0717" class="ne-p"><br></p><p id="84747b6fc087c0fb7354698bf8ce4bef" class="ne-p"><span class="ne-text">搭建web开发环境</span></p><p id="8740d411dc9f4ce20979aa053f2cec87" class="ne-p"><br></p><p id="e2c528b3f837b28f3ac50c3238b54bd2" class="ne-p"><span class="ne-text">资源的访问，点击请求的页面跳转设置</span><code class="ne-code"><span class="ne-text">web.xml</span></code><span class="ne-text">中配置</span></p><p id="13f6a15fa38ec72846cdfad5a4ab71d8" class="ne-p"><br></p><div class="ne-quote"><p id="78d2fc170a0d10a9aca6a2412372b008" class="ne-p"><span class="ne-text">阮一峰的网站当中，有类似域名自动跳转，是否和域名解析有关呢？抑或是对web.xml进行了操作？</span></p></div><p id="6d1417e24a21e014224de790df8d0821" class="ne-p"><br></p><p id="3bd68fe342fbd9d9cb2c4b23a31d838d" class="ne-p"><span class="ne-text">对idea进行web开发 配置</span><a href="https://blog.csdn.net/ZTlink1013/article/details/104815639" data-href="https://blog.csdn.net/ZTlink1013/article/details/104815639" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/ZTlink1013/article/details/104815639</span></a></p><p id="1d3e7592710e52f2d88a70d54337e96d" class="ne-p"><br></p><h1 id="uj23i"><span class="ne-text">【第三章】Servlet</span></h1><h2 id="14d15f0f"><span class="ne-text">一、什么是Servlet</span></h2><h3 id="7622ff83"><span class="ne-text">什么是Servlet</span></h3><p id="4ca993cfab70d1ca929c573608cfdfaa" class="ne-p"><br></p><div class="ne-quote"><p id="e44ffb20465c684f951739be67d58356" class="ne-p"><span class="ne-text">Servlet就是在服务器端的Java接口或者说是类（叫法有狭义广义之分），处理客户端传来的请求并作出相应的响应这么一个网络模块。</span></p></div><p id="e584920c84d31e1bf61b1cdecdae960b" class="ne-p"><br></p><ul class="ne-ul"><li id="035195c6da01f0f6f66063b45b17b0c1"><span class="ne-text">请求：客户端传来的调用或是一系列行为，同时也包含了请求所需要的数据。</span></li><li id="39441e88a5b0ee14537cfc03634f77f0"><span class="ne-text">响应：服务器根据客户端传来的请求做出响应，实时的展示给客户端。这之中Servlet相当于java类当中的一个接口，以请求来的信息作为输入，然后进行分析，做出相应。</span></li></ul><p id="a3dfdce98922ceac5fd71efab656f528" class="ne-p"><br></p><p id="5cc94f241502360f94687b9eb750ded4" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670486756-3febd732-e4ee-413d-8868-a406760f5a22.png" width="472" id="JfLtz" class="ne-image"></p><p id="0062bc072137e713e2a689d2b1062628" class="ne-p"><br></p><h3 id="addc9ffb"><span class="ne-text">JSP和Servlet</span></h3><p id="2370309c847ebb7e458ea52c031ad60a" class="ne-p"><br></p><div class="ne-quote"><p id="995cb19a44e6e6491ea03a430beb9a20" class="ne-p"><span class="ne-text">servlet是控制层，jsp转换为servlet，用servlet来实现http请求。</span></p></div><p id="72afe9eefd85f0b168041b7960c97c41" class="ne-p"><br></p><p id="b096d4029394aec37834fbd8cde0bd8f" class="ne-p"><span class="ne-text">【1】JSP第一次运行的时候会编译成Servlet，驻留在内存中以供调用。</span></p><p id="1329292d23903d585273c1b88155fcbf" class="ne-p"><br></p><p id="770b938eba49555a5a0df875449e354f" class="ne-p"><span class="ne-text">【2】JSP是web开发技术，Servlet是服务器端运用的小程序，我们访问一个JSP页面时，服务器会将这个JSP页面转变成Servlet小程序运行得到结果后，反馈给用户端的浏览器。</span></p><p id="3265744d1002d4e30faffc2b89523df8" class="ne-p"><br></p><p id="b7e83051b69116fc21dc07870e4d5304" class="ne-p"><span class="ne-text">【3】Servlet相当于一个控制层再去调用相应的JavaBean处理数据,最后把结果返回给JSP。</span></p><p id="5f48c438f54946f2793685f51867871a" class="ne-p"><br></p><p id="273fa4590b8dd743b69515326c144f9f" class="ne-p"><span class="ne-text">【4】Servlet主要用于转向，将请求转向到相应的JSP页面。</span></p><p id="539aa69c4de7b6d1348ff9f965f6c519" class="ne-p"><br></p><p id="0a48965ff8bd7cb77d15d3538f3798de" class="ne-p"><span class="ne-text">【5】JSP更多的是进行页面显示，Servlet更多的是处理业务，即JSP是页面，Servlet是实现JSP的方法。</span></p><p id="829319010beb33296e7b629e1a5f5dba" class="ne-p"><br></p><p id="ef4e24864a85e0531b0b0114ed8c0ebe" class="ne-p"><span class="ne-text">【6】Servlet可以实现JSP的所有功能，但由于美工使用Servlet做界面非常困难，后来开发了JSP。</span></p><p id="2d0533fd606099de85a8a04f81a806b8" class="ne-p"><br></p><p id="c329391185a142b8d30643c536900449" class="ne-p"><span class="ne-text">【7】JSP技术开发网站的两种模式：JSP + JavaBean；JSP + Servlet + JavaBean（一般在多层应用中, JSP主要用作表现层,而Servlet则用作控制层,因为在JSP中放太多的代码不利于维护，而把这留给Servlet来实现,而大量的重复代码写在JavaBean中）。</span></p><p id="25d797eb6d8c26c1d0d725a0a65157b4" class="ne-p"><br></p><p id="a22926944ab62d698d215b89a38466cc" class="ne-p"><span class="ne-text">【8】二者之间的差别就是，开发界面是JSP直接可以编写。</span></p><p id="1e55cd614bfa23955ae33e28391f0836" class="ne-p"><br></p><p id="8523ce87146420e2bf0b2f4356ecc6d1" class="ne-p"><span class="ne-text">比如在JSP中写Table标记：</span><code class="ne-code"><span class="ne-text"><table>[数据]</table>；</span></code></p><p id="42002731d37310dd0308181b4fcf29fc" class="ne-p"><br></p><p id="951b66153e368f2bbdd8686385b7cf93" class="ne-p"><span class="ne-text">Servlet需要加入：</span><code class="ne-code"><span class="ne-text">out.println(“<table>[数据]</table>”)。</span></code></p><p id="39ef7656f5215114069ca8661ea4af7b" class="ne-p"><br></p><p id="e32464f639a23894944c912adbebee1f" class="ne-p"><span class="ne-text">JSP文件在被应用服务器(例如：Tomcat、Resin、Weblogic和Websphere),调用过之后，就被编译成为了Servlet文件。也就是说在网页上显示的其实是Servlet文件。Tomcat下面JSP文件编译之后生成的Servlet文件被放在了work文件夹下，JSP中的HTML代码在Servlet都被out出来，而JSP代码按照标签的不同会放在不同的位置。</span></p><p id="341937232ceb9e694630e9c5e65e1df8" class="ne-p"><br></p><p id="60d3582486cfbd8ac886815f3c348094" class="ne-p"><span class="ne-text">【9】JSP中嵌入JAVA代码，而Servlet中嵌入HTML代码。</span></p><p id="0f27858d413f601b4074255311da2c48" class="ne-p"><br></p><p id="5cd54d9fc4911d03573bbccd120d854a" class="ne-p"><span class="ne-text">【10】在一个标准的MVC架构中，Servlet作为Controller接受用户请求并转发给相应的Action处理，JSP作为View主要用来产生动态页面，EJB作为Model实现你的业务代码。</span></p><p id="e34439b7e36421bde7a228d4994572b7" class="ne-p"><br></p><h2 id="385bb557"><span class="ne-text">二、Servlet基础</span></h2><p id="bf79bab2cdffa5e8c8afa2ba7c4a7004" class="ne-p"><br></p><h3 id="df2332cc"><span class="ne-text">接口及其实现类</span></h3><p id="4d2df39762a23d220a9e3729bcd4eaff" class="ne-p"><br></p><p id="9bf4aa0b0f49ce55c08fbeb8c323e778" class="ne-p"><span class="ne-text">就是利用其类编写相关服务器端的相关运行代码</span></p><h3 id="176808a1"><span class="ne-text">生命周期</span></h3><p id="8108b18a5761cdd51ab00c49ff668bb0" class="ne-p"><br></p><p id="9342457c10e8fc91c313fc5161a9a66c" class="ne-p"><span class="ne-text">分三个阶段：初始化阶段->运行阶段->销毁阶段</span></p><h3 id="c0f78462"><span class="ne-text">HttpServlet类</span></h3><p id="fc1ba4bb9174c7618797686205287944" class="ne-p"><br></p><p id="15f314a1b2d8924af38d35a4e6f37e46" class="ne-p"><span class="ne-text">一般客户端和服务器之间都回使用  </span><code class="ne-code"><span class="ne-text">HTTP协议</span></code><span class="ne-text"> ，所以Servlet接口中就提供了一个抽象类</span><code class="ne-code"><span class="ne-text">javax.servlet.http.HttpServlet</span></code><span class="ne-text">，他是 </span><code class="ne-code"><span class="ne-text">GernericServlet</span></code><span class="ne-text"> 的一个子类，专门用来处理 </span><code class="ne-code"><span class="ne-text">HTTP协议</span></code><span class="ne-text"> 的servlet；具体程序中就是用该类</span></p><p id="aa5fde625e15f041d7cde52889145fce" class="ne-p"><br></p><div class="ne-quote"><p id="688031ad3277e502d504cd506a8f0d0c" class="ne-p"><span class="ne-text">HelloWordServlet.java</span></p></div><p id="cc61905bb9c829e1575bf2f6ede64fe6" class="ne-p"><br></p><pre data-language="java" id="4a5ae0d7" class="ne-codeblock language-java">package cn.itcast.firstmyapp.servlet;<p>import java.io.IOException;<br>import java.io.PrintWriter;</p><p>import javax.servlet.ServletException;<br>import javax.servlet.http.HttpServlet;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;</p><p>public class HelloWordServlet extends HttpServlet {</p><pre><code> protected void doGet(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException &#123;     System.out.println(&quot;接受了客户端的请求-----------------------------&quot;);     // 设置响应类型:        resp.setContentType(&quot;text/html&quot;);        // 获取输出流:        PrintWriter pw = resp.getWriter();        // 写入响应:        pw.write(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;);        // 最后不要忘记flush强制输出:        pw.flush();    &#125;</code></pre><p>}</pre><p id="122cf52b455e179a330fa6311f6a4808" class="ne-p"><br></p><h2 id="70b547c4"><span class="ne-text">三、Servlet 虚拟路径的映射</span></h2><p id="80497193b4cc9d117f7a3128536cafbf" class="ne-p"><br></p><h3 id="c4080971"><span class="ne-text">1. 多重映射</span></h3><div class="ne-quote"><p id="e028cdb2b05f70a7c9bd1f1df3b9f816" class="ne-p"><span class="ne-text">就相当于多加几个自己指定的访问路径，在 web.xml 中</span></p></div><p id="9bab8a916b92d85f2351c3a796afa9b2" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670486704-cb7b6356-6317-47d3-85c4-a27582c41121.png" width="487" id="Cm4lh" class="ne-image"></p><p id="5cfd2224bc82de02690509f7d9b92c58" class="ne-p"><br></p><h3 id="45d851eb"><span class="ne-text">2. 映射路径下使用通配符</span></h3><div class="ne-quote"><p id="060dce3f29b0724464466cda95f832b8" class="ne-p"><span class="ne-text">在其中使用通配符，一个目录下的所有路径都可以访问，其中有完全目录匹配，目录匹配，扩展名匹配</span></p></div><p id="24615376a822ef7a6dbd8edcbb610c7f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670487060-fa223535-eabd-40c6-bf7e-088fc77c9c87.png" width="493" id="FGBmm" class="ne-image"></p><p id="e958641f6e459c63556ee8e4a0df54dd" class="ne-p"><br></p><h3 id="ede484bd"><span class="ne-text">3. 缺省</span></h3><p id="b0dab1f4c964e62c342221f7290dd6b6" class="ne-p"><span class="ne-text">通常作用是解决请求的资源找不到的情况，（404：请求的资源找不到）</span></p><h2 id="b92a7e97"><span class="ne-text">四、 </span><code class="ne-code"><span class="ne-text">ServletConfig</span></code><span class="ne-text">  和 </span><code class="ne-code"><span class="ne-text">ServletContext</span></code><span class="ne-text"> </span></h2><p id="5c0aea729f0ca0321c760bba193de32a" class="ne-p"><br></p><div class="ne-quote"><p id="a99709c69da2cb9f9b629bd3a382db50" class="ne-p"><span class="ne-text">ServletConfig 接口</span></p></div><p id="49fddfeec3d71ab2638f850302ac8609" class="ne-p"><br></p><p id="91ad288b3419f5c494acbb674e5cb567" class="ne-p"><span class="ne-text">类比于 git 根文件夹</span><code class="ne-code"><span class="ne-text">.ssh</span></code><span class="ne-text">下的 config 配置文件，它是 servlet 的配置对象，目的就是获取与 servlet 的初始化参数</span></p><p id="e307cabaf73b9951b3959b0e6bcc47ff" class="ne-p"><br></p><div class="ne-quote"><p id="bae134fd8f1a5de586729009cec51f0a" class="ne-p"><span class="ne-text">PS:会使用常用的接口方法</span></p></div><p id="01fdcf311b982c94b85df61fd47b776f" class="ne-p"><br></p><h1 id="R7SLd"><span class="ne-text">【第五章】会话技术</span></h1><h2 id="f2639692"><span class="ne-text">一、会话技术</span></h2><p id="f627049b25649804436485bc72718777" class="ne-p"><span class="ne-text">相当于在客户端和服务器端之间，记录一些用户信息，但是不能用上一章节的，因为那只能保存暂时的信息。 </span><code class="ne-code"><span class="ne-text">servlet</span></code><span class="ne-text">  还提供两个对象 </span><code class="ne-code"><span class="ne-text">Cookie</span></code><span class="ne-text">  和 </span><code class="ne-code"><span class="ne-text">Session</span></code><span class="ne-text">  可以更好地更好地保存会话数据。</span></p><p id="4982765dc0ab314bd287087cd767d0f2" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670565525-6a2b8b74-4105-447a-95ba-034020c747fe.png" width="601" id="H7o94" class="ne-image"></p><h1 id="VKJIv"><span class="ne-text">【第六章】JSP 技术</span></h1><h2 id="9b6445d6"><span class="ne-text">一、JSP 概述</span></h2><p id="b6c0fbde6367aba5f757e0d2caad016a" class="ne-p"><br></p><p id="4c6e7105ebeef5c38bf2d77a62980d41" class="ne-p"><span class="ne-text">一种新的编写动态网页的技术，虽然本质还是调用了 </span><code class="ne-code"><span class="ne-text">servlet</span></code><span class="ne-text"> ，但是相比前者要简单很多（前者向页面写数据麻烦，复杂），其组成可以简单理解为</span></p><p id="89c4399dd7008be7cb78d347d67e1597" class="ne-p" style="text-align: center"><code class="ne-code"><span class="ne-text">jsp = html + java + jsp 自身</span></code></p><p id="deb48ea61d2f78170b1cc6f373d508a8" class="ne-p"><br></p><p id="eb445ab23fd0b84079171d328acaa6f5" class="ne-p"><span class="ne-text">调用 servlet 过程：</span></p><p id="85daca56eb0834af22ce5c09cfa66052" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585374-60fc5166-cb3c-433e-9794-bae3778a3cd8.png" width="477" id="qSgI4" class="ne-image"></p><p id="bf306f11855b719f8b71ce7cc3cd9c47" class="ne-p"><br></p><p id="fcb9b49259f7ec59cb6619b90ed76598" class="ne-p"><span class="ne-text">其中 jsp 生成 java 文件，编译成 class 文件所在目录（本来应该在 tomcat 的 work 路径下）：</span><code class="ne-code"><span class="ne-text">D:\project-java.metadata.plugins\org.eclipse.wst.server.core\tmp0\work\Catalina\localhost\demo-jsp\org\apache\jsp</span></code></p><p id="592ed3cc203703d685648811c3211c13" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585365-5f311403-0761-4643-aa17-931be713fc49.png" width="468" id="aROEK" class="ne-image"></p><p id="000aac780005a40cc7fd3f7c2d8cff5e" class="ne-p"><br></p><p id="f1503215e7aa439707d3486d83fdfb27" class="ne-p"><span class="ne-text">打开 java 文件之后可以看到相关对 sevlet 的继承</span></p><p id="a79e7d44d3d267e0d474a5c1fa7cd5c7" class="ne-p"><br></p><h2 id="ef846b89"><span class="ne-text">二、JSP 语法</span></h2><p id="1fca6f970b00308ea34c0ff1a0b46f21" class="ne-p"><br></p><h3 id="07494b95"><span class="ne-text">jsp 脚本元素</span></h3><p id="d2aba671e14792eaa136e398a314c579" class="ne-p"><br></p><p id="b5e0a6f27c50538fa0fc63f3b801fd2e" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585361-957371bf-bb37-407a-90e8-8f21175d6589.png" width="639" id="zr7hH" class="ne-image"></p><p id="30655c8d1daccf7a0e2823a2f37c8cbd" class="ne-p"><br></p><h3 id="dda4e70c"><span class="ne-text">jsp 注释</span></h3><p id="ee5f003e4d31cfd49a7901849eeb0574" class="ne-p"><br></p><p id="7bc75b81a6886506300b9f25d0254f93" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585756-18f96e5c-8a74-4e14-8c16-55a9fd9124df.png" width="643" id="LgNrf" class="ne-image"></p><p id="29353c991a467a489c3a993b29b08d0b" class="ne-p"><br></p><h3 id="3b8d7fcb"><span class="ne-text">jsp 指令</span></h3><p id="ee9a63c7e55005a5c0fcde1d0b9a519f" class="ne-p"><br></p><div class="ne-quote"><p id="50381928c1f1b3d4852fbf83d804cda0" class="ne-p"><span class="ne-text">page 指令</span></p></div><p id="e5d1c5f206ad21a65404806eb522368a" class="ne-p"><br></p><p id="715fe5635a3bd16e0759221b8ff53cfa" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585347-a182a404-b425-4f70-80d6-712122944623.png" width="658" id="eHsBW" class="ne-image"></p><p id="91d121e789cf317c390951b64f3719ed" class="ne-p"><br></p><div class="ne-quote"><p id="156c9dbab7103c0c1ad925d211e4e91d" class="ne-p"><span class="ne-text">include 指令</span></p></div><p id="3dd38011978f4acd9ce01d334c00bbc0" class="ne-p"><br></p><p id="879c06158de859cbe822a8b7cf1bf8e0" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585378-bbe2df4b-013e-4531-bece-2836e4b8bde0.png" width="677" id="NUHzD" class="ne-image"></p><p id="409ab4ad15244fc01ed82875fbf551f4" class="ne-p"><br></p><div class="ne-quote"><p id="62b682ac970ff8a9a96342f26b40f4b6" class="ne-p"><span class="ne-text">taglib 指令</span></p></div><p id="e5beab2c35cf46c0b6dcf9c48e528a89" class="ne-p"><br></p><h3 id="9a456749"><span class="ne-text">jsp 隐式对象</span></h3><p id="14066e20afd8fba3ed7614c78417fbae" class="ne-p"><br></p><p id="bf315810b5412253befa6b1753d1db15" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585348-c41424d0-e688-4ae6-809e-bcc33afec5e3.png" width="650" id="Z5fkm" class="ne-image"></p><h1 id="NeXMB"><span class="ne-text">【第九章】JDBC</span></h1><h2 id="8057578e"><span class="ne-text">一、什么是 JDBC</span></h2><div class="ne-quote"><p id="dc80a2701370d38bead2f7754c1a76b2" class="ne-p"><span class="ne-text">使用数据库来存储和管理数据</span></p></div><p id="847dbeaf0bc15967966bd0745be53d83" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606448-7b5d3ec0-c6eb-4485-af84-34a1d99fa4a1.png" width="503" id="E6aOX" class="ne-image"></p><p id="3c16f97a1f3dbbdebbe56345dd6f1088" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606324-93a22794-21bb-42fc-9355-64c55411ea53.png" width="487" id="CgXyx" class="ne-image"></p><p id="eb4a0ddd3db11c7d1fe6f43c861af428" class="ne-p"><br></p><h2 id="2e55d434"><span class="ne-text">二、JDBC 常用的 API</span></h2><p id="5edd8befc57cb6088c44e12f2169e0fa" class="ne-p"><br></p><div class="ne-quote"><p id="983cf931227815c13d97334140fccea5" class="ne-p"><span class="ne-text">五个接口一个类（唯一的类）</span></p></div><p id="bce68f29648efb24109a8cc8c5fce5fd" class="ne-p"><br></p><p id="4c017b3ffd8e2deb10db5bee8c0317e6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606334-40b58ccd-ef50-4048-a17a-819885cdcf87.png" width="649" id="lBHLh" class="ne-image"></p><p id="45ea7400ed613e7b5605471640b4864f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606546-72057847-1b52-4b82-8f03-d2dcff6e0ed4.png" width="635" id="a5KOy" class="ne-image"></p><p id="3a50e0d5bc7fb565577dfd49081d8178" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606535-2996029c-eaf0-45ee-a778-614141ceea4f.png" width="624" id="G6Aec" class="ne-image"></p><h1 id="TMDnF"><span class="ne-text">【第十一章】JSP 开发模型</span></h1><h2 id="24cc9c02"><span class="ne-text">一、JSP 两种开发模式</span></h2><p id="34a30d85beb388e63cdc4957641359eb" class="ne-p"><br></p><p id="d03d20cc9754cc30f943e4b2434948d8" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623021-1406c5eb-f010-4d9f-a6fe-cd104b964450.png" width="998" id="XbJTY" class="ne-image"></p><p id="0c431fe2df3c3f5132ec2b77934b4e7e" class="ne-p"><br></p><h3 id="5eb83889"><span class="ne-text">JSP Model1</span></h3><p id="91596b7fa328fd70b5bfac2c7e200abc" class="ne-p"><br></p><p id="af18ff6cc3feaa48009d7afcdc1d8893" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623035-3dae1126-3986-4893-afbf-ce3aa250deb1.png" width="1220" id="bTCTH" class="ne-image"></p><p id="118b3e33dcbdc6817c9cffba0f20c847" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623082-df4cb3b4-1eb4-4590-a68f-f18a31a31816.png" width="579" id="Is4c9" class="ne-image"></p><p id="51a732c657cbb4e09df4917d08456cd2" class="ne-p"><br></p><h3 id="83d5f971"><span class="ne-text">JSP Model2</span></h3><p id="15d2cb3612bdfb77531d34a8eab48187" class="ne-p"><br></p><p id="00f94c86dcc4193c8363be62f04e9a17" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623814-f1853ddf-0ab6-443c-b90f-97147896aa3c.png" width="1045" id="gPlqN" class="ne-image"></p><p id="5c6872af10aef200bd56538482aa9222" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623035-37842a30-2e67-40d6-9b33-fc7a90a89037.png" width="523" id="oq4zV" class="ne-image"></p><p id="4d2f3eccfe01e591b4a56d2ad3bbc736" class="ne-p"><br></p><h2 id="38973f0b"><span class="ne-text">二、MVC 设计模式</span></h2><p id="77497a9c4544bdb015fcf83eba122627" class="ne-p"><br></p><p id="e1c57d0ca139882b97b1945cb783a30e" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623024-0fbab2bd-139b-4e8e-806a-a010e86e6159.png" width="1185" id="AxOXe" class="ne-image"></p><p id="10df61d0a5558d052561e4e95eafaf97" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623036-c1e95730-c04c-44ab-a07d-be7d3ce47970.png" width="1138" id="fmGY7" class="ne-image"></p><p id="8bd4e192cd192c93660d24f3ad7b265b" class="ne-p"><br></p><h2 id="5ddf16b2"><span class="ne-text">三、JavaWeb 开发中的三层架构</span></h2><p id="5beb94f4cb45c681c2a8fe5d4ff1014d" class="ne-p"><br></p><p id="213b1f60bd782d6fe061791ad1b0ce4e" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623143-02074466-5715-4efa-8b09-ee2a1489d94e.png" width="1077" id="oVGry" class="ne-image"></p><p id="33df85f41fa44d78b0f3c3436f547913" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623075-f2b2b6ce-ebd7-4712-86f3-61ee087aafbb.png" width="525" id="cVavj" class="ne-image"></p><p id="ae9f37c93cbd0dbca6d65d7f01e766cf" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670622943-c73fc987-bbd4-4204-9a82-6a93ea4ac8ed.png" width="1066" id="XvkOG" class="ne-image"></p><p id="c7f671c4af7e797c1b81a98182f3ef02" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web其他知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《龙猫·剪辑》数字媒体后期制作大作业</title>
      <link href="/blog/bkthv9/"/>
      <url>/blog/bkthv9/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="wPlqV"><span class="ne-text">后期制作大作业B站地址</span></h2><div class="ne-quote"><p id="u52689734" class="ne-p"><strong><span class="ne-text">菜的一逼</span></strong><span class="ne-text">……</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623289703745-08c74433-8721-408d-9970-e9ea9c43f794.jpeg" width="51" id="cWhW9" class="ne-image"></p><p id="u42e8f4c6" class="ne-p"><span class="ne-text">地址：</span><a href="https://www.bilibili.com/video/BV1UA41187G1" data-href="https://www.bilibili.com/video/BV1UA41187G1" target="_blank" class="ne-link"><span class="ne-text">https://www.bilibili.com/video/BV1UA41187G1</span></a></p></div><p id="u13ac9400" class="ne-p"><br></p><p id="u4efaf34c" class="ne-p"><span class="ne-text"><iframe src="//player.bilibili.com/player.html?aid=327528419&bvid=BV1UA41187G1&cid=173889112&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></span></p><p id="u69523c0c" class="ne-p"><br></p><div id="CaH40" class="ne-thirdparty"><a href="https://player.bilibili.com/player.html?bvid=BV1UA41187G1">https://player.bilibili.com/player.html?bvid=BV1UA41187G1</a></div><h2 id="eeae05d5"><span class="ne-text">PS上课笔记</span></h2><p id="uc080d464" class="ne-p"><br></p><div class="ne-quote"><p id="30081be3385f6edecd64ca0a71c9767f" class="ne-p"><span class="ne-text">认识PS===有许多功能eg：绘画等等</span></p><p id="54fc72d4f407bbda828b38f9019ab834" class="ne-p"><span class="ne-text">准备工作===了解菜单栏；工具栏；基本功能</span></p></div><h3 id="27a623eb"><span class="ne-text">图层面板的认识</span></h3><p id="04922f7563bb990494bb2e6a1a7045b9" class="ne-p"><span class="ne-text">图层顺序 上一层遮挡下一层 蒙版也是图层</span></p><p id="61b5eda02cc0c357e03efda5bb3286c8" class="ne-p"><span class="ne-text">混合模式 就是这层图层与下一层混合叠加的效果</span></p><p id="722fb9208f580e63c1ed4d6271ed9c9e" class="ne-p"><span class="ne-text">@@滤色 就是消去黑色深色只显示白色亮色的部分 案例光晕 用黑背景绘画光晕的图案选择滤色混合样式</span></p><p id="48782638336a851a6f92c9c923c7a6a1" class="ne-p"><span class="ne-text">图层样式</span></p><p id="e2c4e450834e60d8fb47ae43cf846d4e" class="ne-p"><span class="ne-text">不透明</span></p><p id="137491523d3e4db9c99c832e0e25d0ed" class="ne-p"><span class="ne-text">创建 删除 解锁</span></p><h3 id="XFvPc"><span class="ne-text">图片的裁切</span></h3><p id="a5c9a23f2ac2484d6caa3ef9cbe2f0f6" class="ne-p"><span class="ne-text">选框工具不行===无法确定像素 不能缩放要显示的区域</span></p><p id="7f00c31031eb5bbf3b5b5bf79de043c6" class="ne-p"><span class="ne-text">裁剪工具不行===能确定像素 但不能缩放要显示的区域只是同时裁剪图片和画布</span></p><p id="8bea3c7d232aff7edde83b9d462dbf9d" class="ne-p"><span class="ne-text">图像===大小不行--只是压缩图片和画布而已  </span></p><p id="952543e48a5c90fea78ef4ab69f5a3ac" class="ne-p"><span class="ne-text">画布大小（前提是图层不是背景层没有被锁定）</span></p><p id="9cc1a4ccea4a8b73c0a9ee531c9e0824" class="ne-p"><span class="ne-text">调整画布的大小+自由变换工具缩放+移动工具</span></p><p id="fbfec50c7081d2033d158545758a3bba" class="ne-p"><span class="ne-text">我们想要的大小 调整图像等比例缩放 移动到我们要显示的区域</span></p><h3 id="cxNDl"><span class="ne-text">蒙版作用</span></h3><p id="aa0acaa2b6b56854fb301eb743c9674d" class="ne-p"><span class="ne-text">蒙版只有白和黑 只是在通道建立一个白色的蒙版图层（默认全部显示；有选区时，选区是白色的非选区是黑色的）</span></p><p id="cc442de56ff664fad005182b9f7a0e77" class="ne-p"><span class="ne-text">黑透明，白不透明</span></p><p id="0d82d1e9b6b2e3204d8d3383d4228873" class="ne-p"><span class="ne-text">画笔涂抹 透明度 流量</span></p><p id="6781bf382355e426a107482644c983b2" class="ne-p"><span class="ne-text">一般用来合成图片</span></p><p id="5818c579c3c0ed420ff75d4e4db04556" class="ne-p"><span class="ne-text">对图像擦除的效果 但不影响原始图像的像素 便于后期修改</span></p><p id="f2a483d0450134d5e85eae99b7e17a45" class="ne-p"><span class="ne-text">如果用橡皮擦会破坏原始素材</span></p><h3 id="TmF3a"><span class="ne-text">正确校色</span></h3><p id="675be739138f9db9db03fa84860e0164" class="ne-p"><span class="ne-text">图像-调整===对图像校色是不可逆的 不适合后期修改</span></p><p id="7741d11ed86785280b77ebc217daf24c" class="ne-p"><span class="ne-text">创建新的填充和调整图层的按钮 添加带蒙版的调整图层</span></p><p id="48ea8ea83db7ca47140c0c94f7b3364b" class="ne-p"><span class="ne-text">带蒙版的调整图层 是可逆的</span></p><p id="5f40bda493d016310fa66a7a84653b01" class="ne-p"><span class="ne-text">如果想只对**一个图层作用 右击图层-创建剪切蒙版  </span></p><h3 id="GPQrw"><span class="ne-text">钢笔工具  </span></h3><p id="ea8c4f7f7f6bae8b8d90a1747ef21e41" class="ne-p"><span class="ne-text">点击-点击===是直线</span></p><p id="8280889ca10d065613f9d9eaaf35107d" class="ne-p"><span class="ne-text">点击-点击不要松开手===拖动 就是曲线勒</span></p><p id="1dc5944700fb0426946155b87a0194d4" class="ne-p"><span class="ne-text">alt+ 点击瞄点拖拉会产生操纵杆===并且把直线变成曲线</span></p><p id="900d4f5d84565dcf3f282e1710713570" class="ne-p"><span class="ne-text">点击单个操纵杆会单独操纵一边的  </span></p><p id="867833e877112492030593f14318260c" class="ne-p"><span class="ne-text">crtl+ 移动瞄点</span></p><p id="a87ed0a4a538dc84e5e1bcaf381f8ec8" class="ne-p"><span class="ne-text">属性栏【自动添加/删除】打勾时 点击线能添加点 点击点不拖动能删除点</span></p><p id="099e1f4686586252d14a8081275226ea" class="ne-p"><span class="ne-text">描绘到一半的没闭合的图层 要闭合的话就要先ctrl点击最后一点 在点击初始点</span></p><p id="41a275274d0018af34c59a253f239d12" class="ne-p"><span class="ne-text">抠出的区域转为选区 选中图层 点击路径面板-将路径转为选区</span></p><p id="ee60c0c3991f81e6cae2eaadf9ff559b" class="ne-p"><span class="ne-text">这时候的选区可以 建立蒙版把他抠出来单独单独显示 这种抠图是可逆的</span></p><h3 id="rmfan"><span class="ne-text">修片时用到的工具</span></h3><p id="018f10dcd3c4a75a31c31e024430c8cc" class="ne-p"><span class="ne-text">红眼 ===记得是整个眼睛</span></p><p id="f91fae00ffb97af43f149b0984d77355" class="ne-p"><span class="ne-text">污点 ===可以吧污点附近的像素自动修改污点 但是对麻子脸没用</span></p><p id="70e93fea53e300ba61d7cb420fe010f2" class="ne-p"><span class="ne-text">修复画笔 ===把目标的像素填充涂抹的地方 并且能自动融合边缘</span></p><p id="7c522a7d6194079b70909c7e5e8e4777" class="ne-p"><span class="ne-text">修补工具 ===框选一个目标选区 填充涂抹的地方 并且能自动融合边缘</span></p><p id="1b0759a881cb7726edf93f45a4dcffa8" class="ne-p"><br></p><h2 id="6hhqQ"></h2></div>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 后期制作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git安装配置及常用命令总结</title>
      <link href="/blog/fnsge3/"/>
      <url>/blog/fnsge3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="3c159820"><span class="ne-text">一、Git安装和本地用户全局配置</span></h2><h3 id="CAAPD"><span class="ne-text">【1】Git的下载与安装</span></h3><ul class="ne-ul"><li id="2b9fe73bdb3c348c97b1499b05e85e28"><span class="ne-text">进官网下载 </span><a href="https://git-scm.com/download/win" data-href="https://git-scm.com/download/win" target="_blank" class="ne-link"><span class="ne-text">https://git-scm.com/download/win</span></a><span class="ne-text"> 并且安装</span></li><li id="8401e923b718de70f34c519fdacd61cc"><span class="ne-text">查看是否安装成功</span><code class="ne-code"><span class="ne-text">win + R</span></code><span class="ne-text">进入CMD输入git，出现git命令指南，则安装成功</span></li></ul><p id="cda637f43d8ed594201e12079b58def6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624934078835-17bc30b2-2f33-49b2-9d41-5d38ae309d5b.png" width="720" id="acr1I" class="ne-image"></p><p id="6e7f45d287a346806e54cd141f52e354" class="ne-p"><br></p><h3 id="O1HBu"><span class="ne-text">【2】全局配置本地用户</span></h3><p id="u7a93fba1" class="ne-p"><span class="ne-text">在git Bash中进行下面配置，下面的账号名字和邮箱都是github的账号所使用的</span></p><p id="f306853e0c0325fc6d3aed788fdbfa5f" class="ne-p"><br></p><pre data-language="bash" id="b190c7a0" class="ne-codeblock language-bash">git config --global user.name "wztlink1013"<p>git config –global user.email “<a href="mailto:&#x77;&#122;&#x74;&#108;&#105;&#110;&#107;&#x31;&#x30;&#49;&#51;&#x40;&#49;&#54;&#51;&#x2e;&#99;&#111;&#x6d;">&#x77;&#122;&#x74;&#108;&#105;&#110;&#107;&#x31;&#x30;&#49;&#51;&#x40;&#49;&#54;&#51;&#x2e;&#99;&#111;&#x6d;</a>“</pre><p id="ecb8ff6fa82eb81c329ce7938e3c1337" class="ne-p"><br></p><div class="ne-quote"><p id="dfa539d717445f30a0ea67a0f25eb95f" class="ne-p"><span class="ne-text">其中：global 表示全局可用，如果要设置局部可用，则只需要删除 global 即可</span></p></div><h3 id="cdZrf"><span class="ne-text">【3】验证是否配置成功</span></h3><pre data-language="bash" id="NLkrq" class="ne-codeblock language-bash">git config --global --list</pre><p id="fe68c7dc905dbfa1d7b17a6293979690" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624936078225-da481808-a48c-44d4-b462-8bd283f607b3.png" width="441" id="Ib8qE" class="ne-image"></p><h2 id="21431630"><span class="ne-text">二、利用 SSH 绑定 Git 和 GitHub</span></h2><h3 id="kxSPj"><span class="ne-text">【1】生成 SSH 密钥</span></h3><ol class="ne-ol"><li id="u15230470"><span class="ne-text">输入</span><code class="ne-code"><span class="ne-text">ssh-keygen -t rsa</span></code><span class="ne-text">，然后回车三下 </span><span class="ne-text" style="text-decoration: line-through">（有些时候要回车四下）</span></li><li id="u8c3367ec"><span class="ne-text">然后在用户管理员文件夹下生成两个文件夹 id_rsa 和</span><strong><span class="ne-text">id_rsa.pub</span></strong><span class="ne-text">，将</span><strong><span class="ne-text">后者文件内容</span></strong><span class="ne-text">添加到 GitHub 上即可</span></li></ol><p id="2e700fa3904d6bc1021f7b27ab236131" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624936245745-59fb92ec-8f9d-4ad8-8986-d9b245d56ed4.png" width="590" id="uDYmq" class="ne-image"></p><h3 id="Jzy1w"><span class="ne-text">【2】GitHub 上添加生成的 SSH 密钥</span></h3><ul class="ne-ul"><li id="u380ea8ae"><span class="ne-text">在 github 上的 setting 上添加新的 ssh 即可</span></li></ul><p id="uc0533b6f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632592051527-75ccc8a5-88a5-486f-a305-1fa1bc7b86f0.png" width="640.5" id="u0aff0997" class="ne-image"></p><h3 id="IgVkR"><span class="ne-text">【3】验证是否绑定成功</span></h3><pre data-language="bash" id="zj7XC" class="ne-codeblock language-bash">ssh -T <a href="mailto:&#103;&#x69;&#116;&#64;&#103;&#105;&#116;&#x68;&#x75;&#98;&#x2e;&#99;&#x6f;&#109;">&#103;&#x69;&#116;&#64;&#103;&#105;&#116;&#x68;&#x75;&#98;&#x2e;&#99;&#x6f;&#109;</a></pre><ul class="ne-ul"><li id="6a0e4944f3cd68096c1066e9a3b26ef4"><span class="ne-text">响应如下内容则证明绑定成功</span></li></ul><p id="u1e7edcd5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624936534567-668d781f-afc8-4753-85a0-09d7fabe3901.png" width="441" id="CHJEV" class="ne-image"></p><div data-type="danger" class="ne-alert"><p id="u680384cd" class="ne-p"><span class="ne-text">如果报错，则是因为少了一个文件，使用过程中直接点 yes。具体参考：</span><a href="https://blog.csdn.net/qq_34446663/article/details/81106018" data-href="https://blog.csdn.net/qq_34446663/article/details/81106018" target="_blank" class="ne-link"><span class="ne-text">解决原理</span></a></p></div><h2 id="8338528d"><span class="ne-text">三、常用命令总结</span></h2><h3 id="5990883c"><span class="ne-text">git clone</span></h3><p id="44ec70d218885ff49cc7a5d2670b5555" class="ne-p"><span class="ne-text">本地没有 git 仓库，也没有 git init 操作，需要先从 GitHub 上 clone 下来-</span></p><pre data-language="bash" id="USgMZ" class="ne-codeblock language-bash">git clone <a href="https://github.com/wztlink1013/datastructure-algorithm.git">https://github.com/wztlink1013/datastructure-algorithm.git</a></pre><p id="f5996fe8505e46089c5355d6474337e1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624936843530-14b72928-d20f-489c-b84d-f5a5d414cc01.png" width="441" id="dbDXW" class="ne-image"></p><p id="a3bad6ce0e5697b0282d3e44d07e5c23" class="ne-p"><br></p><p id="aab32beef4b4d2ea8b8041ade913c9bf" class="ne-p"><span class="ne-text">对本地文件夹进行一系列更改之后，执行命令：</span></p><p id="7e829c90327d5375884c4f4d8adceabb" class="ne-p"><br></p><pre data-language="bash" id="9e1892de" class="ne-codeblock language-bash">#查看仓库命令状态<br>git status #文件提交到文件缓冲区<br>git add .<br>#提交仓库并且添加提交信息<br>git commmit -m "描述本次修改信息"<br>#查看修改日志<br>git log<br>#再次查看<br>git status</p><h1 id="首次推送"><a href="#首次推送" class="headerlink" title="首次推送"></a>首次推送</h1><p>git push -u origin master</p><h1 id="非首次推送"><a href="#非首次推送" class="headerlink" title="非首次推送"></a>非首次推送</h1><p>git push origin master</pre><h3 id="miiqH"><span class="ne-text">git clone 较大文件失败情况</span></h3><p id="u52ead6a3" class="ne-p"><span class="ne-text">有的 GitHub 仓库存在很久，有很多 commit 历史，特别是曾经的某一次提交带有较大文件的情况，会导致后续 clone 工程大的问题，解决方案：</span></p><ol class="ne-ol"><li id="u94ff89ae"><code class="ne-code"><span class="ne-text">--depth 1</span></code></li></ol><p id="uba9ecd2e" class="ne-p"><span class="ne-text">depth n 参数代表克隆深度，不带该参数则克隆所有历史版本</span></p><ol start="2" class="ne-ol"><li id="u73118b86"><span class="ne-text">直接克隆某个分支下来</span></li></ol><pre data-language="bash" id="sfium" class="ne-codeblock language-bash">git clone -b backup <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#111;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#111;&#x6d;</a>:wztlink1013/wztlink1013.github.io.git</pre><h3 id="49f0a49e"><span class="ne-text">git pull</span></h3><p id="f4b5aee32cad4e1c1385d209d336af00" class="ne-p"><br></p><p id="8ab7cfd0020ecbb134739f4e2e7c4a67" class="ne-p"><span class="ne-text">这种情况是，本地有 git 仓库，指之前已经进行 git init 等一系列命令对该文件夹操作过。新建一个例子：</span></p><pre data-language="bash" id="ZCRH9" class="ne-codeblock language-bash"># 初始化本地仓库<br>git init</p><h1 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h1><p>git remote add origin <a href="https://github.com/wztlink1013/wztlink1013.github.io.git">https://github.com/wztlink1013/wztlink1013.github.io.git</a></p><h1 id="同步远程仓库和本地仓库"><a href="#同步远程仓库和本地仓库" class="headerlink" title="同步远程仓库和本地仓库"></a>同步远程仓库和本地仓库</h1><p>git pull origin master</pre><p id="852e1657be7fdad115bdcd2692e41cd6" class="ne-p"><br></p><div data-type="danger" class="ne-alert"><p id="500b18c0c9935a01e489252b00a20f7a" class="ne-p"><strong><span class="ne-text">注意</span></strong><span class="ne-text">：在进行本地仓库和远程仓库的文件交互时，一定要先 pull 再 push，不然会出未知错误。</span></p></div><p id="u650193a2" class="ne-p"><span class="ne-text"></span></p><p id="ufb7239b6" class="ne-p"><span class="ne-text">1、将远程指定分支 拉取到 本地指定分支上：</span></p><pre data-language="bash" id="lIRRb" class="ne-codeblock language-bash">git pull origin <远程分支名>:<本地分支名></pre><p id="u22fbd131" class="ne-p"><span class="ne-text">2、将远程指定分支 拉取到 本地当前分支上：</span></p><pre data-language="bash" id="ljXVO" class="ne-codeblock language-bash">git pull origin <远程分支名></pre><p id="u72ca0494" class="ne-p"><span class="ne-text">3、将与本地当前分支同名的远程分支 拉取到 本地当前分支上(需先关联远程分支，方法见</span><a href="#KBkAM" data-href="#KBkAM" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/blog/fnsge3#KBkAM</span></a><span class="ne-text">)</span></p><pre data-language="bash" id="CnhYk" class="ne-codeblock language-bash">git pull</pre><p id="uf6c1bf2f" class="ne-p"><span class="ne-text">在克隆远程项目的时候，本地分支会自动与远程仓库建立追踪关系，可以使用默认的 origin 来替代远程仓库名，</span></p><p id="u2b777eb8" class="ne-p"><span class="ne-text">所以，我常用的命令就是 git pull origin &lt;远程仓库名&gt;，操作简单，安全可控。</span></p><p id="u9b66cbc8" class="ne-p"><a href="https://blog.51cto.com/u_15262460/2883040" data-href="https://blog.51cto.com/u_15262460/2883040" target="_blank" class="ne-link"><span class="ne-text"><br></span></a></p><h3 id="Q2YQG"><span class="ne-text">git push</span></h3><p id="u8e52c29a" class="ne-p"><span class="ne-text">1、将本地当前分支 推送到 远程指定分支上（注意：pull 是远程在前本地在后，push 相反）：</span></p><pre data-language="bash" id="cEEHF" class="ne-codeblock language-bash">git push origin <本地分支名>:<远程分支名></pre><p id="udc2681a7" class="ne-p"><span class="ne-text">2、将本地当前分支 推送到 与本地当前分支同名的远程分支上（注意：pull 是远程在前本地在后，push 相反）：</span></p><pre data-language="bash" id="PoReP" class="ne-codeblock language-bash">git push origin <本地分支名></pre><p id="u7eb6e5f5" class="ne-p"><span class="ne-text">3、将本地当前分支 推送到 与本地当前分支同名的远程分支上(需先关联远程分支，方法见</span><a href="#KBkAM" data-href="#KBkAM" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/blog/fnsge3#KBkAM</span></a><span class="ne-text">)</span></p><pre data-language="bash" id="COsFC" class="ne-codeblock language-bash">git push</pre><p id="u808010f5" class="ne-p"><span class="ne-text">同样的，推荐使用第 2 种方式，git push origin &lt;远程同名分支名&gt;</span></p><h3 id="KBkAM"><span class="ne-text">git push -u </span></h3><p id="uda1272d6" class="ne-p"><span class="ne-text">将本地分支与远程同名分支相关联</span></p><pre data-language="bash" id="eWUEz" class="ne-codeblock language-bash">git push --set-upstream origin <本地分支名></pre><p id="uef5930d0" class="ne-p"><span class="ne-text">简写方式：</span></p><pre data-language="bash" id="qO6pr" class="ne-codeblock language-bash">git push -u origin <本地分支名></pre><h3 id="i5nOV"><span class="ne-text">git push -f</span></h3><div data-type="danger" class="ne-alert"><p id="8b9e3b642b8eeac07a822d774fbc95aa" class="ne-p"><span class="ne-text">报错信息</span></p></div><pre data-language="bash" id="STgRT" class="ne-codeblock language-bash">$ git push origin master<br>To <a href="https://github.com/wztlink1013/website-source.git">https://github.com/wztlink1013/website-source.git</a><br>! [rejected] master -> master (fetch first)<br>error: failed to push some refs to '<a href="https://github.com/wztlink1013/website-source.git&#39;">https://github.com/wztlink1013/website-source.git&#39;</a><br>hint: Updates were rejected because the remote contains work that you do<br>hint: not have locally. This is usually caused by another repository pushing<br>hint: to the same ref. You may want to first integrate the remote changes<br>hint: (e.g., 'git pull ...') before pushing again.<br>hint: See the 'Note about fast-forwards' in 'git push --help' for details.</pre><p id="381f09800632d60a3aaf75ec98c39575" class="ne-p"><span class="ne-text">分析并解决问题</span></p><div data-type="success" class="ne-alert"><p id="u7c826156" class="ne-p"><span class="ne-text">强制性 push</span></p></div><pre data-language="bash" id="CzTiS" class="ne-codeblock language-bash">$ git push -f origin master</pre><h3 id="RJdz3"><span class="ne-text">branch 和 checkout</span></h3><pre data-language="bash" id="JpQy2" class="ne-codeblock language-bash"># 创建并切换新的分支<br>git branch -b 分支名</p><h1 id="查看本地所有分支"><a href="#查看本地所有分支" class="headerlink" title="查看本地所有分支"></a>查看本地所有分支</h1><p>git branch</p><h1 id="切换到指定分支"><a href="#切换到指定分支" class="headerlink" title="切换到指定分支"></a>切换到指定分支</h1><p>git checkout 指定分支名</p><h1 id="四部曲"><a href="#四部曲" class="headerlink" title="四部曲"></a>四部曲</h1><p>git status<br>git add .<br>git commit -m “push description infomation”<br>git push origin 分支名 </pre><h3 id="lseEO"><span class="ne-text">git reset –hard</span></h3><p id="u88a0728a" class="ne-p"><span class="ne-text">回退指定历史命令</span></p><p id="u2d3d8b4d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639990649778-2e3ec7b1-e554-47af-b8ca-dbad93bf23a0.png" width="931.5" id="u77bcd18c" class="ne-image"></p><pre data-language="bash" id="nVQna" class="ne-codeblock language-bash">git reset --hard 9fba643590aeb5889c84029585848b93c3e64e5d</pre><h3 id="C2Qva"><span class="ne-text">文件夹相关命令</span></h3><ul class="ne-ul"><li id="u91e8b7b7"><span class="ne-text">复制文件夹</span></li></ul><pre data-language="bash" id="aAKQU" class="ne-codeblock language-bash">cp -r ./js/ ./backup/</pre><ul class="ne-ul"><li id="u1b091df8"><span class="ne-text">移动文件夹</span></li></ul><pre data-language="bash" id="LAhFx" class="ne-codeblock language-bash">mv visualization/ -f .github_pages/</pre><ul class="ne-ul"><li id="ua1d5032e"><span class="ne-text">删除文件夹</span></li></ul><pre data-language="bash" id="C0ga7" class="ne-codeblock language-bash">rm -r .git</pre><p id="1d28be7f4364ca8fcdbe48c0c253fd56" class="ne-p"><br></p><p id="8f7c77cc357b4507b94c559961ed51bc" class="ne-p"><span class="ne-text"></span></p></div></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions代码汇总</title>
      <link href="/blog/uwpbn0/"/>
      <url>/blog/uwpbn0/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="TEpBv"></h2><h2 id="MJWMh"><span class="ne-text">仓库文件夹备份</span></h2><pre data-language="yaml" id="bMRN9" class="ne-codeblock language-yaml">name: CI<p>on: [watch]<br>jobs:<br>build:<br>runs-on: ubuntu-latest<br>steps: - uses: actions/checkout@v2 - name: 配置 Git<br>run: |<br>git config –global user.name ‘wztlink1013’<br>git config –global user.email ‘<a href="mailto:&#x32;&#53;&#53;&#x30;&#x33;&#x37;&#x34;&#56;&#49;&#x35;&#64;&#113;&#x71;&#x2e;&#99;&#x6f;&#x6d;">&#x32;&#53;&#53;&#x30;&#x33;&#x37;&#x34;&#56;&#49;&#x35;&#64;&#113;&#x71;&#x2e;&#99;&#x6f;&#x6d;</a>‘ - name: 在云端进行复制文件夹操作<br>env:<br>Github_Token: $<br>      run: |<br>        git clone https://${Github_Token}@github.com/wztlink1013/website-source website-source<br>cd website-source<br>cp -r ./Secret 文集/ ./backup/<br>git status<br>git add .<br>git commit -m “backup”<br>git push –force –quiet “https://${Github_Token}@github.com/wztlink1013/website-source” master:master</pre><h2 id="vFzCL"><span class="ne-text">博客 CICD 腾讯云函数</span></h2><h3 id="b6DTs"><span class="ne-text">Python2.7 执行环境</span></h3><pre data-language="python" id="ydhP6" class="ne-codeblock language-python"># -<em>- coding: utf8 -</em>-<br>import requests</p><p>def main_handler(event, context):<br>r = requests.post(“<a href="https://api.github.com/repos/wztlink1013/Blog3.0/dispatches&quot;">https://api.github.com/repos/wztlink1013/Blog3.0/dispatches&quot;</a>,<br>json={‘event_type’: “run-it”},<br>headers = {“User-Agent”:’curl/7.52.1’,<br>‘Content-Type’: ‘application/json’,<br>‘Accept’: ‘application/vnd.github.everest-preview+json’,<br>‘Authorization’: ‘token <strong><strong>**</strong></strong>‘})</p><pre><code>if r.status_code == 204:    return &quot;This&#39;s OK!&quot;else:    return r.status_code&lt;/pre&gt;&lt;h3 id=&quot;z3oLj&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;触发器设置&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;340715b874c883b8bf4ab4cadc83964f&quot; class=&quot;ne-p&quot; style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1484158/1594789179624-938bb8c2-ac15-4ece-a5f1-001563e4f08b.png?x-oss-process=image%2Fresize%2Cw_1210&quot; width=&quot;1210&quot; id=&quot;OFWLm&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;wQGMQ&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;博客CICD阿里云函数&lt;/span&gt;&lt;/h2&gt;&lt;h3 id=&quot;32bJh&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;Python3执行环境&lt;/span&gt;&lt;/h3&gt;&lt;pre data-language=&quot;python&quot; id=&quot;2v3Me&quot; class=&quot;ne-codeblock language-python&quot;&gt;# -*- coding: utf-8 -*-</code></pre><p>import logging<br>import requests<br>OK = b’ok\n’</p><p>def handler(environ, start_response):<br>status = ‘200 OK’<br>response_headers = [(‘Content-type’, ‘text/plain’)]<br>sync_yuque()<br>start_response(status, response_headers)<br>return [OK]</p><p>def sync_yuque():<br>requests.post(“<a href="https://api.github.com/repos/wztlink1013/Blog3.0/dispatches&quot;">https://api.github.com/repos/wztlink1013/Blog3.0/dispatches&quot;</a>,<br>json={‘event_type’: “run-it”},<br>headers={“User-Agent”:’curl/7.52.1’,<br>‘Content-Type’: ‘application/json’,<br>‘Accept’: ‘application/vnd.github.everest-preview+json’,<br>‘Authorization’: ‘token <strong><strong>*</strong></strong>‘})</pre><p id="c4750975c712ab801472e9f18b54d795" class="ne-p"><br></p></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS引入和特性</title>
      <link href="/blog/740ee349dcf540d24c44fd240dbbc87f/"/>
      <url>/blog/740ee349dcf540d24c44fd240dbbc87f/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="fdefba74db339c7fd0ecaff7bb6857f9" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="495decaa10271bb0c9a022a3cc79761d" class="ne-p"><span class="ne-text">CSS(Cascading Style Sheets)  ，通常称为CSS样式表或层叠样式表（级联样式表）</span></p></div><h2 id="24FrL"><span class="ne-text">CSS引入</span></h2><h3 id="UoKmW"><span class="ne-text">行内式（内联样式）</span></h3><pre data-language="html" id="0O1H7" class="ne-codeblock language-html"><div style="color: red; font-size: 12px;">文字</div></pre><p id="00b1901eadd23b279f24eafe259a4dff" class="ne-p"><br></p><ul class="ne-ul"><li id="346f97a34544f45c62bd12163c65a4fe"><span class="ne-text">style其实就是标签的属性</span></li><li id="85c0e31687849e033d4fc0ecb89f6e82"><strong><span class="ne-text">样式属性和值中间是</span></strong><code class="ne-code"><strong><span class="ne-text">:</span></strong></code></li><li id="be284148ea165c28f1b88dc71b0405eb"><strong><span class="ne-text">多组属性值之间用</span></strong><code class="ne-code"><strong><span class="ne-text">;</span></strong></code><strong><span class="ne-text">隔开</span></strong></li></ul><h3 id="BpAyf"><span class="ne-text">内部样式表（内嵌样式表）</span></h3><pre data-language="css" id="GtQqB" class="ne-codeblock language-css"><style><pre><code> div &#123;     color: red;     font-size: 12px; &#125;</code></pre><p></style></pre><p id="0befc1eabdb80264b9398ff6c8ac457f" class="ne-p"><br></p><ul class="ne-ul"><li id="9ae5530eb2d81f718d91824d1b220fff"><span class="ne-text">style 标签一般位于 head 标签中，理论可以放在 HTML 文档的任何地方。</span></li><li id="d194cef71b776f79abb0eb02ce612649"><span class="ne-text">type=”text/css”   在 html5 中可以省略。</span></li><li id="96f85dcb410ec04f58121aba0fcd1f52"><span class="ne-text">只能控制当前的页面</span></li></ul><p id="0b8dd88c882d1d2734a39de8a220bc96" class="ne-p"><br></p><h3 id="6zLrM"><span class="ne-text">外部样式表（外链式）</span></h3><pre data-language="html" id="BHVP2" class="ne-codeblock language-html"><head></p>  <link rel="stylesheet" type="text/css" href="css文件路径"></head></pre><p id="33dac0e992c302fc6f8667490f4c4a88" class="ne-p"><br></p><ul class="ne-ul"><li id="44a5ceb547ff51487c1b7bb8544de922"><span class="ne-text">link 是个单标签</span></li><li id="55e4056ff3b3e903e62776df22bf1fa6"><span class="ne-text">link标签需要放在head头部标签中，并且指定link标签的三个属性</span></li></ul><table id="dJV4B" class="ne-table" style="width: 568px"><tbody><tr style="height: 33px"><td width="284"><p id="ua4d01f97" class="ne-p"><span class="ne-text">属性</span></p></td><td width="284"><p id="ud6129755" class="ne-p" style="text-align: left"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="u33fed3c6" class="ne-p"><span class="ne-text">rel</span></p></td><td width="284"><p id="u62d4bbff" class="ne-p" style="text-align: left"><span class="ne-text">定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="u027f9b70" class="ne-p"><span class="ne-text">type</span></p></td><td width="284"><p id="u18454a24" class="ne-p" style="text-align: left"><span class="ne-text">定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。我们都可以省略</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="u96a50878" class="ne-p"><span class="ne-text">href</span></p></td><td width="284"><p id="ubf16cbe2" class="ne-p" style="text-align: left"><span class="ne-text">定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。</span></p></td></tr></tbody></table><p id="05da89e6dedfb9a98e33f150e3fc46f4" class="ne-p"><br></p><p id="8fd966ac37481bdb0da195ec04b195d9" class="ne-p"><br></p><p id="2a8b984809bc2b05952f3cd16f264dcc" class="ne-p"><br></p><h2 id="51lsA"><span class="ne-text">CSS三大特性</span></h2><h3 id="giaIL"><span class="ne-text">层叠性</span></h3><p id="c75c2a8a436614456498c69871257578" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611551959470-031c2889-70e9-4982-96f9-9c144e5051b2.png" width="603" id="V5gO3" class="ne-image"></p><ul class="ne-ul"><li id="9b936beac8f8c5c2a4912079a33e636f"><span class="ne-text">概念：</span><span class="ne-text">所谓层叠性是指多种CSS样式的叠加。</span><span class="ne-text">是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉</span></li><li id="f4a2737f014a7524f1d83f2a7629f65a"><span class="ne-text">原则：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="cb32e2604831a28dd7e26b601cc21a44"><span class="ne-text">样式冲突，遵循的原则是</span><strong><span class="ne-text">就近原则。</span></strong><span class="ne-text"> 那个样式离着结构近，就执行那个样式。</span></li><li id="75f375d8e165210ce53fc64ef9cb44cf"><span class="ne-text">样式不冲突，不会层叠</span></li></ul></ul><pre data-language="plain" id="UHZYg" class="ne-codeblock language-plain">CSS层叠性最后的执行口诀：  长江后浪推前浪，前浪死在沙滩上。</pre><p id="9b072339abd4252e59ab31ce39e5dc03" class="ne-p"><br></p><h3 id="GZ9NO"><span class="ne-text">继承性</span></h3><p id="cedc6417f3c8c35e1e6dddba608a4aa2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611551970799-56adba75-8847-4db1-a411-148ff22f57ac.png" width="598" id="FlrFw" class="ne-image"></p><ul class="ne-ul"><li id="e0ac11b6deb5ed432cd57967edff1a85"><span class="ne-text">概念：</span><span class="ne-text">子标签会继承父标签的某些样式，如文本颜色和字号。</span><span class="ne-text">想要设置一个可继承的属性，只需将它应用于父元素即可。</span></li></ul><p id="60e39e3acb05b2a39cc05336d31c401a" class="ne-p"><span class="ne-text">简单的理解就是：  子承父业。</span></p><ul class="ne-ul"><li id="3df2fd3f70ab542f40f8149f364ee60f"><strong><span class="ne-text">注意</span></strong><span class="ne-text">：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="52a1e97a676230bc7f9be591a50ff054"><span class="ne-text">恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。</span></li><li id="61c91b2e2164f1507e25bf771219ae37"><span class="ne-text">子元素可以继承父元素的样式（</span><strong><span class="ne-text">text-，font-，line-这些元素开头的可以继承，以及color属性</span></strong><span class="ne-text">）</span></li></ul></ul><h3 id="9JW0v"><span class="ne-text">优先级</span></h3><p id="d5bf31c8bfda9ebb17681d1086a02778" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611551983122-6a6e2212-c740-40f6-bfa1-3b66ae0a9c46.png" width="599" id="ATZOo" class="ne-image"></p><ul class="ne-ul"><li id="8ac00d0c2b65e58c170ff7d13c205e5e"><span class="ne-text">概念：定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时，</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="69c355c81d518cedce554ec70c247f22"><span class="ne-text">选择器相同，则执行层叠性</span></li><li id="c7756aa0fb2c8835a985705a2b43bf29"><span class="ne-text">选择器不同，就会出现优先级的问题。</span></li></ul></ul><div data-type="info" class="ne-alert"><p id="4f4ad24f4169c6ca19dfaeab9a5997e6" class="ne-p"><span class="ne-text">权重计算公式</span></p></div><p id="c37427b6372485819bad12420b198c43" class="ne-p"><span class="ne-text">关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</span></p><table id="LanbR" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="ubd4da0a3" class="ne-p"><span class="ne-text">标签选择器</span></p></td><td width="375"><p id="ub4a11b61" class="ne-p"><span class="ne-text">计算权重公式</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uf1230f80" class="ne-p"><span class="ne-text">继承或者 *</span></p></td><td width="375"><p id="ud3c891b7" class="ne-p"><span class="ne-text">0,0,0,0</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uc3e3dbd5" class="ne-p"><span class="ne-text">每个元素（标签选择器）</span></p></td><td width="375"><p id="ubc7b5f83" class="ne-p"><span class="ne-text">0,0,0,1</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u9b847a1d" class="ne-p"><span class="ne-text">每个类，伪类</span></p></td><td width="375"><p id="ubc56155d" class="ne-p"><span class="ne-text">0,0,1,0</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ue6747e33" class="ne-p"><span class="ne-text">每个ID</span></p></td><td width="375"><p id="ub501574b" class="ne-p"><span class="ne-text">0,1,0,0</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ufff1b145" class="ne-p"><span class="ne-text">每个行内样式 style=""</span></p></td><td width="375"><p id="u09d95f5d" class="ne-p"><span class="ne-text">1,0,0,0</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u24394b91" class="ne-p"><span class="ne-text">每个!important  重要的</span></p></td><td width="375"><p id="uf51c7951" class="ne-p"><span class="ne-text">∞ 无穷大</span></p></td></tr></tbody></table><ul class="ne-ul"><li id="195cf52ec1b403760c2c716841873efb"><span class="ne-text">值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。</span></li><li id="e0a7f97ac051063e30dcd2a168619ddd"><span class="ne-text">关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</span></li><li id="e2ff8772c445471d7552d330ead9d526"><span class="ne-text">div {</span><span class="ne-text">color: pink!important;</span><span class="ne-text">}</span></li></ul><div data-type="info" class="ne-alert"><p id="1d1aefe9d3ebc0339692d3bb23b0a9c8" class="ne-p"><span class="ne-text">权重叠加</span></p></div><p id="38764e64e5d27976e38b96a54b47b332" class="ne-p"><span class="ne-text">我们经常用交集选择器，后代选择器等，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。</span></p><p id="95a78de3cad8abec942a19d04f98d5b4" class="ne-p"><span class="ne-text">就是一个简单的加法计算</span></p><ul class="ne-ul"><li id="4da9a9baefce08f8e11c1b23c7f3b47e"><span class="ne-text">div ul  li   ------>      0,0,0,3</span></li><li id="9a61760b700deb5690eb1d1aae4f256d"><span class="ne-text">.nav ul li   ------>      0,0,1,2</span></li><li id="026d3e82d2036f8c7f398b351ce4e5ae"><span class="ne-text">a:hover      -----—>   0,0,1,1</span></li><li id="569bc6beccece02a8656ad749e55f739"><span class="ne-text">.nav a       ------>      0,0,1,1</span></li></ul><p id="43d873c80618908922e2dcca359cca94" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1611549555499-d752a9dc-33fc-4649-95b6-58b25d08ef80.jpg" width="31" id="XMn3N" class="ne-image"><span class="ne-text"> 注意：</span></p><ol class="ne-ol"><li id="54f8fa7ec85b350def6b05d6483434c9"><span class="ne-text">数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。</span></li></ol><div data-type="info" class="ne-alert"><p id="45a5ae561bbb5c2001543cbb8125aa6a" class="ne-p"><span class="ne-text">继承的权重是0</span></p></div><p id="48deb4ae5ac96c3a9d565e179f4b2243" class="ne-p"><span class="ne-text">这个不难，但是忽略很容易绕晕。其实，我们修改样式，一定要看该标签有没有被选中。</span></p><p id="c40c86909e7c1bb487965eceaf0d6971" class="ne-p"><span class="ne-text">1） 如果选中了，那么以上面的公式来计权重。谁大听谁的。</span></p><p id="668ca512a339921e5ae0c626b2d530b9" class="ne-p"><span class="ne-text">2） 如果没有选中，那么权重是0，因为继承的权重为0.</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《世界上所有的夜晚》——那段难忘的谈吐</title>
      <link href="/essay/c47f3d9a749fd0229277f9e9604e69a2/"/>
      <url>/essay/c47f3d9a749fd0229277f9e9604e69a2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ud8b3f1df" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622165460883-a7b33b3d-8426-46e7-ade7-e603c065322e.jpeg" width="135" id="uedac2836" class="ne-image"></p><p id="ubc8be0f2" class="ne-p" style="text-align: center"><br></p><p id="u30d31720" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #111111; font-size: 14px">每本书，总会有那么一段让你记忆难忘。最难忘的是和蒋百嫂酒后那段谈吐，夜半作者打算回旅馆，却听见轰隆隆的响声，当看见冰柜里的那具尸体之后，仿佛像是探照灯照亮了一个人不愿流露的内心，悲凉，同情。每个人都有属于自己的夜晚，心灵寄居在此，有的看似洒脱却也痛苦无奈。</span></p><p id="u9fd7c745" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #111111; font-size: 14px"></span></p><p id="u3760b15d" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #111111; font-size: 14px">看完这本书，我才渐渐了解迟子建这个作家，不过非常尴尬，在此之前我一直以为迟子建是位男作家····作者真的是一个善于观察的生活记录者，很喜欢那样轻快的语言，迟子建是在我读书时期，让我喜欢上文学的人之一，高中那会，就喜欢蹲在书店的书架后面看他写的书，看完之后，心情甚是愉悦~～～回忆啊，那个下午放学到晚自习那段一个小时，总喜欢跑书店看一些神神叨叨的书</span></p><p id="ubf6a34bc" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #111111; font-size: 14px"></span></p><p id="u0c2db998" class="ne-p"><span class="ne-text" style="color: #111111; font-size: 14px">每个人都有属于自己的夜晚，每个人都有属于自己的回忆 :-）</span></p><p id="u94367c57" class="ne-p"><br></p><hr id="zWNXp" class="ne-hr"><p id="u910ad56d" class="ne-p"><br></p><p id="u29e8bd35" class="ne-p"><span class="ne-text">《世界上所有的夜晚》迟子建的一本比较短的小说，这部小说，也是在那期间第一本我一天之内看完的一本小说，很多时候，我总是想起煤矿镇的那个村庄的人，事实上，那都是我们身边的人，也是那本书我内心深深的感知，这世上有很多不幸的人，这世上不止一个夜晚，有无数个人人牵挂的夜晚，这世上又只有一个夜晚，那个独自存在的灵魂的夜晚……</span></p><p id="uf4a332de" class="ne-p"><br></p><p id="u96555e86" class="ne-p"><br></p><hr id="WObKJ" class="ne-hr"><p id="u6b2bc270" class="ne-p"><br></p><p id="u506a2f5e" class="ne-p"><span class="ne-text">想想以前的一些悠闲经历， 上课偷偷式看小说 、备考期间，自我欺骗/麻痹式看小说 ，大学依旧是上课老喜欢在全班同学都认真听讲而我坐在后排靠窗角落看小说</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622165717851-7436873d-a34b-48b7-a8fa-d32e45eb7e4b.jpeg" width="51" id="HxzJ4" class="ne-image"></p><p id="uf8a684f2" class="ne-p"><br></p><p id="uc20af8ee" class="ne-p"><br></p><p id="uc58eea44" class="ne-p"><span class="ne-text">然而现在， 快节奏的日常似乎霸占生活的全部 ，身边有这么优秀的环境，我忘却了曾经的那一丝快感……</span></p><p id="u5a4c0257" class="ne-p"><br></p><p id="ude9c354b" class="ne-p"><span class="ne-text">其实，生活本可以有一丝轻快，不用太过追求什么</span></p><p id="u33098461" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>至暗之路</title>
      <link href="/essay/ew2l6r/"/>
      <url>/essay/ew2l6r/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B12%2C0%2C5%5D%2C%5B12%2C0%2C5%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="84fca8abe9d50557666319033f6713e2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">一个人如若是他很强，一或者说在别人眼中看起来很强，那么他一定是有着他自己的一段至暗时光。</p><p data-lake-id="7c5ac138d2b9271acb9a6c4afb002989" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c70128d04575f817fb31a00f159f4aaa" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">我们总是不喜欢往回看。往回看有两种情况，一种是你的过往是让你愉悦的，让你充满开心快乐，还有一种就是让你哽咽，不想多言，或是说，那段时光虽然让你收获很多，但是它并非是你很想经历的。至暗时光的确可以让自己变得更强，但是凡事你能得到就必然有舍弃，我觉得那段至暗时光让我舍弃的就是与他人的人情味。</p><p data-lake-id="c8a095e88296ed380c3d65eef501fb34" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="3294b573ac4ae1e75c99048de5494474" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">我的确很恨，恨为什么是我经受那种环境，一个本不是第一环境的人，却也落得个第一环境的人，就像是内壁中有遗留下的异世界的人一样，很愤懑，却也不得抒情。我觉得这可能就是古时候的诗人那般抒情吧，失意，惆怅，但唯一与身边人不同的就是，不会迷茫，内心却是异常的笃定，于是乎他开始变得与周围的人都不太一样，他开始学会跳出内壁，内壁下的人们就仿佛是用来衬托这个本不该落下的内壁之外的人，但，就像是那片沙漠尽头的那般高墙一般，他的落下，是因为他在他那个文明下触及到他不应该触及的所谓的“法律”。</p><p data-lake-id="89c53d091225673f5fafb8b50d54b47a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="62c89cf900593957f41bf1b2d0c90bbc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">“什么都不舍弃，就什么改变不了”</p><p data-lake-id="6b2f189f9ea9fbc97e7de0629176b65c" style="text-align: right; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">——爱尔敏</p><p data-lake-id="6a7344e9eec3e23cd6843f8ba2c48055" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="8222eafcb027ff2688393174fc37470b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">于是乎，他开始讨厌内壁下的种种，他觉得，在他那个文明，这不应该是他应该所接触的。他觉得，他不是内壁下的人们，他应该回到他所觉得的那个高级文明。所以，他的那种与世人抵触，让他踏上至暗时光，在此有必要提醒一点，至暗，不一定是贬义词，更多的时候，它是一种中性词。</p><p data-lake-id="351d69dfa1ae7a1aed67e18407434dbf" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="71a2b2a09b2d030f9a9cb466ef309776" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">“错的不是我，而是这个世界”</p><p data-lake-id="89dd753afe5dfd31fbb1dca994e19223" style="text-align: right; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">——金木研</p><p data-lake-id="79a4b4832f341c7cde8a392400d93bbb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="a68844bf16b3d944665ccdc664b4159f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="3c75f8b7ba1c11af2289ca086bee2f9e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions+语雀+serverless云函数实现hexo自动化部署</title>
      <link href="/blog/vyeuk3/"/>
      <url>/blog/vyeuk3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="4XWuu"><span class="ne-text">一、整体思路</span></h2><p id="4016379116a379d18c4872818f1562f6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1610002276789-6c7bf0a3-f39b-4a27-a493-01c2e579ec87.jpeg" width="2062" id="Rnqi1" class="ne-image"></p><p id="693f2b2afca1c9aa5067a9e02b334f9a" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="09333828093ed067f8cf43b2529f880b"><span class="ne-text">【1】利用</span><code class="ne-code"><span class="ne-text">npm</span></code><span class="ne-text">插件</span><code class="ne-code"><span class="ne-text">yuque-hexo-lyrics</span></code><span class="ne-text">将语雀云端的文章同步到博客源码</span><code class="ne-code"><span class="ne-text">source/_posts</span></code><span class="ne-text">文件夹下。</span></li><li id="f98575c94e60b37a4c4ab20e038d2d4a"><span class="ne-text">【2】再利用</span><code class="ne-code"><span class="ne-text">GitHub Actions</span></code><span class="ne-text">自动化部署将GitHub私有仓库（</span><code class="ne-code"><span class="ne-text">website</span></code><span class="ne-text">）的博客源文件编译成静态博客文件并部署push到静态博客仓库（</span><code class="ne-code"><span class="ne-text">wztlink1013.github.io</span></code><span class="ne-text">）下。</span></li></ul><p id="66dea340fdf3da51b3e3b42e36fd70aa" class="ne-p"><br></p><div data-type="danger" class="ne-alert"><p id="1da0b75f62048cb4f4b43f7af57040f0" class="ne-p"><span class="ne-text">但是以上【1】【2】两种方式并不能解决语雀一发布文章就触发GitHub源码仓库的GitHub Actions</span></p></div><p id="3f3fc78a27c6d2caaf3dca2614c8b662" class="ne-p"><br></p><ul class="ne-ul"><li id="22924826abb1ece2bead19ffb295172c"><span class="ne-text">【3】所以需要中间</span><code class="ne-code"><span class="ne-text">TencentCloud</span></code><span class="ne-text">云函数/</span><code class="ne-code"><span class="ne-text">Aliyun</span></code><span class="ne-text">云函数，云函数的作用就是，语雀文章一经正式发布就触发云函数，从而云函数再触发GitHub私有的源码仓库下的</span><code class="ne-code"><span class="ne-text">GitHub Actions</span></code><span class="ne-text">达到编译静态博客的效果。</span></li></ul><p id="u91493ea8" class="ne-p"><span class="ne-text"></span></p><h2 id="eaGqv"><span class="ne-text">二、网站源文件配置</span></h2><div class="ne-quote"><p id="e5d00f608777a6cde25ae914395657e3" class="ne-p"><span class="ne-text">插件npm地址【暂未GitHub开源】：</span><a href="https://www.npmjs.com/package/yuque-hexo-lyrics" data-href="https://www.npmjs.com/package/yuque-hexo-lyrics" target="_blank" class="ne-link"><span class="ne-text">https://www.npmjs.com/package/yuque-hexo-lyrics</span></a></p></div><h3 id="JEJYA"><span class="ne-text">yuque-hexo-lyrics插件使用</span></h3><div data-type="info" class="ne-alert"><p id="5f4d6afaed5ca4bb0267ab435bef2350" class="ne-p"><span class="ne-text">本人基于yuque-hexo项目修改的进阶插件</span></p></div><p id="1161c5b8fba91d60db113e23742b67f6" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="b3a80d03dcc9e48b50664d0230755a46" class="ne-p"><span class="ne-text">【1】在开发环境当中下载插件（全局安装）</span></p></div><pre data-language="bash" id="1ik1w" class="ne-codeblock language-bash">npm i -g yuque-hexo-lyrics</pre><div class="ne-quote"><p id="9635a3cf7afa8c353a1727941c51f828" class="ne-p"><span class="ne-text">【2】相关hexo命令</span></p></div><pre data-language="bash" id="Bzi4U" class="ne-codeblock language-bash">yuque-hexo-lyrics clean # 清缓存删除yuque文件夹 删除yuque.json文件(更新之后的插件不删除yuque.json)<p>yuque-hexo-lyrics sync # 从云端拉取到本地</pre><div class="ne-quote"><p id="9f6540e268430a36a567ca9563355a3a" class="ne-p"><span class="ne-text">【3】特别需要注意的是：开发环境语雀 Token 变量的传入</span></p></div><p id="b7022720188d7016f5822e3b3cb9f145" class="ne-p"><span class="ne-text">语雀为了防止用户恶意多次拉取数据，出于对知识库安全性的调整，使用第三方 API 访问知识库，需要传入环境变量 </span><code class="ne-code"><span class="ne-text">YUQUE_TOKEN</span></code><span class="ne-text">，如果是本地使用建议使用环境变量，也可以是终端的方式输入</span><span class="ne-text">。</span></p><p id="99e2e3be707b30e19510c1232c92a67d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1594788656022-fb5e7959-fa2a-4418-911b-773e3674afb8.png" width="484" id="vrXpA" class="ne-image"></p><p id="687a270681e92edb8f306ee46feebc8c" class="ne-p" style="text-align: left"><span class="ne-text">如果是在</span><code class="ne-code"><span class="ne-text">GitHub Actions</span></code><span class="ne-text">里面的环境执行</span><code class="ne-code"><span class="ne-text">yuque-hexo-lyrics sync</span></code><span class="ne-text">命令的时候，通过如下命令传入语雀的</span><code class="ne-code"><span class="ne-text">token</span></code></p><pre data-language="yaml" id="x06xU" class="ne-codeblock language-yaml">YUQUE_TOKEN=$ yuque-hexo sync</pre><div class="ne-quote"><p id="a136077158d8c31393ed83ee1bed5e61" class="ne-p"><span class="ne-text">【4】最后的配置样式（本插件可以同时下载多个知识库）</span></p></div><pre data-language="json" id="jQDwv" class="ne-codeblock language-json"><br>"yuqueConfig_blog": {<br>"baseUrl": "<a href="https://www.yuque.com/api/v2&quot;">https://www.yuque.com/api/v2&quot;</a>,<br>"login": "wztlink1013",<br>"repo": "blog",<br>"postPath": "source/_posts/blog",<br>"cachePath": "yuque_blog.json",<br>"mdNameFormat": "slug",<br>"onlyPublished": false,<br>"onlyPublic": false,<br>"adapter": "hexo",<br>"timeout": "150s"<br>},<br>"yuqueConfig_essay": {<br>"baseUrl": "<a href="https://www.yuque.com/api/v2&quot;">https://www.yuque.com/api/v2&quot;</a>,<br>"login": "wztlink1013",<br>"repo": "essay",<br>"postPath": "source/_posts/essay",<br>"cachePath": "yuque_essay.json",<br>"mdNameFormat": "slug",<br>"onlyPublished": false,<br>"onlyPublic": false,<br>"adapter": "hexo",<br>"timeout": "150s"<br>},<br>"yuqueConfig_dsal": {<br>"baseUrl": "<a href="https://www.yuque.com/api/v2&quot;">https://www.yuque.com/api/v2&quot;</a>,<br>"login": "wztlink1013",<br>"repo": "dsal",<br>"postPath": "source/_posts/blog",<br>"cachePath": "yuque_dsal.json",<br>"mdNameFormat": "slug",<br>"onlyPublished": false,<br>"onlyPublic": false,<br>"adapter": "hexo",<br>"timeout": "150s"<br>},<br>"yuqueConfig_javascript": {<br>"baseUrl": "<a href="https://www.yuque.com/api/v2&quot;">https://www.yuque.com/api/v2&quot;</a>,<br>"login": "wztlink1013",<br>"repo": "javascript",<br>"postPath": "source/_posts/blog",<br>"cachePath": "yuqueConfig_javascript.json",<br>"mdNameFormat": "slug",<br>"onlyPublished": false,<br>"onlyPublic": false,<br>"adapter": "hexo",<br>"timeout": "150s"<br>},<br>"scripts": {<br>"build": "hexo generate",<br>"clean": "hexo clean",<br>"deploy": "hexo deploy",<br>"server": "hexo server"<br>}</pre><p id="2e220e29934e4caab7fbf25163b5b4df" class="ne-p"><span class="ne-text">更详细使用参考官方</span><a href="https://www.npmjs.com/package/yuque-hexo-lyrics" data-href="https://www.npmjs.com/package/yuque-hexo-lyrics" target="_blank" class="ne-link"><span class="ne-text">官方仓库</span></a><span class="ne-text">。</span></p><h3 id="rgoKe"><span class="ne-text">GitHub Actions 文件的配置</span></h3><p id="a09e1a4fc7ecbc2b448cb31a3ad0a4d7" class="ne-p"><span class="ne-text">在博客源文件夹下新建如下</span><span class="ne-text">GitHub Actions</span><span class="ne-text">文件</span></p><p id="7a6c247e4896fc4886a41b459033f746" class="ne-p"><code class="ne-code"><span class="ne-text">.github/workflows/main.yml</span></code><span class="ne-text"> </span></p><p id="8b2fb837e7f745e7c16e2910e3e9e4d3" class="ne-p"><br></p><div class="ne-quote"><p id="5fa3cfd52518e36e13ac83a1fb87d460" class="ne-p"><span class="ne-text">文件内容配置如下</span></p></div><pre data-language="yaml" id="BbAH8" class="ne-codeblock language-yaml"># workflow name<br>name: website to wztlink1013.github.io CI/CD</p><p>on: [repository_dispatch, watch]</p><p>jobs:<br>Deploy-Pages:<br>name: website to wztlink1013.github.io<br>runs-on: ubuntu-latest</p><pre><code>steps:# check it to your workflow can access it# from: https://github.com/actions/checkout- name: Checkout Repository master branch  uses: actions/checkout@main# from: https://github.com/actions/setup-node- name: Setup Node.js 10.x  uses: actions/setup-node@main  with:    node-version: &quot;10.x&quot;- name: add Git infomations  run: |    git config --global user.name &#39;$&#123;&#123;secrets.GIT_NAME&#125;&#125;&#39;    git config --global user.email &#39;$&#123;&#123;secrets.GIT_EMAIL&#125;&#125;&#39;- name: submit commit infomations  run: |    git log --pretty=format:&quot;%s from Github Actions at `date +&quot;%Y-%m-%d %H:%M:%S&quot;`&quot; --date=short -n 1  &gt; commit-message.log- name: npm istall hexo-cli、yuque-hexo、*  env:    YUQUE_TOKEN: $&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125;  run: |    npm install hexo-cli -g    npm install yuque-hexo-lyrics -g    npm install- name: generate articles  run: |    hexo clean    yuque-hexo-lyrics clean    YUQUE_TOKEN=$&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125; yuque-hexo-lyrics sync    hexo generate- name: push wztlink1013.github.io repository  env:    Github_Pages: github.com/wztlink1013/wztlink1013.github.io    Github_Token: $&#123;&#123; secrets.token_GithubAPI &#125;&#125;  run: |    git clone https://$&#123;Github_Token&#125;@$&#123;Github_Pages&#125; .github_pages    mv .github_pages/.git/ ./public/    cd ./public/    git add .    git commit -F ../commit-message.log    git push --force --quiet &quot;https://$&#123;Github_Token&#125;@$&#123;Github_Pages&#125;&quot; master:master    &lt;/pre&gt;&lt;h2 id=&quot;CykMS&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;三、Serverless云函数配置&lt;/span&gt;&lt;/h2&gt;&lt;h3 id=&quot;C99fO&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;腾讯云serverless&lt;/span&gt;&lt;/h3&gt;&lt;div data-type=&quot;info&quot; class=&quot;ne-alert&quot;&gt;&lt;p id=&quot;12afe219166d95e94c34e1e96aaf4baf&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;python2.7的配置&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;pre data-language=&quot;python&quot; id=&quot;P2MOT&quot; class=&quot;ne-codeblock language-python&quot;&gt;# -*- coding: utf8 -*-</code></pre><p>import requests</p><p>def main_handler(event, context):<br>r = requests.post(“<a href="https://api.github.com/repos/wztlink1013/website/dispatches&quot;">https://api.github.com/repos/wztlink1013/website/dispatches&quot;</a>,<br>json={‘event_type’: “run-it”},<br>headers = {“User-Agent”:’curl/7.52.1’,<br>‘Content-Type’: ‘application/json’,<br>‘Accept’: ‘application/vnd.github.everest-preview+json’,<br>‘Authorization’: ‘token <strong><strong>***</strong></strong>‘})</p><pre><code>if r.status_code == 204:    return &quot;This&#39;s OK!&quot;else:    return r.status_code&lt;/pre&gt;&lt;div data-type=&quot;info&quot; class=&quot;ne-alert&quot;&gt;&lt;p id=&quot;9ac47632c743de995059f4b422cb26c9&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;触发器的设置&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;p id=&quot;358567e27aa5f5c43c465d6744659c9d&quot; class=&quot;ne-p&quot; style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1484158/1594789179624-938bb8c2-ac15-4ece-a5f1-001563e4f08b.png&quot; width=&quot;605&quot; id=&quot;zNnuw&quot; class=&quot;ne-image&quot;&gt;&lt;/p&gt;&lt;h3 id=&quot;aONRK&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;阿里云serverless&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;8d5a1bbfadec86b9382b91a1c81b8769&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;记录一下Hexo自动化部署过程中阿里云平台的原函数配置的python代码&lt;/span&gt;&lt;/p&gt;&lt;div data-type=&quot;info&quot; class=&quot;ne-alert&quot;&gt;&lt;p id=&quot;33dd79d73dc15f09e7f8fa5e5a8d5ca3&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;python2.7&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;pre data-language=&quot;python&quot; id=&quot;NIyyF&quot; class=&quot;ne-codeblock language-python&quot;&gt;# -*- coding: utf-8 -*-</code></pre><p>import logging<br>import requests</p><h1 id="To-enable-the-initializer-feature-https-help-aliyun-com-document-detail-158208-html"><a href="#To-enable-the-initializer-feature-https-help-aliyun-com-document-detail-158208-html" class="headerlink" title="To enable the initializer feature (https://help.aliyun.com/document_detail/158208.html)"></a>To enable the initializer feature (<a href="https://help.aliyun.com/document_detail/158208.html">https://help.aliyun.com/document_detail/158208.html</a>)</h1><h1 id="please-implement-the-initializer-function-as-below："><a href="#please-implement-the-initializer-function-as-below：" class="headerlink" title="please implement the initializer function as below："></a>please implement the initializer function as below：</h1><h1 id="def-initializer-context"><a href="#def-initializer-context" class="headerlink" title="def initializer(context):"></a>def initializer(context):</h1><h1 id="logger-logging-getLogger"><a href="#logger-logging-getLogger" class="headerlink" title="logger = logging.getLogger()"></a>logger = logging.getLogger()</h1><h1 id="logger-info-‘initializing’"><a href="#logger-info-‘initializing’" class="headerlink" title="logger.info(‘initializing’)"></a>logger.info(‘initializing’)</h1><p>def handler(event, context):</p><h1 id="logger-logging-getLogger-1"><a href="#logger-logging-getLogger-1" class="headerlink" title="logger = logging.getLogger()"></a>logger = logging.getLogger()</h1><h1 id="logger-info-‘hello-world’"><a href="#logger-info-‘hello-world’" class="headerlink" title="logger.info(‘hello world’)"></a>logger.info(‘hello world’)</h1><h1 id="return-‘hello-world’"><a href="#return-‘hello-world’" class="headerlink" title="return ‘hello world’"></a>return ‘hello world’</h1><pre><code>r = requests.post(&quot;https://api.github.com/repos/wztlink1013/blog-source/dispatches&quot;,json=&#123;&#39;event_type&#39;: &quot;run-it&quot;&#125;,headers = &#123;&quot;User-Agent&quot;:&#39;curl/7.52.1&#39;,          &#39;Content-Type&#39;: &#39;application/json&#39;,          &#39;Accept&#39;: &#39;application/vnd.github.everest-preview+json&#39;,          &#39;Authorization&#39;: &#39;token f43964836a33dce244385bc303c8c20adc1bd52194&#39;&#125;)if r.status_code == 204:    return &quot;This&#39;s OK!&quot;else:    return r.status_code</code></pre><h1 id="coding-utf8"><a href="#coding-utf8" class="headerlink" title="# -- coding: utf8 --"></a># -<em>- coding: utf8 -</em>-</h1><h1 id="import-requests"><a href="#import-requests" class="headerlink" title="import requests"></a>import requests</h1><h1 id="def-main-handler-event-context"><a href="#def-main-handler-event-context" class="headerlink" title="def main_handler(event, context):"></a>def main_handler(event, context):</h1><h1 id="r-requests-post-“https-api-github-com-repos-wztlink1013-blog-source-dispatches-quot"><a href="#r-requests-post-“https-api-github-com-repos-wztlink1013-blog-source-dispatches-quot" class="headerlink" title="r = requests.post(“https://api.github.com/repos/wztlink1013/blog-source/dispatches&quot;,"></a>r = requests.post(“<a href="https://api.github.com/repos/wztlink1013/blog-source/dispatches&quot;">https://api.github.com/repos/wztlink1013/blog-source/dispatches&quot;</a>,</h1><h1 id="json-‘event-type’-“run-it”"><a href="#json-‘event-type’-“run-it”" class="headerlink" title="json={‘event_type’: “run-it”},"></a>json={‘event_type’: “run-it”},</h1><h1 id="headers-“User-Agent”-’curl-7-52-1’"><a href="#headers-“User-Agent”-’curl-7-52-1’" class="headerlink" title="headers = {“User-Agent”:’curl/7.52.1’,"></a>headers = {“User-Agent”:’curl/7.52.1’,</h1><h1 id="‘Content-Type’-‘application-json’"><a href="#‘Content-Type’-‘application-json’" class="headerlink" title="‘Content-Type’: ‘application/json’,"></a>‘Content-Type’: ‘application/json’,</h1><h1 id="‘Accept’-‘application-vnd-github-everest-preview-json’"><a href="#‘Accept’-‘application-vnd-github-everest-preview-json’" class="headerlink" title="‘Accept’: ‘application/vnd.github.everest-preview+json’,"></a>‘Accept’: ‘application/vnd.github.everest-preview+json’,</h1><h1 id="‘Authorization’-‘token-144a87bd45e62ff1cf30dc18880787917bc7865417’"><a href="#‘Authorization’-‘token-144a87bd45e62ff1cf30dc18880787917bc7865417’" class="headerlink" title="‘Authorization’: ‘token 144a87bd45e62ff1cf30dc18880787917bc7865417’})"></a>‘Authorization’: ‘token 144a87bd45e62ff1cf30dc18880787917bc7865417’})</h1><h1 id="if-r-status-code-204"><a href="#if-r-status-code-204" class="headerlink" title="if r.status_code == 204:"></a>if r.status_code == 204:</h1><h1 id="return-“This’s-OK-”"><a href="#return-“This’s-OK-”" class="headerlink" title="return “This’s OK!”"></a>return “This’s OK!”</h1><h1 id="else"><a href="#else" class="headerlink" title="else:"></a>else:</h1><h1 id="return-r-status-codepython3-版本-coding-utf-8"><a href="#return-r-status-codepython3-版本-coding-utf-8" class="headerlink" title="return r.status_codepython3 版本# -- coding: utf-8 --"></a>return r.status_code</pre><div data-type="info" class="ne-alert"><p id="c1219572cef3387be9ec32898bbfe0e5" class="ne-p"><span class="ne-text">python3 版本</span></p></div><pre data-language="python" id="tWrdt" class="ne-codeblock language-python"># -<em>- coding: utf-8 -</em>-</h1><p>import logging<br>import requests<br>OK = b’ok\n’</p><p>def handler(environ, start_response):<br>status = ‘200 OK’<br>response_headers = [(‘Content-type’, ‘text/plain’)]<br>sync_yuque()<br>start_response(status, response_headers)<br>return [OK]</p><p>def sync_yuque():<br>requests.post(“<a href="https://api.github.com/repos/wztlink1013/Blog3.0/dispatches&quot;">https://api.github.com/repos/wztlink1013/Blog3.0/dispatches&quot;</a>,<br>json={‘event_type’: “run-it”},<br>headers={“User-Agent”:’curl/7.52.1’,<br>‘Content-Type’: ‘application/json’,<br>‘Accept’: ‘application/vnd.github.everest-preview+json’,<br>‘Authorization’: ‘token f43964836a33dce415385bc303c8c20adc1bd52194’})</pre><div data-type="info" class="ne-alert"><ul class="ne-ul"><li id="3c600909972be4f842c6d28b9c9e78f9"><span class="ne-text">触发器配置</span></li></ul></div><p id="2e5237f2bdcd6df56a544ceb0f6e7be9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608448464729-f5e542f2-0a6e-4817-bd93-b8cf6f67b8fa.png" width="773.5" id="V2THU" class="ne-image"></p><p id="8e9cf4466b6fd1baca7e130d23f326a6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608448488925-30baf354-0b23-490c-8b05-4b054ca1b868.png" width="522.5" id="vXRT1" class="ne-image"></p><h3 id="Ia0Tb"><span class="ne-text">【推荐】Vercel 的 serverless</span></h3><ul class="ne-ul"><li id="17ad4c77dd90f7c792974f75dd3a5c5f"><a href="https://github.com/wztlink1013/yuque-github-api" data-href="https://github.com/wztlink1013/yuque-github-api" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wztlink1013/yuque-github-api</span></a></li></ul><h2 id="8LnNg"><span class="ne-text">四、语雀云端的配置</span></h2><p id="ba85c0f4a2299d376a43f55916f57c82" class="ne-p"><span class="ne-text">在所需要拉取的仓库中 webhook 中填入云函数所留下的那串网址，勾选所需要触发的选项即可。</span></p><p id="686a64a0b2b1b8cf91c94cc98d75ecda" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624971959931-874c6c43-8c51-4c56-9b32-e952f8c87f6c.png" width="555.5" id="TI4F3" class="ne-image"></p><h2 id="BLygZ"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="89c3356bf1b049a1bec201e225f16b30"><a href="https://github.com/x-cold/yuque-hexo" data-href="https://github.com/x-cold/yuque-hexo" target="_blank" class="ne-link"><span class="ne-text">yuque-hexo 开发仓库</span></a></li><li id="74c1f2d07150fbd11374439ee411f94d"><a href="https://www.zhwei.cn/hexo-github-actions-yuque/" data-href="https://www.zhwei.cn/hexo-github-actions-yuque/" target="_blank" class="ne-link"><span class="ne-text">Hexo：语雀云端写作，Github Actions 持续集成</span></a></li><li id="3e6686a9e74b880065e29a6141d20240"><a href="https://segmentfault.com/a/1190000017797561" data-href="https://segmentfault.com/a/1190000017797561" target="_blank" class="ne-link"><span class="ne-text">Hexo 博客终极玩法：云端写作，自动部署</span></a></li><li id="e30cf16dc70ad3935957ad81c54a9bd5"><a href="https://www.xiayinchang.top/post/b2362878.html" data-href="https://www.xiayinchang.top/post/b2362878.html" target="_blank" class="ne-link"><span class="ne-text">阿里云云函数使用用户</span></a></li><li id="f13bd285d7b7894c1ec10a631cf5be30"><a href="https://bbs.pediy.com/thread-260866.htm" data-href="https://bbs.pediy.com/thread-260866.htm" target="_blank" class="ne-link"><span class="ne-text">[原创]自动同步语雀文档到你的 hexo 博客</span></a></li><li id="b911ba9cb292fdbf0ee1067f802f15be"><a href="https://github.com/Zfour/yuque_vercel_webhook_api" data-href="https://github.com/Zfour/yuque_vercel_webhook_api" target="_blank" class="ne-link"><span class="ne-text">https://github.com/Zfour/yuque_vercel_webhook_api</span></a></li></ul></div></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>“什么都无法舍弃，什么也改变不了”</title>
      <link href="/essay/vattip/"/>
      <url>/essay/vattip/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p class="ne-p"><span class="ne-text">什么也无法舍弃的人，也无法改变任何事情吧。</span></p><p class="ne-p"><span class="ne-text">——爱尔敏·阿诺德</span></p></div><p class="ne-p"><br></p><p class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620265214393-3e90a086-8121-4c96-8f09-6d9bd1406fd2.png" width="383.5"></p><p class="ne-p"><br></p><p class="ne-p"><code class="ne-code"><span class="ne-text">2021.04.28</span></code></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">突然对舍弃有了一个新的见解，</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">舍弃，很多时候，不仅仅是执行者主观的做法，还有一种就是，被动的舍弃…</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">因为你注定要成为什么样的人，所以注定你必须要舍弃某些东西，那么这个时候，对这样的选择该怎么办呢？</span></p><p class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619589532108-e98a4fc8-907a-40c4-9e74-2eb76b34d311.jpeg" width="445"></p><p class="ne-p"><br></p><p class="ne-p"><code class="ne-code"><span class="ne-text">2021.04.29</span></code></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">什么是得到呢？</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">也许，现在的你没得到，不代表今后的你不会得到，不同的时段，我们所在乎的还会一样吗？</span></p><p class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快节奏下的人们</title>
      <link href="/essay/gm1to9/"/>
      <url>/essay/gm1to9/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B10%2C0%2C48%5D%2C%5B10%2C0%2C48%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">如今的抒情，早已不知道为何变得如此奢侈</p><p data-lake-id="79eeea539b9d202e36b6faf150f4260b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="58b2d7fe339545ff61bc6a7d7b962732" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">我们更多的是用心感受远行，而不是，来到一个地方，拍个照，发朋友圈，嗯，我来过，而已……</p><p data-lake-id="f5ca9b0380dd34579466b6f61bd45b0a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="916cf591785d0dfa3c5b8380c7c10eba" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">什么时候，抒情也变得如此廉价</p><p data-lake-id="ce2a01aa01573a17990818ee709b9b12" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="bf7454c7494d1e86d5cd8bab0db34087" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="1526ef00699787ea894a90b00912c7a7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">写东西更多的是一种抒发内心想法，简单且纯粹，就像是记录下来的，就是我的内心真实写照，</p><p data-lake-id="fbf163a1dd38817a952f15095e27ce62" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="f2f87ec4aed0ccc740746755a184ed94" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="97b22bf37303cadfc2842d6d0c242554" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">微商—自媒体—短视频，人们变得不仅是快节奏，更是一种焦虑，为什么会焦虑呢？因为这个社会太快了……</p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
